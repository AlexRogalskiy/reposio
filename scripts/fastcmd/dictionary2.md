--------------------------------------------------------------------------------------------------------
String pricePayload = JacksonJsonHelper.serialize(request.getCurrent_price());
--------------------------------------------------------------------------------------------------------
@Test
public void massIndexation() throws InterruptedException {
    EntityManager em = Persistence.createEntityManagerFactory("studentPu").createEntityManager();
    org.hibernate.Session hibernateSession = (Session)em.getDelegate();
    FullTextSession fullTextSession = Search.getFullTextSession(hibernateSession);
    fullTextSession.createIndexer().startAndWait();
} 
--------------------------------------------------------------------------------------------------------
public class NumericKeyValueJsonDeserializer extends JsonDeserializer<List<NumericKeyValue>>{

    @Override
    public List<NumericKeyValue> deserialize(JsonParser jp, DeserializationContext ctxt)
            throws IOException, JsonProcessingException {
        TypeReference<List<NumericKeyValue>> typeRef = new TypeReference<List<NumericKeyValue>>(){};
        ObjectMapper mapper = new ObjectMapper();
        JsonNode root = jp.getCodec().readTree(jp);
        String numericKeyValue = root.get("numericKeyValue").asText();
        return mapper.readValue( numericKeyValue, typeRef);
    }

}
--------------------------------------------------------------------------------------------------------
         //            final MediaType mediaType = jsonParser.getCodec().readValue(jsonParser, MediaType.class);
            final JsonNode root = jsonParser.getCodec().readTree(jsonParser);
            final String type = root.get("type").asText();
            final String subType = root.get("subType").asText();
			
            return MediaType.TEXT_HTML
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
language: java

sudo: false
dist: trusty

install: echo "Disabled Travis CI 'install' stage by default"

env:
  global:
  - # ossrhUsername
  - secure: GwuNkNkV6QUnThmV+ZsiPuR+M50sVN+7qT+Ca9qRiXAhbUJpV0kcQz+NSV/gDE9UmsdzKfPzsSaKPjtIbKN9gFzFsOCd99TXGD1n3Kkya//Pw1ziDOtZFI9EMjO/8qPIEIR+Cfk7niqpyET/ypC7aklxv8raiCVrPDXJ8TJWsYM=
  - # ossrhPassword
  - secure: i+gbt9z+eCnGV1TadNWPrkOgxmeTYUvfkQYOvVQ01cqkTeNL5YKoWx3cpoidEvx4Bj00XkNqXXvMEBViEgnVlA4Xqm8n/05WcVr6uJ/HFq1hkBTiVl5LJEvXH4NBVoEZJTY4h9B7ulMHqvhM9U/vTBYbjK+L+9OC6B+U/IJe2Ho=

matrix:
  include:
  - jdk: oraclejdk8
  - jdk: oraclejdk9
  - jdk: openjdk10
  - jdk: openjdk11
    env: DEPLOY=true
  - jdk: openjdk12
  - jdk: openjdk-13
  - jdk: openjdk-ea
  allow_failures:
  - jdk: openjdk-13
  - jdk: openjdk-ea

before_cache:
- rm -f  $HOME/.gradle/caches/modules-2/modules-2.lock
- rm -fr $HOME/.gradle/caches/*/plugin-resolution/
cache:
  directories:
  - "$HOME/.gradle/caches/"
  - "$HOME/.gradle/wrapper/"

before_install:
- export GRADLE_JAVA_HOME="$JAVA_HOME"
- unset _JAVA_OPTIONS

script:
- ./gradlew check --info -Dorg.gradle.java.home="$GRADLE_JAVA_HOME"
- if [ -n "$(git status -su src-gen)" ]; then exit 1; fi

after_success:
- if [[ -n $DEPLOY ]]; then bash <(curl -s https://codecov.io/bash); fi
- if [[ -n $DEPLOY ]] && [ "$TRAVIS_REPO_SLUG" == "vavr-io/vavr" ] && [ "$TRAVIS_PULL_REQUEST" == "false" ] && [ "$TRAVIS_BRANCH" == "master" ]; then ./gradlew uploadArchives -PossrhUsername="$ossrhUsername" -PossrhPassword="$ossrhPassword"; fi
--------------------------------------------------------------------------------------------------------
/* ____  ______________  ________________________  __________
 * \   \/   /      \   \/   /   __/   /      \   \/   /      \
 *  \______/___/\___\______/___/_____/___/\___\______/___/\___\
 *
 * Copyright 2019 Vavr, http://vavr.io
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.vavr;

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
   G E N E R A T O R   C R A F T E D
\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/



import io.vavr.collection.List;
import io.vavr.collection.Seq;
import java.io.Serializable;
import java.util.Comparator;
import java.util.Objects;
import java.util.function.Function;

/**
 * A tuple of three elements which can be seen as cartesian product of three components.
 *
 * @param <T1> type of the 1st element
 * @param <T2> type of the 2nd element
 * @param <T3> type of the 3rd element
 */
public final class Tuple3<T1, T2, T3> implements Tuple, Comparable<Tuple3<T1, T2, T3>>, Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * The 1st element of this tuple.
     */
    public final T1 _1;

    /**
     * The 2nd element of this tuple.
     */
    public final T2 _2;

    /**
     * The 3rd element of this tuple.
     */
    public final T3 _3;

    /**
     * Constructs a tuple of three elements.
     *
     * @param t1 the 1st element
     * @param t2 the 2nd element
     * @param t3 the 3rd element
     */
    public Tuple3(T1 t1, T2 t2, T3 t3) {
        this._1 = t1;
        this._2 = t2;
        this._3 = t3;
    }

    public static <T1, T2, T3> Comparator<Tuple3<T1, T2, T3>> comparator(Comparator<? super T1> t1Comp, Comparator<? super T2> t2Comp, Comparator<? super T3> t3Comp) {
        return (Comparator<Tuple3<T1, T2, T3>> & Serializable) (t1, t2) -> {
            final int check1 = t1Comp.compare(t1._1, t2._1);
            if (check1 != 0) {
                return check1;
            }

            final int check2 = t2Comp.compare(t1._2, t2._2);
            if (check2 != 0) {
                return check2;
            }

            final int check3 = t3Comp.compare(t1._3, t2._3);
            if (check3 != 0) {
                return check3;
            }

            // all components are equal
            return 0;
        };
    }

    @SuppressWarnings("unchecked")
    private static <U1 extends Comparable<? super U1>, U2 extends Comparable<? super U2>, U3 extends Comparable<? super U3>> int compareTo(Tuple3<?, ?, ?> o1, Tuple3<?, ?, ?> o2) {
        final Tuple3<U1, U2, U3> t1 = (Tuple3<U1, U2, U3>) o1;
        final Tuple3<U1, U2, U3> t2 = (Tuple3<U1, U2, U3>) o2;

        final int check1 = t1._1.compareTo(t2._1);
        if (check1 != 0) {
            return check1;
        }

        final int check2 = t1._2.compareTo(t2._2);
        if (check2 != 0) {
            return check2;
        }

        final int check3 = t1._3.compareTo(t2._3);
        if (check3 != 0) {
            return check3;
        }

        // all components are equal
        return 0;
    }

    @Override
    public int arity() {
        return 3;
    }

    @Override
    public int compareTo(Tuple3<T1, T2, T3> that) {
        return Tuple3.compareTo(this, that);
    }

    /**
     * Getter of the 1st element of this tuple.
     *
     * @return the 1st element of this Tuple.
     */
    public T1 _1() {
        return _1;
    }

    /**
     * Sets the 1st element of this tuple to the given {@code value}.
     *
     * @param value the new value
     * @return a copy of this tuple with a new value for the 1st element of this Tuple.
     */
    public Tuple3<T1, T2, T3> update1(T1 value) {
        return new Tuple3<>(value, _2, _3);
    }

    /**
     * Getter of the 2nd element of this tuple.
     *
     * @return the 2nd element of this Tuple.
     */
    public T2 _2() {
        return _2;
    }

    /**
     * Sets the 2nd element of this tuple to the given {@code value}.
     *
     * @param value the new value
     * @return a copy of this tuple with a new value for the 2nd element of this Tuple.
     */
    public Tuple3<T1, T2, T3> update2(T2 value) {
        return new Tuple3<>(_1, value, _3);
    }

    /**
     * Getter of the 3rd element of this tuple.
     *
     * @return the 3rd element of this Tuple.
     */
    public T3 _3() {
        return _3;
    }

    /**
     * Sets the 3rd element of this tuple to the given {@code value}.
     *
     * @param value the new value
     * @return a copy of this tuple with a new value for the 3rd element of this Tuple.
     */
    public Tuple3<T1, T2, T3> update3(T3 value) {
        return new Tuple3<>(_1, _2, value);
    }


    /**
     * Maps the components of this tuple using a mapper function.
     *
     * @param mapper the mapper function
     * @param <U1> new type of the 1st component
     * @param <U2> new type of the 2nd component
     * @param <U3> new type of the 3rd component
     * @return A new Tuple of same arity.
     * @throws NullPointerException if {@code mapper} is null
     */
    public <U1, U2, U3> Tuple3<U1, U2, U3> map(Function3<? super T1, ? super T2, ? super T3, Tuple3<U1, U2, U3>> mapper) {
        Objects.requireNonNull(mapper, "mapper is null");
        return mapper.apply(_1, _2, _3);
    }

    /**
     * Maps the components of this tuple using a mapper function for each component.
     *
     * @param f1 the mapper function of the 1st component
     * @param f2 the mapper function of the 2nd component
     * @param f3 the mapper function of the 3rd component
     * @param <U1> new type of the 1st component
     * @param <U2> new type of the 2nd component
     * @param <U3> new type of the 3rd component
     * @return A new Tuple of same arity.
     * @throws NullPointerException if one of the arguments is null
     */
    public <U1, U2, U3> Tuple3<U1, U2, U3> map(Function<? super T1, ? extends U1> f1, Function<? super T2, ? extends U2> f2, Function<? super T3, ? extends U3> f3) {
        Objects.requireNonNull(f1, "f1 is null");
        Objects.requireNonNull(f2, "f2 is null");
        Objects.requireNonNull(f3, "f3 is null");
        return Tuple.of(f1.apply(_1), f2.apply(_2), f3.apply(_3));
    }

    /**
     * Maps the 1st component of this tuple to a new value.
     *
     * @param <U> new type of the 1st component
     * @param mapper A mapping function
     * @return a new tuple based on this tuple and substituted 1st component
     */
    public <U> Tuple3<U, T2, T3> map1(Function<? super T1, ? extends U> mapper) {
        Objects.requireNonNull(mapper, "mapper is null");
        final U u = mapper.apply(_1);
        return Tuple.of(u, _2, _3);
    }

    /**
     * Maps the 2nd component of this tuple to a new value.
     *
     * @param <U> new type of the 2nd component
     * @param mapper A mapping function
     * @return a new tuple based on this tuple and substituted 2nd component
     */
    public <U> Tuple3<T1, U, T3> map2(Function<? super T2, ? extends U> mapper) {
        Objects.requireNonNull(mapper, "mapper is null");
        final U u = mapper.apply(_2);
        return Tuple.of(_1, u, _3);
    }

    /**
     * Maps the 3rd component of this tuple to a new value.
     *
     * @param <U> new type of the 3rd component
     * @param mapper A mapping function
     * @return a new tuple based on this tuple and substituted 3rd component
     */
    public <U> Tuple3<T1, T2, U> map3(Function<? super T3, ? extends U> mapper) {
        Objects.requireNonNull(mapper, "mapper is null");
        final U u = mapper.apply(_3);
        return Tuple.of(_1, _2, u);
    }

    /**
     * Transforms this tuple to an object of type U.
     *
     * @param f Transformation which creates a new object of type U based on this tuple's contents.
     * @param <U> type of the transformation result
     * @return An object of type U
     * @throws NullPointerException if {@code f} is null
     */
    public <U> U apply(Function3<? super T1, ? super T2, ? super T3, ? extends U> f) {
        Objects.requireNonNull(f, "f is null");
        return f.apply(_1, _2, _3);
    }

    @Override
    public Seq<?> toSeq() {
        return List.of(_1, _2, _3);
    }

    /**
     * Append a value to this tuple.
     *
     * @param <T4> type of the value to append
     * @param t4 the value to append
     * @return a new Tuple with the value appended
     */
    public <T4> Tuple4<T1, T2, T3, T4> append(T4 t4) {
        return Tuple.of(_1, _2, _3, t4);
    }

    /**
     * Concat a tuple's values to this tuple.
     *
     * @param <T4> the type of the 4th value in the tuple
     * @param tuple the tuple to concat
     * @return a new Tuple with the tuple values appended
     * @throws NullPointerException if {@code tuple} is null
     */
    public <T4> Tuple4<T1, T2, T3, T4> concat(Tuple1<T4> tuple) {
        Objects.requireNonNull(tuple, "tuple is null");
        return Tuple.of(_1, _2, _3, tuple._1);
    }

    /**
     * Concat a tuple's values to this tuple.
     *
     * @param <T4> the type of the 4th value in the tuple
     * @param <T5> the type of the 5th value in the tuple
     * @param tuple the tuple to concat
     * @return a new Tuple with the tuple values appended
     * @throws NullPointerException if {@code tuple} is null
     */
    public <T4, T5> Tuple5<T1, T2, T3, T4, T5> concat(Tuple2<T4, T5> tuple) {
        Objects.requireNonNull(tuple, "tuple is null");
        return Tuple.of(_1, _2, _3, tuple._1, tuple._2);
    }

    /**
     * Concat a tuple's values to this tuple.
     *
     * @param <T4> the type of the 4th value in the tuple
     * @param <T5> the type of the 5th value in the tuple
     * @param <T6> the type of the 6th value in the tuple
     * @param tuple the tuple to concat
     * @return a new Tuple with the tuple values appended
     * @throws NullPointerException if {@code tuple} is null
     */
    public <T4, T5, T6> Tuple6<T1, T2, T3, T4, T5, T6> concat(Tuple3<T4, T5, T6> tuple) {
        Objects.requireNonNull(tuple, "tuple is null");
        return Tuple.of(_1, _2, _3, tuple._1, tuple._2, tuple._3);
    }

    /**
     * Concat a tuple's values to this tuple.
     *
     * @param <T4> the type of the 4th value in the tuple
     * @param <T5> the type of the 5th value in the tuple
     * @param <T6> the type of the 6th value in the tuple
     * @param <T7> the type of the 7th value in the tuple
     * @param tuple the tuple to concat
     * @return a new Tuple with the tuple values appended
     * @throws NullPointerException if {@code tuple} is null
     */
    public <T4, T5, T6, T7> Tuple7<T1, T2, T3, T4, T5, T6, T7> concat(Tuple4<T4, T5, T6, T7> tuple) {
        Objects.requireNonNull(tuple, "tuple is null");
        return Tuple.of(_1, _2, _3, tuple._1, tuple._2, tuple._3, tuple._4);
    }

    /**
     * Concat a tuple's values to this tuple.
     *
     * @param <T4> the type of the 4th value in the tuple
     * @param <T5> the type of the 5th value in the tuple
     * @param <T6> the type of the 6th value in the tuple
     * @param <T7> the type of the 7th value in the tuple
     * @param <T8> the type of the 8th value in the tuple
     * @param tuple the tuple to concat
     * @return a new Tuple with the tuple values appended
     * @throws NullPointerException if {@code tuple} is null
     */
    public <T4, T5, T6, T7, T8> Tuple8<T1, T2, T3, T4, T5, T6, T7, T8> concat(Tuple5<T4, T5, T6, T7, T8> tuple) {
        Objects.requireNonNull(tuple, "tuple is null");
        return Tuple.of(_1, _2, _3, tuple._1, tuple._2, tuple._3, tuple._4, tuple._5);
    }

    // -- Object

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        } else if (!(o instanceof Tuple3)) {
            return false;
        } else {
            final Tuple3<?, ?, ?> that = (Tuple3<?, ?, ?>) o;
            return Objects.equals(this._1, that._1)
                    && Objects.equals(this._2, that._2)
                    && Objects.equals(this._3, that._3);
        }
    }

    @Override
    public int hashCode() {
        return Tuple.hash(_1, _2, _3);
    }

    @Override
    public String toString() {
        return "(" + _1 + ", " + _2 + ", " + _3 + ")";
    }
}
--------------------------------------------------------------------------------------------------------
@ExtendWith({
        WiremockResolver.class,
        WiremockUriResolver.class
})
class WiremockJUnit5Test {

    @Test
    void shouldInjectWiremock(@Wiremock WireMockServer server, @WiremockUri String uri) {
        customize(server); // your setup
        SomeApiClient api = SomeApiClient.connect(uri);

        Response response = api.call();
        assertThat(response.headers(), hasSize(1));
    }
}
--------------------------------------------------------------------------------------------------------
@TestPropertySource(locations = "classpath:/test.properties")
@EmbeddedKafka(topics = { "any-topic", "${kafka.topics.another-topic}" },
        brokerProperties = { "log.dir=${kafka.broker.logs-dir}",
                            "listeners=PLAINTEXT://localhost:${kafka.broker.port}",
                            "auto.create.topics.enable=${kafka.broker.topics-enable:true}" }
        brokerPropertiesLocation = "classpath:/broker.properties")
--------------------------------------------------------------------------------------------------------
public class KafkaTest {

  @Test
  public void shouldWaitForRecordsToBePublished() throws Exception {

    try (EmbeddedKafkaCluster cluster = provisionWith(useDefaults())) {
      cluster.send(to("test-topic", "a", "b", "c").useDefaults());
      cluster.observe(on("test-topic", 3).useDefaults());
    }
  }
}
--------------------------------------------------------------------------------------------------------
public enum Page {
    
    FIRST("first.html"),
    SECOND("second.html"),
    HOTKEYS("hotkeys.html"),
    ALERT("alert.html"),
    FRAMES("frames.html"),
    DRAG("drag.html");
    
    private final String name;

    Page(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
--------------------------------------------------------------------------------------------------------
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.kodedu.cloudterm.service.TerminalService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class TerminalSocket extends TextWebSocketHandler {

    private final TerminalService terminalService;

    @Autowired
    public TerminalSocket(TerminalService terminalService) {
        this.terminalService = terminalService;
    }

    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        terminalService.setWebSocketSession(session);
        super.afterConnectionEstablished(session);
    }

    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        Map<String, String> messageMap = getMessageMap(message);

        if (messageMap.containsKey("type")) {
            String type = messageMap.get("type");

            switch (type) {
                case "TERMINAL_INIT":
                    terminalService.onTerminalInit();
                    break;
                case "TERMINAL_READY":
                    terminalService.onTerminalReady();
                    break;
                case "TERMINAL_COMMAND":
                    terminalService.onCommand(messageMap.get("command"));
                    break;
                case "TERMINAL_RESIZE":
                    terminalService.onTerminalResize(messageMap.get("columns"), messageMap.get("rows"));
                    break;
                default:
                    throw new RuntimeException("Unrecodnized action");
            }
        }
    }

    private Map<String, String> getMessageMap(TextMessage message) {
        try {
            Map<String, String> map = new ObjectMapper().readValue(message.getPayload(), new TypeReference<Map<String, String>>() {
            });

            return map;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return new HashMap<>();
    }

    @Override
    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
        super.handleTransportError(session, exception);
    }

    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        super.afterConnectionClosed(session, status);
    }

    @Override
    public boolean supportsPartialMessages() {
        return super.supportsPartialMessages();
    }
}


import com.kodedu.cloudterm.websocket.TerminalSocket;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;
import org.springframework.web.socket.handler.PerConnectionWebSocketHandler;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry
                .addHandler(terminalSocket(), "/terminal");
    }

    @Bean
    public WebSocketHandler terminalSocket() {
        WebSocketHandler webSocketHandler = new PerConnectionWebSocketHandler(TerminalSocket.class);
        return webSocketHandler;
    }
}
--------------------------------------------------------------------------------------------------------
@Bean
public KafkaAdmin admin() {
    Map<String, Object> configs = new HashMap<>();
    configs.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, ...);
    return new KafkaAdmin(configs);
}

@Bean
public NewTopic topic1() {
    return TopicBuilder.name("thing1")
            .partitions(10)
            .replicas(3)
            .compact()
            .build();
}

@Bean
public NewTopic topic2() {
    return TopicBuilder.name("thing2")
            .partitions(10)
            .replicas(3)
            .config(TopicConfig.COMPRESSION_TYPE_CONFIG, "zstd")
            .build();
}

@Bean
public NewTopic topic3() {
    return TopicBuilder.name("thing3")
            .assignReplicas(0, Arrays.asList(0, 1))
            .assignReplicas(1, Arrays.asList(1, 2))
            .assignReplicas(2, Arrays.asList(2, 0))
            .config(TopicConfig.COMPRESSION_TYPE_CONFIG, "zstd")
            .build();
}

public void sendToKafka(final MyOutputData data) {
    final ProducerRecord<String, String> record = createRecord(data);

    try {
        template.send(record).get(10, TimeUnit.SECONDS);
        handleSuccess(data);
    }
    catch (ExecutionException e) {
        handleFailure(data, record, e.getCause());
    }
    catch (TimeoutException | InterruptedException e) {
        handleFailure(data, record, e);
    }
}

@SpringBootApplication
public class KReplyingApplication {

    public static void main(String[] args) {
        SpringApplication.run(KReplyingApplication.class, args);
    }

    @KafkaListener(id="server", topics = "kRequests")
    @SendTo // use default replyTo expression
    public String listen(String in) {
        System.out.println("Server received: " + in);
        return in.toUpperCase();
    }

    @Bean
    public NewTopic kRequests() {
        return TopicBuilder.name("kRequests")
            .partitions(10)
            .replicas(2)
            .build();
    }

    @Bean // not required if Jackson is on the classpath
    public MessagingMessageConverter simpleMapperConverter() {
        MessagingMessageConverter messagingMessageConverter = new MessagingMessageConverter();
        messagingMessageConverter.setHeaderMapper(new SimpleKafkaHeaderMapper());
        return messagingMessageConverter;
    }

}


@Configuration
@EnableKafka
public class Config implements KafkaListenerConfigurer {

    @Autowired
    private LocalValidatorFactoryBean validator;
    ...

    @Override
    public void configureKafkaListeners(KafkaListenerEndpointRegistrar registrar) {
      registrar.setValidator(this.validator);
    }
}

@KafkaListener(id="validated", topics = "annotated35", errorHandler = "validationErrorHandler",
      containerFactory = "kafkaJsonListenerContainerFactory")
public void validatedListener(@Payload @Valid ValidatedClass val) {
    ...
}

@Bean
public KafkaListenerErrorHandler validationErrorHandler() {
    return (m, e) -> {
        ...
    };
}


@KafkaListener(topics = "annotated21")
@SendTo("!{request.value()}") // runtime SpEL
public String replyingListener(String in) {
    ...
}

@KafkaListener(topics = "${some.property:annotated22}")
@SendTo("#{myBean.replyTopic}") // config time SpEL
public Collection<String> replyingBatchListener(List<String> in) {
    ...
}

@KafkaListener(topics = "annotated23", errorHandler = "replyErrorHandler")
@SendTo("annotated23reply") // static reply topic definition
public String replyingListenerWithErrorHandler(String in) {
    ...
}
...
@KafkaListener(topics = "annotated25")
@SendTo("annotated25reply1")
public class MultiListenerSendTo {

    @KafkaHandler
    public String foo(String in) {
        ...
    }

    @KafkaHandler
    @SendTo("!{'annotated25reply2'}")
    public String bar(@Payload(required = false) KafkaNull nul,
            @Header(KafkaHeaders.RECEIVED_MESSAGE_KEY) int key) {
        ...
    }

}


@Bean
public ConcurrentKafkaListenerContainerFactory<Integer, String> kafkaListenerContainerFactory() {
    ConcurrentKafkaListenerContainerFactory<Integer, String> factory =
        new ConcurrentKafkaListenerContainerFactory<>();
    factory.setConsumerFactory(cf());
    factory.setReplyTemplate(template());
    factory.setReplyHeadersConfigurer((k, v) -> k.equals("cat"));
    return factory;
}

@Bean
public ConcurrentKafkaListenerContainerFactory<Integer, String> kafkaListenerContainerFactory() {
    ConcurrentKafkaListenerContainerFactory<Integer, String> factory =
        new ConcurrentKafkaListenerContainerFactory<>();
    factory.setConsumerFactory(cf());
    factory.setReplyTemplate(template());
    factory.setReplyHeadersConfigurer(new ReplyHeadersConfigurer() {

      @Override
      public boolean shouldCopy(String headerName, Object headerValue) {
        return false;
      }

      @Override
      public Map<String, Object> additionalHeaders() {
        return Collections.singletonMap("qux", "fiz");
      }

    });
    return factory;
}
--------------------------------------------------------------------------------------------------------
public class TestBean {

    @Size(min = 1, max = 2)
    private Seq<@Max(10) Integer> seqWithOneOrTwoDecimals = List.of(0);

    @NotEmpty
    private Either<String, @Positive Integer> mustNotBeLeftOrNull = Either.right(42);
    
    private Tuple3<@NotBlank String, @NotBlank String, @NotNull Integer> allElementsMustBeProvided =
        Tuple.of("a", "x", 3);

    @NotNull
    @NotEmpty
    private Map<@Pattern(regexp = "^[a-z]$") String, @NotBlank String> allCharKeysMustHaveNonBlankValues =
        HashMap.of("a", "Alice");
    
    // getters and setters
    
}
--------------------------------------------------------------------------------------------------------
@RestController
public class UserApi {
    private final UserService userService;
    public UserApi(UserService userService) {
        this.userService = userService;
    }
    @JsonView(UserViews.BasicView.class)
    @GetMapping("/users/{userId}/basic")
    public ResponseEntity<UserDetails> getUserDetails(@PathVariable long userId) {
        return ResponseEntity.ok(userDetails);
    }
    @JsonView(UserViews.ExtendedView.class)
    @GetMapping("/users/{userId}/extended")
    public ResponseEntity<UserDetails> getUserDetailsExtended(@PathVariable long userId) {
        return ResponseEntity.ok(userDetails);
    }


import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.java.jacksondemo.model.UserDetails;
import java.io.IOException;
public class UserDetailsSerializer extends StdSerializer<UserDetails> {
    private final JacksonDemoProperties jacksonDemoProperties;
    protected UserDetailsSerializer(JacksonDemoProperties jacksonDemoProperties) {
        super(UserDetails.class);
        this.jacksonDemoProperties = jacksonDemoProperties;
    }
    @Override
    public void serialize(UserDetails userDetails, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        jsonGenerator.writeStartObject();
        jsonGenerator.writeNumberField("user-id", userDetails.getUserId());
        jsonGenerator.writeStringField("first-name", userDetails.getFirstName());
        if (jacksonDemoProperties.isSerializeSensitiveInfo()) {
            jsonGenerator.writeStringField("ssn", userDetails.getSsn());
            jsonGenerator.writeNumberField("age", userDetails.getAge());
        }
        jsonGenerator.writeEndObject();
    }


   public ObjectMapper objectMapper(JacksonDemoProperties provider) {
        ObjectMapper objectMapper = new ObjectMapper();      objectMapper.setPropertyNamingStrategy(PropertyNamingStrategy.KEBAB_CASE);
        SimpleModule simpleModule = new SimpleModule();
        simpleModule.addSerializer(UserDetails.class, new UserDetailsSerializer(provider));
        objectMapper.registerModule(simpleModule);
        return objectMapper;

@JsonNaming(value = PropertyNamingStrategy.SnakeCaseStrategy.class)
spring.jackson.property-naming-strategy=KEBAB_CASE

import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;
@JsonDeserialize(builder = User.UserBuilder.class)
public class User {
    private String firstName;
    private Integer age;
    private User(String firstName, Integer age) {
        this.firstName = firstName;
        this.age = age;
    }
    public Integer getAge() {
        return age;
    }
    public String getFirstName() {
        return firstName;
    }
    @JsonPOJOBuilder
    public static class UserBuilder {
        private String firstName;
        private Integer age;
        public UserBuilder withFirstName(String firstName) {
            this.firstName = firstName;
            return this;
        }
        public UserBuilder withAge(Integer age) {
            this.age = age;
            return this;
        }
        public User build() {
            return new User(firstName, age);
        }
    }
}
--------------------------------------------------------------------------------------------------------
        stubFor(post(urlEqualTo("/"))
                .willReturn(
                        aResponse()
                                .withStatus(200)
                                .withHeader("content-type", 
                          "text/xml")                             
                .withBodyFile("CountrySuccessResponse.xml")
                )
--------------------------------------------------------------------------------------------------------
@ParameterizedTest
@EnumSource(value = TimeUnit.class, mode = EXCLUDE, names = { "DAYS", "HOURS" })
void testWithEnumSourceExclude(TimeUnit timeUnit) {
    assertFalse(EnumSet.of(TimeUnit.DAYS, TimeUnit.HOURS).contains(timeUnit));
    assertTrue(timeUnit.name().length() > 5);
}
@ParameterizedTest
@EnumSource(value = TimeUnit.class, mode = MATCH_ALL, names = "^(M|N).+SECONDS$")
void testWithEnumSourceRegex(TimeUnit timeUnit) {
    String name = timeUnit.name();
    assertTrue(name.startsWith("M") || name.startsWith("N"));
    assertTrue(name.endsWith("SECONDS"));
}
--------------------------------------------------------------------------------------------------------
spring.jpa.properties.hibernate.ddl-auto=none
spring.jpa.generate-ddl=false
spring.jpa.properties.hibernate.id.new_generator_mappings=false
--------------------------------------------------------------------------------------------------------
@Bean(name = "dataSource")
public DriverManagerDataSource dataSource() {
    DriverManagerDataSource dataSource = new DriverManagerDataSource();
    dataSource.setDriverClassName("org.h2.Driver");
    dataSource.setUrl("jdbc:h2:~/myDB;MV_STORE=false");
    dataSource.setUsername("sa");
    dataSource.setPassword("");

    // schema init
    Resource initSchema = new ClassPathResource("scripts/schema-h2.sql");
    Resource initData = new ClassPathResource("scripts/data-h2.sql");
    DatabasePopulator databasePopulator = new ResourceDatabasePopulator(initSchema, initData);
    DatabasePopulatorUtils.execute(databasePopulator, dataSource);

    return dataSource;
}
--------------------------------------------------------------------------------------------------------
spring.datasource.tomcat.initSQL=ALTER SESSION SET...
--------------------------------------------------------------------------------------------------------
ALTER SESSION SET NLS_COMP=LINGUISTIC;  
ALTER SESSION SET NLS_SORT=BINARY_CI; 
--------------------------------------------------------------------------------------------------------
//    private Fairy buildFairy(final AnnotatedElement annotatedElement) {
//        final Random random = findAnnotation(annotatedElement, Random.class).get();
//        final Builder builder = Fairy.builder();
//
//        final String locale = random.locale();
//        if (!Random.DEFAULT_LOCALE.equals(locale)) {
//            builder.withLocale(Locale.forLanguageTag(locale));
//        }
//
//        final int seed = random.seed();
//        if (Random.DEFAULT_SEED != seed) {
//            builder.withRandomSeed(seed);
//        }
//        return builder.build();
//    }
--------------------------------------------------------------------------------------------------------
@ParameterizedTest
@CsvSource({
    "Jane, Doe, F, 1990-05-20",
    "John, Doe, M, 1990-10-22"
})
void testWithArgumentsAggregator(@AggregateWith(PersonAggregator.class) Person person) {
    // perform assertions against person
}
public class PersonAggregator implements ArgumentsAggregator {
    @Override
    public Person aggregateArguments(ArgumentsAccessor arguments, ParameterContext context) {
        return new Person(arguments.getString(0),
                          arguments.getString(1),
                          arguments.get(2, Gender.class),
                          arguments.get(3, LocalDate.class));
    }
}
--------------------------------------------------------------------------------------------------------
@ParameterizedTest
@ValueSource(strings = { "01.01.2017", "31.12.2017" })
void testWithExplicitJavaTimeConverter(
        @JavaTimeConversionPattern("dd.MM.yyyy") LocalDate argument) {

    assertEquals(2017, argument.getYear());
}

@ParameterizedTest
@EnumSource(TimeUnit.class)
void testWithExplicitArgumentConversion(
        @ConvertWith(ToStringArgumentConverter.class) String argument) {

    assertNotNull(TimeUnit.valueOf(argument));
}
public class ToStringArgumentConverter extends SimpleArgumentConverter {

    @Override
    protected Object convert(Object source, Class<?> targetType) {
        assertEquals(String.class, targetType, "Can only convert to String");
        return String.valueOf(source);
    }
}

      return providers.stream()
            .filter(provider -> provider.supports(targetType))
            .map(provider -> provider.createFor(annotatedElement, targetType))
            .findFirst()
            .orElseThrow(() -> new IllegalArgumentException("Cannot find provider for type: " + targetType));
			

@ParameterizedTest
@CsvSource({
    "Jane, Doe, F, 1990-05-20",
    "John, Doe, M, 1990-10-22"
})
void testWithArgumentsAccessor(ArgumentsAccessor arguments) {
    Person person = new Person(arguments.getString(0),
                               arguments.getString(1),
                               arguments.get(2, Gender.class),
                               arguments.get(3, LocalDate.class));

    if (person.getFirstName().equals("Jane")) {
        assertEquals(Gender.F, person.getGender());
    }
    else {
        assertEquals(Gender.M, person.getGender());
    }
    assertEquals("Doe", person.getLastName());
    assertEquals(1990, person.getDateOfBirth().getYear());
}
--------------------------------------------------------------------------------------------------------
https://jbehave.org/reference/latest/dependencies.html
--------------------------------------------------------------------------------------------------------
@BeforeStory
	public void beforeStory()
	{
		getDriverProvider().initialize();
		
		manage().timeouts().implicitlyWait(pageLoadTimeout, TimeUnit.SECONDS);
		manage().timeouts().pageLoadTimeout(pageLoadTimeout, TimeUnit.SECONDS);
		
		loginSteps.GivenMyWebSiteWithConfig();
	}

	@AfterStory
	public void afterStory() {
		getDriverProvider().end();
	}
--------------------------------------------------------------------------------------------------------
@Configuration
public class OutputConfiguration {
    @Bean
    @Primary
    public ObjectMapper customJson(){
        return new Jackson2ObjectMapperBuilder()
                   .indentOutput(true)
                   .serializationInclusion(JsonInclude.Include.NON_NULL)
                   .propertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE)
                   .build();
    }
}
@Configuration
public class OutputConfiguration {
   @Bean
    public Jackson2ObjectMapperBuilder customJson() {
        return new Jackson2ObjectMapperBuilder()
                .indentOutput(true)
                .serializationInclusion(JsonInclude.Include.NON_NULL)
                .propertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
    }
}
@Bean
    public MappingJackson2HttpMessageConverter customJson(){
        return new MappingJackson2HttpMessageConverter(
                new Jackson2ObjectMapperBuilder()
                        .indentOutput(true)
                        .serializationInclusion(JsonInclude.Include.NON_NULL)
                        .propertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE)
                        .build()
        );
} 
--------------------------------------------------------------------------------------------------------
#!/bin/bash

# New-year script, tested on a Mac

# Prevent sed error 'illegal byte sequence'
export LC_ALL=C LC_CTYPE=C LANG=C

newYear=`date +'%Y'`
echo "Updating copyright notice to $newYear"

# Exclude specific directories: -type d \( -path ./.git -o -path ./.ide \) -prune -o
# Make sed work on Mac: sed -e
# Prevent making backups: -i ''
find . -type d \( -path ./.git -o -path ./gradle \) -prune -o -type f -print0 | xargs -0 sed -i '' -e "s/Copyright 2019 Vavr/Copyright $newYear Vavr/"
--------------------------------------------------------------------------------------------------------
import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.UnknownHostException;
import java.util.Map;

import javax.annotation.PostConstruct;
import javax.net.ssl.SSLException;

import org.apache.commons.httpclient.ConnectTimeoutException;
import org.apache.curator.utils.CloseableUtils;
import org.apache.http.Header;
import org.apache.http.HttpEntityEnclosingRequest;
import org.apache.http.HttpRequest;
import org.apache.http.StatusLine;
import org.apache.http.client.HttpRequestRetryHandler;
import org.apache.http.client.ResponseHandler;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpDelete;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.client.protocol.HttpClientContext;
import org.apache.http.conn.HttpHostConnectException;
import org.apache.http.entity.ByteArrayEntity;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.protocol.HttpContext;
import org.apache.http.util.EntityUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class HttpClientManager {

    private static final Logger LOGGER = LoggerFactory.getLogger(HttpClientManager.class);

    @Value("${httpconfig.maxHttpConnections}")
    private transient Integer maxHttpConnections;

    @Value("${httpconfig.maxHttpConnectionsPerRoute}")
    private transient Integer maxHttpConnectionsPerRoute;

    @Value("${httpconfig.connectionTimeout}")
    private transient Integer connectionTimeout;

    @Value("${httpconfig.connectionRequestTimeout}")
    private transient Integer connectionRequestTimeout;

    @Value("${httpconfig.socketTimeout}")
    private transient Integer socketTimeout;

    @Value("${httpconfig.maxHttpRetries}")
    private transient Integer maxHttpRetries;

    CloseableHttpClient client = null;

    @PostConstruct
    public void init() {

        final PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();
        connectionManager.setMaxTotal(maxHttpConnections);
        connectionManager.setDefaultMaxPerRoute(maxHttpConnectionsPerRoute);

        final RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(connectionTimeout * 1000)
                .setConnectionRequestTimeout(connectionRequestTimeout * 1000).setSocketTimeout(socketTimeout * 1000)
                .build();

        client = HttpClients.custom().setRetryHandler(retryHandler).setDefaultRequestConfig(requestConfig)
                .setConnectionManager(connectionManager).build();
    }

    public String doHttpGet(final String url, final ResponseHandler<? extends Object> handler,
            final Map<String, String> headers) throws IOException {

        final HttpClientContext context = HttpClientContext.create();
        final HttpGet httpGet = new HttpGet(url);

        LOGGER.debug("Executing request {}", httpGet.getRequestLine());
        if (headers != null && headers.size() > 0) {
            for (final String key : headers.keySet()) {
                httpGet.addHeader(key, headers.get(key));
            }
        }
        if (client == null) {
            LOGGER.info("Re-initializing the http-client");
            client = httpClient(true);
        }

        final String responseBody = (String) client.execute(httpGet, handler, context);
        LOGGER.debug("Server Response: {}", responseBody);
        return responseBody;
    }

    public String doHttpDelete(final String url) throws IOException {

        CloseableHttpResponse httpResponse = null;

        try {
            final HttpClientContext context = HttpClientContext.create();
            final HttpDelete httpDelete = new HttpDelete(url);
            LOGGER.debug("Executing Delete request {}", httpDelete.getRequestLine());

            if (client == null) {
                LOGGER.info("Re-initializing the http-client");
                client = httpClient(true);
            }
            httpResponse = client.execute(httpDelete, context);
            final String content = EntityUtils.toString(httpResponse.getEntity());

            final StatusLine statusLine = httpResponse.getStatusLine();

            LOGGER.debug("Server Response for delete: {}", statusLine, content);

            final String response = String.valueOf(statusLine.getStatusCode());

            return response;
        } finally {
            CloseableUtils.closeQuietly(httpResponse);
        }
    }

    public CloseableHttpResponse doHttpGet(final String uri, final Header[] headers) throws Exception {
        CloseableHttpResponse closeableresponse = null;
        final HttpGet httpget = new HttpGet(uri);
        httpget.setHeaders(headers);
        if (client == null) {
            LOGGER.info("Re-initializing the http-client");
            client = httpClient(true);
        }
        closeableresponse = client.execute(httpget);
        LOGGER.debug("Response Status line :" + closeableresponse.toString());
        LOGGER.debug("HTTP status " + closeableresponse.getStatusLine().getStatusCode());
        if (closeableresponse.getStatusLine().getStatusCode() == 202
                || closeableresponse.getStatusLine().getStatusCode() == 200) {

            return closeableresponse;
        } else {
            throw new Exception("cannot get records using anchor id and query. status code: "
                    + closeableresponse.getStatusLine().getStatusCode());
        }
    }

    public String doHttpPost(final String url, final String payload, final Header[] headers,
            final ResponseHandler<String> handler) throws IOException {

        final HttpClientContext context = HttpClientContext.create();
        final HttpPost post = new HttpPost(url);
        post.setEntity(new StringEntity(payload));
        post.setHeaders(headers);
        LOGGER.debug("Executing request {} with payload {}", post.getRequestLine(), payload);

        if (client == null) {
            LOGGER.info("Re-initializing the http-client");
            client = httpClient(true);
        }
        final String responseBody = client.execute(post, handler, context);
        LOGGER.debug("Server Response: {}", responseBody);

        return responseBody;
    }

    public String doHttpPut(final String url, final String payload, final Header[] headers,
            final ResponseHandler<String> handler) throws IOException {

        final HttpClientContext context = HttpClientContext.create();
        final HttpPut post = new HttpPut(url);
        post.setEntity(new StringEntity(payload));
        post.setHeaders(headers);
        LOGGER.debug("Executing request {} with payload {}", post.getRequestLine(), payload);
        if (client == null) {
            LOGGER.info("Re-initializing the http-client");
            client = httpClient(true);
        }
        final String responseBody = client.execute(post, handler, context);
        LOGGER.debug("Server Response: {}", responseBody);

        return responseBody;
    }

    public String doHttpPut(final String url, final String payload, final Map<String, String> headers,
            final ResponseHandler<String> handler) throws IOException {

        final HttpClientContext context = HttpClientContext.create();
        final HttpPut put = new HttpPut(url);
        put.setEntity(new StringEntity(payload));

        if (headers != null && headers.size() > 0) {
            for (final String key : headers.keySet()) {
                put.addHeader(key, headers.get(key));
            }
        }

        LOGGER.debug("Executing request {} with payload {}", put.getRequestLine(), payload);
        if (client == null) {
            LOGGER.info("Re-initializing the http-client");
            client = httpClient(true);
        }
        final String responseBody = client.execute(put, handler, context);
        LOGGER.debug("Server Response: {}", responseBody);

        return responseBody;
    }

    public String doHttpPost(final String url, final String payload, final Map<String, String> headers,
            final ResponseHandler<String> handler) throws IOException {

        final HttpClientContext context = HttpClientContext.create();
        final HttpPost post = new HttpPost(url);
        post.setEntity(new StringEntity(payload));

        if (headers != null && headers.size() > 0) {
            for (final String key : headers.keySet()) {
                post.addHeader(key, headers.get(key));
            }
        }

        LOGGER.debug("Executing request {} with payload {}", post.getRequestLine(), payload);

        if (client == null) {
            LOGGER.info("Re-initializing the http-client");
            client = httpClient(true);
        }
        final String responseBody = client.execute(post, handler, context);
        LOGGER.debug("Server Response: {}", responseBody);

        return responseBody;
    }

    public String doHttpPut(final String url, final byte[] payload, final Map<String, String> headers,
            final ResponseHandler<String> handler) throws IOException {

        final HttpClientContext context = HttpClientContext.create();
        final HttpPut put = new HttpPut(url);
        put.setEntity(new ByteArrayEntity(payload));

        if (headers != null && headers.size() > 0) {
            for (final String key : headers.keySet()) {
                put.addHeader(key, headers.get(key));
            }
        }

        LOGGER.debug("Executing request {}", put.getRequestLine());
        if (client == null) {
            LOGGER.info("Re-initializing the http-client");
            client = httpClient(true);
        }
        final String responseBody = client.execute(put, handler, context);
        LOGGER.debug("Server Response: {}", responseBody);

        return responseBody;
    }

    private CloseableHttpClient httpClient(final boolean useRetryHandler) {

        HttpClientBuilder builder = HttpClientBuilder.create();

        final PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();
        connectionManager.setMaxTotal(maxHttpConnections);
        connectionManager.setDefaultMaxPerRoute(maxHttpConnectionsPerRoute);

        if (useRetryHandler) {
            builder = builder.setRetryHandler(retryHandler);
        }
        final RequestConfig config = RequestConfig.custom().setConnectTimeout(connectionTimeout * 1000)
                .setConnectionRequestTimeout(connectionRequestTimeout * 1000).setSocketTimeout(socketTimeout * 1000)
                .build();
        final CloseableHttpClient httpClient = builder.setDefaultRequestConfig(config)
                .setConnectionManager(connectionManager).build();

        return httpClient;
    }

    private final HttpRequestRetryHandler retryHandler = new HttpRequestRetryHandler() {

        @Override
        public boolean retryRequest(final IOException exception, final int executionCount, final HttpContext context) {
            LOGGER.warn(
                    "Exception occoured while performing REST operation. Retrying the operation {} times for every 5 seconds and execution count is {}/{}  ",
                    maxHttpRetries, executionCount, maxHttpRetries);
            try {
                Thread.sleep(5000);
            } catch (final Exception e) {
                LOGGER.error("Thread interrupted occured while waiting for next iteration ", e);
            }

            // Do not retry if over max retry count
            if (executionCount >= maxHttpRetries) { return false; }

            // Timeout
            if (exception instanceof InterruptedIOException || exception instanceof UnknownHostException
                    || exception instanceof ConnectTimeoutException || exception instanceof HttpHostConnectException
                    || exception instanceof SSLException) {

            return false; }

            final HttpClientContext clientContext = HttpClientContext.adapt(context);
            final HttpRequest request = clientContext.getRequest();
            final boolean idempotent = !(request instanceof HttpEntityEnclosingRequest);
            LOGGER.info("idempotent {}", idempotent);
            // Retry if the request is considered idempotent
            if (idempotent) { return true; }
            return false;
        }

    };

    public void shutdown() {
        LOGGER.info("Shutting down http connection manager.");
        CloseableUtils.closeQuietly(client);
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.redsky.client.exception.ResourceValidationException;
import com.redsky.client.pojo.RequestPayload;

@Component
public class InputRequestValidator implements RequestValidator<RequestPayload> {

    @Autowired
    private BeanValidator validator;

    @Autowired
    private NameValidator nameValidator;

    @Override
    public boolean validate(final RequestPayload bean) throws ResourceValidationException {
        boolean result = false;
        if (bean != null) {
            result = validator.validate(bean);
        }
        if (result) {
            result = nameValidator.isValidName(bean.getProduct().getName());
        }

        return result;
    }
}
--------------------------------------------------------------------------------------------------------
tring jsonCarArray = 
  "[{ \"color\" : \"Black\", \"type\" : \"BMW\" }, { \"color\" : \"Red\", \"type\" : \"FIAT\" }]";
ObjectMapper objectMapper = new ObjectMapper();
objectMapper.configure(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);
Car[] cars = objectMapper.readValue(jsonCarArray, Car[].class);
// print cars
--------------------------------------------------------------------------------------------------------
String jsonCarArray = 
  "[{ \"color\" : \"Black\", \"type\" : \"BMW\" }, { \"color\" : \"Red\", \"type\" : \"FIAT\" }]";
ObjectMapper objectMapper = new ObjectMapper();
List<Car> listCar = objectMapper.readValue(jsonCarArray, new TypeReference<List<Car>>(){});
// print cars
--------------------------------------------------------------------------------------------------------
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.springframework.stereotype.Component;

@Component
public class NameValidator {

    private static final String NAME_PATTERN = "^[a-zA-Z0-9\\._\\s\\-]+$";

    public boolean isValidName(final String name) {
        final Pattern pattern = Pattern.compile(NAME_PATTERN);
        final Matcher matcher = pattern.matcher(name);
        return matcher.matches();
    }
}
--------------------------------------------------------------------------------------------------------
-- create a keyspace
create keyspace if not exists target with replication = {'class':'SimpleStrategy','replication_factor':1};

-- use keyspace
use target;

-- create table
create table product(productid bigint primary key, price double);

-- insert products
insert into product(productid, price) values(22222111, 243.87);
insert into product(productid, price) values(1234567, 243.87);
--------------------------------------------------------------------------------------------------------
from flask import Flask, request, Response
import json

""""
Product name webservice to get and post product name
endpoints:
    GET   /products/<id> gives product json with id and name if product exists in dictionary
    POST  /products  adds a product id and its corresponding name to the dictionary
"""
app = Flask(__name__)
products = dict()


@app.route("/products/<id>")
def get_product(id):
    """
    api method to get a product details by its id from products dictionary
    :param id: product id
    :type id: int
    :return: json
    :returns : product id and name if product exists / 404 not found if id is empty /
               id and None if product is not found
    """
    if not products.get(id, None):
        return Response(status=404)
    _product = dict()
    _product["id"] = id
    _product["name"] = products.get(id, None)
    return json.dumps(_product)


@app.route("/products", methods=['POST'])
def add_product():
    """
    api method to add a product and its name to products dictionary
    :return: Response object
    :returns Response 200 on success / Response 400 for missing or invalid data
    """
    if not request.data:
        return Response(status=400)
    id = None
    name = ""
    data = json.loads(request.data)
    for key, val in data.items():
        if key == "id":
            id = val
        if key == "name":
            name = val
    if not name or not id:
        return Response(status=400)
    products[id] = name
    print("adding product {0} {1}".format(id, name))
    return Response(status=201)


if __name__ == "__main__":
    app.run(port=8100)
	
Flask==0.12.2
Jinja2==2.10
MarkupSafe==1.0
Werkzeug==0.12.2
click==6.7
itsdangerous==0.24
wsgiref==0.1.2

cassandra.contactpoints=localhost
cassandra.port=9042
cassandra.keyspace=target
--------------------------------------------------------------------------------------------------------
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;
import org.springframework.data.cassandra.config.CassandraClusterFactoryBean;
import org.springframework.data.cassandra.config.java.AbstractCassandraConfiguration;
import org.springframework.data.cassandra.mapping.BasicCassandraMappingContext;
import org.springframework.data.cassandra.mapping.CassandraMappingContext;
import org.springframework.data.cassandra.repository.config.EnableCassandraRepositories;

/**
 * Created by pranith macha on 12/3/17.
 */
@Configuration
@PropertySource(value = {"classpath:cassandra.properties"})
@EnableCassandraRepositories(basePackages = {"com.boot.docker.SpringBootDocker"})
public class CassandraConfig extends AbstractCassandraConfiguration {

    @Autowired
    private Environment environment;

    @Bean
    public CassandraClusterFactoryBean cluster() {
        CassandraClusterFactoryBean cluster = new CassandraClusterFactoryBean();
        cluster.setContactPoints(environment.getProperty("cassandra.contactpoints"));
        cluster.setPort(Integer.parseInt(environment.getProperty("cassandra.port")));
        return cluster;
    }

    @Override
    protected String getKeyspaceName() {
        return environment.getProperty("cassandra.keyspace");
    }

    @Bean
    public CassandraMappingContext cassandraMapping() throws ClassNotFoundException {
        return new BasicCassandraMappingContext();
    }
}
--------------------------------------------------------------------------------------------------------

import com.retail.target.data.ProductDAO;
import org.springframework.data.cassandra.repository.CassandraRepository;
import org.springframework.stereotype.Repository;

/**
 * Created by pranith macha on 12/3/17.
 */

@Repository
public interface ProductRepository extends CassandraRepository<ProductDAO> {
}
--------------------------------------------------------------------------------------------------------
import org.springframework.cassandra.core.Ordering;
import org.springframework.cassandra.core.PrimaryKeyType;
import org.springframework.data.cassandra.mapping.Column;
import org.springframework.data.cassandra.mapping.PrimaryKeyColumn;
import org.springframework.data.cassandra.mapping.Table;

/**
 * Created by pranith macha on 11/30/17.
 */

@Table(value = "product")
public class ProductDAO {


    @PrimaryKeyColumn(name = "productid", type = PrimaryKeyType.PARTITIONED, ordering = Ordering.DESCENDING)
    private long productid;

    @Column(value = "price")
    private double price;

    public long getProductid() {
        return productid;
    }

    public void setProductid(long productid) {
        this.productid = productid;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }
}
--------------------------------------------------------------------------------------------------------
	String fileName = "C:/Users/eo903e/contentModerator-master/ContentModeratorAPI/src/main/resources/objectionable_content.txt";
		Path path = Paths.get(fileName);
		byte[] bytes = Files.readAllBytes(path);
		List<String> langList = Files.readAllLines(path, StandardCharsets.UTF_8);
		return langList;
--------------------------------------------------------------------------------------------------------
version: "3"
services:
  mysql:
    build: mysql
    ports:
      - "3306:3306"
    environment:
        MYSQL_ROOT_PASSWORD: password
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      timeout: 20s
      retries: 10
--------------------------------------------------------------------------------------------------------
FROM mysql:5.6

# 確認用
# ENV TZ=Asia/Tokyo
# RUN echo $TZ | tee /etc/timezone && dpkg-reconfigure --frontend noninteractive tzdata

ADD my.cnf /etc/mysql/conf.d/my.cnf
ADD dbinit.sql /docker-entrypoint-initdb.d/

RUN chmod 644 /etc/mysql/conf.d/my.cnf /docker-entrypoint-initdb.d/*
--------------------------------------------------------------------------------------------------------
CREATE DATABASE IF NOT EXISTS workdb;
CREATE DATABASE IF NOT EXISTS tododb;
CREATE USER 'user'@'%' IDENTIFIED BY 'password';
GRANT ALL PRIVILEGES ON *.* TO 'user'@'%' WITH GRANT OPTION;
--------------------------------------------------------------------------------------------------------
[mysqld]
character_set_server=utf8mb4
collation_server=utf8mb4_general_ci
autocommit=0
transaction-isolation=READ-COMMITTED
--------------------------------------------------------------------------------------------------------
spring.data.rest.base-path=/api
--------------------------------------------------------------------------------------------------------
    @RequestMapping(value="/login", method=RequestMethod.POST)
    public AuthenticationToken login(

            @RequestBody AuthenticationRequest authenticationRequest, HttpSession session ) {
        String username = authenticationRequest.getUsername();
        String password = authenticationRequest.getPassword();
        UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(username, password);
        Authentication authentication = authenticationManager.authenticate(token);
        SecurityContextHolder.getContext().setAuthentication(authentication);
        session.setAttribute(HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY, SecurityContextHolder.getContext());
        UserDetails user = customUserDetailsService.loadUserByUsername(username);  // 예제에선 유저 객체에서 직접 이름과 authorities와 id를 가져왔는데 details에서 가져오면 상관없지않을까?

        return new AuthenticationToken(user.getUsername(), user.getAuthorities(), session.getId());
    }
--------------------------------------------------------------------------------------------------------
    @PostMapping("")
    public String create(Member member) {
        MemberRole role = new MemberRole();
        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
        member.setUpw(passwordEncoder.encode(member.getUpw()));
        role.setRoleName("BASIC");
        member.setRoles(Arrays.asList(role));
        memberRepository.save(member);
        return "redirect:/";
    }
--------------------------------------------------------------------------------------------------------
import com.example.demo.service.CustomUserDetailsService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter{

    @Autowired
    CustomUserDetailsService customUserDetailsService;

    //스프링 시큐리티에서 로그인 처리를 구현하려면 SecurityConfig에서
    // AuthenticationManagerBuilder를 주입해서 인증에 대한 처리를 해야 한다.

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        //method 를 autowired할때는 그 return 값을 객체로 빈에 저장하는것이 아니었나?
        auth.userDetailsService(customUserDetailsService)
                .passwordEncoder(passwordEncoder());
    }

    @Bean  // . authenticationManagerBean 메소드의 경우에는 SpringSecurity에서 사용되는 인증객체를 Bean으로 등록할 때 사용합니다.
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean(); }


    @Override
    public void configure(WebSecurity web) throws Exception
    {
        web.ignoring().antMatchers("/css/**", "/script/**", "image/**", "/fonts/**", "lib/**");
    }
    @Override
    protected void configure(HttpSecurity http) throws Exception
    {
        http.csrf().disable()
                .authorizeRequests()
                .antMatchers("/user/login")
                .permitAll() .antMatchers("/user")
                .hasAuthority("USER") .antMatchers("/admin")
                .hasAuthority("ADMIN")
                .anyRequest().authenticated()
                .and().logout();

    }



    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

}
--------------------------------------------------------------------------------------------------------
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Properties;
import java.util.Set;

import org.apache.log4j.Logger;

public class RegionCountryMap {
	
	private static RegionCountryMap instance = new RegionCountryMap();
	private Logger logger = Logger.getLogger(RegionCountryMap.class);
	
	private Properties prop;
	
	private RegionCountryMap(){
		
		InputStream  input = null;
		 
		try { 
			URL url = RegionCountryMap.class.getClassLoader().getResource("region_to_country.dat");
			String file = url.getPath();
			prop = new Properties();
			input = new FileInputStream(file);
			prop.load(input);
	 
		} catch (IOException ex) {
			logger.error(ex);
		} finally {
			if (input != null) {
				try {
					input.close();
				} catch (IOException e) {
					logger.error(e);
				}
			}
		}
		
	}
	
	public static RegionCountryMap getInstance(){
		return instance;
	}
	
	public String getCountry(String region){
		return prop.getProperty(region);
	}
	
	public boolean hasCountry(String region){
		if(prop.getProperty(region) != null){
			return true;
		}
		return false;
	}

	public Set<Object> getKeys() {
		return prop.keySet();
	}
	

}
--------------------------------------------------------------------------------------------------------
public enum States {
	// US states
	AL("Alabama"), AK("Alaska"), AZ("Arizona"), AR("Arkansas"), CA("California"), CO("Colorado"),
	CT("Connecticut"), DE("Delaware"), FL("Florida"), GA("Georgia"), HI("Hawaii"), ID("Idaho"), 
	IL("Illinois"), IN("Indiana"), IA("Iowa"), KS("Kansas"), KY("Kentucky"), LA("Louisiana"),
	ME("Maine"), MD("Maryland"), MA("Massachusetts"), MI("Michigan"), MN("Minnesota"), MS("Mississippi"), 
	MO("Missouri"), MT("Montana"), NE("Nebraska"), NV("Nevada"), NH("New Hampshire"), NJ("New Jersey"),
	NM("New Mexico"), NY("New York"), NC("North Carolina"), ND("North Dakota"), OH("Ohio"), OK("Oklahoma"),
	OR("Oregon"), PA("Pennsylvania"), RI("Rhode Island"), SC("South Carolina"), SD("South Dakota"), 
	TN("Tennessee"), TX("Texas"), UT("Utah"), VT("Vermont"), VA("Virginia"), WA("Washington"), 
	WV("West Virginia"), WI("Wisconsin"), WY("Wyoming"), DC("District of Columbia"), AS("American Samoa"), 
	GU("Guam"), MP("Northern Mariana Islands"), PR("Puerto Rico"), VI("U.S. Virgin Islands"),
	// Canada states
	NB("New Brunswick"), NU("Nunavut"), NL("Newfoundland and Labrador"), MB("Manitoba"), YT("Yukon"),
	BC("British Columbia"), PE("Prince Edward Island"), NT("Northwest Territories"), QC("Quebec"), 
	NS("Nova Scotia"), AB("Alberta"), SK("Saskatchewan"), ON("Ontario");
	
	private String keyword;
	
	private States(String k) {
		this.keyword = k;
	}
	
	public static States getEnum(String state) {
		for (States c : States.values()) {
			if (c.name().equalsIgnoreCase(state)) {
				return c;
			}
		}
		return null;
	}
	
	public String getKeyword(){
		return keyword;
	}

}
--------------------------------------------------------------------------------------------------------
public enum Platform {
	ANDROID("android"),IOS("ios"),WINDOWS("windows");
	
	private String keyword;
	
	private Platform(String key) {
		this.keyword = key;
	}
	
	public static Platform matchText(String text){
		text = text.toLowerCase();
		for(Platform a:Platform.values()){
			if(text.contains(a.keyword)){
				return a;
			}
		}
		return null;
	}

	public static Platform getEnum(String val){
		for(Platform key: Platform.values()){
			if(key.keyword.equalsIgnoreCase(val)){
				return key;
			}
		}
		return null;
	}
}
--------------------------------------------------------------------------------------------------------

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import org.apache.hadoop.hbase.util.Bytes;


//written by Robin Li for HBase key optimization

public class HBaseUtil {
	
	public static byte[] constructKey (int token_i, String udid_s){
		byte[] udid = udid_s.getBytes();
		MessageDigest md;
		try {
			md = MessageDigest.getInstance("MD5");
			udid = md.digest(udid); 
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		}
		int salt = ((int) udid[0])<<29 | (token_i);

		byte[] key = Bytes.add(Bytes.toBytes(salt), udid);
		return key;
	}
	
}
--------------------------------------------------------------------------------------------------------
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import org.apache.hadoop.hbase.client.Result;
import org.apache.log4j.Logger;

public class HBaseThreadPool {
	
	private ExecutorService service = Executors.newFixedThreadPool(10);
	
	private static HBaseThreadPool instance = new HBaseThreadPool();
	private static Logger logger = Logger.getLogger(HBaseThreadPool.class);
	
	private HBaseThreadPool(){
		
	}
	
	public static HBaseThreadPool getInstance(){
		return instance;
	}
	
	public List<Future<Result>> submitHBaseTaskList(List<HBaseTask> tasks){
		try {
			List<Future<Result>> results = service.invokeAll(tasks);
			return results;
		} catch (InterruptedException e) {
			logger.error(e);
			e.printStackTrace();
		}
		return null;
	}

}
--------------------------------------------------------------------------------------------------------
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.ZooKeeperConnectionException;
import org.apache.hadoop.hbase.client.HConnection;
import org.apache.hadoop.hbase.client.HConnectionManager;
import org.apache.log4j.Logger;

public class HBaseDataSource {
	
	private Configuration config;
	private Logger logger = Logger.getLogger(HBaseDataSource.class);
	
	private static HBaseDataSource instance = new HBaseDataSource();
	
	private HBaseDataSource() {
		config = HBaseConfiguration.create(); 
	}
	
	public static HBaseDataSource getInstance(){
		return instance;
	}
	
	public HConnection getConnection(){
		try {
			return HConnectionManager.createConnection(config);
		} catch (ZooKeeperConnectionException e) {
			logger.error(e);
			e.printStackTrace();
		}
		return null;
	}
}
--------------------------------------------------------------------------------------------------------
#
# This file configures the New Relic Agent.  New Relic monitors
# Java applications with deep visibility and low overhead.  For more
# information, visit www.newrelic.com.
#
# This configuration file is custom generated for Tapjoy
#
# This section is for settings common to all environments.
# Do not add anything above this next line.
common: &default_settings
  #
  # ============================== LICENSE KEY ===============================

  # You must specify the license key associated with your New Relic
  # account.  This key binds your Agent's data to your account in the
  # New Relic service.
  license_key: 'bb8353602ba48d962a5db59ac4e1468d2da7fb8d'
  
  # Agent Enabled
  # Use this setting to force the agent to run or not run.
  # Default is true.
  # agent_enabled: true
  
  # Set to true to enable support for auto app naming.
  # The name of each web app is detected automatically
  # and the agent reports data separately for each one.
  # This provides a finer-grained performance breakdown for
  # web apps in New Relic.
  # Default is false.
  enable_auto_app_naming: false
  
  # Set to true to enable component-based transaction naming.
  # Set to false to use the URI of a web request as the name of the transaction.
  # Default is true.
  enable_auto_transaction_naming: true
 
  # Set the name of your application as you'd like it show up in New Relic.
  # if enable_auto_app_naming is false, the agent reports all data to this application.
  # Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application.
  # To report data to more than one application, separate the application names with ";".
  # For example, to report data to"My Application" and "My Application 2" use this:
  # app_name: My Application;My Application 2
  # This setting is required.
  app_name: Reach Service

  # The agent uses its own log file to keep its logging
  # separate from that of your application.  Specify the log level here.
  # This setting is dynamic, so changes do not require restarting your application.
  # The levels in increasing order of verboseness are: off, severe, warning, info, fine, finer, finest
  # Default is info.
  log_level: info
  
  # Log all data to and from New Relic in plain text.
  # This setting is dynamic, so changes do not require restarting your application.
  # Default is false.
  #audit_mode: true
  
  # The number of log files to use.
  # Default is 1.
  #log_file_count: 1
  
  # The maximum number of bytes to write to any one log file.
  # Default is 0 (no limit).
  #log_limit_in_kbytes: 0

  # The name of the log file.
  # Default is newrelic_agent.log.
  #log_file_name: newrelic_agent.log
  
  # The log file directory.
  # Default is the logs directory in the newrelic.jar parent directory.
  #log_file_path:
  
  # The agent communicates with New Relic via https by
  # default.  If you want to communicate with newrelic via http,
  # then turn off SSL by setting this value to false.
  # This work is done asynchronously to the threads that process your
  # application code, so response times will not be directly affected
  # by this change.
  # Default is true.
  ssl: true
  
  # Proxy settings for connecting to the New Relic server.
  #
  # If a proxy is used, the host setting is required.  Other settings
  # are optional.  Default port is 8080.  The username and password
  # settings will be used to authenticate to Basic Auth challenges
  # from a proxy server.
  #
  # proxy_host: hostname
  # proxy_port: 8080
  # proxy_user: username
  # proxy_password: password

  # Tells transaction tracer and error collector (when enabled)
  # whether or not to capture HTTP params.  When true, frameworks can
  # exclude HTTP parameters from being captured.
  # Default is false.
  capture_params: false
  
  # Tells transaction tracer and error collector to not to collect
  # specific http request parameters. 
  # ignored_params: credit_card, ssn, password

  # Transaction tracer captures deep information about slow
  # transactions and sends this to the New Relic service once a
  # minute. Included in the transaction is the exact call sequence of
  # the transactions including any SQL statements issued.
  transaction_tracer:
  
    # Transaction tracer is enabled by default. Set this to false to
    # turn it off. This feature is only available at the higher product levels.
    # Default is true.
    enabled: true
    
    # Threshold in seconds for when to collect a transaction
    # trace. When the response time of a controller action exceeds
    # this threshold, a transaction trace will be recorded and sent to
    # New Relic. Valid values are any float value, or (default) "apdex_f",
    # which will use the threshold for the "Frustrated" Apdex level
    # (greater than four times the apdex_t value).
    # Default is apdex_f.
    transaction_threshold: apdex_f
 
    # When transaction tracer is on, SQL statements can optionally be
    # recorded. The recorder has three modes, "off" which sends no
    # SQL, "raw" which sends the SQL statement in its original form,
    # and "obfuscated", which strips out numeric and string literals.
    # Default is obfuscated.
    record_sql: obfuscated
    
    # Obfuscate only occurrences of specific SQL fields names.
    # This setting only applies if "record_sql" is set to "raw".
    #obfuscated_sql_fields: credit_card, ssn, password

    # Set this to true to log SQL statements instead of recording them.
    # SQL is logged using the record_sql mode.
    # Default is false.
    log_sql: false

    # Threshold in seconds for when to collect stack trace for a SQL
    # call. In other words, when SQL statements exceed this threshold,
    # then capture and send to New Relic the current stack trace. This is
    # helpful for pinpointing where long SQL calls originate from.
    # Default is 0.5 seconds.
    stack_trace_threshold: 0.5

    # Determines whether the agent will capture query plans for slow
    # SQL queries. Only supported for MySQL and PostgreSQL.
    # Default is true.
    explain_enabled: true

    # Threshold for query execution time below which query plans will not 
    # not be captured.  Relevant only when `explain_enabled` is true.
    # Default is 0.5 seconds.
    explain_threshold: 0.5
    
    # Use this setting to control the variety of transaction traces.
    # The higher the setting, the greater the variety.
    # Set this to 0 to always report the slowest transaction trace.
    # Default is 20.
    top_n: 20
    
  
  # Error collector captures information about uncaught exceptions and
  # sends them to New Relic for viewing
  error_collector:
    
    # Error collector is enabled by default. Set this to false to turn
    # it off. This feature is only available at the higher product levels.
    # Default is true.
    enabled: true
        
    # To stop specific exceptions from reporting to New Relic, set this property
    # to a comma separated list of full class names.
    #
    # ignore_errors:

    # To stop specific http status codes from being reporting to New Relic as errors, 
    # set this property to a comma separated list of status codes to ignore.
    # When this property is commented out it defaults to ignoring 404s.
    #
    # ignore_status_codes: 404

  # Cross Application Tracing adds request and response headers to
  # external calls using the Apache HttpClient libraries to provided better
  # performance data when calling applications monitored by other New Relic Agents.
  #
  cross_application_tracer:
    # Set to true to enable cross application tracing.
    # Default is true.
    enabled: true

  # Thread profiler measures wall clock time, CPU time, and method call counts
  # in your application's threads as they run.
  thread_profiler:

    # Set to false to disable the thread profiler.
    # Default is true.
    enabled: true
  
  #============================== Browser Monitoring ===============================
  # New Relic Real User Monitoring gives you insight into the performance real users are
  # experiencing with your website. This is accomplished by measuring the time it takes for
  # your users' browsers to download and render your web pages by injecting a small amount
  # of JavaScript code into the header and footer of each page. 
  browser_monitoring:
    # By default the agent automatically inserts API calls in compiled JSPs to
    # inject the monitoring JavaScript into web pages.
    # Set this attribute to false to turn off this behavior.
    auto_instrument: true
    # Set this attribute to false to prevent injection of the monitoring JavaScript.
    # Default is true.
    enabled: true
    
# Application Environments
# ------------------------------------------
# Environment specific settings are in this section.
# You can use the environment to override the default settings.
# For example, to change the app_name setting.
# Use -Dnewrelic.environment=<environment> on the Java command line
# to set the environment.
# The default environment is production.

# NOTE if your application has other named environments, you should
# provide configuration settings for these environments here.

development:
  <<: *default_settings
  app_name: My Application (Development)

test:
  <<: *default_settings
  app_name: My Application (Test)

production:
  <<: *default_settings

staging:
  <<: *default_settings
  app_name: My Application (Staging)
--------------------------------------------------------------------------------------------------------
#!/bin/bash

# Set up classpath and invoke 'java' with it ...


cp=".:./../resources:./../dist/ReachService.jar"

cp=$cp:$(echo ./../lib/*.jar | tr ' ' :)
echo "classpath are: $cp"

ja="-javaagent:./../newrelic/newrelic.jar"
#ja="-javaagent:/home/tjopt/GIT_opt/tapjoyoptimization/opt_server/newrelic/newrelic.jar"
#echo "Javaagent: $ja"

exec java "$ja" -cp $cp com.tapjoy.reach.service.ReachService 
echo $! > pid
--------------------------------------------------------------------------------------------------------
@Configuration
@ComponentScan("com.concretepage")
@EnableWebMvc
public class AppConfig implements WebMvcConfigurer {
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
        builder.indentOutput(true);
        converters.add(new MappingJackson2HttpMessageConverter(builder.build()));
    }
} 

--------------------------------------------------------------------------------------------------------
//    @Bean
//    public FilterRegistrationBean httpsOnlyFilter() {
//        FilterRegistrationBean registration = new FilterRegistrationBean();
//        registration.setFilter(new HttpsOnlyFilter());
//        registration.addUrlPatterns("/*");
//        return registration;
//    }
--------------------------------------------------------------------------------------------------------
//import org.springframework.context.annotation.Configuration;
//import org.springframework.data.mongodb.core.convert.DefaultMongoTypeMapper;
//
///**
// *
// * Custom Mongo Type Mapper
// *
// * @author Alex
// * @version 1.0.0
// * @since 2017-08-08
// */
//@Configuration("publicationAppConfiguration")
//public class AppConfiguration2 extends DefaultMongoTypeMapper {
//    //implement custom type mapping here
//}

--------------------------------------------------------------------------------------------------------
    @Bean
    public HazelcasetInstance getInstance() {
        return HazelcasetClient.newHazelCastClient();
    }
--------------------------------------------------------------------------------------------------------
private class SwaggerInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if (!authHeaderValid(request.getHeader("Authorization"))) {
            response.addHeader("Access-Control-Allow-Origin", "null");
            response.addHeader("WWW-Authenticate", "Basic realm=\"\"");
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().println("HTTP Status " + HttpServletResponse.SC_UNAUTHORIZED);

            return false;
        }

        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { }

    private boolean authHeaderValid(String authorization) {
        if (authorization != null && authorization.startsWith("Basic ")) {
            final String[] values = new String(Base64.getDecoder().decode(authorization.substring("Basic ".length()))).split(":");

            return values[0].equals("username") && values[1].equals("password");
        }

        return false;
    }
}
--------------------------------------------------------------------------------------------------------
//public static class CustomizedViewResolver extends UrlBasedViewResolver {
//    @Override
//    protected AbstractUrlBasedView buildView(final String viewName) throws Exception {
//        String newViewName;
//        if (viewName.equals("index.html")) {
//            newViewName = "swagger-ui.html";
//        } else {
//            newViewName = viewName;
//        }
//        return super.buildView(newViewName);
//    }
//
//    @Nullable
//    protected Class<?> getViewClass() {
//        return InternalResourceView.class;
//    }
//}

/*
 @Controller
 public class HomeController {

 @RequestMapping(value = "/", method = RequestMethod.GET)
 public ModelAndView home(Locale locale, Model model) {
 // (...)

 return new ModelAndView("/someurl/resources/home.html"); // NOTE here there is /someurl/resources
 }

 }

 */

/*
@Configuration
@EnableWebMvc
public class WebConfig extends WebMvcConfigurerAdapter {
  @Autowired
  @Qualifier("jstlViewResolver")
  private ViewResolver jstlViewResolver;

  @Override
  public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler("/someurl/resources/**").addResourceLocations("/resources/");

  }

  @Bean
  @DependsOn({ "jstlViewResolver" })
  public ViewResolver viewResolver() {
    return jstlViewResolver;
  }

  @Bean(name = "jstlViewResolver")
  public ViewResolver jstlViewResolver() {
    UrlBasedViewResolver resolver = new UrlBasedViewResolver();
    resolver.setPrefix(""); // NOTE: no preffix here
    resolver.setViewClass(JstlView.class);
    resolver.setSuffix(""); // NOTE: no suffix here
    return resolver;
  }

// NOTE: you can use InternalResourceViewResolver it does not matter
//  @Bean(name = "internalResolver")
//  public ViewResolver internalViewResolver() {
//    InternalResourceViewResolver resolver = new InternalResourceViewResolver();
//    resolver.setPrefix("");
//    resolver.setSuffix("");
//    return resolver;
//  }
}
--------------------------------------------------------------------------------------------------------
////    @Bean
////    public SSLContextParameters sslContextParameters(@Value("${horweb.javamail.keystore.location}") final String location,
////                                                     @Value("${horweb.javamail.keystore.password}") final String password) {
////        final KeyStoreParameters store = new KeyStoreParameters();
////        store.setResource(location);
////        store.setPassword(password);
////
////        final TrustManagersParameters trust = new TrustManagersParameters();
////        trust.setKeyStore(store);
////
////        final SSLContextParameters parameters = new SSLContextParameters();
////        parameters.setTrustManagers(trust);
////        return parameters;
////    }
--------------------------------------------------------------------------------------------------------
@Configuration
@ConditionalOnClass({ DispatcherHandler.class, HttpHandler.class })
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
@ConditionalOnMissingBean(HttpHandler.class)
@AutoConfigureAfter({ WebFluxAutoConfiguration.class })
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
--------------------------------------------------------------------------------------------------------
@Configuration
public class HandlerConfiguration {

    /*
     * Create required HandlerMapping, to avoid several default HandlerMapping instances being created
     */
    @Bean
    public HandlerMapping handlerMapping() {
        return new RequestMappingHandlerMapping();
    }

    /*
     * Create required HandlerAdapter, to avoid several default HandlerAdapter instances being created
     */
    @Bean
    public HandlerAdapter handlerAdapter() {
        return new RequestMappingHandlerAdapter();
    }

    /*
     * optimization - avoids creating default exception resolvers; not required as the serverless container handles
     * all exceptions
     *
     * By default, an ExceptionHandlerExceptionResolver is created which creates many dependent object, including
     * an expensive ObjectMapper instance.
     */
    @Bean
    public HandlerExceptionResolver handlerExceptionResolver() {
        return (request, response, handler, ex) -> null;
    }
}
--------------------------------------------------------------------------------------------------------
//import org.springframework.context.annotation.Configuration;
//import org.springframework.context.annotation.Profile;
//import org.springframework.hateoas.config.EnableHypermediaSupport;
//import org.springframework.hateoas.config.EnableHypermediaSupport.HypermediaType;
//
///**
// * Separate configuration class to enable Spring Hateoas functionality if the {@code hateoas} profile is activated.
// *
// */
//@Configuration
//@Profile("hateoas")
//@EnableHypermediaSupport(type = HypermediaType.HAL)
//public class HyperMediaConfiguration {
//}
--------------------------------------------------------------------------------------------------------
//import com.mongodb.MongoClient;
//import com.mongodb.MongoClientOptions;
//
//import com.wildbeeslabs.api.rest.common.service.interfaces.IPropertiesConfiguration;
//import java.util.HashSet;
//import java.util.Properties;
//import java.util.Set;
//
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
//import org.springframework.context.annotation.Bean;
//import org.springframework.context.annotation.Configuration;
//import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;
//import org.springframework.data.mongodb.MongoDbFactory;
//import org.springframework.data.mongodb.config.AbstractMongoConfiguration;
//import org.springframework.data.mongodb.config.EnableMongoAuditing;
//import org.springframework.data.mongodb.core.MongoTemplate;
//import org.springframework.data.mongodb.core.SimpleMongoDbFactory;
//import org.springframework.data.mongodb.core.convert.MappingMongoConverter;
//import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;
//import org.springframework.scheduling.annotation.EnableAsync;
//import org.springframework.transaction.annotation.EnableTransactionManagement;
//import org.springframework.data.mongodb.core.convert.DefaultMongoTypeMapper;
//import org.springframework.data.mongodb.core.convert.MongoTypeMapper;
//import org.springframework.data.mongodb.core.mapping.event.LoggingEventListener;
//import org.springframework.data.mongodb.gridfs.GridFsTemplate;
//
///**
// *
// * Mongo DB Configuration
// *
// * @author Alex
// * @version 1.0.0
// * @since 2017-08-08
// */
//@Configuration("publicationMongoConfiguration")
//@EnableAutoConfiguration
//@EnableAsync
//@EnableMongoAuditing
//@EnableTransactionManagement
//@EnableMongoRepositories(basePackages = "com.wildbeeslabs.api.rest.publication.repository")
////@ComponentScan(basePackages = {"com.wildbeeslabs.api.rest.publication.*"})
//class MongoConfiguration extends AbstractMongoConfiguration {
//
//    @Autowired
//    private IPropertiesConfiguration propertyConfig;
//
////    @Value("${datasource.publicationapp.mongodb.url}")
////    private String mongodbUrl;
////
////    @Value("${datasource.publicationapp.mongodb.db}")
////    private String defaultDb;
//    @Bean
//    public GridFsTemplate gridFsTemplate() throws Exception {
//        return new GridFsTemplate(mongoDbFactory(), mappingMongoConverter());
//    }
//
//    @Override
//    protected String getDatabaseName() {
//        return propertyConfig.getProperty("datasource.publicationapp.mongodb.db");
//    }
//
////    @Override
////    public String getMappingBasePackage() {
////        return "com.wildbeeslabs.api.rest.publication.model";
//////        return propertyConfig.getProperty("datasource.publicationapp.mongodb.basePackage");
////    }
//
//    @Bean
//    @Override
//    public MongoClient mongo() throws Exception {
//        MongoClientOptions mongoOptions = new MongoClientOptions.Builder().maxWaitTime(propertyConfig.getProperty("datasource.publicationapp.mongodb.timeout", Integer.class)).build();
//        MongoClient mongo = new MongoClient(propertyConfig.getProperty("datasource.publicationapp.mongodb.url"), mongoOptions);
//        return mongo;
//    }
//
//    @Bean
//    @Override
//    public MongoDbFactory mongoDbFactory() throws Exception {
//        MongoDbFactory mongoDbFactory = new SimpleMongoDbFactory(mongo(), propertyConfig.getProperty("datasource.publicationapp.mongodb.db"));//new MongoClient()
//        return mongoDbFactory;
//    }
//
//    @Bean
//    @Override
//    public MappingMongoConverter mappingMongoConverter() throws Exception {
//        MappingMongoConverter converter = super.mappingMongoConverter();
//        converter.setTypeMapper(customTypeMapper());
//        return converter;
//    }
//
//    @Bean
//    public MongoTypeMapper customTypeMapper() {
//        return new DefaultMongoTypeMapper(null);
//    }
//
//    @Bean
//    @Override
//    public MongoTemplate mongoTemplate() throws Exception {
//        return new MongoTemplate(mongoDbFactory());
//    }
//
////    @Bean
////    public MongoTemplate mongoTemplate(MongoDbFactory mongoDbFactory, MongoMappingContext context) {
////        MappingMongoConverter converter = new MappingMongoConverter(new DefaultDbRefResolver(mongoDbFactory), context);
////        converter.setTypeMapper(new DefaultMongoTypeMapper(null));
////        MongoTemplate mongoTemplate = new MongoTemplate(mongoDbFactory, converter);
////        return mongoTemplate;
////    }
//    @Bean
//    public static PropertySourcesPlaceholderConfigurer propertyConfigInDev() {
//        return new PropertySourcesPlaceholderConfigurer();
//    }
//
//    @Bean
//    public LoggingEventListener mappingEventsListener() {
//        return new LoggingEventListener();
//    }
//
//    /**
//     * Get Mongo properties configuration
//     *
//     * @return Mongo properties configuration
//     */
//    private Properties mongoProperties() {
//        final Properties properties = new Properties();
//        properties.put("mongo.url", propertyConfig.getMandatoryProperty("datasource.publicationapp.mongodb.url"));
//        properties.put("mongo.db", propertyConfig.getProperty("datasource.publicationapp.mongodb.db"));
//        properties.put("mongo.port", propertyConfig.getProperty("datasource.publicationapp.mongodb.port"));
//        properties.put("mongo.timeout", propertyConfig.getProperty("datasource.publicationapp.mongodb.timeout"));
//        return properties;
//    }
//}

//import org.springframework.context.annotation.Bean;
//import org.springframework.context.annotation.Configuration;
//import org.springframework.data.mongodb.core.mapping.event.ValidatingMongoEventListener;
//import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;
//
//@Configuration
//public class MongoValidationConfig {
//
//    @Bean
//    public ValidatingMongoEventListener validatingMongoEventListener() {
//        return new ValidatingMongoEventListener(validator());
//    }
//
//    @Bean
//    public LocalValidatorFactoryBean validator() {
//        return new LocalValidatorFactoryBean();
//    }
//}
--------------------------------------------------------------------------------------------------------
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 * Utility class which provides utility methods for managing json content from a
 * path.
 *
 * @author giuliana.bezerra
 *
 */
public class JSONPathUtil {

	private JSONPathUtil() {
		// DO NOTHING.
	}

	public static String getJSONFromPath(String jsonPath) {
		try {
			return handleJsonPath(jsonPath);
		} catch (Exception e) {
			throw new RestRuntimeException(e.getMessage());
		}
	}

	private static String handleJsonPath(String jsonPath) throws RestException {
		try {
			if (isPathNotEmpty(jsonPath))
				return getJSONFileContent(jsonPath);
			else
				return null;
		} catch (Exception e) {
			throw new RestException(e);
		}
	}

	private static boolean isPathNotEmpty(String jsonPath) {
		return jsonPath != null && !jsonPath.trim().isEmpty();
	}

	private static String getJSONFileContent(String jsonPath) throws RestException {
		FileReader fileReader = null;
		BufferedReader bufferedReader = null;

		try {
			fileReader = new FileReader(jsonPath);
			bufferedReader = new BufferedReader(fileReader);
			String line;
			StringBuilder json = new StringBuilder();
			while ((line = bufferedReader.readLine()) != null) {
				json.append(line);
			}
			return json.toString();
		} catch (Exception e) {
			throw new RestException(e);
		} finally {
			closeResources(fileReader, bufferedReader);
		}
	}

	private static void closeResources(FileReader fileReader, BufferedReader bufferedReader) {
		try {
			if (fileReader != null)
				fileReader.close();
			if (bufferedReader != null)
				bufferedReader.close();
		} catch (IOException e) {
			// DO NOTHING.
		}
	}
}
--------------------------------------------------------------------------------------------------------
//@SpringBootApplication(exclude={com.github.torlight.sbex.User.class})
public class MyTypeExcludeFilter extends TypeExcludeFilter {

    @Override
    public boolean match(final MetadataReader metadataReader, final MetadataReaderFactory metadataReaderFactory) throws IOException {
        return StringUtils.equalsAnyIgnoreCase("com.github.torlight.sbex.User", metadataReader.getClassMetadata().getClassName());
    }
}
--------------------------------------------------------------------------------------------------------
//@Configuration
//@EnableWebMvc
//@EnableSpringDataWebSupport
//public class PaginationConfig extends SpringDataWebConfiguration {
//
//    @Override
//    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {
//        PageableHandlerMethodArgumentResolver resolver = new PageableHandlerMethodArgumentResolver(sortResolver());
//        resolver.setFallbackPageable(new PageRequest(0, 50));
//        resolver.setSizeParameterName("p");
//        resolver.setPageParameterName("s");
//        argumentResolvers.add(resolver);
//        super.addArgumentResolvers(argumentResolvers);
//    }
//}
--------------------------------------------------------------------------------------------------------
import retrofit.Call;
import retrofit.Retrofit;
import retrofit.http.Body;
import retrofit.http.GET;
import retrofit.http.POST;
import retrofit.http.Query;

public interface Apiservice {

    @GET("curators.json")
    Call<Freemusicpojo> getDataset(@Query("api_key")  String api_key);

}
--------------------------------------------------------------------------------------------------------

import java.lang.Math;
import java.util.Queue;
import java.util.ArrayDeque;
import java.util.Map;
import java.util.HashMap;

public class ChessKnight {
    private static int[] row = { 2, 2, -2, -2, 1, 1, -1, -1 };
    private static int[] column = { -1, 1, 1, -1, 2, -2, 2, -2 };

    public static int getYCoordinate(String position) {
        for (int i = position.length() - 1; i >= 0; i--) {
            if (Character.isLetter(position.charAt(i))) {
                return Integer.valueOf(position.substring(i + 1)) - 1;
            }
        }

        return -1;
    }

    public static int getXCoordinate(String position) {
        int result = 0, stop = 0;

        for (int i = 0; i < position.length(); i++) {
            if (Character.isDigit(position.charAt(i))) {
                stop = i - 1;
                break;
            }
        }

        for (int i = 0, j = stop; i <= stop; i++, j--) {
            result += ((int) Character.toLowerCase(position.charAt(i)) - 96) * Math.pow(26.0, j);
        }

        return result - 1;
    }

    public static int count(int x1, int y1, int x2, int y2, int width, int height) {
        return bfs(new Node(x1, y1), new Node(x2, y2), width, height);
    }

    public static boolean valid(int x, int y, int width, int height) {
        if (x < 0 || y < 0 || x >= width || y >= height)
            return false;

        return true;
    }

    public static int bfs(Node start, Node end, int width, int height) {
        Map<Node, Boolean> visited = new HashMap<>();
        Queue<Node> q = new ArrayDeque<>();

        q.add(start);

        while (!q.isEmpty()) {
            Node node = q.poll();

            int x = node.x;
            int y = node.y;
            int distance = node.distance;

            if (x == end.x && y == end.y)
                return distance;

            if (visited.get(node) == null) {
                visited.put(node, true);

                for (int i = 0; i < 8; i++) {
                    int x1 = x + row[i];
                    int y1 = y + column[i];

                    if (valid(x1, y1, width, height))
                        q.add(new Node(x1, y1, distance + 1));
                }
            }
        }

        return -1;
    }
}

public class Node {
    int x, y, distance;

    public Node(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public Node(int x, int y, int distance) {
        this.x = x;
        this.y = y;
        this.distance = distance;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Node node = (Node) o;

        if (x != node.x) return false;
        if (y != node.y) return false;
        return distance == node.distance;
    }

    @Override
    public int hashCode() {
        int result = x;
        result = 31 * result + y;
        result = 31 * result + distance;
        return result;
    }
}
--------------------------------------------------------------------------------------------------------
import java.io.PrintStream;

import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;
import org.kohsuke.args4j.Option;

import com.netiq.websockify.PortUnificationHandler;
import com.netiq.websockify.WebsockifyServer;
import com.netiq.websockify.WebsockifyServer.SSLSetting;
import com.netiq.websockify.WebsockifySslContext;



public class ExternalVNCRepeater
{   
   @Option(name="--help",usage="show this help message and quit")
   private boolean showHelp = false;
   
   @Option( name = "--enable-ssl", usage = "enable SSL" )
   private boolean       enableSSL  = false;

   @Option( name = "--ssl-only", usage = "disallow non-encrypted connections" )
   private boolean       requireSSL = false;
   
   @Option(name="--keystore",usage="path to a java keystore file. Required for SSL.")
   private String keystore = null;
   
   @Option(name="--keystore-password",usage="password to the java keystore file. Required for SSL.")
   private String keystorePassword = null;
   
   @Option(name="--keystore-key-password",usage="password to the private key in the java keystore file. If not specified the keystore-password value will be used.")
   private String keystoreKeyPassword = null;
   
   @Option(name="--direct-proxy-timeout",usage="connection timeout before a direct proxy connection is established in milliseconds. Default is 5000 (5 seconds). With the VNC protocol the server sends the first message. This means that a client that wants a direct proxy connection will connect and not send a message. The external VNC repeater will wait the specified number of milliseconds for an incoming connection to send a message. If no message is recieved it initiates a direct proxy connection. Setting this value too low will cause connection attempts that aren't direct proxy connections to fail. Set this to 0 to disable direct proxy connections.")
   private int directProxyTimeout = 5000;

   @Argument( index = 0, metaVar = "source_port", usage = "(required) local port the external repeater will listen on", required = true )
   private int           sourcePort;

   @Argument( index = 1, metaVar = "cmas_base_url", usage = "(required) the base URL of the CMAS server.  For example http://ncmdev.netiq.com:8182", required = true )
   private String        cmasBaseUrl;

   private CmdLineParser parser;


   public ExternalVNCRepeater()
   {
      parser = new CmdLineParser ( this );
   }


   public void printUsage( PrintStream out )
   {
      out.println ( "Usage:" );
      out.println ( " java -jar external-vnc-repeater.jar [options] source_port cmas_base_url" );
      out.println ( );
      out.println ( "Options:" );
      parser.printUsage ( out );
      out.println ( );
      out.println ( "Example:" );
      out.println ( " java -jar external-vnc-repeater.jar 5900 https://cloud.acmecloud.demo" );
   }
   
   public static void main(String[] args) throws Exception {
     new ExternalVNCRepeater().doMain(args);
   }
   
   public void doMain(String[] args) throws Exception
   {
      parser.setUsageWidth ( 80 );

      // parse the command line arguments
      try
      {
         parser.parseArgument ( args );
      }
      // if there's a problem show the error and command line usage help
      catch ( CmdLineException e )
      {
         System.err.println ( e.getMessage ( ) );
         printUsage ( System.err );
         return;
      }

      // if we were asked for help show it and exit
      if ( showHelp )
      {
         printUsage ( System.out );
         return;
      }
      
      // set the SSL setting based on the command line params
      SSLSetting sslSetting = SSLSetting.OFF;
      if ( requireSSL ) sslSetting = SSLSetting.REQUIRED;
      else if ( enableSSL ) sslSetting = SSLSetting.ON;

      // if we are doing SSL
      if ( sslSetting != SSLSetting.OFF ) {
         // make sure there is a keystore path specified
          if (keystore == null || keystore.isEmpty()) {
              System.err.println("No keystore specified.");
          printUsage(System.err);
              System.exit(1);
          }

          // and make sure there is a keystore password specified
          if (keystorePassword == null || keystorePassword.isEmpty()) {
              System.err.println("No keystore password specified.");
          printUsage(System.err);
              System.exit(1);
          }
          
          // if there's no keystore key password, use the keystore password
          if (keystoreKeyPassword == null || keystoreKeyPassword.isEmpty()) {
             keystoreKeyPassword = keystorePassword;
          }
          
          // and validate the keystore settings - this actually starts up an SSL
          // context and lets us know if there were exceptions starting it
          // this doesn't happen in the current thread when the server is started
          // so we only know about it in worker threads and put it out to the logger
          try
          {
             WebsockifySslContext.validateKeystore(keystore, keystorePassword, keystoreKeyPassword);
          }
          catch ( Exception e )
          {
             System.err.println("Error validating keystore: " + e.getMessage() );
             printUsage(System.err);
             System.exit(2);
          }
      }

      System.out.println ( "Proxying *:" + sourcePort + " to workloads defined by CMAS at " + cmasBaseUrl + " ..." );
      if(sslSetting != SSLSetting.OFF) System.out.println("SSL is " + (sslSetting == SSLSetting.REQUIRED ? "required." : "enabled."));
      
      PortUnificationHandler.setConnectionToFirstMessageTimeout(directProxyTimeout);

      WebsockifyServer ws = new WebsockifyServer ( );
      ws.connect ( sourcePort, new CMASRestResolver ( cmasBaseUrl ), sslSetting, keystore, keystorePassword, keystoreKeyPassword, null );

   }
}

import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.api.client.config.DefaultClientConfig;
import com.sun.jersey.client.urlconnection.HTTPSProperties;

public class ClientHelper {
	
	public static ClientConfig configureClient() {
		TrustManager[ ] certs = new TrustManager[ ] {
	            new X509TrustManager() {
					public X509Certificate[] getAcceptedIssuers() {
						return null;
					}
					public void checkServerTrusted(X509Certificate[] chain, String authType)
							throws CertificateException {
					}
					public void checkClientTrusted(X509Certificate[] chain, String authType)
							throws CertificateException {
					}
				}
	    };
	    SSLContext ctx = null;
	    try {
	        ctx = SSLContext.getInstance("TLS");
	        ctx.init(null, certs, new SecureRandom());
	    } catch (java.security.GeneralSecurityException ex) {
	    }
	    HttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());
	    
	    ClientConfig config = new DefaultClientConfig();
	    try {
		    config.getProperties().put(HTTPSProperties.PROPERTY_HTTPS_PROPERTIES, new HTTPSProperties(
		        new HostnameVerifier() {
					public boolean verify(String hostname, SSLSession session) {
						return true;
					}
		        }, 
		        ctx
		    ));
	    } catch(Exception e) {
	    }
	    return config;
	}
	
	public static Client createClient() {
	    return Client.create(ClientHelper.configureClient());
	}
}
--------------------------------------------------------------------------------------------------------
# See http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html
spring.thymeleaf.cache=false
spring.main.show-banner=false
logging.level.jdbc=OFF
logging.level.jdbc.sqltiming=DEBUG
logging.level.jdbc.resultsettable=DEBUG
--------------------------------------------------------------------------------------------------------
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
        <plugin>
            <artifactId>maven-jar-plugin</artifactId>
            <executions>
                <execution>
                    <id>lib</id>
                    <phase>package</phase>
                    <goals>
                        <goal>jar</goal>
                    </goals>
                    <configuration>
                        <classifier>lib</classifier>
                        <excludes>
                            <exclude>application.yml</exclude>
                        </excludes>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
--------------------------------------------------------------------------------------------------------
package com.paragon.microservices.crmmailadapter.system.property;

import com.paragon.mailingcontour.commons.databus.model.NameValueEntry;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.NestedConfigurationProperty;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;

import javax.validation.Valid;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;

@Data
@Validated
@Component
@ConfigurationProperties(prefix = "rest.registry", ignoreInvalidFields = true)
public class RestRegistryProperty {
    @NotBlank(message = "{property.rest.registry.base-path.notBlank}")
    private String basePath;

    /**
     * Get user path {@link Paths}
     */
    @Valid
    @NestedConfigurationProperty
    @NotNull(message = "{property.rest.registry.get-user-path.notNull}")
    private ParamsPaths getUserPath;

    /**
     * Create user path {@link Paths}
     */
    @Valid
    @NestedConfigurationProperty
    @NotNull(message = "{property.rest.registry.create-user-path.notNull}")
    private Paths createUserPath;

    @Data
    @Validated
    public static class Paths {
        @NotBlank(message = "{property.rest.registry.user-path.notBlank}")
        private String userPath;
    }

    @Data
    @Validated
    @EqualsAndHashCode(callSuper = true)
    @ToString(callSuper = true)
    public static class ParamsPaths extends Paths {
        @Valid
        @NestedConfigurationProperty
        @NotNull(message = "{property.rest.registry.params.notNull}")
        private Params params;
    }

    @Data
    @Validated
    public static class Params {
        @NestedConfigurationProperty
        @NotNull(message = "{property.rest.registry.params.email.notNull}")
        private NameValueEntry email;
    }
}

--------------------------------------------------------------------------------------------------------
        <dependency>
            <groupId>com.jayway.restassured</groupId>
            <artifactId>rest-assured</artifactId>
            <version>${rest.assured.version}</version>
        </dependency>
		
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <dependencies>
                    <dependency>
                        <groupId>org.springframework</groupId>
                        <artifactId>springloaded</artifactId>
                        <version>${spring-loaded.version}</version>
                    </dependency>
                </dependencies>
            </plugin>
--------------------------------------------------------------------------------------------------------
/**
 * Syntax highlighting styles
 */
.highlight {
    background: #fff;
    @extend %vertical-rhythm;

    .c     { color: #998; font-style: italic } // Comment
    .err   { color: #a61717; background-color: #e3d2d2 } // Error
    .k     { font-weight: bold } // Keyword
    .o     { font-weight: bold } // Operator
    .cm    { color: #998; font-style: italic } // Comment.Multiline
    .cp    { color: #999; font-weight: bold } // Comment.Preproc
    .c1    { color: #998; font-style: italic } // Comment.Single
    .cs    { color: #999; font-weight: bold; font-style: italic } // Comment.Special
    .gd    { color: #000; background-color: #fdd } // Generic.Deleted
    .gd .x { color: #000; background-color: #faa } // Generic.Deleted.Specific
    .ge    { font-style: italic } // Generic.Emph
    .gr    { color: #a00 } // Generic.Error
    .gh    { color: #999 } // Generic.Heading
    .gi    { color: #000; background-color: #dfd } // Generic.Inserted
    .gi .x { color: #000; background-color: #afa } // Generic.Inserted.Specific
    .go    { color: #888 } // Generic.Output
    .gp    { color: #555 } // Generic.Prompt
    .gs    { font-weight: bold } // Generic.Strong
    .gu    { color: #aaa } // Generic.Subheading
    .gt    { color: #a00 } // Generic.Traceback
    .kc    { font-weight: bold } // Keyword.Constant
    .kd    { font-weight: bold } // Keyword.Declaration
    .kp    { font-weight: bold } // Keyword.Pseudo
    .kr    { font-weight: bold } // Keyword.Reserved
    .kt    { color: #458; font-weight: bold } // Keyword.Type
    .m     { color: #099 } // Literal.Number
    .s     { color: #d14 } // Literal.String
    .na    { color: #008080 } // Name.Attribute
    .nb    { color: #0086B3 } // Name.Builtin
    .nc    { color: #458; font-weight: bold } // Name.Class
    .no    { color: #008080 } // Name.Constant
    .ni    { color: #800080 } // Name.Entity
    .ne    { color: #900; font-weight: bold } // Name.Exception
    .nf    { color: #900; font-weight: bold } // Name.Function
    .nn    { color: #555 } // Name.Namespace
    .nt    { color: #000080 } // Name.Tag
    .nv    { color: #008080 } // Name.Variable
    .ow    { font-weight: bold } // Operator.Word
    .w     { color: #bbb } // Text.Whitespace
    .mf    { color: #099 } // Literal.Number.Float
    .mh    { color: #099 } // Literal.Number.Hex
    .mi    { color: #099 } // Literal.Number.Integer
    .mo    { color: #099 } // Literal.Number.Oct
    .sb    { color: #d14 } // Literal.String.Backtick
    .sc    { color: #d14 } // Literal.String.Char
    .sd    { color: #d14 } // Literal.String.Doc
    .s2    { color: #d14 } // Literal.String.Double
    .se    { color: #d14 } // Literal.String.Escape
    .sh    { color: #d14 } // Literal.String.Heredoc
    .si    { color: #d14 } // Literal.String.Interpol
    .sx    { color: #d14 } // Literal.String.Other
    .sr    { color: #009926 } // Literal.String.Regex
    .s1    { color: #d14 } // Literal.String.Single
    .ss    { color: #990073 } // Literal.String.Symbol
    .bp    { color: #999 } // Name.Builtin.Pseudo
    .vc    { color: #008080 } // Name.Variable.Class
    .vg    { color: #008080 } // Name.Variable.Global
    .vi    { color: #008080 } // Name.Variable.Instance
    .il    { color: #099 } // Literal.Number.Integer.Long
}
--------------------------------------------------------------------------------------------------------
version: 2
jobs:

  build-caches:
    machine: true
    steps:
      # restore_cache.keys does not work, so multiple restore_cache.key is used
      - restore_cache:
          key: m2-cache
      - checkout
      - run:
          name: skip_ci creation
          command: |
            mkdir -p .ci-temp
            echo -n ".github|appveyor.yml|.travis.yml|\.ci/" >> .ci-temp/skip_ci_files
            echo -n "|distelli-manifest.yml|fast-forward-merge.sh" >> .ci-temp/skip_ci_files
            echo -n "|LICENSE|LICENSE.apache20|README.md|release.sh" >> .ci-temp/skip_ci_files
            echo -n "|RIGHTS.antlr|shippable.yml|codeship" >> .ci-temp/skip_ci_files
            echo -n "|shippable.sh|wercker.yml|wercker.sh" >> .ci-temp/skip_ci_files
            echo -n "|intellij-idea-inspections.xml" >> .ci-temp/skip_ci_files
            echo -n "|org.eclipse.jdt.core.prefs" >> .ci-temp/skip_ci_files
            echo -n "|Jenkinsfile" >> .ci-temp/skip_ci_files
            SKIP_CI=false;
            if [ $(git diff --name-only HEAD HEAD~1 \
                   | grep -vE $(cat .ci-temp/skip_ci_files) | wc -c) -gt 0 ] ; then
                SKIP_CI=false;
              else
                SKIP_CI=true;
            fi
            echo $SKIP_CI > .ci-temp/skip_ci
      - run:
          name: download all maven dependencies and groovy
          command: |
            SKIP_CI=`cat .ci-temp/skip_ci`
            echo "SKIP_CI="$SKIP_CI
            if [[ $SKIP_CI == 'false' ]]; then
              pwd
              ls -la
              java -version
              mvn --version
              mvn -Ppitest-metrics dependency:go-offline
            else
              echo "build is skipped ..."
            fi
      - persist_to_workspace:
          root: /home/circleci/
          paths:
            - .m2
            - project
            - contribution

  pitest1:
    machine: true
    parallelism: 4
    steps:
      - attach_workspace:
          at: /home/circleci/
      - run:
          command: |
            SKIP_CI=`cat .ci-temp/skip_ci`
            echo "SKIP_CI="$SKIP_CI
            if [[ $SKIP_CI == 'false' ]]; then
              echo "./.ci/pitest.sh pitest-coding"  >> commands.txt
              echo "./.ci/pitest.sh pitest-common"  >> commands.txt
              echo "./.ci/pitest.sh pitest-imports" >> commands.txt
              echo "./.ci/pitest.sh pitest-ant"     >> commands.txt
              CMD="$(circleci tests split commands.txt)"
              echo "Command: $CMD"
              eval $CMD
            else
              echo "build is skipped ..."
            fi
  pitest2:
    machine: true
    parallelism: 4
    steps:
      - attach_workspace:
          at: /home/circleci/
      - run:
          command: |
            SKIP_CI=`cat .ci-temp/skip_ci`
            echo "SKIP_CI="$SKIP_CI
            if [[ $SKIP_CI == 'false' ]]; then
              echo "./.ci/pitest.sh pitest-main"        >> commands.txt
              echo "./.ci/pitest.sh pitest-javadoc"     >> commands.txt
              echo "./.ci/pitest.sh pitest-indentation" >> commands.txt
              echo "./.ci/pitest.sh pitest-xpath"       >> commands.txt
              CMD="$(circleci tests split commands.txt)"
              echo "Command: $CMD"
              eval $CMD
            else
              echo "build is skipped ..."
            fi
  pitest3:
    machine: true
    parallelism: 4
    steps:
      - attach_workspace:
          at: /home/circleci/
      - run:
          command: |
            SKIP_CI=`cat .ci-temp/skip_ci`
            echo "SKIP_CI="$SKIP_CI
            if [[ $SKIP_CI == 'false' ]]; then
              echo "./.ci/pitest.sh pitest-misc"    >> commands.txt
              echo "./.ci/pitest.sh pitest-design"  >> commands.txt
              echo "./.ci/pitest.sh pitest-api"     >> commands.txt
              echo "./.ci/pitest.sh pitest-utils"   >> commands.txt
              CMD="$(circleci tests split commands.txt)"
              echo "Command: $CMD"
              eval $CMD
            else
              echo "build is skipped ..."
            fi
  pitest4:
    machine: true
    parallelism: 4
    steps:
      - attach_workspace:
          at: /home/circleci/
      - run:
          command: |
            SKIP_CI=`cat .ci-temp/skip_ci`
            echo "SKIP_CI="$SKIP_CI
            if [[ $SKIP_CI == 'false' ]]; then
              echo "./.ci/pitest.sh pitest-whitespace" >> commands.txt
              echo "./.ci/pitest.sh pitest-filters"    >> commands.txt
              echo "./.ci/pitest.sh pitest-header"     >> commands.txt
              echo "./.ci/pitest.sh pitest-annotation" >> commands.txt
              CMD="$(circleci tests split commands.txt)"
              echo "Command: $CMD"
              eval $CMD
            else
              echo "build is skipped ..."
            fi
  pitest5:
    machine: true
    parallelism: 4
    steps:
      - attach_workspace:
          at: /home/circleci/
      - run:
          command: |
            SKIP_CI=`cat .ci-temp/skip_ci`
            echo "SKIP_CI="$SKIP_CI
            if [[ $SKIP_CI == 'false' ]]; then
              echo "./.ci/pitest.sh pitest-packagenamesloader" >> commands.txt
              echo "./.ci/pitest.sh pitest-tree-walker"        >> commands.txt
              echo "./.ci/pitest.sh pitest-naming"             >> commands.txt
              echo "./.ci/pitest.sh pitest-metrics"            >> commands.txt
              CMD="$(circleci tests split commands.txt)"
              echo "Command: $CMD"
              eval $CMD
            else
              echo "build is skipped ..."
            fi
  pitest6:
    machine: true
    parallelism: 4
    steps:
      - attach_workspace:
          at: /home/circleci/
      - run:
          command: |
            SKIP_CI=`cat .ci-temp/skip_ci`
            echo "SKIP_CI="$SKIP_CI
            if [[ $SKIP_CI == 'false' ]]; then
              echo "./.ci/pitest.sh pitest-blocks"   >> commands.txt
              echo "./.ci/pitest.sh pitest-sizes"    >> commands.txt
              echo "./.ci/pitest.sh pitest-modifier" >> commands.txt
              echo "./.ci/pitest.sh pitest-regexp"   >> commands.txt
              CMD="$(circleci tests split commands.txt)"
              echo "Command: $CMD"
              eval $CMD
            else
              echo "build is skipped ..."
            fi
  pitest7:
    machine: true
    parallelism: 4
    steps:
      - attach_workspace:
          at: /home/circleci/
      - run:
          command: |
            SKIP_CI=`cat .ci-temp/skip_ci`
            echo "SKIP_CI="$SKIP_CI
            if [[ $SKIP_CI == 'false' ]]; then
              echo "./.ci/pitest.sh pitest-gui"   >> commands.txt
              CMD="$(circleci tests split commands.txt)"
              echo "Command: $CMD"
              eval $CMD
            else
              echo "build is skipped ..."
            fi
workflows:
  version: 2
  pitest-testing:
    jobs:
      - build-caches
      - pitest1:
          requires:
            - build-caches
      - pitest2:
          requires:
            - build-caches
      - pitest3:
          requires:
            - build-caches
      - pitest4:
          requires:
            - build-caches
      - pitest5:
          requires:
            - build-caches
      - pitest6:
          requires:
            - build-caches
      # we do not do thorough testing of gui part
      # - pitest7:
      #     requires:
      #       - build-caches
--------------------------------------------------------------------------------------------------------
language: java

matrix:
    include:
        - os: linux
          sudo: false
          jdk: oraclejdk8
          before_install:
            # codecov.io
            - pip install --user codecov
          script: >
            if [ "${COVERITY_SCAN_BRANCH}" != 1 ]; then
            ./gradlew build jacocoTestReport javadoc versionEyeSecurityAndLicenseCheck artifactoryPublish codacyUpload
            -PbuildInfo.build.number=$TRAVIS_BUILD_NUMBER
            -PbuildInfo.buildUrl=https://travis-ci.org/${TRAVIS_REPO_SLUG}/builds/${TRAVIS_JOB_ID}
            -PbuildInfo.principal=$USER
            --continue --stacktrace --no-daemon --profile --scan ;
            fi
          after_success:
            - ./publish-docs-to-github.sh
            # codecov.io
            - if [ "${COVERITY_SCAN_BRANCH}" != 1 ]; then codecov ; fi
            - cat ./cov-int/build-log*.txt
          addons:
            coverity_scan:
              project:
                name: ddimtirov/nuggets
                version: 0.3.0-SNAPSHOT
                description: nuggets is (yet another) utility library for Java Edit
              notification_email: dimitar.dimitrov@gmail.com
              build_command_prepend: rm -rf ./build
              build_command: ./gradlew --no-daemon --info jar
              branch_pattern: coverity_scan
        - os: osx
          osx_image: xcode8.2
          script: ./gradlew build javadoc --continue --stacktrace --no-daemon --profile --scan
        - os: linux
          sudo: required
          jdk: oraclejdk9
          dist: trusty
          script:
             - export GRADLE_OPTS=--add-opens java.base/java.lang=ALL-UNNAMED
             - ./gradlew build javadoc --continue --stacktrace --no-daemon --profile --scan
    allow_failures:
        - jdk: oraclejdk9


env:
  global:
    # GH_TOKEN for ddimtirov/nuggets
    - secure: u0YEKxdx3cEbtJAZU9xeh7X+8ix3MZNirUor+i/u5WPflXmqAe32BO7Oh92lfM46h7b2e/AVSeA4UQUsRcz2HMWDLy3jVjIxpS4bIc4Lfpf06UH9ZSxmN3qfAVp6W8sN/YII0h9WfAaNLX5VxY91LmloTdtvS3zgRFoaBL+W0nVicu/O4yPBn8o5DGyf8q83gmx2jNI3RTMyvMrliQbS+jtzgCPDrW/KqKPHmiaEl7yuXShZnRlxrjDa65fkDPnCRbexklmbnaF2ssjVB3sKofvmzFQKIp+44Jvgpm93eXqFYOfcrma8+8J2g9u/WL9uOIy7lE7bCf098QmoOthyvL3lUGgRPIbuiPygrFPEUpb74zyLZB6BpIXG8VjTlqZtoVddQNyglU5Kiyh/2ZNK1nQPssxo/y868gl2QWn9ZB0N9EU2MLJf1kVsJMHVEeDMyKzoHQW1fjeLvPJkDBFJtOuLltB0kfWkOzGcdJHtznNWGZoLAEa6Yr8A0OZAEqrxG81sttDL/dYQJDhJdGn1U/Q6adk2MTa6HXjJgQbuACDw8TpmFp8Lv13d907ZmJFojjzUJS9TxTKIXQKzCZoCGFhWxajZdDI9jOq3Ypt4rZ/zXea9YlIDx4Op3immdbcW8mNiS2bJg1kw53a2CiCHYS7rKHyMKAXY/SkR6D81jZI=
    # VERSIONEYE_API_KEY
    - secure: seO01Lxrkxn09Mbf/4Io6VMpwGFhpaRVZfCL25/xEqiKhDgQLaKzI/SLVT3Kv4D30KABngWPLcPiAGOxleSjKMEPdOA5XO2yQanO54Q4yXinbJO9WBZn6ok7OvWNLZIS1vR1SJhP51pHEde+dcYvHd+Om1Uio4yMIZrhv2XJjUHZvkyi+ZGc8XErElLrIc5UWC/2bRnddZKdP/sE8Euqc4MvES8G1DjoWLbgAPy3+Jj7XMBTDxqpGEDdafgxzWC1GpiwKhefqvqSPeHO1CH5rXVzS4IXALugYgCoO7G0YVeEw1YLmhMqLnjpkXrUKDeEuuL0uJvYdpDDqCVynPvW3aDH7nTznXb3OoaIQjoQfN9OaS/DNAZ4DmuBt8orDYYZZ9O5Z/5M50QPBks46UucSNcUfoet/p1PrqQWwxtIPgjcWnnz7vWMT7g9IntuAwXwUrtzvhAgd0aF+/5Ivptq8Aq2tOfuULH0Wbk+htiW2/FTQ7g7UED9iPCas0JVDPNT2B09Gx1wWKpt8XIC4k6U8iTCcMGphI/2lyiDA21do9AuRGGrm72fGHGPQyUG0VGTudF9xvV06ChmvGQxcGRNZ09AlhLEPaQdlLZlKhZM7ufBz6y9qg83y1zIzS/+KYOFhmYxuj5OyKmNlvoFJKrh6ACcgg+3rA8r+NYMnbklNu0=
    # BINTRAY_USER & BINTRAY_KEY
    - secure: HF19auHUTRaUgbPykpnsloFCreDFQ8Cr09kZaEZKgXuQnQU9AWNlvCzh3bBBIhnbCMaa2EB0BOWWpmtZ/cbs1qWuCejri0wgLcGIJfW+I9OisY/cMxac7qR/8oXY9Ng702QSyxWHzMCa24KiQdvLSfPgcdcJs4468YGk0w8j5IpclOBoc2pphEv6M7GlEyu8b6iWo9e+1W5LV8TuF8Twe0MNfPrJpU3pSb8/Df6YKnF7h+Fm++LHuKAw+m1IvuSxla2klcySjXzC2HdlaIXcfRgHCFA96y5gqSSn704kRDIF2TVARVbJH0MvkjHQTuusZemyV8kZ7NCDSG9eS6FxgwteAV9hQa4gTHOBrTO2LP/KVLJgUgGKfyZIKCpr5FCRReYnOtkkxwW6X1tgXcNO03VtOkmyVcMfAp6CZ1KTOWs1nefRIqZnfEr7V9amI8xBojt8wVnTdhDtFlDG69za2OH1yoNxY6O5bmaNCZ0sMXW/KjrePZWh9pfPSeBaH8d5Q9rxxUd+m0h6TMuJ7uOAiU2tjfvlkS2U8KdWUKzzF8h8Bn/ukBnlsVEA1/wFOZiWsQOwDxfsC9VVn49cjejVn8uoPokvsse5lHxnPEktrWfUuVSBF3VNsH+EGT8su5tyN4KARQ61O/jaWPtW4swrU1QGmd/3h7PGJuya1tnO30c=
    - secure: TuOf/FL4ISdG6FRMHVxA9UPxHDqJGvZRKu13H/8z1gxLGFGFNUsWlr1LekjUfBxGjjTKa9xpTBR1af3CRyotd5Yn6gspQnqr9vVrfPdboRwu1xLYtVD8amrPEBM7BKZ8HxxVR5RRaxkMMHeOPKYIF05P9V381pjRPgOBUolEVUyBfmSipzVX+eid6hdn2ePWZYL2FM+Ge23aIPkvwedafmiRItWX42cqYeLou3fsYXFukGVFGRvjj7PaM9mSLcu4hHru5WvxrELb/DxGdxphPNhHCkK4bWaN3H8HTpf6rKNpqplMYxClfN+n8Ciw68BFSS7eH/ns7H0pr/vYNQ/xjvteCDaoy9XJfdyTYH3BcrECll278W2r07X6kdkLQLqIqNsrUEC1ck75sRCVxwzQpZJ4FJZcfR5rw4CxdouHJXxWvCACkJ6tX48mtVX8JDUNkMPywgmdrAMjr7FYcKqf3RQtp1LPW/GYQmZbyLpOGhNOv6CTCH6D8Y/T+EeWmCvUvEWqLjBBdu6uEnuboYs/wCQWueqaKfZohb94KQ7c4UUG0yHxDgdWUC7bukA6txnE/xonWOVv7xbG2mRsG4Jt6ynwnBhfEhjG1LH5xhkkHpqdEfRwZNy/O2npbCaanBhvKIk85b0J8vp6uRNHMXZsy1ouLX5iknxi7wSmranO2wg=
    # Codacy
    - secure: od/L5mnmQZ0DDbcleQbq8ZiRxPvc3AsCW+6IiMlIt7dMd4Hg4OkNQ2mIXOKYZRF1IwYG2e1rW7TcNyOZiAP7S0ih7XzlzSpW7U3P//j3u1MVLWbWLcI9bhNNiJaO54nydytUFKI5N4H3sR2BRnuIx2MI4WsZFsyxs2x2RIOz6uPvnCMkrq4GKYHkgFAbW0g0zo5Bmgs6fIFGLo5N6l4HJemGVCRVdGM6VApFzagPMbjQCuC+TyV8Agi6X3jq932qeHz69kVNT28TN5xTUA8i2X1EpI7vXudJ3v60ZJZxyBs4G5pE0A/faPMhvpDzxsVYPDR5IfMQMjjhYrjUf14/r3Ubj2uEAM82NjnkAz9Mn+N++HJ1/1HqvnyURmpeEnydrAWl8wIIgPIKHJybg5lJvcgUjvPctrySZagRrgvwRMZZng8C7WsWtbTbdNwjCU4bfuesine0shN2encXMcXL1eD1A81FoJSQshcpghYpBU/SNr0wsnApHHSDrm0AnJx7952YvBbK0J4NruXp1IVvmAgu1tRDkj8mlIutr4QRrEFU080JzaVhpAEkD17aR8ifuMTRfpR47Uzb6hwB0wp8NBU2Dto5bm9dXwLBJA/6WDyF6HiId+mWEJLg4boHXfSddQniyqK2P/jaHGuH4EawmoT01b+wmV62Yp1gbQiUJ9E=
    # COVERITY_SCAN_TOKEN
    - secure: MOCopiLQt8tiR3S7iJyLxj5eg7Akcs9pVBH81dpyeUzTErzq3NNP8lpZ9xZsR7epAE3PcxauoSIgEXPbe57rijH15mm8Cy5UXBbg+q5htjElwrZsaFfySBDi4WSCDm4jYcDF26JH9Cj3JAnlVMpgIthyxRfjnaCROFYIc42blsw+5FehcE0Wuj1PVYOFhgxOY5qLBfwcG+A+3Yr4jkiQ3S8SHC2tn2hv/Dpwq/jizRsQc0lLIoQRujBDrGiBN5dREcL6A0QTFIZolHQC/lhRc5nTDP2zxeUiGnOZ1njFzX8qniZVtqUx1KGnBdv1Rm72nlf8/JvedJP24TPVaGV8Xgorz6tL49vwjjJ0l64CZgU5TqiJ7ugwU2HcczLZN0vVRVDadN0letGJBfT+f/YQMSXFtQcE3gc3eORzy9V0WXY9RFXfQU8d708okLCP0UK7zxQyUUBV6Np04STSYTyeUJa4Mm6XOqEz8cNuM8lx9i5vFRaVrZ75FxHcU7kT0QaFcoQSR/tsE0MJ0kAvGRIwRNPKnAShD0eiNP2bqeV2lo96FIC4FwPlEtBi14i7wneyZ+pEyKSxc29nW17X0PRhzlgLdPxbKlvXblKKY7jJa6Fwl/mzPCpUiRX1BWLP4TrXxMDms2ptlqfO1vtclYcCnDsr/Fs1qkNUSl0tRq1s3qs=

# see https://docs.travis-ci.com/user/languages/java/#Projects-Using-Gradle
before_cache:
  - rm -f  $HOME/.gradle/caches/modules-2/modules-2.lock
  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/
  - rm -f  $HOME/.cache/pip/log/debug.log

cache:
  directories:
    - $HOME/.gradle/caches/
    - $HOME/.gradle/wrapper/
    - $HOME/.cache/pip
--------------------------------------------------------------------------------------------------------
@Configuration
public class AppConfig {
    @Autowired
    DataSourceProperties dataSourceProperties;

    @Bean
    @ConfigurationProperties(prefix = DataSourceProperties.PREFIX)
    DataSource realDataSource() {
        DataSource dataSource = DataSourceBuilder
                .create(this.dataSourceProperties.getClassLoader())
                .url(this.dataSourceProperties.getUrl())
                .username(this.dataSourceProperties.getUsername())
                .password(this.dataSourceProperties.getPassword())
                .build();
        return dataSource;
    }

    @Bean
    @Primary
    DataSource dataSource() {
        return new DataSourceSpy(realDataSource());
    }
}
--------------------------------------------------------------------------------------------------------
//    @Option(names = {"-h", "--help"}, help = true, description = "Shows help message and exits")
//    private boolean helpRequested;

init-test-suite run --single-test --config=config --log
--------------------------------------------------------------------------------------------------------
           <!--<exclusions>-->
                <!--<exclusion>-->
                    <!--<groupId>org.springframework.boot</groupId>-->
                    <!--<artifactId>spring-boot-starter-data-redis</artifactId>-->
                <!--</exclusion>-->
                <!--<exclusion>-->
                    <!--<groupId>org.springframework.data</groupId>-->
                    <!--<artifactId>spring-data-redis</artifactId>-->
                <!--</exclusion>-->
                <!--<exclusion>-->
                    <!--<groupId>org.springframework.boot</groupId>-->
                    <!--<artifactId>spring-boot-starter-data-jpa</artifactId>-->
                <!--</exclusion>-->
            <!--</exclusions>-->
--------------------------------------------------------------------------------------------------------
    public static <T> @Nullable T defaultValue(@NotNull Class<T> c) {
        try {
            Constructor<?> constructor = c.getConstructor();
            if (constructor !=null) return c.cast(constructor.newInstance());
        } catch (Exception ignored) { }

        if (c.isPrimitive()) {
            @SuppressWarnings("unchecked")
            Class<T> boxedEquivalent = (Class<T>) boxClass(c);
            c = boxedEquivalent;
        }

        if (c.isArray())                            return c.cast(Array.newInstance(c.getComponentType(), 0));
        if (BigDecimal.class.isAssignableFrom(c))   return c.cast(BigDecimal.ZERO);
        if (BigInteger.class.isAssignableFrom(c))   return c.cast(BigInteger.ZERO);
        if (Boolean.class.equals(c))                return c.cast(Boolean.FALSE);
        if (Byte.class.equals(c))                   return c.cast((byte) 0);
        if (Character.class.equals(c))              return c.cast('\0');
        if (Double.class.equals(c))                 return c.cast(0d);
        if (Float.class.equals(c))                  return c.cast(0f);
        if (Integer.class.equals(c))                return c.cast(0);
        if (Long.class.equals(c))                   return c.cast(0L);
        if (Short.class.equals(c))                  return c.cast((short) 0);

        if (Map.class.isAssignableFrom(c))          return c.cast(new LinkedHashMap<>());
        if (Set.class.isAssignableFrom(c))          return c.cast(new LinkedHashSet<>());
        if (List.class.isAssignableFrom(c))         return c.cast(new ArrayList<>());
        if (Collection.class.isAssignableFrom(c))   return c.cast(new ArrayList<>());

        return null; // void, classes without default constructor, etc.
    }
--------------------------------------------------------------------------------------------------------
   @Bean
    public CommandLineRunner commandLineRunner(ApplicationContext ctx) {
        return args -> {
            System.out.println("Let's inspect the beans provided by Spring Boot:");
            String[] beanNames = ctx.getBeanDefinitionNames();
            Arrays.sort(beanNames);
            for (String beanName : beanNames) {
                System.out.println(beanName);
            }
        };
    }
--------------------------------------------------------------------------------------------------------
import com.justynsoft.simplerecon.core.worker.CSVFileReconWorker;
import com.justynsoft.simplerecon.core.worker.DatabaseReconWorker;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;

@Configuration
public class TradeConfig {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Bean
    public DatabaseReconWorker TradeAllocationDatabaseReconWorker(){
        DatabaseReconWorker databaseWorker = new DatabaseReconWorker();
        databaseWorker.setSQL("SELECT * FROM allocation");
        databaseWorker.setJdbcTemplate(this.jdbcTemplate);
        databaseWorker.setClazz(TradeAllocation.class);
        return databaseWorker;
    }

    @Bean
    public CSVFileReconWorker TradeAllocationCSVReconWorker(){
        CSVFileReconWorker csvFileReconWorker = new CSVFileReconWorker();
        csvFileReconWorker.setClazz(TradeAllocation.class);
        csvFileReconWorker.setFileName("/com/justynsoft/simplerecon/traderecon/data.csv");
        return csvFileReconWorker;
    }
}
--------------------------------------------------------------------------------------------------------
   @Bean
    public JdbcTemplate getJdbcTemplate(){
        return new JdbcTemplate(dataSource);
    }
--------------------------------------------------------------------------------------------------------
// Comment to get more information during initialization
logLevel := Level.Warn

// The Typesafe repository
resolvers += "Typesafe repository" at "http://repo.typesafe.com/typesafe/releases/"

// Use the Play sbt plugin for Play projects
addSbtPlugin("com.typesafe.play" % "sbt-plugin" % "2.2.3")
--------------------------------------------------------------------------------------------------------
<resources>
    <!--
    TODO: Before you run your application, you need a Google Maps API key.
    To get one, follow this link, follow the directions and press "Create" at the end:
    https://console.developers.google.com/flows/enableapi?apiid=maps_android_backend&keyType=CLIENT_SIDE_ANDROID&r=B6:CA:08:B3:82:8C:4D:7D:81:2F:E4:E6:99:5E:7B:04:E2:BA:F2:8A%3Bbreathe.inventerous.com.breathe
    You can also add your credentials to an existing key, using these values:
    Package name:
    B6:CA:08:B3:82:8C:4D:7D:81:2F:E4:E6:99:5E:7B:04:E2:BA:F2:8A
    SHA-1 certificate fingerprint:
    B6:CA:08:B3:82:8C:4D:7D:81:2F:E4:E6:99:5E:7B:04:E2:BA:F2:8A
    Alternatively, follow the directions here:
    https://developers.google.com/maps/documentation/android/start#get-key
    Once you have your key (it starts with "AIza"), replace the "google_maps_key"
    string in this file.
    -->
    <string name="google_maps_key" templateMergeStrategy="preserve" translatable="false">AIzaSyABDlQcs7xlKmsvbp_XIktPtGQVSWl8wAw</string>
</resources>
--------------------------------------------------------------------------------------------------------
import android.content.Context;
import android.support.test.InstrumentationRegistry;
import android.support.test.runner.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

import static org.junit.Assert.*;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {
    @Test
    public void useAppContext() {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getTargetContext();

        assertEquals("breathe.inventerous.com.breathe", appContext.getPackageName());
    }
}
--------------------------------------------------------------------------------------------------------
spring.datasource.initialization-mode=always
--------------------------------------------------------------------------------------------------------
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.JpaVendorAdapter;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.Database;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

import javax.persistence.EntityManagerFactory;
import javax.sql.DataSource;

@SpringBootApplication//(exclude = { SecurityAutoConfiguration.class })
@EnableJpaRepositories(basePackages = {"com.exercise.dao", "com.exercise.conf"} )
public class Application {

    public static void main(String... args) {
        SpringApplication.run(Application.class, args);
    }

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2).build();
    }

    @Bean
    public JpaVendorAdapter jpaVendorAdapter() {
        HibernateJpaVendorAdapter bean = new HibernateJpaVendorAdapter();
        bean.setDatabase(Database.H2);
        bean.setGenerateDdl(true);
        bean.setShowSql(true);
        return bean;
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource,
                                                                       JpaVendorAdapter jpaVendorAdapter) {
        LocalContainerEntityManagerFactoryBean bean = new LocalContainerEntityManagerFactoryBean();
        bean.setDataSource(dataSource);
        bean.setJpaVendorAdapter(jpaVendorAdapter);
        bean.setPackagesToScan("com.exercise.domain");
        return bean;

    }

    @Bean
    public JpaTransactionManager transactionManager(EntityManagerFactory emf) {
        return new JpaTransactionManager(emf);
    }

    @Bean
    BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
--------------------------------------------------------------------------------------------------------
//import javax.sql.DataSource;
//
//import org.springframework.context.annotation.Bean;
//import org.springframework.context.annotation.Configuration;
//import org.springframework.jdbc.datasource.embedded.EmbeddedDatabase;
//import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;
//import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;
//
//@Configuration
//public class PersistenceConfig {
//
//    @Bean
//    public DataSource dataSource() {
//        EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();
//        EmbeddedDatabase db = builder.setType(EmbeddedDatabaseType.H2).addScript("mySchema.sql").addScript("myData.sql").build();
//        return db;
//    }
//
//}
--------------------------------------------------------------------------------------------------------
//	@Override
//	public void addCorsMappings(CorsRegistry registry) {
//		registry.addMapping("/**").maxAge(3600).allowedHeaders("Content-type", "Authorization").allowedMethods("*")
//				.allowCredentials(true).allowedOrigins(origin);
//	}

//    @Override
//    protected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {
//        argumentResolvers.add(
//            new ServletWebArgumentResolverAdapter(new PageableArgumentResolver()));
//    }
--------------------------------------------------------------------------------------------------------
	static {
		// Eagerly load the NestedExceptionUtils class to avoid classloader deadlock
		// issues on OSGi when calling getMessage(). Reported by Don Brown; SPR-5607.
		NestedExceptionUtils.class.getName();
	}
--------------------------------------------------------------------------------------------------------
  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
--------------------------------------------------------------------------------------------------------
@Bean(name = “userCacheManager”)
public RedisCacheManager userCacheManager(RedisConnectionFactory connectionFactory, UserService userService) {
RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();
DefaultFormattingConversionService conversionService = (DefaultFormattingConversionService) redisCacheConfiguration.getConversionService();
conversionService.addConverter(UserCacheKey.class, String.class, new UserCacheKeyConverter(userService));
redisCacheConfiguration
.entryTtl(Duration.ofSeconds(1800)).withConversionService(conversionService)
.disableCachingNullValues();
return RedisCacheManager.builder(connectionFactory)
.cacheDefaults(redisCacheConfiguration)
.withInitialCacheConfigurations(Collections.singletonMap(“user-cache”, redisCacheConfiguration))
.build();
}
--------------------------------------------------------------------------------------------------------
@WritingConverter
public class AddressToMapConverter implements Converter<Address, Map<String,byte[]>> {

  @Override
  public Map<String,byte[]> convert(Address source) {
    return singletonMap("ciudad", source.getCity().getBytes());
  }
}

@ReadingConverter
public class MapToAddressConverter implements Converter<Address, Map<String, byte[]>> {

  @Override
  public Address convert(Map<String,byte[]> source) {
    return new Address(new String(source.get("ciudad")));
  }
}
--------------------------------------------------------------------------------------------------------
/*
@RunWith(SpringRunner.class)
@SpringBootTestConfiguration(
        activeClasses = {
                FileToUploadRequestConverter.class
        })
@EnableAutoConfiguration(
        exclude = {
                TaskExecutionAutoConfiguration.class,
                IntegrationAutoConfiguration.class,
                KafkaAutoConfiguration.class,
                MetricsAutoConfiguration.class,
                WebMvcMetricsAutoConfiguration.class,
                RestTemplateAutoConfiguration.class
        }
)
public class FileToUploadRequestConverterTest extends AbstractBaseTest {
    private static final String FILE_TYPE = "pdf";
    private static final String FILE_NAME = "test";
    private static final long FILE_SIZE = 20L;

    @Autowired
    private ConversionService conversionService;

    @Test
    public void test_valid_File_to_UploadFileRequest_ByConverter() {
        // given
        final File file = this.getFile(new byte[]{0, 1, 3}, FILE_NAME, FILE_SIZE, FILE_TYPE);

        // when
        final UploadFileRequest request = this.conversionService.convert(file, UploadFileRequest.class);

        // then
        assertThat(request, is(not(nullValue())));
        assertThat(request.getContent(), equalTo(file.getContent()));
        assertThat(request.getMediaType(), equalTo(file.getType()));
        assertThat(request.getName(), equalTo(file.getDispositionName()));
        assertThat(request.getSize(), equalTo(file.getSize()));
        assertThat(request.getLastModified(), equalTo(0L));
    }

    @Test
    public void test_invalid_File_to_UploadFileRequest_ByConverter() {
        // given
        final File file = this.getFile(null, EMPTY, 0L, FILE_TYPE);

        // when
        final UploadFileRequest request = this.conversionService.convert(file, UploadFileRequest.class);

        // then
        assertThat(request, is(not(nullValue())));
        assertThat(request.getContent(), equalTo(file.getContent()));
        assertThat(request.getMediaType(), equalTo(file.getType()));
        assertThat(request.getName(), equalTo(file.getDispositionName()));
        assertThat(request.getSize(), equalTo(file.getSize()));
        assertThat(request.getLastModified(), equalTo(0L));
    }
}
 */
--------------------------------------------------------------------------------------------------------
http://localhost:8089/api/v0/distributor/download/c108cda3-8b4b-483d-a987-d65e6bfe3024/lombok.config

    @Autowired
    private SessionService sessionService;

    @GetMapping("/created")
    public ResponseEntity init() {
        final Session session = new Session();
        session.setId("c108cda3-8b4b-483d-a987-d65e6bfe3024");
        session.setFilepath("C:\\git-project\\paragon.microservices.distributor");
        session.setFilename("lombok.config");
        session.setDownloadStatus(DownloadStatus.NEW);
        this.sessionService.save(session);

        final Session session2 = new Session();
        session2.setId("c108cda3-8b4b-483d-a987-d65e6bfe3025");
        session2.setFilepath("C:\\git-project\\paragon.microservices.distributor");
        session2.setFilename("lombok.config2");
        session2.setDownloadStatus(DownloadStatus.NEW);
        this.sessionService.save(session2);
        return ResponseEntity.ok().build();
    }
--------------------------------------------------------------------------------------------------------
    @Bean
    public MappingRedisConverter redisConverter(final RedisMappingContext mappingContext,
                                                final List<RedisConverter> customConversions,
                                                final ReferenceResolver referenceResolver
    ) {
        final MappingRedisConverter mappingRedisConverter = new MappingRedisConverter(mappingContext, null, referenceResolver);
        mappingRedisConverter.setCustomConversions(new RedisCustomConversions(customConversions));
        return mappingRedisConverter;
    }
--------------------------------------------------------------------------------------------------------
    @Bean
    public MappingRedisConverter redisConverter(final RedisMappingContext mappingContext, final RedisCustomConversions customConversions, final ReferenceResolver referenceResolver) {
        final MappingRedisConverter mappingRedisConverter = new MappingRedisConverter(mappingContext, null, referenceResolver, customTypeMapper());
        mappingRedisConverter.setCustomConversions(customConversions);
        mappingRedisConverter.afterPropertiesSet();
        return mappingRedisConverter;
    }

    @Bean
    public RedisTypeMapper customTypeMapper() {
        return new DefaultRedisTypeMapper("data");
    }
--------------------------------------------------------------------------------------------------------
@Configuration
class SampleRedisConfiguration {

  @Bean
  public MappingRedisConverter redisConverter(RedisMappingContext mappingContext,
        RedisCustomConversions customConversions, ReferenceResolver referenceResolver) {

    MappingRedisConverter mappingRedisConverter = new MappingRedisConverter(mappingContext, null, referenceResolver,
            customTypeMapper());

    mappingRedisConverter.setCustomConversions(customConversions);

    return mappingRedisConverter;
  }

  @Bean
  public RedisTypeMapper customTypeMapper() {
    return new CustomRedisTypeMapper();
  }
}
--------------------------------------------------------------------------------------------------------
@WritingConverter
public class AddressToBytesConverter implements Converter<Address, byte[]> {

  private final Jackson2JsonRedisSerializer<Address> serializer;

  public AddressToBytesConverter() {

    serializer = new Jackson2JsonRedisSerializer<Address>(Address.class);
    serializer.setObjectMapper(new ObjectMapper());
  }

  @Override
  public byte[] convert(Address value) {
    return serializer.serialize(value);
  }
}

@ReadingConverter
public class BytesToAddressConverter implements Converter<byte[], Address> {

  private final Jackson2JsonRedisSerializer<Address> serializer;

  public BytesToAddressConverter() {

    serializer = new Jackson2JsonRedisSerializer<Address>(Address.class);
    serializer.setObjectMapper(new ObjectMapper());
  }

  @Override
  public Address convert(byte[] value) {
    return serializer.deserialize(value);
  }
}
--------------------------------------------------------------------------------------------------------
//package de.pearl.pem.common.system;
//
//public class SpringSprungConfig extends DelegatingWebMvcConfiguration {
//
//    // Delegate resource requests to default servlet
//    @Bean
//    protected DefaultServletHttpRequestHandler defaultServletHttpRequestHandler() {
//        DefaultServletHttpRequestHandler dsrh = new DefaultServletHttpRequestHandler();
//        return dsrh;
//    }
//
//    //map static resources by extension
//    @Bean
//    public SimpleUrlHandlerMapping resourceServletMapping() {
//        SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
//
//        //make sure static resources are mapped first since we are using
//        //a slightly different approach
//        mapping.setOrder(0);
//        Properties urlProperties = new Properties();
//        urlProperties.put("/**/*.css", "defaultServletHttpRequestHandler");
//        urlProperties.put("/**/*.js", "defaultServletHttpRequestHandler");
//        urlProperties.put("/**/*.png", "defaultServletHttpRequestHandler");
//        urlProperties.put("/**/*.html", "defaultServletHttpRequestHandler");
//        urlProperties.put("/**/*.woff", "defaultServletHttpRequestHandler");
//        urlProperties.put("/**/*.ico", "defaultServletHttpRequestHandler");
//        mapping.setMappings(urlProperties);
//        return mapping;
//    }
//
//    @Override
//    @Bean
//    public RequestMappingHandlerMapping requestMappingHandlerMapping() {
//        RequestMappingHandlerMapping handlerMapping = super.requestMappingHandlerMapping();
//
//        //controller mappings must be evaluated after the static resource requests
//        handlerMapping.setOrder(1);
//        handlerMapping.setInterceptors(this.getInterceptors());
//        handlerMapping.setPathMatcher(this.getPathMatchConfigurer().getPathMatcher());
//        handlerMapping.setRemoveSemicolonContent(false);
//        handlerMapping.setUseSuffixPatternMatch(false);
//        //set other options here
//        return handlerMapping;
//    }
//}


/*
    @Override
    public void addViewControllers(final ViewControllerRegistry registry) {
        registry.addRedirectViewController("/swagger", "/swagger-ui.html");
    }

    @Override
    public void configurePathMatch(final PathMatchConfigurer configurer) {
        configurer.setUseTrailingSlashMatch(true);
    }

//    @Override
//    public void addInterceptors(final InterceptorRegistry registry) {
//        registry.addInterceptor(new SwaggerInterceptor()).addPathPatterns("/swagger");
//    }
//
//    private class SwaggerInterceptor extends HandlerInterceptorAdapter {
//
//        @Override
//        public void afterCompletion(final HttpServletRequest request, final HttpServletResponse response, final Object handler, @Nullable final Exception ex) throws IOException {
//            response.sendRedirect("/swagger-ui.html");
//        }
//    }

//    @Bean
//    public Docket newsApi(final ServletContext servletContext) {
//        return new Docket(DocumentationType.SWAGGER_2)
//                .select()
//                .apis(RequestHandlerSelectors.basePackage("com.paragon.microservices.crmadapter.controller"))
//                .paths(PathSelectors.any())
//                .build()
//                .enable(true)
//                .pathProvider(new RelativePathProvider(servletContext) {
//                    @Override
//                    public String getApplicationBasePath() {
//                        return join("/swagger", super.getApplicationBasePath());
//                    }
//                }).host("newhost:8095");
//    }
 */

--------------------------------------------------------------------------------------------------------//package de.pearl.pem.common.system.property;
//
//import javax.inject.Inject;
//
//import org.springframework.context.annotation.Bean;
//import org.springframework.context.annotation.Configuration;
//
//import com.mangofactory.swagger.configuration.SpringSwaggerConfig;
//import com.mangofactory.swagger.models.dto.ApiInfo;
//import com.mangofactory.swagger.models.dto.builder.ApiInfoBuilder;
//import com.mangofactory.swagger.plugin.EnableSwagger;
//import com.mangofactory.swagger.plugin.SwaggerSpringMvcPlugin;
//
//@Configuration
//@EnableSwagger
//public class SwaggerConfiguration {
//
//    @Inject
//    private SpringSwaggerConfig springSwaggerConfig;
//
//    private ApiInfo getApiInfo() {
//
//        ApiInfo apiInfo = new ApiInfoBuilder()
//                .title("QuickPoll REST API")
//                .description("QuickPoll Api for creating and managing polls")
//                .termsOfServiceUrl("http://example.com/terms-of-service")
//                .contact("info@example.com")
//                .license("MIT License")
//                .licenseUrl("http://opensource.org/licenses/MIT")
//                .build();
//
//        return apiInfo;
//    }
//
//    @Bean
//    public SwaggerSpringMvcPlugin v1APIConfiguration() {
//        SwaggerSpringMvcPlugin swaggerSpringMvcPlugin = new SwaggerSpringMvcPlugin(this.springSwaggerConfig);
//        swaggerSpringMvcPlugin
//                .apiInfo(getApiInfo()).apiVersion("1.0")
//                .includePatterns("/v1/*.*").swaggerGroup("v1");
//        swaggerSpringMvcPlugin.useDefaultResponseMessages(false);
//        return swaggerSpringMvcPlugin;
//    }
//
//    @Bean
//    public SwaggerSpringMvcPlugin v2APIConfiguration(){
//        SwaggerSpringMvcPlugin swaggerSpringMvcPlugin = new SwaggerSpringMvcPlugin(this.springSwaggerConfig);
//        swaggerSpringMvcPlugin
//                .apiInfo(getApiInfo()).apiVersion("2.0")
//                .includePatterns("/v2/*.*").swaggerGroup("v2");
//        swaggerSpringMvcPlugin.useDefaultResponseMessages(false);
//        return swaggerSpringMvcPlugin;
//    }
//
//    @Bean
//    public SwaggerSpringMvcPlugin v3APIConfiguration(){
//        SwaggerSpringMvcPlugin swaggerSpringMvcPlugin = new SwaggerSpringMvcPlugin(this.springSwaggerConfig);
//        swaggerSpringMvcPlugin
//                .apiInfo(getApiInfo()).apiVersion("3.0")
//                .includePatterns("/v3/*.*").swaggerGroup("v3");
//        swaggerSpringMvcPlugin.useDefaultResponseMessages(false);
//        return swaggerSpringMvcPlugin;
//    }
//}
import com.kodedu.controller.ApplicationController;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

import java.util.Base64;

@Configuration
@EnableWebSocket
@ComponentScan(basePackages = "com.kodedu.**")
@EnableAutoConfiguration
public class SpringAppConfig extends SpringBootServletInitializer implements WebSocketConfigurer {

    @Autowired
    private ApplicationController applicationController;

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(applicationController, "/ws", "/ws**", "/ws/**").withSockJS();
    }

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(SpringAppConfig.class);
    }

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

    @Bean
    public Base64.Encoder base64Encoder() {
        return Base64.getEncoder();
    }
}

--------------------------------------------------------------------------------------------------------
//import org.springframework.context.annotation.Bean;
//import org.springframework.context.annotation.ComponentScan;
//import org.springframework.context.annotation.Configuration;
//import org.springframework.context.annotation.PropertySource;
//import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;
//import org.springframework.scheduling.annotation.EnableScheduling;
//import org.springframework.scheduling.annotation.SchedulingConfigurer;
//import org.springframework.scheduling.config.ScheduledTaskRegistrar;
//
//import java.util.concurrent.Executor;
//import java.util.concurrent.Executors;
//
//import static com.sportics.principal.hor.horweb.configs.SchedulerConfig.DEFAULT_SCHEDULER_PACKAGE;
//
//@Configuration
//@EnableScheduling
//@ComponentScan(DEFAULT_SCHEDULER_PACKAGE)
//@PropertySource("classpath:cron")
//public class SchedulerConfiguration implements SchedulingConfigurer {
//
//    /**
//     * Default scheduler packages
//     */
//    public static final String DEFAULT_SCHEDULER_PACKAGE = "com.sportics.principal.hor.horweb.scheduler";
//
//    // Default scheduling pool size
//    private static final int DEFAULT_SCHEDULER_POOL_SIZE = 10;
//
//    @Bean
//    public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {
//        return new PropertySourcesPlaceholderConfigurer();
//    }
//
//    @Override
//    public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) {
//        scheduledTaskRegistrar.setScheduler(taskExecutor());
//    }
//
//    @Bean(destroyMethod = "shutdown")
//    public Executor taskExecutor() {
//        return Executors.newScheduledThreadPool(DEFAULT_SCHEDULER_POOL_SIZE);
//    }
//}
--------------------------------------------------------------------------------------------------------
//SET DATABASE UNIQUE NAME HSQLDB4D3A66AE30
//    SET DATABASE GC 0
//    SET DATABASE DEFAULT RESULT MEMORY ROWS 0
//    SET DATABASE EVENT LOG LEVEL 0
//    SET DATABASE TRANSACTION CONTROL LOCKS
//    SET DATABASE DEFAULT ISOLATION LEVEL READ COMMITTED
//    SET DATABASE TRANSACTION ROLLBACK ON CONFLICT TRUE
//    SET DATABASE TEXT TABLE DEFAULTS ''
//    SET DATABASE SQL NAMES FALSE
//    SET DATABASE SQL REFERENCES FALSE
//    SET DATABASE SQL SIZE TRUE
//    SET DATABASE SQL TYPES FALSE
//    SET DATABASE SQL TDC DELETE TRUE
//    SET DATABASE SQL TDC UPDATE TRUE
//    SET DATABASE SQL TRANSLATE TTI TYPES TRUE
//    SET DATABASE SQL CONCAT NULLS TRUE
//    SET DATABASE SQL UNIQUE NULLS TRUE
//    SET DATABASE SQL CONVERT TRUNCATE TRUE
//    SET DATABASE SQL AVG SCALE 0
//    SET DATABASE SQL DOUBLE NAN TRUE
//    SET FILES WRITE DELAY 500 MILLIS
//    SET FILES BACKUP INCREMENT TRUE
//    SET FILES CACHE SIZE 10000
//    SET FILES CACHE ROWS 50000
//    SET FILES SCALE 32
//    SET FILES LOB SCALE 32
//    SET FILES DEFRAG 0
//    SET FILES NIO TRUE
//    SET FILES NIO SIZE 256
//    SET FILES LOG TRUE
//    SET FILES LOG SIZE 50
//    CREATE USER SA PASSWORD DIGEST 'c12e01f2a13ff5587e1e9e4aedb8242d'
//    ALTER USER SA SET LOCAL TRUE
//    CREATE SCHEMA PUBLIC AUTHORIZATION DBA
//    ALTER SEQUENCE SYSTEM_LOBS.LOB_ID RESTART WITH 1
//    SET DATABASE DEFAULT INITIAL SCHEMA PUBLIC
//    GRANT USAGE ON DOMAIN INFORMATION_SCHEMA.SQL_IDENTIFIER TO PUBLIC
//    GRANT USAGE ON DOMAIN INFORMATION_SCHEMA.YES_OR_NO TO PUBLIC
//    GRANT USAGE ON DOMAIN INFORMATION_SCHEMA.TIME_STAMP TO PUBLIC
//    GRANT USAGE ON DOMAIN INFORMATION_SCHEMA.CARDINAL_NUMBER TO PUBLIC
//    GRANT USAGE ON DOMAIN INFORMATION_SCHEMA.CHARACTER_DATA TO PUBLIC
//    GRANT DBA TO SA
//    SET SCHEMA SYSTEM_LOBS
//    INSERT INTO BLOCKS VALUES(0,2147483647,0)
--------------------------------------------------------------------------------------------------------
import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.env.MutablePropertySources;
import org.springframework.core.env.PropertySource;
import org.springframework.env.redis.RedisPropertySource;
import org.springframework.web.context.ConfigurableWebApplicationContext;

public class XmlConfigPropertySourceInitializer implements ApplicationContextInitializer<ConfigurableWebApplicationContext> {
    @Override
    public void initialize(ConfigurableWebApplicationContext applicationContext) {
        MutablePropertySources propertySources = applicationContext.getEnvironment().getPropertySources();
        propertySources.addFirst(getPropertySource());
    }

    private PropertySource getPropertySource() {
        ClassPathXmlApplicationContext propertySourceContext =
                new ClassPathXmlApplicationContext("classpath:/META-INF/spring/property-source-context.xml");

        return propertySourceContext.getBean(RedisPropertySource.class);
    }
}
--------------------------------------------------------------------------------------------------------
JacksonAutoConfiguration
--------------------------------------------------------------------------------------------------------
  <dependency>

            <groupId>net.serenity-bdd</groupId>

            <artifactId>serenity-core</artifactId>

            <version>${serenity.version}</version>

            <scope>test</scope>

            <exclusions>

                <!-- Need to exclude for servlet API, see https://groups.google.com/forum/#!topic/thucydides-users/HwfhPGseucI-->

                <exclusion>

                    <groupId>net.sourceforge.htmlunit</groupId>

                    <artifactId>htmlunit</artifactId>

                </exclusion>

            </exclusions>

        </dependency>

        <dependency>

            <groupId>net.serenity-bdd</groupId>

            <artifactId>serenity-junit</artifactId>

            <version>${serenity.version}</version>

            <scope>test</scope>

        </dependency>

    </dependencies>
--------------------------------------------------------------------------------------------------------
Files management
These commands are the basics that every Linux beginner should learn
Maybe you already know them, but it will be a reminder

The Linux arborescence is a Tree, starting at the root: /
Each subfolder created under is accessible with /
Ex: /home/pi => pi is a subfolder of /home, home is a subfolder  in /
Don't forget to use sudo if you are not allowed to access the file or directory (sudo gives you administrator privileges for the command that follows)
cd <path>: Changes directory, go to the specified folder in the files tree
cd /home/pi
ls: Lists the files and directory in the current or specified folder
ls
ls /home/pi
ls -latr /home/pi
mkdir <folder>: Creates a new subfolder in the current or specified folder
mkdir myfolder
mkdir /home/pi/myfolder
cp <file> <destination>: Copies a file or a directory to another location (to copy a complete directory you need to add the -r parameter for “recursive”)
cp test.txt /home/pi/Documents/
cp /home/pi/test.txt /home/pi/Documents/
cp -r /home/pi/test/ /home/pi/Documents/
mv <source> <destination>: Moves a file or a directory to another location
mv /home/pi/test.txt /home/Documents/
mv /home/pi/test/ /home/Documents/
cat <file>: Displays all the content of the specified file
cat /home/pi/README.txt
more <file>: Displays the content of the specified file, page per page (enter or space to continue, q to quit)
more /var/log/syslog
tail <file>: Tail allows you to display the end of a file, it’s useful to check new entries in a log file
tail /var/log/syslog
You can specify the number of lines to display with -n

tail -n20 /var/log/syslog
And finally, my favorite is the option -f to displays new lines in real-time

tail -f /var/log/syslog
head <file>: It’s the same as tail but to display the beginning of a file
head /home/pi/file.txt
head -n20 /home/pi/file.txt
grep <string>: Grep is a powerful tool to search string in a text. You can use it to search something in a file or to filter the output of another command or script
Basic usage:
grep dhcp /var/log/syslog
As I say, you can use it on a file or a script output:

cat /var/log/syslog | grep dhcp
/home/pi/myscript.sh | grep error
ls -latr | grep php
And finally, there is a lot of options to use with grep, like regular expressions or options to display lines before (-B), after (-A) or around (-C) the search string
You can also use -v to display everything except the input string

grep 'dhcp\|dns' /var/log/syslog
grep -A2 -B4 'Fatal error' /var/log/apache/error.log
grep -v 'Notice' /var/log/apache/error.log
If you like this tool, I recommend you to read the man page to know exactly what you can do with

man grep
nano <file>: Nano is text editor. It would need an entire article to go into detail
But quickly, it allows you to edit a file, and save your changes with (CTRL + O, Enter, CTRL + X)
nano /home/pi/myscript.sh
You’ll find all actions available at the bottom of the screen

rm <file>: Deletes a file. For a folder add option -rf (recursive and force)
rm monscript.sh
rm -rf /home/pi/scripts/
tar -c: You can use tar to store files into an archive. It’s often used with gzip to compress files
tar -cvfz archive.tar.gz /home/pi/Documents/mydirectory
-c: create an archive
-v: verbose
-f: filename of the archive follow
-z: compress files with gzip

tar -x: It’s the same command but to extract files
tar -xvfz archive.tar.gz
-x: extract an archive

find: As the name suggests, find is useful to locate files on your Raspberry Pi
find /home/pi -iname *.tar.gz
There is a lot of options to help you find the good file (size, last modification date, …)

pwd: Pwd lets you see in which directory you are.
pwd
tree: Another great tool to analyze your current location in the files tree. It will show you the entire lower tree (see the example below)
tree
pi@raspberrypi:/var/log $ tree
.
|-- alternatives.log
|-- alternatives.log.1
|-- alternatives.log.2.gz
|-- apt
|   |-- eipp.log.xz
|   |-- history.log
|   |-- history.log.1.gz
|   |-- history.log.2.gz
|   |-- term.log
|   |-- term.log.1.gz
|   `-- term.log.2.gz
...
Network commands
Shortly after your first Raspbian installation, you’ll surely need some of this commands to help you with the network configuration (especially if you are on a lite version or with SSH)

Configuration
By default, the Raspberry Pi 3B+ comes with 2 interfaces (Ethernet and WiFi)
The ethernet is called eth0 and the WiFi is wlan0
You have to use these names with some of the commands below
ifconfig: Displays your current network configuration, mainly your IP address if connected
ifconfig
ping <ip>: Sends a ping packet to another IP on the network to check if the host is alive
ping 192.168.1.1
ifup <interface>: Enables the specified interface
sudo ifup eth0
ifdown <interface>: Disables the specified interface. Could be useful to disable WiFi if you are already connected by cable for example
sudo ifdown wlan0
File transfer and remote connection
wget <url>: This command allows you to download a file from the Internet
wget https://wordpress.org/latest.zip
ssh <user>@<ip>: SSH is a network protocol that provides you a way to connect securely to a remote computer
ssh root@192.168.1.201
scp <file> <user>@<ip>:<path>: scp can transfer a file to a remote computer over SSH
scp test.txt root@192.168.1.201:/root/
rsync <file> <user>@<ip>:<path>: rsync does almost the same thing but with a delta comparison algorithm and some optimizations to transfer files faster
rsync test.txt root@192.168.1.201:/root/
rsync -auzr /home/pi/Documents/* /home/pi/backups/Documents/
As you can see, you can also use rsync for local files synchronization

System updates
Just after the network configuration, you’ll have to update your system to get the last version of each default packages installed

On Raspbian, and generally on all Linux distributions, you'll have a package for each app or command you install
A list of all available packages is called a repository
Once installed, you need to update this repository and all your packages regularly to keep your system safe
These commands explain you how to do this
We'll need sudo for all these commands
apt-get update: Downloads the last repository version for each one you have in your configuration (/etc/apt/sources.list)
sudo apt-get update
apt-get upgrade: Updates all installed packages if needed
sudo apt-get upgrade
rpi-update: Only use this if you know what you do.
This command will update everything on your Raspberry Pi (firmware, packages, …) and can potentially break something
rpi-update
Packages management
After that, you may want to install new packages on your Raspberry Pi
Here are the commands you need to know to do this

apt-get install <package>:  Installs the specified package(s)
sudo apt-get install phpmyadmin
sudo apt-get install vim htop
apt-get remove <package>: Removes a previously selected package
sudo apt-get remove vim
apt-cache search <search>: Searchs for a package name in the packages list (repository)
sudo apt-cache search myadmin
sudo apt-cache search php
dpkg -l: Lists all installed packages on your system. You can use grep to find a specific package
dpkg -l
dpkg -l | grep myadmin
System management
Here are the commands you’ll often use to manage your Raspberry Pi hardware

reboot: As the name says, this command will restart the Raspberry Pi immediately
sudo reboot
shutdown -h now: This is to stop the Raspberry Pi immediately
sudo shutdown -h now
You can replace “now” by a specific time (shutdown -h 12:05)

service <servicename> <action>: This command allows you to start or stop services
service apache2 start
service apache2 stop
Sometimes there are other options, depending on the service, for example:

service apache2 reload
service apache2 restart
Don’t type any action to see all those available:

service apache2
update-rc.d <service> <action>: On Debian, this command allows you to manage the service start or stop on the system boot
To start a service on boot:
sudo update-rc.d ssh enable
To disable start of the service:

sudo update-rc.d -f ssh remove
The -f option is here to force the symbolic link deletion

This command is only for service
To start other scripts or commands on boot, you have to edit the /etc/rc.local file

sudo nano /etc/rc.local
ps: This command displays all running process on your Raspberry Pi
The basic command is this one to display everything:
ps aux
You can also display process started by a specific user:

ps -u pi
This will give you a list like this
ps linux command
The process ID (PID) could be useful for other commands, to stop it for example (next command)

kill <pid>: The kill command allows you to terminate a process. You’ll need the process ID to do this (see the previous command)
kill 12345
Sometime you may need to use the -9 option to force all related commands to stop
For example, if you run 20 commands in a script and kill it, it’ll continue to the next line, not exit the program, except if you use the -9 option

kill -9 12345
You could also use killall to stop all occurrences of a program

killall php
This command will stop all PHP scripts

Be aware that this commands will immediately stop the process asked, no matter what was going on. It’s not a clean stop
You don’t know what the script is doing so it can damage data or corrupt files
This should be used as a last step, and if possible on the non-critical process

htop: This tool is an alternative to top. It’s more user-friendly than top, with colors and dynamic load bars
htop
df: Displays the partitions list, with the disk space used and available for each one
df
df -h
-h option is for the human-readable format

vcgencmd measure_temp: You may not remember it, but this command displays the current CPU temperature
vcgencmd measure_temp
Raspbian commands
Most of the commands from this post are basically Linux commands
But Raspbian has some exclusive ones that I will introduce first

These are not all essentials, but you may not know them even if you are good with Linux

raspi-config: This tool allows you to manage all the configuration from a terminal or an SSH connection
sudo raspi-config
raspi config

raspistill: If you have a camera plugged in the camera module, this command takes a shot and save it to an image file
raspistill -o image.jpg
raspivid: It’s the same command but for video capture from the camera
raspivid -o video.h264 -t 10000
-t parameter is the time of the capture in milliseconds

raspi-gpio:  This command allows you to manage the GPIO pins of the Raspberry Pi. You can either set or get a value
raspi-gpio get
raspi-gpio get 20
raspi-gpio set 20 a5 
raspi-gpio set 20 op pn dh
raspividyuv or raspiyuv:  This command is similar to the raspivid but for a raw YUV video stream
raspividyuv -o video.yuv
rpi-update: Only use this if you know what you do. This will update everything on your Raspberry Pi (firmware, packages, …) and can potentially break something
sudo rpi-update
Misc
Here are some other useful commands that I haven’t managed to place in the other categories 🙂

history: Linux store any command you type in an archive file. History is the command to use to display this list.
history
You can also clear all the history

history -c
Or clear one specific entry

history -d 123
crontab: Cron is a tool to schedule tasks on a Raspberry Pi. Crontab is the file where your enter lines for each task to run
crontab -l
crontab -e
-l option to display lines
-e option to edit lines
You can use sudo before to schedule tasks to run with root privileges

screen: This tool allows you to let something run in the background even if you close your session
screen -s <name>
screen -r <name>
-s option to start a new screen with the following name
-r option to resume a running screen with this name
You can forget the name if you want, an ID will be generated, use screen -r to find it and screen -r <ID> to resume it
With only one screen running, screen -r will resume it directly

Warrior commands
For this last part, I’ll introduce some powerful commands to master your Raspberry Pi
If you start on Linux, you may not need to know this one, but if you want to save time or go further on Raspberry Pi,  you should know this commands

awk: awk is nearly a programming language, it allows you to search string and transform them to display it differently.
So it’ll be difficult to summarize all of the possibilities in a few lines, but I’ll try to give you some examples to understand it
The basic syntax of awk is this one:
awk [-F] [-v var=value] 'program' file
-F is the field separator string (“:” or “,” for example)
-v allows you to define variables to use it later in the process
What I called program is the expression used to process the file, we’ll see this part just after
And finally, the “file” parameter is the file name you want to process

Here is a basic example:

awk -F":" '{print $1}' /etc/passwd
/etc/passwd is the file to parse. The field separator is “:” so we use it in the -F option
Then in the program string, we ask to display only the first column
So this command will display only a list of usernames
This is the simple way to use it if you want to know more, I recommend to read a dedicated tutorial like this one

sed: sed allows you to do similar things to awk, it will transform text to what you want.
As for awk, it’s a complex command to master, and I’ll only introduce it here
The basic syntax looks like this:
sed <option> <script> <file>
So it’s very close to awk on this
Let’s see an example :

sed '/^#/d' /etc/apache2/apache2.conf
Generally, in each configuration file, you’ll find a lot of comments to explain what is each line
This command will display the apache configuration file without comments
We use a regular expression to delete lines starting with #
You have to redirect the output to another file to save it

sed '/^#/d' /etc/apache2/apache2.conf > /etc/apache2/apache2-nocomment.conf
Like for awk, this is just a glimpse of what sed can do
If you want to know more, there is also a good sed tutorial on the same website

cut: cut is the last way I’ll introduce here to transform text. It’s less powerful but it’s simpler to use, so if cut can do it, you’ll probably prefer to use it rather than awk or sed
As the name suggests, cut allows you to extract part of a text or file
The basic syntax is:
cut <options> <file>
echo <string> | cut <options>
The first one is for a file, and the second one to cut a string directly
A basic example now:

echo "abcdefghi" | cut -c 2-4
This will display only “bcd”
-c option is for the character, so basically, it’ll extract character 2 to 4

Here are other options with a file:

cut -d : -f 1 /etc/passwd
This will do the same thing as the first example of the awk command
/etc/password is a file with “:” use as a delimiter
-d option is to give the delimiter character (“:”)
-f option is to indicate the column to extract (f stands for the field)
So, this will display only the first column and you’ll get a list of usernames

wc: wc stands for Word Count, it allows you to count everything in a file or stream
There are three main options: -l for lines, -w for words and -m for characters
There is also the -c option to get the file size
Wc without option will give you all of this
wc .bash_history
668  1977 17979 .bash_history
The first column is line count, second is word count and last is the file size in bytes
Here are some examples of options:

wc -l .bash_history
ls -latr | wc -l
wc -w myfile.txt
lsof:  lsof stands for “List open files”. This command displays all files open on your Raspberry Pi
This could be useful to know why you can’t edit a file, or which file lock the unmount process
lsof
watch: If you are waiting for something, in a file or directory, the watch command could help you to monitor what happens. This will execute the same command every two seconds
watch date
watch ls -latr
watch cat output.txt
You can also change the refresh rate with the -n option

watch -n10 date
This will display the current date every ten seconds

netstat: Netstat is a powerful tool to monitor what your Raspberry Pi is doing with the network. For example, you could see every port open and every traffic flow
But netstat is a complex tool that i can’t explain in detail in a few lines.
I will only introduce some basic usages to display all listening connections you can use:
netstat -l
-p option will add the process id (PID)

netstat -lp
-c option allows you to refresh data continuously

netstat -lpc
You can find all options in the man page of netstat

dmesg:  This command is useful for troubleshooting your Raspberry Pi boot
It will show you every event that happened in the start sequence
Here you could see errors with drivers or services and understand why something doesn’t work the way you want
dmesg
You will get a column with the time elapsed since the beginning of the boot and a text explaining what happened
There are also normal messages when everything is fine

Conclusion
Here we are.
Now you should have a better idea of commands to learn to get the best of your Raspberry Pi

And you, what are your more used commands?
You can see it by analyzing your history file with this kind of command:

history | awk '{CMD[$2]++;count++;}END { for (a in CMD)print CMD[a] " " CMD[a]/count*100 "% " a;}' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl | head -n10
--------------------------------------------------------------------------------------------------------
import com.bfwg.security.TokenHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * Created by fan.jin on 2016-10-19.
 */
public class TokenAuthenticationFilter extends OncePerRequestFilter {

    private final Log logger = LogFactory.getLog(this.getClass());

    private TokenHelper tokenHelper;

    private UserDetailsService userDetailsService;

    public TokenAuthenticationFilter(TokenHelper tokenHelper, UserDetailsService userDetailsService) {
        this.tokenHelper = tokenHelper;
        this.userDetailsService = userDetailsService;
    }


    @Override
    public void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain chain
    ) throws IOException, ServletException {

        String username;
        String authToken = tokenHelper.getToken(request);

        if (authToken != null) {
            // get username from token
            username = tokenHelper.getUsernameFromToken(authToken);
            if (username != null) {
                // get user
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                if (tokenHelper.validateToken(authToken, userDetails)) {
                    // create authentication
                    TokenBasedAuthentication authentication = new TokenBasedAuthentication(userDetails);
                    authentication.setToken(authToken);
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            }
        }
        chain.doFilter(request, response);
    }

}
--------------------------------------------------------------------------------------------------------
import com.bfwg.security.TokenHelper;
import com.bfwg.security.auth.RestAuthenticationEntryPoint;
import com.bfwg.security.auth.TokenAuthenticationFilter;
import com.bfwg.service.impl.CustomUserDetailsService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import org.springframework.security.web.util.matcher.RequestMatcher;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Created by fan.jin on 2016-10-19.
 */

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Autowired
    private CustomUserDetailsService jwtUserDetailsService;

    @Autowired
    private RestAuthenticationEntryPoint restAuthenticationEntryPoint;

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Autowired
    public void configureGlobal( AuthenticationManagerBuilder auth ) throws Exception {
        auth.userDetailsService( jwtUserDetailsService )
            .passwordEncoder( passwordEncoder() );
    }

    @Autowired
    TokenHelper tokenHelper;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        List<RequestMatcher> csrfMethods = new ArrayList<>();
        Arrays.asList( "POST", "PUT", "PATCH", "DELETE" )
                .forEach( method -> csrfMethods.add( new AntPathRequestMatcher( "/**", method ) ) );
        http
                .sessionManagement().sessionCreationPolicy( SessionCreationPolicy.STATELESS ).and()
                .exceptionHandling().authenticationEntryPoint( restAuthenticationEntryPoint ).and()
                .authorizeRequests()
                .antMatchers(
                        HttpMethod.GET,
                        "/",
                        "/webjars/**",
                        "/*.html",
                        "/favicon.ico",
                        "/**/*.html",
                        "/**/*.css",
                        "/**/*.js"
                ).permitAll()
                .antMatchers("/auth/**").permitAll()
                .anyRequest().authenticated().and()
                .addFilterBefore(new TokenAuthenticationFilter(tokenHelper, jwtUserDetailsService), BasicAuthenticationFilter.class);

        http.csrf().disable();
    }


    @Override
    public void configure(WebSecurity web) throws Exception {
        // TokenAuthenticationFilter will ignore the below paths
        web.ignoring().antMatchers(
                HttpMethod.POST,
                "/auth/login"
        );
        web.ignoring().antMatchers(
                HttpMethod.GET,
                "/",
                "/webjars/**",
                "/*.html",
                "/favicon.ico",
                "/**/*.html",
                "/**/*.css",
                "/**/*.js"
            );

    }
}
--------------------------------------------------------------------------------------------------------
import org.apache.coyote.http11.Http11NioProtocol;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;
import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;
import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.io.File;

@Configuration
public class ContainerConfiguration {

    @Bean
    EmbeddedServletContainerCustomizer containerCustomizer(
            @Value("${keystore.file}") String keystoreFile,
            @Value("${server.port}") final String serverPort,
            @Value("${keystore.pass}") final String keystorePass)
            throws Exception {

        // This is boiler plate code to setup https on embedded Tomcat
        // with Spring Boot:

        final String absoluteKeystoreFile = new File(keystoreFile)
                .getAbsolutePath();

        return new EmbeddedServletContainerCustomizer() {
            @Override
            public void customize(ConfigurableEmbeddedServletContainer container) {
                TomcatEmbeddedServletContainerFactory tomcat = (TomcatEmbeddedServletContainerFactory) container;
                tomcat.addConnectorCustomizers(connector -> {
                    connector.setPort(Integer.parseInt(serverPort));
                    connector.setSecure(true);
                    connector.setScheme("https");

                    Http11NioProtocol proto = (Http11NioProtocol) connector
                            .getProtocolHandler();
                    proto.setSSLEnabled(true);

                    proto.setKeystoreFile(absoluteKeystoreFile);
                    proto.setKeystorePass(keystorePass);
                    proto.setKeystoreType("JKS");
                    proto.setKeyAlias("tomcat");
                });
            }
        };
    }
}
--------------------------------------------------------------------------------------------------------
import com.fasterxml.jackson.databind.ObjectMapper;
import com.futureprocessing.spring.api.ApiController;
import com.google.common.base.Optional;
import com.google.common.base.Strings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.InternalAuthenticationServiceException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.authentication.encoding.MessageDigestPasswordEncoder;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken;
import org.springframework.web.filter.GenericFilterBean;
import org.springframework.web.util.UrlPathHelper;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class AuthenticationFilter extends GenericFilterBean {

    private final static Logger logger = LoggerFactory.getLogger(AuthenticationFilter.class);
    public static final String TOKEN_SESSION_KEY = "token";
    public static final String USER_SESSION_KEY = "user";
    private AuthenticationManager authenticationManager;

    public AuthenticationFilter(AuthenticationManager authenticationManager) {
        this.authenticationManager = authenticationManager;
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest httpRequest = asHttp(request);
        HttpServletResponse httpResponse = asHttp(response);

        Optional<String> username = Optional.fromNullable(httpRequest.getHeader("X-Auth-Username"));
        Optional<String> password = Optional.fromNullable(httpRequest.getHeader("X-Auth-Password"));
        Optional<String> token = Optional.fromNullable(httpRequest.getHeader("X-Auth-Token"));

        String resourcePath = new UrlPathHelper().getPathWithinApplication(httpRequest);

        try {
            if (postToAuthenticate(httpRequest, resourcePath)) {
                logger.debug("Trying to authenticate user {} by X-Auth-Username method", username);
                processUsernamePasswordAuthentication(httpResponse, username, password);
                return;
            }

            if (token.isPresent()) {
                logger.debug("Trying to authenticate user by X-Auth-Token method. Token: {}", token);
                processTokenAuthentication(token);
            }

            logger.debug("AuthenticationFilter is passing request down the filter chain");
            addSessionContextToLogging();
            chain.doFilter(request, response);
        } catch (InternalAuthenticationServiceException internalAuthenticationServiceException) {
            SecurityContextHolder.clearContext();
            logger.error("Internal authentication service exception", internalAuthenticationServiceException);
            httpResponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        } catch (AuthenticationException authenticationException) {
            SecurityContextHolder.clearContext();
            httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, authenticationException.getMessage());
        } finally {
            MDC.remove(TOKEN_SESSION_KEY);
            MDC.remove(USER_SESSION_KEY);
        }
    }

    private void addSessionContextToLogging() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String tokenValue = "EMPTY";
        if (authentication != null && !Strings.isNullOrEmpty(authentication.getDetails().toString())) {
            MessageDigestPasswordEncoder encoder = new MessageDigestPasswordEncoder("SHA-1");
            tokenValue = encoder.encodePassword(authentication.getDetails().toString(), "not_so_random_salt");
        }
        MDC.put(TOKEN_SESSION_KEY, tokenValue);

        String userValue = "EMPTY";
        if (authentication != null && !Strings.isNullOrEmpty(authentication.getPrincipal().toString())) {
            userValue = authentication.getPrincipal().toString();
        }
        MDC.put(USER_SESSION_KEY, userValue);
    }

    private HttpServletRequest asHttp(ServletRequest request) {
        return (HttpServletRequest) request;
    }

    private HttpServletResponse asHttp(ServletResponse response) {
        return (HttpServletResponse) response;
    }

    private boolean postToAuthenticate(HttpServletRequest httpRequest, String resourcePath) {
        return ApiController.AUTHENTICATE_URL.equalsIgnoreCase(resourcePath) && httpRequest.getMethod().equals("POST");
    }

    private void processUsernamePasswordAuthentication(HttpServletResponse httpResponse, Optional<String> username, Optional<String> password) throws IOException {
        Authentication resultOfAuthentication = tryToAuthenticateWithUsernameAndPassword(username, password);
        SecurityContextHolder.getContext().setAuthentication(resultOfAuthentication);
        httpResponse.setStatus(HttpServletResponse.SC_OK);
        TokenResponse tokenResponse = new TokenResponse(resultOfAuthentication.getDetails().toString());
        String tokenJsonResponse = new ObjectMapper().writeValueAsString(tokenResponse);
        httpResponse.addHeader("Content-Type", "application/json");
        httpResponse.getWriter().print(tokenJsonResponse);
    }

    private Authentication tryToAuthenticateWithUsernameAndPassword(Optional<String> username, Optional<String> password) {
        UsernamePasswordAuthenticationToken requestAuthentication = new UsernamePasswordAuthenticationToken(username, password);
        return tryToAuthenticate(requestAuthentication);
    }

    private void processTokenAuthentication(Optional<String> token) {
        Authentication resultOfAuthentication = tryToAuthenticateWithToken(token);
        SecurityContextHolder.getContext().setAuthentication(resultOfAuthentication);
    }

    private Authentication tryToAuthenticateWithToken(Optional<String> token) {
        PreAuthenticatedAuthenticationToken requestAuthentication = new PreAuthenticatedAuthenticationToken(token, null);
        return tryToAuthenticate(requestAuthentication);
    }

    private Authentication tryToAuthenticate(Authentication requestAuthentication) {
        Authentication responseAuthentication = authenticationManager.authenticate(requestAuthentication);
        if (responseAuthentication == null || !responseAuthentication.isAuthenticated()) {
            throw new InternalAuthenticationServiceException("Unable to authenticate Domain User for provided credentials");
        }
        logger.debug("User successfully authenticated");
        return responseAuthentication;
    }
}
--------------------------------------------------------------------------------------------------------
import com.futureprocessing.spring.api.ApiController;
import com.google.common.base.Optional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.InternalAuthenticationServiceException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.GenericFilterBean;
import org.springframework.web.util.UrlPathHelper;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashSet;
import java.util.Set;

public class ManagementEndpointAuthenticationFilter extends GenericFilterBean {

    private final static Logger logger = LoggerFactory.getLogger(ManagementEndpointAuthenticationFilter.class);
    private AuthenticationManager authenticationManager;
    private Set<String> managementEndpoints;

    public ManagementEndpointAuthenticationFilter(AuthenticationManager authenticationManager) {
        this.authenticationManager = authenticationManager;
        prepareManagementEndpointsSet();
    }

    private void prepareManagementEndpointsSet() {
        managementEndpoints = new HashSet<>();
        managementEndpoints.add(ApiController.AUTOCONFIG_ENDPOINT);
        managementEndpoints.add(ApiController.BEANS_ENDPOINT);
        managementEndpoints.add(ApiController.CONFIGPROPS_ENDPOINT);
        managementEndpoints.add(ApiController.ENV_ENDPOINT);
        managementEndpoints.add(ApiController.MAPPINGS_ENDPOINT);
        managementEndpoints.add(ApiController.METRICS_ENDPOINT);
        managementEndpoints.add(ApiController.SHUTDOWN_ENDPOINT);
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest httpRequest = asHttp(request);
        HttpServletResponse httpResponse = asHttp(response);

        Optional<String> username = Optional.fromNullable(httpRequest.getHeader("X-Auth-Username"));
        Optional<String> password = Optional.fromNullable(httpRequest.getHeader("X-Auth-Password"));

        String resourcePath = new UrlPathHelper().getPathWithinApplication(httpRequest);

        try {
            if (postToManagementEndpoints(resourcePath)) {
                logger.debug("Trying to authenticate user {} for management endpoint by X-Auth-Username method", username);
                processManagementEndpointUsernamePasswordAuthentication(username, password);
            }

            logger.debug("ManagementEndpointAuthenticationFilter is passing request down the filter chain");
            chain.doFilter(request, response);
        } catch (AuthenticationException authenticationException) {
            SecurityContextHolder.clearContext();
            httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, authenticationException.getMessage());
        }
    }

    private HttpServletRequest asHttp(ServletRequest request) {
        return (HttpServletRequest) request;
    }

    private HttpServletResponse asHttp(ServletResponse response) {
        return (HttpServletResponse) response;
    }

    private boolean postToManagementEndpoints(String resourcePath) {
        return managementEndpoints.contains(resourcePath);
    }

    private void processManagementEndpointUsernamePasswordAuthentication(Optional<String> username, Optional<String> password) throws IOException {
        Authentication resultOfAuthentication = tryToAuthenticateWithUsernameAndPassword(username, password);
        SecurityContextHolder.getContext().setAuthentication(resultOfAuthentication);
    }

    private Authentication tryToAuthenticateWithUsernameAndPassword(Optional<String> username, Optional<String> password) {
        BackendAdminUsernamePasswordAuthenticationToken requestAuthentication = new BackendAdminUsernamePasswordAuthenticationToken(username, password);
        return tryToAuthenticate(requestAuthentication);
    }

    private Authentication tryToAuthenticate(Authentication requestAuthentication) {
        Authentication responseAuthentication = authenticationManager.authenticate(requestAuthentication);
        if (responseAuthentication == null || !responseAuthentication.isAuthenticated()) {
            throw new InternalAuthenticationServiceException("Unable to authenticate Backend Admin for provided credentials");
        }
        logger.debug("Backend Admin successfully authenticated");
        return responseAuthentication;
    }
}
--------------------------------------------------------------------------------------------------------
    private String[] actuatorEndpoints() {
        return new String[]{ApiController.AUTOCONFIG_ENDPOINT, ApiController.BEANS_ENDPOINT, ApiController.CONFIGPROPS_ENDPOINT,
                ApiController.ENV_ENDPOINT, ApiController.MAPPINGS_ENDPOINT,
                ApiController.METRICS_ENDPOINT, ApiController.SHUTDOWN_ENDPOINT};
    }
	antMatchers(actuatorEndpoints()).hasRole(backendAdminRole).
--------------------------------------------------------------------------------------------------------
import com.futureprocessing.spring.api.ApiController;
import com.futureprocessing.spring.infrastructure.externalwebservice.SomeExternalServiceAuthenticator;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.annotation.web.servlet.configuration.EnableWebMvcSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;

import javax.servlet.http.HttpServletResponse;

@Configuration
@EnableWebMvcSecurity
@EnableScheduling
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Value("${backend.admin.role}")
    private String backendAdminRole;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.
                csrf().disable().
                sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).
                and().
                authorizeRequests().
                antMatchers(actuatorEndpoints()).hasRole(backendAdminRole).
                anyRequest().authenticated().
                and().
                anonymous().disable().
                exceptionHandling().authenticationEntryPoint(unauthorizedEntryPoint());

        http.addFilterBefore(new AuthenticationFilter(authenticationManager()), BasicAuthenticationFilter.class).
                addFilterBefore(new ManagementEndpointAuthenticationFilter(authenticationManager()), BasicAuthenticationFilter.class);
    }

    private String[] actuatorEndpoints() {
        return new String[]{ApiController.AUTOCONFIG_ENDPOINT, ApiController.BEANS_ENDPOINT, ApiController.CONFIGPROPS_ENDPOINT,
                ApiController.ENV_ENDPOINT, ApiController.MAPPINGS_ENDPOINT,
                ApiController.METRICS_ENDPOINT, ApiController.SHUTDOWN_ENDPOINT};
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(domainUsernamePasswordAuthenticationProvider()).
                authenticationProvider(backendAdminUsernamePasswordAuthenticationProvider()).
                authenticationProvider(tokenAuthenticationProvider());
    }

    @Bean
    public TokenService tokenService() {
        return new TokenService();
    }

    @Bean
    public ExternalServiceAuthenticator someExternalServiceAuthenticator() {
        return new SomeExternalServiceAuthenticator();
    }

    @Bean
    public AuthenticationProvider domainUsernamePasswordAuthenticationProvider() {
        return new DomainUsernamePasswordAuthenticationProvider(tokenService(), someExternalServiceAuthenticator());
    }

    @Bean
    public AuthenticationProvider backendAdminUsernamePasswordAuthenticationProvider() {
        return new BackendAdminUsernamePasswordAuthenticationProvider();
    }

    @Bean
    public AuthenticationProvider tokenAuthenticationProvider() {
        return new TokenAuthenticationProvider(tokenService());
    }

    @Bean
    public AuthenticationEntryPoint unauthorizedEntryPoint() {
        return (request, response, authException) -> response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    }
}
--------------------------------------------------------------------------------------------------------
jdbc:h2:mem:%s;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
jdbc:derby:memory:%s;create=true
jdbc:hsqldb:mem:%s
--------------------------------------------------------------------------------------------------------import org.springframework.cloud.gateway.handler.predicate.AfterRoutePredicateFactory;
import org.springframework.cloud.gateway.handler.predicate.BeforeRoutePredicateFactory;
import org.springframework.cloud.gateway.handler.predicate.BetweenRoutePredicateFactory;
import org.springframework.cloud.gateway.handler.predicate.CookieRoutePredicateFactory;
import org.springframework.cloud.gateway.handler.predicate.HeaderRoutePredicateFactory;
import org.springframework.cloud.gateway.handler.predicate.HostRoutePredicateFactory;
import org.springframework.cloud.gateway.handler.predicate.MethodRoutePredicateFactory;
import org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory;
import org.springframework.cloud.gateway.handler.predicate.QueryRoutePredicateFactory;
import org.springframework.cloud.gateway.handler.predicate.RemoteAddrRoutePredicateFactory;
import org.springframework.cloud.gateway.route.Route;
import org.springframework.http.HttpMethod;
import org.springframework.web.server.ServerWebExchange;

import java.time.ZonedDateTime;
import java.util.function.Predicate;

public class PredicateSpec extends UriSpec {

	PredicateSpec(Route.Builder routeBuilder, RouteLocatorBuilder.Builder builder) {
		super(routeBuilder, builder);
	}

	public PredicateSpec order(int order) {
		this.routeBuilder.order(order);
		return this;
	}

	public BooleanSpec predicate(Predicate<ServerWebExchange> predicate) {
		this.routeBuilder.predicate(predicate);
		return createBooleanSpec();
	}

	protected BooleanSpec createBooleanSpec() {
		return new BooleanSpec(this.routeBuilder, this.builder);
	}

	public BooleanSpec after(ZonedDateTime datetime) {
		return predicate(getBean(AfterRoutePredicateFactory.class).apply(datetime));
	}

	public BooleanSpec before(ZonedDateTime datetime) {
		return predicate(getBean(BeforeRoutePredicateFactory.class).apply(datetime));
	}

	public BooleanSpec between(ZonedDateTime datetime1, ZonedDateTime datetime2) {
		return predicate(getBean(BetweenRoutePredicateFactory.class).apply(datetime1, datetime2));
	}

	public BooleanSpec cookie(String name, String regex) {
		return predicate(getBean(CookieRoutePredicateFactory.class).apply(name, regex));
	}

	public BooleanSpec header(String header, String regex) {
		return predicate(getBean(HeaderRoutePredicateFactory.class).apply(header, regex));
	}

	public BooleanSpec host(String pattern) {
		return predicate(getBean(HostRoutePredicateFactory.class).apply(pattern));
	}

	public BooleanSpec method(String method) {
		return predicate(getBean(MethodRoutePredicateFactory.class).apply(method));
	}

	public BooleanSpec method(HttpMethod method) {
		return predicate(getBean(MethodRoutePredicateFactory.class).apply(method));
	}

	public BooleanSpec path(String pattern) {
		return predicate(getBean(PathRoutePredicateFactory.class).apply(pattern));
	}

	public BooleanSpec query(String param, String regex) {
		return predicate(getBean(QueryRoutePredicateFactory.class).apply(param, regex));
	}

	public BooleanSpec query(String param) {
		return predicate(getBean(QueryRoutePredicateFactory.class).apply(param, null));
	}

	public BooleanSpec remoteAddr(String... addrs) {
		return predicate(getBean(RemoteAddrRoutePredicateFactory.class).apply(addrs));
	}

	public BooleanSpec alwaysTrue() {
		return predicate(exchange -> true);
	}
}

import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.cloud.gateway.config.GatewayAutoConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.DispatcherHandler;

/**
 * @author Spencer Gibb
 */
@Configuration
@ConditionalOnProperty(name = "spring.cloud.gateway.enabled", matchIfMissing = true)
@AutoConfigureBefore(GatewayAutoConfiguration.class)
@ConditionalOnClass({DispatcherHandler.class, DiscoveryClient.class})
public class GatewayDiscoveryClientAutoConfiguration {

	@Bean
	@ConditionalOnBean(DiscoveryClient.class)
	@ConditionalOnProperty(name = "spring.cloud.gateway.discovery.locator.enabled")
	public DiscoveryClientRouteDefinitionLocator discoveryClientRouteDefinitionLocator(DiscoveryClient discoveryClient) {
		return new DiscoveryClientRouteDefinitionLocator(discoveryClient);
	}

}
--------------------------------------------------------------------------------------------------------
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * A class that performs some subnet calculations given a network address and a subnet mask.
 * See original from commons-net org.apache.commons.net.util.SubnetUtils
 * @see "http://www.faqs.org/rfcs/rfc1519.html"
 */
@SuppressWarnings("unused")
public class SubnetUtils {

	private static final String IP_ADDRESS = "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})";
	private static final String SLASH_FORMAT = IP_ADDRESS + "/(\\d{1,3})";
	private static final Pattern addressPattern = Pattern.compile(IP_ADDRESS);
	private static final Pattern cidrPattern = Pattern.compile(SLASH_FORMAT);
	private static final int NBITS = 32;

	private int netmask = 0;
	private int address = 0;
	private int network = 0;
	private int broadcast = 0;

	/** Whether the broadcast/network address are included in host count */
	private boolean inclusiveHostCount = false;


	/**
	 * Constructor that takes a CIDR-notation string, e.g. "192.168.0.1/16"
	 * @param cidrNotation A CIDR-notation string, e.g. "192.168.0.1/16"
	 * @throws IllegalArgumentException if the parameter is invalid,
	 * i.e. does not match n.n.n.n/m where n=1-3 decimal digits, m = 1-3 decimal digits in range 1-32
	 */
	public SubnetUtils(String cidrNotation) {
		calculate(cidrNotation);
	}

	/**
	 * Constructor that takes a dotted decimal address and a dotted decimal mask.
	 * @param address An IP address, e.g. "192.168.0.1"
	 * @param mask A dotted decimal netmask e.g. "255.255.0.0"
	 * @throws IllegalArgumentException if the address or mask is invalid,
	 * i.e. does not match n.n.n.n where n=1-3 decimal digits and the mask is not all zeros
	 */
	public SubnetUtils(String address, String mask) {
		calculate(toCidrNotation(address, mask));
	}


	/**
	 * Returns <code>true</code> if the return value of {@link SubnetInfo#getAddressCount()}
	 * includes the network and broadcast addresses.
	 * @since 2.2
	 * @return true if the hostcount includes the network and broadcast addresses
	 */
	public boolean isInclusiveHostCount() {
		return inclusiveHostCount;
	}

	/**
	 * Set to <code>true</code> if you want the return value of {@link SubnetInfo#getAddressCount()}
	 * to include the network and broadcast addresses.
	 * @param inclusiveHostCount true if network and broadcast addresses are to be included
	 * @since 2.2
	 */
	public void setInclusiveHostCount(boolean inclusiveHostCount) {
		this.inclusiveHostCount = inclusiveHostCount;
	}



	/**
	 * Convenience container for subnet summary information.
	 *
	 */
	public final class SubnetInfo {
		/* Mask to convert unsigned int to a long (i.e. keep 32 bits) */
		private static final long UNSIGNED_INT_MASK = 0x0FFFFFFFFL;

		private SubnetInfo() {}

		private int netmask()       { return netmask; }
		private int network()       { return network; }
		private int address()       { return address; }
		private int broadcast()     { return broadcast; }

		// long versions of the values (as unsigned int) which are more suitable for range checking
		private long networkLong()  { return network &  UNSIGNED_INT_MASK; }
		private long broadcastLong(){ return broadcast &  UNSIGNED_INT_MASK; }

		private int low() {
			return (isInclusiveHostCount() ? network() :
					broadcastLong() - networkLong() > 1 ? network() + 1 : 0);
		}

		private int high() {
			return (isInclusiveHostCount() ? broadcast() :
					broadcastLong() - networkLong() > 1 ? broadcast() -1  : 0);
		}

		/**
		 * Returns true if the parameter <code>address</code> is in the
		 * range of usable endpoint addresses for this subnet. This excludes the
		 * network and broadcast adresses.
		 * @param address A dot-delimited IPv4 address, e.g. "192.168.0.1"
		 * @return True if in range, false otherwise
		 */
		public boolean isInRange(String address) {
			return isInRange(toInteger(address));
		}

		/**
		 *
		 * @param address the address to check
		 * @return true if it is in range
		 * @since 3.4 (made public)
		 */
		public boolean isInRange(int address) {
			long addLong = address & UNSIGNED_INT_MASK;
			long lowLong = low() & UNSIGNED_INT_MASK;
			long highLong = high() & UNSIGNED_INT_MASK;
			return addLong >= lowLong && addLong <= highLong;
		}

		public String getBroadcastAddress() {
			return format(toArray(broadcast()));
		}

		public String getNetworkAddress() {
			return format(toArray(network()));
		}

		public String getNetmask() {
			return format(toArray(netmask()));
		}

		public String getAddress() {
			return format(toArray(address()));
		}

		/**
		 * Return the low address as a dotted IP address.
		 * Will be zero for CIDR/31 and CIDR/32 if the inclusive flag is false.
		 *
		 * @return the IP address in dotted format, may be "0.0.0.0" if there is no valid address
		 */
		public String getLowAddress() {
			return format(toArray(low()));
		}

		/**
		 * Return the high address as a dotted IP address.
		 * Will be zero for CIDR/31 and CIDR/32 if the inclusive flag is false.
		 *
		 * @return the IP address in dotted format, may be "0.0.0.0" if there is no valid address
		 */
		public String getHighAddress() {
			return format(toArray(high()));
		}

		/**
		 * Get the count of available addresses.
		 * Will be zero for CIDR/31 and CIDR/32 if the inclusive flag is false.
		 * @return the count of addresses, may be zero.
		 * @throws RuntimeException if the correct count is greater than {@code Integer.MAX_VALUE}
		 * @deprecated (3.4) use {@link #getAddressCountLong()} instead
		 */
		@Deprecated
		public int getAddressCount() {
			long countLong = getAddressCountLong();
			if (countLong > Integer.MAX_VALUE) {
				throw new RuntimeException("Count is larger than an integer: " + countLong);
			}
			// N.B. cannot be negative
			return (int)countLong;
		}

		/**
		 * Get the count of available addresses.
		 * Will be zero for CIDR/31 and CIDR/32 if the inclusive flag is false.
		 * @return the count of addresses, may be zero.
		 * @since 3.4
		 */
		public long getAddressCountLong() {
			long b = broadcastLong();
			long n = networkLong();
			long count = b - n + (isInclusiveHostCount() ? 1 : -1);
			return count < 0 ? 0 : count;
		}

		public int asInteger(String address) {
			return toInteger(address);
		}

		public String getCidrSignature() {
			return toCidrNotation(
					format(toArray(address())),
					format(toArray(netmask()))
			);
		}

		public String[] getAllAddresses() {
			int ct = getAddressCount();
			String[] addresses = new String[ct];
			if (ct == 0) {
				return addresses;
			}
			for (int add = low(), j=0; add <= high(); ++add, ++j) {
				addresses[j] = format(toArray(add));
			}
			return addresses;
		}

		/**
		 * {@inheritDoc}
		 * @since 2.2
		 */
		@Override
		public String toString() {
			final StringBuilder buf = new StringBuilder();
			buf.append("CIDR Signature:\t[").append(getCidrSignature()).append("]")
					.append(" Netmask: [").append(getNetmask()).append("]\n")
					.append("Network:\t[").append(getNetworkAddress()).append("]\n")
					.append("Broadcast:\t[").append(getBroadcastAddress()).append("]\n")
					.append("First Address:\t[").append(getLowAddress()).append("]\n")
					.append("Last Address:\t[").append(getHighAddress()).append("]\n")
					.append("# Addresses:\t[").append(getAddressCount()).append("]\n");
			return buf.toString();
		}
	}

	/**
	 * Return a {@link SubnetInfo} instance that contains subnet-specific statistics
	 * @return new instance
	 */
	public final SubnetInfo getInfo() { return new SubnetInfo(); }

	/*
	 * Initialize the internal fields from the supplied CIDR mask
	 */
	private void calculate(String mask) {
		Matcher matcher = cidrPattern.matcher(mask);

		if (matcher.matches()) {
			address = matchAddress(matcher);

            /* Create a binary netmask from the number of bits specification /x */
			int cidrPart = rangeCheck(Integer.parseInt(matcher.group(5)), 0, NBITS);
			for (int j = 0; j < cidrPart; ++j) {
				netmask |= (1 << 31 - j);
			}

            /* Calculate base network address */
			network = (address & netmask);

            /* Calculate broadcast address */
			broadcast = network | ~(netmask);
		} else {
			throw new IllegalArgumentException("Could not parse [" + mask + "]");
		}
	}

	/*
	 * Convert a dotted decimal format address to a packed integer format
	 */
	private int toInteger(String address) {
		Matcher matcher = addressPattern.matcher(address);
		if (matcher.matches()) {
			return matchAddress(matcher);
		} else {
			throw new IllegalArgumentException("Could not parse [" + address + "]");
		}
	}

	/*
	 * Convenience method to extract the components of a dotted decimal address and
	 * pack into an integer using a regex match
	 */
	private int matchAddress(Matcher matcher) {
		int addr = 0;
		for (int i = 1; i <= 4; ++i) {
			int n = (rangeCheck(Integer.parseInt(matcher.group(i)), 0, 255));
			addr |= ((n & 0xff) << 8*(4-i));
		}
		return addr;
	}

	/*
	 * Convert a packed integer address into a 4-element array
	 */
	private int[] toArray(int val) {
		int ret[] = new int[4];
		for (int j = 3; j >= 0; --j) {
			ret[j] |= ((val >>> 8*(3-j)) & (0xff));
		}
		return ret;
	}

	/*
	 * Convert a 4-element array into dotted decimal format
	 */
	private String format(int[] octets) {
		StringBuilder str = new StringBuilder();
		for (int i =0; i < octets.length; ++i){
			str.append(octets[i]);
			if (i != octets.length - 1) {
				str.append(".");
			}
		}
		return str.toString();
	}

	/*
	 * Convenience function to check integer boundaries.
	 * Checks if a value x is in the range [begin,end].
	 * Returns x if it is in range, throws an exception otherwise.
	 */
	private int rangeCheck(int value, int begin, int end) {
		if (value >= begin && value <= end) { // (begin,end]
			return value;
		}

		throw new IllegalArgumentException("Value [" + value + "] not in range ["+begin+","+end+"]");
	}

	/*
	 * Count the number of 1-bits in a 32-bit integer using a divide-and-conquer strategy
	 * see Hacker's Delight section 5.1
	 */
	int pop(int x) {
		x = x - ((x >>> 1) & 0x55555555);
		x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);
		x = (x + (x >>> 4)) & 0x0F0F0F0F;
		x = x + (x >>> 8);
		x = x + (x >>> 16);
		return x & 0x0000003F;
	}

	/* Convert two dotted decimal addresses to a single xxx.xxx.xxx.xxx/yy format
	 * by counting the 1-bit population in the mask address. (It may be better to count
	 * NBITS-#trailing zeroes for this case)
	 */
	private String toCidrNotation(String addr, String mask) {
		return addr + "/" + pop(toInteger(mask));
	}
}
--------------------------------------------------------------------------------------------------------
import java.util.List;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.AutoConfigureAfter;
import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration;
import org.springframework.cloud.gateway.filter.ratelimit.RedisRateLimiter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.data.redis.connection.ReactiveRedisConnectionFactory;
import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.data.redis.core.script.RedisScript;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;
import org.springframework.scripting.support.ResourceScriptSource;
import org.springframework.web.reactive.DispatcherHandler;

@Configuration
@AutoConfigureAfter(RedisReactiveAutoConfiguration.class)
@AutoConfigureBefore(GatewayAutoConfiguration.class)
@ConditionalOnBean(ReactiveRedisTemplate.class)
@ConditionalOnClass({RedisTemplate.class, DispatcherHandler.class})
class GatewayRedisAutoConfiguration {

	@Bean
	@SuppressWarnings("unchecked")
	public RedisScript redisRequestRateLimiterScript() {
		DefaultRedisScript redisScript = new DefaultRedisScript<>();
		redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource("META-INF/scripts/request_rate_limiter.lua")));
		redisScript.setResultType(List.class);
		return redisScript;
	}

	@Bean
	//TODO: replace with ReactiveStringRedisTemplate in future
	public ReactiveRedisTemplate<String, String> stringReactiveRedisTemplate(
			ReactiveRedisConnectionFactory reactiveRedisConnectionFactory,
			ResourceLoader resourceLoader) {
		RedisSerializer<String> serializer = new StringRedisSerializer();
		RedisSerializationContext<String , String> serializationContext = RedisSerializationContext
				.<String, String>newSerializationContext()
				.key(serializer)
				.value(serializer)
				.hashKey(serializer)
				.hashValue(serializer)
				.build();
		return new ReactiveRedisTemplate<>(reactiveRedisConnectionFactory,
				serializationContext);
	}

	@Bean
	public RedisRateLimiter redisRateLimiter(ReactiveRedisTemplate<String, String> redisTemplate,
											 @Qualifier("redisRequestRateLimiterScript") RedisScript<List<Long>> redisScript) {
		return new RedisRateLimiter(redisTemplate, redisScript);
	}
}
--------------------------------------------------------------------------------------------------------
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.Ordered;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.web.reactive.function.BodyExtractors;
import org.springframework.web.reactive.function.client.ClientResponse;
import org.springframework.web.server.ServerWebExchange;

import static org.springframework.cloud.gateway.support.ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR;

import reactor.core.publisher.Mono;

/**
 * @author Spencer Gibb
 */
public class WebClientWriteResponseFilter implements GlobalFilter, Ordered {

	private static final Log log = LogFactory.getLog(WebClientWriteResponseFilter.class);

	public static final int WRITE_RESPONSE_FILTER_ORDER = -1;

	@Override
	public int getOrder() {
		return WRITE_RESPONSE_FILTER_ORDER;
	}

	@Override
	public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
		// NOTICE: nothing in "pre" filter stage as CLIENT_RESPONSE_ATTR is not added
		// until the WebHandler is run
		return chain.filter(exchange).then(Mono.defer(() -> {
			ClientResponse clientResponse = exchange.getAttribute(CLIENT_RESPONSE_ATTR);
			if (clientResponse == null) {
				return Mono.empty();
			}
			log.trace("WebClientWriteResponseFilter start");
			ServerHttpResponse response = exchange.getResponse();

			return response.writeWith(clientResponse.body(BodyExtractors.toDataBuffers())).log("webClient response");
		}));
	}

}
--------------------------------------------------------------------------------------------------------
import java.net.URI;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.cloud.gateway.route.Route;
import org.springframework.core.Ordered;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.util.UriComponentsBuilder;

import static org.springframework.cloud.gateway.support.ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR;
import static org.springframework.cloud.gateway.support.ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR;
import static org.springframework.cloud.gateway.support.ServerWebExchangeUtils.containsEncodedQuery;

import reactor.core.publisher.Mono;

/**
 * @author Spencer Gibb
 */
public class RouteToRequestUrlFilter implements GlobalFilter, Ordered {

	private static final Log log = LogFactory.getLog(RouteToRequestUrlFilter.class);
	public static final int ROUTE_TO_URL_FILTER_ORDER = 10000;

	@Override
	public int getOrder() {
		return ROUTE_TO_URL_FILTER_ORDER;
	}

	@Override
	public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
		Route route = exchange.getAttribute(GATEWAY_ROUTE_ATTR);
		if (route == null) {
			return chain.filter(exchange);
		}
		log.trace("RouteToRequestUrlFilter start");
		URI uri = exchange.getRequest().getURI();
		boolean encoded = containsEncodedQuery(uri);
		URI requestUrl = UriComponentsBuilder.fromUri(uri)
				.uri(route.getUri())
				.build(encoded)
				.toUri();
		exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, requestUrl);
		return chain.filter(exchange);
	}

}
--------------------------------------------------------------------------------------------------------
import org.junit.ClassRule;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;
import org.junit.runners.model.Statement;
import org.springframework.cloud.gateway.filter.RemoveHopByHopHeadersFilterTests;
import org.springframework.cloud.gateway.filter.factory.AddRequestHeaderGatewayFilterFactoryTests;
import org.springframework.cloud.gateway.filter.factory.AddRequestParameterGatewayFilterFactoryTests;
import org.springframework.cloud.gateway.filter.factory.HystrixGatewayFilterFactoryTests;
import org.springframework.cloud.gateway.filter.factory.PreserveHostHeaderGatewayFilterFactoryTests;
import org.springframework.cloud.gateway.filter.factory.RedirectToGatewayFilterFactoryTests;
import org.springframework.cloud.gateway.filter.factory.RemoveNonProxyHeadersGatewayFilterFactoryTests;
import org.springframework.cloud.gateway.filter.factory.RemoveRequestHeaderGatewayFilterFactoryTests;
import org.springframework.cloud.gateway.filter.factory.RemoveResponseHeaderGatewayFilterFactoryTests;
import org.springframework.cloud.gateway.filter.factory.RequestRateLimiterGatewayFilterFactoryTests;
import org.springframework.cloud.gateway.filter.factory.RewritePathGatewayFilterFactoryIntegrationTests;
import org.springframework.cloud.gateway.filter.factory.RewritePathGatewayFilterFactoryTests;
import org.springframework.cloud.gateway.filter.factory.SecureHeadersGatewayFilterFactoryTests;
import org.springframework.cloud.gateway.filter.factory.SetPathGatewayFilterFactoryIntegrationTests;
import org.springframework.cloud.gateway.filter.factory.SetPathGatewayFilterFactoryTests;
import org.springframework.cloud.gateway.filter.factory.SetResponseGatewayFilterFactoryTests;
import org.springframework.cloud.gateway.filter.factory.SetStatusGatewayFilterFactoryTests;
import org.springframework.cloud.gateway.filter.ratelimit.PrincipalNameKeyResolverIntegrationTests;
import org.springframework.cloud.gateway.filter.ratelimit.RedisRateLimiterTests;
import org.springframework.cloud.gateway.handler.predicate.AfterRoutePredicateFactoryTests;
import org.springframework.cloud.gateway.handler.predicate.BeforeRoutePredicateFactoryTests;
import org.springframework.cloud.gateway.handler.predicate.BetweenRoutePredicateFactoryTests;
import org.springframework.cloud.gateway.handler.predicate.HostRoutePredicateFactoryTests;
import org.springframework.cloud.gateway.handler.predicate.MethodRoutePredicateFactoryTests;
import org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactoryTests;
import org.springframework.cloud.gateway.route.RouteDefinitionRouteLocatorTests;
import org.springframework.cloud.gateway.test.websocket.WebSocketIntegrationTests;

import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.is;
import static org.junit.Assume.assumeThat;

/**
 * To run this suite in an IDE, set env var GATEWAY_ADHOC_ENABLED=true in test runner.
 * @author Spencer Gibb
 */
@RunWith(Suite.class)
@SuiteClasses({
		WebfluxNotIncludedTests.class,
		GatewayIntegrationTests.class,
		FormIntegrationTests.class,
		HttpStatusTests.class,
		PostTests.class,
		ForwardTests.class,
		WebSocketIntegrationTests.class,
		RemoveHopByHopHeadersFilterTests.class,
		// FilterFactory Tests
		RemoveNonProxyHeadersGatewayFilterFactoryTests.class,
		RemoveResponseHeaderGatewayFilterFactoryTests.class,
		HystrixGatewayFilterFactoryTests.class,
		RewritePathGatewayFilterFactoryIntegrationTests.class,
		RemoveRequestHeaderGatewayFilterFactoryTests.class,
		SetPathGatewayFilterFactoryTests.class,
		RewritePathGatewayFilterFactoryTests.class,
		SetStatusGatewayFilterFactoryTests.class,
		RedirectToGatewayFilterFactoryTests.class,
		AddRequestHeaderGatewayFilterFactoryTests.class,
		SecureHeadersGatewayFilterFactoryTests.class,
		RequestRateLimiterGatewayFilterFactoryTests.class,
		SetPathGatewayFilterFactoryIntegrationTests.class,
		AddRequestParameterGatewayFilterFactoryTests.class,
		SetResponseGatewayFilterFactoryTests.class,
		PrincipalNameKeyResolverIntegrationTests.class,
		RedisRateLimiterTests.class,
		RouteDefinitionRouteLocatorTests.class,
		PreserveHostHeaderGatewayFilterFactoryTests.class,
		// PredicateFactory Tests
		MethodRoutePredicateFactoryTests.class,
		HostRoutePredicateFactoryTests.class,
		AfterRoutePredicateFactoryTests.class,
		PathRoutePredicateFactoryTests.class,
		BetweenRoutePredicateFactoryTests.class,
		BeforeRoutePredicateFactoryTests.class,

})
public class AdhocTestSuite {

	@ClassRule
	public static AdhocEnabled adhocEnabled = new AdhocEnabled();

	static class AdhocEnabled implements TestRule {

		@Override
		public Statement apply(Statement base, Description description) {
			assumeThat("Adhoc Tests ignored",
					System.getenv("GATEWAY_ADHOC_ENABLED"),
					is(equalTo("true")));

			return base;
		}
	}
}
--------------------------------------------------------------------------------------------------------
	static class AdhocEnabled implements TestRule {

		@Override
		public Statement apply(Statement base, Description description) {
			assumeThat("Adhoc Tests ignored",
					System.getenv("GATEWAY_ADHOC_ENABLED"),
					is(equalTo("true")));

			return base;
		}
	}
--------------------------------------------------------------------------------------------------------
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.context.annotation.Import;
import org.springframework.http.HttpHeaders;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.reactive.server.WebTestClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Collections;
import java.util.Map;

import static org.springframework.boot.test.context.SpringBootTest.WebEnvironment.RANDOM_PORT;

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = RANDOM_PORT)
@DirtiesContext
@SuppressWarnings("unchecked")
public class ForwardTests {
	@LocalServerPort
	protected int port = 0;

	protected WebTestClient client;

	@Before
	public void setup() {
		String baseUri = "http://localhost:" + port;
		this.client = WebTestClient.bindToServer()
				.baseUrl(baseUri)
				.build();
	}

	@Test
	public void forwardWorks() {
		this.client.get().uri("/localcontroller")
				.header(HttpHeaders.HOST, "www.forward.org")
				.exchange()
				.expectStatus().isOk()
				.expectBody().json("{\"from\":\"localcontroller\"}");
	}

	@EnableAutoConfiguration
	@SpringBootConfiguration
	@RestController
	@Import(PermitAllSecurityConfiguration.class)
	public static class TestConfig {

		@RequestMapping("/httpbin/localcontroller")
		public Map<String, String> localController() {
			return Collections.singletonMap("from", "localcontroller");
		}
	}
}
--------------------------------------------------------------------------------------------------------
@Retention(RetentionPolicy.RUNTIME)
@JacksonAnnotationsInside
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({"name", "id", "dateCreated"})
public @interface CustomAnnotation {
}
--------------------------------------------------------------------------------------------------------
import com.hantsylabs.restexample.springmvc.domain.User;
import com.hantsylabs.restexample.springmvc.domain.User_;
import java.util.ArrayList;
import java.util.List;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.StringUtils;

/**
 *
 * @author Hantsy Bai<hantsy@gmail.com>
 *
 */
public class UserSpecifications {

    private UserSpecifications() {}

    public static Specification<User> filterUsersByKeyword(
            final String keyword,//
            final String role //
    ) {

        return (Root<User> root, CriteriaQuery<?> query, CriteriaBuilder cb) -> {

            List<Predicate> predicates = new ArrayList<>();

            if (StringUtils.hasText(keyword)) {
                predicates.add(
                        cb.or(
                                cb.like(root.get(User_.name), "%" + keyword + "%"),
                                cb.like(root.get(User_.username), "%" + keyword + "%")
                        ));
            }

            if (StringUtils.hasText(role) && !"ALL".equals(role)) {
                predicates.add(cb.equal(root.get(User_.role), role));
//                ListJoin<User_, String> roleJoin = root.join(User_.roles);
//                predicates.add(cb.equal(roleJoin, role));
            }

//            if (StringUtils.hasText(locked)) {
//                predicates.add(cb.equal(root.get(User_.locked), Boolean.valueOf(locked)));
//            }
            return cb.and(predicates.toArray(new Predicate[predicates.size()]));
        };
    }
}

import com.hantsylabs.restexample.springmvc.domain.Post;
import com.hantsylabs.restexample.springmvc.domain.Post_;
import java.util.ArrayList;
import java.util.List;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.StringUtils;

/**
 *
 * @author Hantsy Bai<hantsy@gmail.com>
 *
 */
public class PostSpecifications {

    private PostSpecifications() {}

    public static Specification<Post> filterByKeywordAndStatus(
            final String keyword,//
            final Post.Status status) {
        return (Root<Post> root, CriteriaQuery<?> query, CriteriaBuilder cb) -> {
            List<Predicate> predicates = new ArrayList<>();
            if (StringUtils.hasText(keyword)) {
                predicates.add(
                        cb.or(cb.like(root.get(Post_.title), "%" + keyword + "%"),
                                cb.like(root.get(Post_.content), "%" + keyword + "%"))
                );
            }

            if (status != null) {
                predicates.add(cb.equal(root.get(Post_.status), status));
            }

            return cb.and(predicates.toArray(new Predicate[predicates.size()]));
        };
    }
}
--------------------------------------------------------------------------------------------------------
#!/bin/bash

# The environment variables are already set up by the Dockerfile
java -Djava.security.egd=file:/dev/urandom -Dspring.profiles.active=docker -jar ${APP_JAR_NAME}-${APP_JAR_VERSION}.jar
--------------------------------------------------------------------------------------------------------
    @RequestMapping(method = RequestMethod.POST)
    public String insertData(ModelMap model, 
                             @ModelAttribute("insertRecord") @Valid Record record,
                             BindingResult result) {
        if (!result.hasErrors()) {
            repository.save(record);
        }
        return home(model);
    }
--------------------------------------------------------------------------------------------------------
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.ImportAutoConfiguration;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.security.oauth2.client.ResourceServerTokenRelayAutoConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.client.OAuth2ClientContext;
import org.springframework.security.oauth2.client.OAuth2RestTemplate;
import org.springframework.security.oauth2.client.resource.OAuth2ProtectedResourceDetails;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;

/**
 * Configuration that sets up the OAuth2 client operation for making calls to
 * the comments-webservice.<br>
 * <br>
 * 
 * We add a {@link HandlerInterceptor} to add the JWT token relayed by the Zuul
 * gateway into the OAuth2RestTemplate. This needs to be added manually to the
 * WebMvc intercepter chain because of an existing bug in Spring boot 1.5.3.
 * 
 * @author anilallewar
 *
 */
@Configuration
@ImportAutoConfiguration(classes = { ResourceServerTokenRelayAutoConfiguration.class })
public class OAuthClientConfiguration extends WebMvcConfigurerAdapter {

	/**
	 * Issues with JWT token not getting relayed by the resource server
	 * {@linkplain https://stackoverflow.com/questions/43566515/spring-security-oauth2-jwt-token-relay-issue}
	 */
	@Autowired
	@Qualifier("tokenRelayRequestInterceptor")
	HandlerInterceptor tokenRelayHandlerInterceptor;

	/**
	 * RestTempate that relays the OAuth2 token passed to the task webservice.
	 * 
	 * @param oauth2ClientContext
	 * @return
	 */
	@Bean
	@LoadBalanced
	public OAuth2RestTemplate restTemplate(OAuth2ProtectedResourceDetails resource, OAuth2ClientContext context) {
		return new OAuth2RestTemplate(resource, context);
	}

	@Override
	public void addInterceptors(InterceptorRegistry registry) {
		registry.addInterceptor(this.tokenRelayHandlerInterceptor);
	}

}
--------------------------------------------------------------------------------------------------------
/**
 * Inner class to perform the de-serialization of the comments array
 * 
 * @author anilallewar
 *
 */
class CommentsCollectionDeserializer extends JsonDeserializer<CommentCollectionResource> {
	@Override
	public CommentCollectionResource deserialize(JsonParser jp, DeserializationContext ctxt)
			throws IOException, JsonProcessingException {
		CommentCollectionResource commentArrayResource = new CommentCollectionResource();
		CommentResource commentResource = null;

		JsonNode jsonNode = jp.readValueAsTree();

		for (JsonNode childNode : jsonNode) {
			if (childNode.has(CommentResource.JP_TASKID)) {
				commentResource = new CommentResource();
				commentResource.setTaskId(childNode.get(CommentResource.JP_TASKID).asText());
				commentResource.setComment(childNode.get(CommentResource.JP_COMMENT).asText());
				commentResource.setPosted(new Date(childNode.get(CommentResource.JP_POSTED).asLong()));

				commentArrayResource.addComment(commentResource);
			}
		}
		return commentArrayResource;

	}
}
--------------------------------------------------------------------------------------------------------
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import org.springframework.security.test.context.support.WithSecurityContext;

/**
 * Annotation to help us setup our own security context
 * @author anilallewar
 *
 */
@Retention(RUNTIME)
@Target(METHOD)
@WithSecurityContext(factory = WithOAuth2MockAccessTokenSecurityContextFactory.class)
public @interface WithMockOAuth2Token {

	// Default OAuth2 scope
	String[] scopes() default { "openid" };

	// Default roles
	String[] authorities() default { "ROLE_ADMIN", "ROLE_USER" };

	// Default user name
	String userName() default "anil";

	// Default password
	String password() default "password";
	
	// Default redirect Url
	String redirectUrl() default "http://localhost:8765";
	
	// Default client id
	String clientId() default "acme";
}

import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mock.web.MockHttpSession;
import org.springframework.security.authentication.TestingAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.oauth2.client.OAuth2ClientContext;
import org.springframework.security.oauth2.common.DefaultOAuth2AccessToken;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.OAuth2Request;
import org.springframework.security.test.context.support.WithSecurityContextFactory;

/**
 * Security context factory that will help us in mocking up the OAuth2 workflow
 * so that we can embed an mock access token in the security context.<br>
 * <br>
 * 
 * @author anilallewar
 *
 */
public class WithOAuth2MockAccessTokenSecurityContextFactory
		implements WithSecurityContextFactory<WithMockOAuth2Token> {

	// Default OAuth2 access token
	private static final String TEST_ACCESS_TOKEN = "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE0OTgwMDA0MDEsInVzZXJfbmFtZSI6ImFuaWwiLCJhdXRob3JpdGllcyI6WyJST0xFX0FETUlOIiwiUk9MRV9VU0VSIl0sImp0aSI6IjkzY2Y3Y2U0LWY2ZDgtNGJkNi04NGE5LWQ4NDViYmEwZGY2ZCIsImNsaWVudF9pZCI6ImFjbWUiLCJzY29wZSI6WyJvcGVuaWQiXX0.NdAHIna-8GCRGmvaDqO5iOGy3gkjaVaAZqXkDvpjKiQqSVrM_1j1xvPBwuy2iWjyD_crkw_zehE_jKfLpcLxw2JLJZPOtLaUeCYs6euUvboOAVKpmg62mi81PgV3tpEBaqSi5MmATtVcerXFf64LgS1ZPnsw8WIogGlqkhziSzOR4yH2tAzY0aIheL7AWxAgxfBe6I7Lej9ld1Fx6xHodIz8TzmSD-wlZ18e40WBpd_0wc7M8VE_uK18f39btM2VS02FxVm9fdxxwwDXzDT-ODJOs0L_NoKHmZx-JF72bjNUmac81ZcH4fU-fVdme5b-oJowFPgfhZZZ4_nKFv71Ww";

	@Autowired
	MockHttpSession session;

	@Override
	public SecurityContext createSecurityContext(WithMockOAuth2Token withMockOAuth2Token) {
		
		SecurityContext context = SecurityContextHolder.createEmptyContext();
		Authentication authentication = this.getOauthTestAuthentication(withMockOAuth2Token);
		context.setAuthentication(authentication);

		this.session.setAttribute("scopedTarget.oauth2ClientContext", this.getOauth2ClientContext());
		return context;
	}

	/**
	 * Create the authentication object that we need to setup in context
	 * 
	 * @param withMockOAuth2Token
	 * @return
	 */
	private Authentication getOauthTestAuthentication(WithMockOAuth2Token withMockOAuth2Token) {
		return new OAuth2Authentication(getOauth2Request(withMockOAuth2Token), getAuthentication(withMockOAuth2Token));
	}

	/**
	 * Mock OAuth2Request
	 * 
	 * @param withMockOAuth2Token
	 * @return
	 */
	private OAuth2Request getOauth2Request(WithMockOAuth2Token withMockOAuth2Token) {
		String clientId = withMockOAuth2Token.clientId();
		Map<String, String> requestParameters = Collections.emptyMap();
		boolean approved = true;
		String redirectUrl = withMockOAuth2Token.redirectUrl();
		Set<String> responseTypes = Collections.emptySet();
		Set<String> scopes = new HashSet<>(Arrays.asList(withMockOAuth2Token.scopes()));
		Set<String> resourceIds = Collections.emptySet();
		Map<String, Serializable> extensionProperties = Collections.emptyMap();
		List<GrantedAuthority> authorities = AuthorityUtils.createAuthorityList(withMockOAuth2Token.authorities());

		OAuth2Request oAuth2Request = new OAuth2Request(requestParameters, clientId, authorities, approved, scopes,
				resourceIds, redirectUrl, responseTypes, extensionProperties);

		return oAuth2Request;
	}

	/**
	 * Provide the mock user information to be used
	 * 
	 * @param withMockOAuth2Token
	 * @return
	 */
	private Authentication getAuthentication(WithMockOAuth2Token withMockOAuth2Token) {
		List<GrantedAuthority> authorities = AuthorityUtils.createAuthorityList(withMockOAuth2Token.authorities());

		User userPrincipal = new User(withMockOAuth2Token.userName(), withMockOAuth2Token.password(), true, true, true,
				true, authorities);

		HashMap<String, String> details = new HashMap<String, String>();
		details.put("user_name", withMockOAuth2Token.userName());
		details.put("email", "anilallewar@yahoo.co.in");
		details.put("name", "Anil Allewar");

		TestingAuthenticationToken token = new TestingAuthenticationToken(userPrincipal, null, authorities);
		token.setAuthenticated(true);
		token.setDetails(details);

		return token;
	}

	/**
	 * Create the mock {@link OAuth2ClientContext} object that will be injected
	 * into the session associated with the request.<br>
	 * <br>
	 * 
	 * Without this object in the session, Spring security will attempt to make
	 * a request to obtain the token if the controller object attempts to use it
	 * (as in our case)
	 * 
	 * @return
	 */
	private OAuth2ClientContext getOauth2ClientContext() {
		OAuth2ClientContext mockClient = mock(OAuth2ClientContext.class);
		when(mockClient.getAccessToken()).thenReturn(new DefaultOAuth2AccessToken(TEST_ACCESS_TOKEN));

		return mockClient;
	}
}
--------------------------------------------------------------------------------------------------------
mport org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.cloud.contract.stubrunner.spring.AutoConfigureStubRunner;
import org.springframework.context.annotation.Import;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.junit4.SpringRunner;

import com.anilallewar.microservices.task.apis.CommentsService;
import com.anilallewar.microservices.task.model.CommentCollectionResource;
import com.anilallewar.microservices.task.oauth2.config.OAuth2ClientTestConfiguration;
import com.anilallewar.microservices.task.oauth2.security.WithMockOAuth2Token;

/**
 * @author anilallewar
 *
 */
@RunWith(SpringRunner.class)
@SpringBootTest(classes = { TaskApplication.class }, webEnvironment = WebEnvironment.MOCK, properties = {
		"spring.cloud.discovery.enabled=false", "spring.cloud.config.enabled=false",
		"stubrunner.idsToServiceIds.basic-comments-webservice-stubs=comments-webservice",
		"spring.zipkin.enabled=false" })
@Import(OAuth2ClientTestConfiguration.class)
@AutoConfigureStubRunner(ids = { "anilallewar:basic-comments-webservice-stubs:+:stubs:9083" }, workOffline = true)
@DirtiesContext
public class CommentsServiceTests {

	@Autowired
	private CommentsService commentsService;

	private static final String TEST_TASK_ID = "task11";
	private static final String REQUEST_TASK_ID = "task12";

	/**
	 * @throws java.lang.Exception
	 */
	@Before
	public void setUp() throws Exception {
	}

	/**
	 * @throws java.lang.Exception
	 */
	@After
	public void tearDown() throws Exception {
	}

	@Test
	@WithMockOAuth2Token(userName = "dave")
	public void testGetCommentsForTask() {
		CommentCollectionResource comments = this.commentsService.getCommentsForTask(REQUEST_TASK_ID);

		Assert.assertEquals(2, comments.getTaskComments().size());
		Assert.assertTrue(comments.getTaskComments().get(0).getTaskId().equals(TEST_TASK_ID));
	}
}

https://www.programcreek.com/java-api-examples/index.php?project_name=anilallewar%2Fmicroservices-basics-spring-boot#
--------------------------------------------------------------------------------------------------------
import com.shawn.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
import org.springframework.security.oauth2.provider.token.DefaultTokenServices;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.InMemoryTokenStore;

/**
 * @author Xiaoyue Xiao
 */
@Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter {

    @Autowired
    private TokenStore tokenStore;

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private UserService userService;

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients
            .inMemory()
                .withClient("client")
                    .authorizedGrantTypes("password", "refresh_token")
                    .scopes("read", "write")
                    .secret("fucksecurity");
    }

    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints
            .tokenStore(tokenStore)
            .authenticationManager(authenticationManager)
            .userDetailsService(userService);
    }

    @Bean
    public TokenStore tokenStore() {
        return new InMemoryTokenStore();
    }

    @Bean
    @Primary
    public DefaultTokenServices tokenServices() {
        DefaultTokenServices tokenServices = new DefaultTokenServices();
        tokenServices.setSupportRefreshToken(true); // support refresh token
        tokenServices.setTokenStore(tokenStore); // use in-memory token store
        return tokenServices;
    }

}
--------------------------------------------------------------------------------------------------------
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(book.getId())
                .toUri();
--------------------------------------------------------------------------------------------------------
        <!-- Spring Security Oauth2 -->
        <dependency>
            <groupId>org.springframework.security.oauth</groupId>
            <artifactId>spring-security-oauth2</artifactId>
        </dependency>
--------------------------------------------------------------------------------------------------------
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.config.server.EnableConfigServer;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableAutoConfiguration
@EnableDiscoveryClient
@EnableConfigServer
public class ConfigServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConfigServiceApplication.class, args);
    }
}
--------------------------------------------------------------------------------------------------------
#!/usr/bin/env sh
set -x

function setup() {
    mkdir -p $(pwd -P)/integration-test/aws-volume
    docker run --rm -ti -v $(pwd -P)/integration-test/aws-volume:/root \
      --env AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
      --env AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
      --env PROJECT_NAME=$PROJECT_NAME \
      --env EC2_INSTANCE_TYPE=$EC2_INSTANCE_TYPE \
      --name=aws kbastani/docker-run-ec2 \
      sh ./aws-create-instance.sh
}

function tearDown() {
    docker run --rm -ti -v $(pwd -P)/integration-test/aws-volume:/root \
      --env AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
      --env AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
      --env PROJECT_NAME=$PROJECT_NAME \
      --name=aws kbastani/docker-run-ec2 \
      sh ./aws-delete-instance.sh
}

function run() {
    docker run --rm -ti -v $(pwd -P)/integration-test/aws-volume:/root \
      --env AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
      --env AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
      --env PROJECT_NAME=$PROJECT_NAME \
      --env DOCKER_COMMAND="$1" \
      --name=aws kbastani/docker-run-ec2 \
      sh ./ssh-docker-run.sh

    # Continue until the health check connection is ready
    if [ $2 ]; then
        while [ "$HEALTH_CHECK_READY" = "" ]; do
          echo "Creating container..."
          HEALTH_CHECK_READY=$(curl -s "$PUBLIC_IP:$2/$3"; echo);
          sleep 1
        done
    fi
}

function health_check() {
    HEALTH_CHECK_READY=
    while [ "$HEALTH_CHECK_READY" = "" ]; do
      echo "Creating container..."
      HEALTH_CHECK_READY=$(curl -s "$PUBLIC_IP:$1/$2"; echo);
      sleep 1
    done
}

function compose() {
    scp -i $INSTALL_PATH/aws-volume/$PROJECT_NAME.pem -o StrictHostKeyChecking=no $INSTALL_PATH/docker-compose.yml ec2-user@$PUBLIC_IP:/home/ec2-user

    # Run a docker compose command
    ssh -tt -i $INSTALL_PATH/aws-volume/$PROJECT_NAME.pem -o StrictHostKeyChecking=no ec2-user@$PUBLIC_IP "docker-compose $1"
}

# Create the EC2 instance
setup

# Export EC2 public IP
export PUBLIC_IP="$(cat $(pwd -P)/integration-test/aws-volume/public_ip | sed 's/\( -\)//1')"

compose "up -d"

declare -a ports=("7474" "8761/health" "8888/admin/health")
# Do health checks on compose services
for i in "${ports[@]}"
do
   health_check "$i"
done



#!/usr/bin/env sh
set -x

function tearDown() {
    docker run --rm -ti -v $(pwd -P)/integration-test/aws-volume:/root \
      --env AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
      --env AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
      --env PROJECT_NAME=$PROJECT_NAME \
      --name=aws kbastani/docker-run-ec2 \
      sh ./aws-delete-instance.sh
}

# Export EC2 public IP
export PUBLIC_IP="$(cat $(pwd -P)/integration-test/aws-volume/public_ip | sed 's/\( -\)//1')"

set -e

export SPRING_NEO4J_HOST=$PUBLIC_IP
export SPRING_RABBITMQ_HOST=$PUBLIC_IP
export EUREKA_CLIENT_SERVICEURL_DEFAULTZONE="http://$PUBLIC_IP:8761/eureka/"
export SPRING_CLOUD_CONFIG_URI="http://$PUBLIC_IP:8888"

# Run tests and tear down
mvn clean install || tearDown || die "'mvn clean install' failed" 1

tearDown
--------------------------------------------------------------------------------------------------------
import org.neo4j.ogm.annotation.*;

/**
 * This domain class is a Neo4j relationship indicating a directed follows connection between two users.
 *
 * @author kbastani
 */
@RelationshipEntity(type = "FOLLOWS")
public class Follows {

    @GraphId
    private Long relationshipId;
    @StartNode
    private User userA;
    @EndNode
    private User userB;

    public Follows(User userA, User userB) {
        this.userA = userA;
        this.userB = userB;
    }

    public Follows() {
    }

    public Long getRelationshipId() {
        return relationshipId;
    }

    public void setRelationshipId(Long relationshipId) {
        this.relationshipId = relationshipId;
    }

    public User getUserA() {
        return userA;
    }

    public void setUserA(User userA) {
        this.userA = userA;
    }

    public User getUserB() {
        return userB;
    }

    public void setUserB(User userB) {
        this.userB = userB;
    }

    @Override
    public String toString() {
        return "Follows{" +
                "relationshipId=" + relationshipId +
                ", userA=" + userA +
                ", userB=" + userB +
                '}';
    }
}



https://www.programcreek.com/java-api-examples/index.php?project_name=kbastani%2Fspring-boot-graph-processing-example#
--------------------------------------------------------------------------------------------------------
    @Bean
    public HttpMessageConverters customConverters() {
        Collection<HttpMessageConverter<?>> messageConverters = new ArrayList<>();
        JsonbHttpMessageConverter jsonbHttpMessageConverter = new JsonbHttpMessageConverter();
        messageConverters.add(jsonbHttpMessageConverter);
        return new HttpMessageConverters(true, messageConverters);
    }
--------------------------------------------------------------------------------------------------------
import java.net.Socket;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.Principal;
import java.security.PrivateKey;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLEngine;
import javax.net.ssl.X509ExtendedKeyManager;

class SingleX509KeyManager extends X509ExtendedKeyManager {

	private String alias;

	private PrivateKey pk;

	private X509Certificate[] certs;

	public SingleX509KeyManager(String alias, PrivateKey pk, Certificate[] certs) {
		this.alias = alias;
		this.pk = pk;
		this.certs = copy(certs);
	}

	public SingleX509KeyManager(String alias, KeyStore keystore, char[] keyPass)
			throws UnrecoverableKeyException, KeyStoreException, NoSuchAlgorithmException {
		this.alias = alias;
		this.pk = (PrivateKey) keystore.getKey(alias, keyPass);
		this.certs = copy(keystore.getCertificateChain(alias));
	}

	@Override
	public String chooseEngineClientAlias(String[] paramArrayOfString, Principal[] paramArrayOfPrincipal,
			SSLEngine paramSSLEngine) {
		return alias;
	}

	@Override
	public String chooseEngineServerAlias(String paramString, Principal[] paramArrayOfPrincipal,
			SSLEngine paramSSLEngine) {
		return alias;
	}

	public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) {
		return alias;
	}

	public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket) {
		return alias;
	}

	public X509Certificate[] getCertificateChain(String alias) {
		return copy(certs);
	}

	public String[] getClientAliases(String keyType, Principal[] issuers) {
		return new String[] { alias };
	}

	public PrivateKey getPrivateKey(String alias) {
		return pk;
	}

	public String[] getServerAliases(String keyType, Principal[] issuers) {
		return new String[] { alias };
	}

	private X509Certificate[] copy(Certificate[] certs) {
		if (certs == null)
			return null;
		X509Certificate[] copy = new X509Certificate[certs.length];
		System.arraycopy(certs, 0, copy, 0, certs.length);
		return copy;
	}
}
--------------------------------------------------------------------------------------------------------
@Configuration(proxyBeanMethods = false)

public class ActuatorSecurity extends WebSecurityConfigurerAdapter {

 

    @Override

    protected void configure(HttpSecurity http) throws Exception {

        http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests((requests) ->

                requests.anyRequest().hasRole("ENDPOINT_ADMIN"));

        http.httpBasic();

    }

 

}

@Configuration(proxyBeanMethods = false)

public class ActuatorSecurity extends WebSecurityConfigurerAdapter {

 

    @Override

    protected void configure(HttpSecurity http) throws Exception {

        http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests((requests) ->

            requests.anyRequest().permitAll());

    }

 

}
--------------------------------------------------------------------------------------------------------
import org.kbastani.twitter.FollowsRepository;
import org.kbastani.twitter.UserRepository;
import org.neo4j.ogm.session.SessionFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.neo4j.config.Neo4jConfiguration;
import org.springframework.data.neo4j.repository.config.EnableNeo4jRepositories;
import org.springframework.data.neo4j.server.Neo4jServer;
import org.springframework.data.neo4j.server.RemoteServer;
import org.springframework.transaction.annotation.EnableTransactionManagement;

/**
 * Manages the configuration for a Neo4j graph database server
 *
 * @author Kenny Bastani
 */
@EnableNeo4jRepositories(basePackageClasses = {FollowsRepository.class, UserRepository.class})
@EnableTransactionManagement
@Configuration
public class GraphConfiguration extends Neo4jConfiguration {

    @Value("${spring.neo4j.host}")
    private String host;

    @Value("${spring.neo4j.port}")
    private String port;

    @Bean
    public Neo4jServer neo4jServer() {
        return new RemoteServer(String.format("http://%s:%s", host, port));
    }

    @Bean
    public SessionFactory getSessionFactory() {
        return new SessionFactory(UserRepository.class.getPackage().getName());
    }

}




import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.neo4j.ogm.session.Neo4jSession;
import org.neo4j.ogm.session.transaction.Transaction;
import org.springframework.amqp.core.Queue;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;
import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.social.twitter.api.Twitter;
import org.springframework.social.twitter.api.impl.TwitterTemplate;

/**
 * This configuration defines the setup information for RabbitMQ queues and a command line runner bean
 * that will ensure that a unique constraint is applied to the connected Neo4j database server
 *
 * @author kbastani
 */
@Configuration
public class TwitterCrawlerConfig {

    private final Log logger = LogFactory.getLog(TwitterCrawlerConfig.class);

    @Bean
    public EmbeddedServletContainerFactory servletContainer() {
        return new TomcatEmbeddedServletContainerFactory();
    }

    @Bean
    Queue follows() {
        return new Queue("twitter.follows", true, false, false);
    }

    @Bean
    Queue followers() {
        return new Queue("twitter.followers", true, false, false);
    }

    @Value("${spring.social.twitter.appId}")
    private String appId;

    @Value("${spring.social.twitter.appSecret}")
    private String appSecret;

    @Value("${spring.social.twitter.accessToken}")
    private String accessToken;

    @Value("${spring.social.twitter.accessTokenSecret}")
    private String accessTokenSecret;

    @Bean
    Twitter twitter(final @Value("${spring.social.twitter.appId}") String appId,
                    final @Value("${spring.social.twitter.appSecret}") String appSecret,
                    final @Value("${spring.social.twitter.accessToken}") String accessToken,
                    final @Value("${spring.social.twitter.accessTokenSecret}") String accessTokenSecret) {
        return new TwitterTemplate(appId, appSecret, accessToken, accessTokenSecret);
    }


    Twitter twitters(String appId, String appSecret,
                     String accessToken, String accessTokenSecret) {
        return new TwitterTemplate(appId, appSecret, accessToken, accessTokenSecret);
    }

    @Bean
    CommandLineRunner commandLineRunner(Neo4jSession neo4jSession) {
        return (args) -> {
            // Make sure that a constraint is created on the Neo4j database
            try {
                // This constraint ensures that each profileId is unique per user node
                Transaction tx = neo4jSession.beginTransaction();
                neo4jSession.execute("CREATE CONSTRAINT ON (user:User) ASSERT user.profileId IS UNIQUE");
                tx.commit();
                tx.close();
            } catch (Exception ex) {
                // The constraint is already created or the database is not available
                logger.error(ex);
            }

        };
    }
}
--------------------------------------------------------------------------------------------------------
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.IntegrationTest;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.boot.test.TestRestTemplate;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

import java.util.Map;

import static org.junit.Assert.assertEquals;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = ConfigServiceApplication.class)
@WebAppConfiguration
@IntegrationTest("server.port=0")
public class ConfigServiceApplicationTests {

	@Value("${local.server.port}")
	private int port = 0;

	@Test
	public void configurationAvailable() {
		@SuppressWarnings("rawtypes")
		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity(
				"http://localhost:" + port + "/app/production", Map.class);
		assertEquals(HttpStatus.OK, entity.getStatusCode());
	}

	@Test
	public void envPostAvailable() {
		MultiValueMap<String, String> form = new LinkedMultiValueMap<>();
		@SuppressWarnings("rawtypes")
		ResponseEntity<Map> entity = new TestRestTemplate().postForEntity(
				"http://localhost:" + port + "/admin/env", form, Map.class);
		assertEquals(HttpStatus.OK, entity.getStatusCode());
	}

}
--------------------------------------------------------------------------------------------------------
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.springframework.boot.autoconfigure.web.DefaultErrorAttributes;
import org.springframework.http.HttpStatus;
import org.springframework.web.context.request.RequestAttributes;

/**
 * The default implementation of {@link ExceptionAttributes}. This
 * implementation seeks to be similar to the {@link DefaultErrorAttributes}
 * class, but differs in the source of the attribute data. The
 * DefaultErrorAttributes class requires the exception to be thrown from the
 * Controller so that it may gather attribute values from
 * {@link RequestAttributes}. This class uses the {@link Exception},
 * {@link HttpServletRequest}, and {@link HttpStatus} values.
 *
 * Provides a Map of the following attributes when they are available:
 * <ul>
 * <li>timestamp - The time that the exception attributes were processed
 * <li>status - The HTTP status code in the response
 * <li>error - The HTTP status reason text
 * <li>exception - The class name of the Exception
 * <li>message - The Exception message
 * <li>path - The HTTP request servlet path when the exception was thrown
 * </ul>
 * 
 * @author Matt Warman
 * @see ExceptionAttributes
 *
 */
public class DefaultExceptionAttributes implements ExceptionAttributes {

    /**
     * The timestamp attribute key.
     */
    public static final String TIMESTAMP = "timestamp";
    /**
     * The status attribute key.
     */
    public static final String STATUS = "status";
    /**
     * The error attribute key.
     */
    public static final String ERROR = "error";
    /**
     * The exception attribute key.
     */
    public static final String EXCEPTION = "exception";
    /**
     * The message attribute key.
     */
    public static final String MESSAGE = "message";
    /**
     * The path attribute key.
     */
    public static final String PATH = "path";

    @Override
    public Map<String, Object> getExceptionAttributes(Exception exception,
            HttpServletRequest httpRequest, HttpStatus httpStatus) {

        Map<String, Object> exceptionAttributes = new LinkedHashMap<String, Object>();

        exceptionAttributes.put(TIMESTAMP, new Date());
        addHttpStatus(exceptionAttributes, httpStatus);
        addExceptionDetail(exceptionAttributes, exception);
        addPath(exceptionAttributes, httpRequest);

        return exceptionAttributes;
    }

    /**
     * Adds the status and error attribute values from the {@link HttpStatus}
     * value.
     * @param exceptionAttributes The Map of exception attributes.
     * @param httpStatus The HttpStatus enum value.
     */
    private void addHttpStatus(Map<String, Object> exceptionAttributes,
            HttpStatus httpStatus) {
        exceptionAttributes.put(STATUS, httpStatus.value());
        exceptionAttributes.put(ERROR, httpStatus.getReasonPhrase());
    }

    /**
     * Adds the exception and message attribute values from the
     * {@link Exception}.
     * @param exceptionAttributes The Map of exception attributes.
     * @param exception The Exception object.
     */
    private void addExceptionDetail(Map<String, Object> exceptionAttributes,
            Exception exception) {
        exceptionAttributes.put(EXCEPTION, exception.getClass().getName());
        exceptionAttributes.put(MESSAGE, exception.getMessage());
    }

    /**
     * Adds the path attribute value from the {@link HttpServletRequest}.
     * @param exceptionAttributes The Map of exception attributes.
     * @param httpRequest The HttpServletRequest object.
     */
    private void addPath(Map<String, Object> exceptionAttributes,
            HttpServletRequest httpRequest) {
        exceptionAttributes.put(PATH, httpRequest.getServletPath());
    }
}

import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * The ExceptionAttributes interface defines the behavioral contract to be
 * implemented by concrete ExceptionAttributes classes.
 * 
 * Provides attributes which describe Exceptions and the context in which they
 * occurred.
 * 
 * @author Matt Warman
 * @see DefaultExceptionAttributes
 *
 */
public interface ExceptionAttributes {

    /**
     * Returns a {@link Map} of exception attributes. The Map may be used to
     * display an error page or serialized into a {@link ResponseBody}.
     * 
     * @param exception The Exception reported.
     * @param httpRequest The HttpServletRequest in which the Exception
     *        occurred.
     * @param httpStatus The HttpStatus value that will be used in the
     *        {@link HttpServletResponse}.
     * @return A Map of exception attributes.
     */
    Map<String, Object> getExceptionAttributes(Exception exception,
            HttpServletRequest httpRequest, HttpStatus httpStatus);

}
--------------------------------------------------------------------------------------------------------
import java.util.Collection;

import javax.persistence.EntityExistsException;
import javax.persistence.NoResultException;

import org.example.ws.model.Greeting;
import org.example.ws.repository.GreetingRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.metrics.CounterService;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * The GreetingServiceBean encapsulates all business behaviors operating on the
 * Greeting entity model object.
 * 
 * @author Matt Warman
 */
@Service
@Transactional(
        propagation = Propagation.SUPPORTS,
        readOnly = true)
public class GreetingServiceBean implements GreetingService {

    private Logger logger = LoggerFactory.getLogger(this.getClass());

    /**
     * The <code>CounterService</code> captures metrics for Spring Actuator.
     */
    @Autowired
    private CounterService counterService;

    /**
     * The Spring Data repository for Greeting entities.
     */
    @Autowired
    private GreetingRepository greetingRepository;

    @Override
    public Collection<Greeting> findAll() {
        logger.info("> findAll");

        counterService.increment("method.invoked.greetingServiceBean.findAll");

        Collection<Greeting> greetings = greetingRepository.findAll();

        logger.info("< findAll");
        return greetings;
    }

    @Override
    @Cacheable(
            value = "greetings",
            key = "#id")
    public Greeting findOne(Long id) {
        logger.info("> findOne id:{}", id);

        counterService.increment("method.invoked.greetingServiceBean.findOne");

        Greeting greeting = greetingRepository.findOne(id);

        logger.info("< findOne id:{}", id);
        return greeting;
    }

    @Override
    @Transactional(
            propagation = Propagation.REQUIRED,
            readOnly = false)
    @CachePut(
            value = "greetings",
            key = "#result.id")
    public Greeting create(Greeting greeting) {
        logger.info("> create");

        counterService.increment("method.invoked.greetingServiceBean.create");

        // Ensure the entity object to be created does NOT exist in the
        // repository. Prevent the default behavior of save() which will update
        // an existing entity if the entity matching the supplied id exists.
        if (greeting.getId() != null) {
            // Cannot create Greeting with specified ID value
            logger.error(
                    "Attempted to create a Greeting, but id attribute was not null.");
            throw new EntityExistsException(
                    "The id attribute must be null to persist a new entity.");
        }

        Greeting savedGreeting = greetingRepository.save(greeting);

        logger.info("< create");
        return savedGreeting;
    }

    @Override
    @Transactional(
            propagation = Propagation.REQUIRED,
            readOnly = false)
    @CachePut(
            value = "greetings",
            key = "#greeting.id")
    public Greeting update(Greeting greeting) {
        logger.info("> update id:{}", greeting.getId());

        counterService.increment("method.invoked.greetingServiceBean.update");

        // Ensure the entity object to be updated exists in the repository to
        // prevent the default behavior of save() which will persist a new
        // entity if the entity matching the id does not exist
        Greeting greetingToUpdate = findOne(greeting.getId());
        if (greetingToUpdate == null) {
            // Cannot update Greeting that hasn't been persisted
            logger.error(
                    "Attempted to update a Greeting, but the entity does not exist.");
            throw new NoResultException("Requested entity not found.");
        }

        greetingToUpdate.setText(greeting.getText());
        Greeting updatedGreeting = greetingRepository.save(greetingToUpdate);

        logger.info("< update id:{}", greeting.getId());
        return updatedGreeting;
    }

    @Override
    @Transactional(
            propagation = Propagation.REQUIRED,
            readOnly = false)
    @CacheEvict(
            value = "greetings",
            key = "#id")
    public void delete(Long id) {
        logger.info("> delete id:{}", id);

        counterService.increment("method.invoked.greetingServiceBean.delete");

        greetingRepository.delete(id);

        logger.info("< delete id:{}", id);
    }

    @Override
    @CacheEvict(
            value = "greetings",
            allEntries = true)
    public void evictCache() {
        logger.info("> evictCache");
        logger.info("< evictCache");
    }
}

import java.util.concurrent.Future;

import org.example.ws.model.Greeting;
import org.example.ws.util.AsyncResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

/**
 * The EmailServiceBean implements all business behaviors defined by the
 * EmailService interface.
 * 
 * @author Matt Warman
 */
@Service
public class EmailServiceBean implements EmailService {

    /**
     * The Logger for this class.
     */
    private Logger logger = LoggerFactory.getLogger(this.getClass());

    @Override
    public Boolean send(Greeting greeting) {
        logger.info("> send");

        Boolean success = Boolean.FALSE;

        // Simulate method execution time
        long pause = 5000;
        try {
            Thread.sleep(pause);
        } catch (Exception e) {
            // do nothing
        }
        logger.info("Processing time was {} seconds.", pause / 1000);

        success = Boolean.TRUE;

        logger.info("< send");
        return success;
    }

    @Async
    @Override
    public void sendAsync(Greeting greeting) {
        logger.info("> sendAsync");

        try {
            send(greeting);
        } catch (Exception e) {
            logger.warn("Exception caught sending asynchronous mail.", e);
        }

        logger.info("< sendAsync");
    }

    @Async
    @Override
    public Future<Boolean> sendAsyncWithResult(Greeting greeting) {
        logger.info("> sendAsyncWithResult");

        AsyncResponse<Boolean> response = new AsyncResponse<Boolean>();

        try {
            Boolean success = send(greeting);
            response.complete(success);
        } catch (Exception e) {
            logger.warn("Exception caught sending asynchronous mail.", e);
            response.completeExceptionally(e);
        }

        logger.info("< sendAsyncWithResult");
        return response;
    }

}

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.metrics.CounterService;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

/**
 * The QuoteServiceBean encapsulates all business behaviors operating on the
 * Quote class.
 * 
 * @author Matt Warman
 */
@Service
public class QuoteServiceBean implements QuoteService {

    /**
     * The Logger for this class.
     */
    private Logger logger = LoggerFactory.getLogger(this.getClass());

    /**
     * The <code>CounterService</code> captures metrics for Spring Actuator.
     */
    @Autowired
    private CounterService counterService;

    /**
     * The RestTemplate used to retrieve data from the remote Quote API.
     */
    private final RestTemplate restTemplate;

    /**
     * Construct a QuoteServiceBean with a RestTemplateBuilder used to
     * instantiate the RestTemplate used by this business service.
     * @param restTemplateBuilder A RestTemplateBuilder injected from the
     *        ApplicationContext.
     */
    public QuoteServiceBean(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplate = restTemplateBuilder.build();
    }

    @Override
    public Quote getDaily(String category) {
        logger.info("> getDaily");

        counterService.increment("method.invoked.quoteServiceBean.getDaily");

        String quoteCategory = QuoteService.CATEGORY_INSPIRATIONAL;
        if (category != null && category.trim().length() > 0) {
            quoteCategory = category.trim();
        }

        QuoteResponse quoteResponse = this.restTemplate.getForObject(
                "http://quotes.rest/qod.json?category={cat}",
                QuoteResponse.class, quoteCategory);

        Quote quote = quoteResponse.getQuote();

        logger.info("< getDaily");
        return quote;
    }

}
--------------------------------------------------------------------------------------------------------import java.util.Collection;

import org.example.ws.model.Greeting;
import org.example.ws.service.GreetingService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Profile;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

/**
 * The GreetingBatchBean contains <code>@Scheduled</code> methods operating on
 * Greeting entities to perform batch operations.
 * 
 * @author Matt Warman
 */
@Profile("batch")
@Component
public class GreetingBatchBean {

    /**
     * The Logger for this class.
     */
    private Logger logger = LoggerFactory.getLogger(this.getClass());

    /**
     * The GreetingService business service.
     */
    @Autowired
    private GreetingService greetingService;

    /**
     * Use a cron expression to execute logic on a schedule.
     * 
     * Expression: second minute hour day-of-month month weekday
     * 
     * @see http ://docs.spring.io/spring/docs/current/javadoc-api/org/
     *      springframework /scheduling/support/CronSequenceGenerator.html
     */
    @Scheduled(
            cron = "${batch.greeting.cron}")
    public void cronJob() {
        logger.info("> cronJob");

        // Add scheduled logic here
        Collection<Greeting> greetings = greetingService.findAll();
        logger.info("There are {} greetings in the data store.",
                greetings.size());

        logger.info("< cronJob");
    }

    /**
     * Execute logic beginning at fixed intervals with a delay after the
     * application starts. Use the <code>fixedRate</code> element to indicate
     * how frequently the method is to be invoked. Use the
     * <code>initialDelay</code> element to indicate how long to wait after
     * application startup to schedule the first execution.
     */
    @Scheduled(
            initialDelayString = "${batch.greeting.initialdelay}",
            fixedRateString = "${batch.greeting.fixedrate}")
    public void fixedRateJobWithInitialDelay() {
        logger.info("> fixedRateJobWithInitialDelay");

        // Add scheduled logic here

        // Simulate job processing time
        long pause = 5000;
        long start = System.currentTimeMillis();
        do {
            if (start + pause < System.currentTimeMillis()) {
                break;
            }
        } while (true);
        logger.info("Processing time was {} seconds.", pause / 1000);

        logger.info("< fixedRateJobWithInitialDelay");
    }

    /**
     * Execute logic with a delay between the end of the last execution and the
     * beginning of the next. Use the <code>fixedDelay</code> element to
     * indicate the time to wait between executions. Use the
     * <code>initialDelay</code> element to indicate how long to wait after
     * application startup to schedule the first execution.
     */
    @Scheduled(
            initialDelayString = "${batch.greeting.initialdelay}",
            fixedDelayString = "${batch.greeting.fixeddelay}")
    public void fixedDelayJobWithInitialDelay() {
        logger.info("> fixedDelayJobWithInitialDelay");

        // Add scheduled logic here

        // Simulate job processing time
        long pause = 5000;
        long start = System.currentTimeMillis();
        do {
            if (start + pause < System.currentTimeMillis()) {
                break;
            }
        } while (true);
        logger.info("Processing time was {} seconds.", pause / 1000);

        logger.info("< fixedDelayJobWithInitialDelay");
    }

}
import java.util.Collection;

import org.example.ws.model.Greeting;
import org.example.ws.service.GreetingService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Profile;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

/**
 * The GreetingBatchBean contains <code>@Scheduled</code> methods operating on
 * Greeting entities to perform batch operations.
 * 
 * @author Matt Warman
 */
@Profile("batch")
@Component
public class GreetingBatchBean {

    /**
     * The Logger for this class.
     */
    private Logger logger = LoggerFactory.getLogger(this.getClass());

    /**
     * The GreetingService business service.
     */
    @Autowired
    private GreetingService greetingService;

    /**
     * Use a cron expression to execute logic on a schedule.
     * 
     * Expression: second minute hour day-of-month month weekday
     * 
     * @see http ://docs.spring.io/spring/docs/current/javadoc-api/org/
     *      springframework /scheduling/support/CronSequenceGenerator.html
     */
    @Scheduled(
            cron = "${batch.greeting.cron}")
    public void cronJob() {
        logger.info("> cronJob");

        // Add scheduled logic here
        Collection<Greeting> greetings = greetingService.findAll();
        logger.info("There are {} greetings in the data store.",
                greetings.size());

        logger.info("< cronJob");
    }

    /**
     * Execute logic beginning at fixed intervals with a delay after the
     * application starts. Use the <code>fixedRate</code> element to indicate
     * how frequently the method is to be invoked. Use the
     * <code>initialDelay</code> element to indicate how long to wait after
     * application startup to schedule the first execution.
     */
    @Scheduled(
            initialDelayString = "${batch.greeting.initialdelay}",
            fixedRateString = "${batch.greeting.fixedrate}")
    public void fixedRateJobWithInitialDelay() {
        logger.info("> fixedRateJobWithInitialDelay");

        // Add scheduled logic here

        // Simulate job processing time
        long pause = 5000;
        long start = System.currentTimeMillis();
        do {
            if (start + pause < System.currentTimeMillis()) {
                break;
            }
        } while (true);
        logger.info("Processing time was {} seconds.", pause / 1000);

        logger.info("< fixedRateJobWithInitialDelay");
    }

    /**
     * Execute logic with a delay between the end of the last execution and the
     * beginning of the next. Use the <code>fixedDelay</code> element to
     * indicate the time to wait between executions. Use the
     * <code>initialDelay</code> element to indicate how long to wait after
     * application startup to schedule the first execution.
     */
    @Scheduled(
            initialDelayString = "${batch.greeting.initialdelay}",
            fixedDelayString = "${batch.greeting.fixeddelay}")
    public void fixedDelayJobWithInitialDelay() {
        logger.info("> fixedDelayJobWithInitialDelay");

        // Add scheduled logic here

        // Simulate job processing time
        long pause = 5000;
        long start = System.currentTimeMillis();
        do {
            if (start + pause < System.currentTimeMillis()) {
                break;
            }
        } while (true);
        logger.info("Processing time was {} seconds.", pause / 1000);

        logger.info("< fixedDelayJobWithInitialDelay");
    }

}

import com.shawn.model.entity.Book;
import com.shawn.repository.BookRepository;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.util.List;

/**
 * @author Xiaoyue Xiao
 */
@Mapper
public interface BookMapper extends BookRepository {

    @Override
    List<Book> selectBooksByLowPriceAndHighPrice(@Param("lowPrice") Double lowPrice, @Param("highPrice") Double highPrice);

    @Override
    List<Book> selectBooksByPage(@Param("offset") Integer offset, @Param("perPage") Integer perPage);

}
--------------------------------------------------------------------------------------------------------
    @Bean(name = "dataSource",initMethod = "init", destroyMethod = "close")
    public DataSource druidDataSource(@Value("${druid.datasource.driverClassName}") String driver,
                                      @Value("${druid.datasource.url}") String url, @Value("${druid.datasource.username}") String username,
                                      @Value("${druid.datasource.password}") String password,
                                      @Value("${druid.datasource.initialSize}") Integer initialSize,
                                      @Value("${druid.datasource.minIdle}") Integer minIdle,
                                      @Value("${druid.datasource.maxActive}") Integer maxActive) {
        DruidDataSource druidDataSource = new DruidDataSource();
        druidDataSource.setDriverClassName(driver);
        druidDataSource.setUrl(url);
        druidDataSource.setUsername(username);
        druidDataSource.setPassword(password);
        druidDataSource.setValidationQuery("SELECT * FROM DUAL");
        druidDataSource.setPoolPreparedStatements(false);
        try {
            druidDataSource.setFilters("stat");
        } catch (SQLException e1) {
            logger.error("setFilters error", e1);
        }
        try {
            druidDataSource.setFilters("stat, wall");
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return druidDataSource;
    }
--------------------------------------------------------------------------------------------------------
package com.bootcwenao.feignserver.kafka.listeners;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;

import java.util.Optional;

/**
 * @author cwenao
 * @version $Id KafkaListeners.java, v 0.1 2017-01-21 21:31 cwenao Exp $$
 */
public class KafkaListeners {

    @KafkaListener(topics = {"bootcwenaoTopic"})
    public void testListener(ConsumerRecord<?, ?> record) {

        Optional<?> messages = Optional.ofNullable(record.value());

        if (messages.isPresent()) {
            Object msg = messages.get();
            System.out.println("  this is the testTopic send message: " + msg);
        }

    }

}
--------------------------------------------------------------------------------------------------------
import com.bootcwenao.feignserver.servers.impl.FeignServerFactoryImpl;
import com.bootcwenao.feignserver.servers.impl.FeignServerImpl;
import org.springframework.cloud.netflix.feign.FeignClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * @author cwenao
 * @version $Id FeignServer.java, v 0.1 2017-01-15 13:51 cwenao Exp $$
 */
@FeignClient(value = "ribbonserver" , fallbackFactory = FeignServerFactoryImpl.class )
public interface FeignServer {

    @RequestMapping(value ="/testRealRibbon",method= RequestMethod.GET)
    String testRealRibbon(@RequestParam("content") String content);

}

import com.bootcwenao.feignserver.servers.FeignServer;
import feign.hystrix.FallbackFactory;
import org.springframework.stereotype.Component;

/**
 * @author cwenao
 * @version $Id FeignServerFactoryImpl.java, v 0.1 2017-01-17 10:40 cwenao Exp $$
 */
@Component
public class FeignServerFactoryImpl implements FallbackFactory<FeignServer> {
    /**
     * Returns an instance of the fallback appropriate for the given cause
     *
     * @param cause corresponds to {@link AbstractCommand#getFailedExecutionException()}
     *              often, but not always an instance of {@link FeignException}.
     */
    public FeignServer create(Throwable cause) {

        return new FeignServer() {
            public String testRealRibbon(String content) {
                return content + ", it's fallback Factory with feign";
            }
        };
    }
}

mvn install:install-file -Dfile=D:\Downloads2\mailingcontour\paragon.mailingcontour\0.3.0-alpha-0352-ef7813f\paragon.mailingcontour-0.3.0-alpha-0352-ef7813f.pom -DgroupId=com.paragon.mailingcontour -DartifactId=paragon.mailingcontour -Dversion=0.3.0-alpha-0352-ef7813f -Dpackaging=pom

mvn install:install-file -Dfile=D:\Downloads2\mailingcontour\paragon.mailingcontour.commons\0.3.0-alpha-0352-ef7813f\paragon.mailingcontour.commons-0.3.0-alpha-0352-ef7813f.pom -DgroupId=com.paragon.mailingcontour -DartifactId=paragon.mailingcontour.commons -Dversion=0.3.0-alpha-0352-ef7813f -Dpackaging=pom
--------------------------------------------------------------------------------------------------------
mvn dependency:tree -X
--------------------------------------------------------------------------------------------------------

import org.junit.Test;

import java.io.IOException;

import static de.otto.edison.acceptance.api.FeatureTogglesApi.internal_toggles_is_retrieved_as;
import static de.otto.edison.acceptance.api.FeatureTogglesApi.the_returned_json;
import static de.otto.edison.testsupport.dsl.Then.assertThat;
import static de.otto.edison.testsupport.dsl.Then.then;
import static de.otto.edison.testsupport.dsl.When.when;
import static org.hamcrest.Matchers.is;

public class FeatureTogglesControllerAcceptanceTest {

    @Test
    public void shouldTogglesAsJson() throws IOException {
        when(
                internal_toggles_is_retrieved_as("application/json")
        );

        then(
                assertThat(the_returned_json().at("/features/TEST_FEATURE/description").asText(), is("a test feature toggle")),
                assertThat(the_returned_json().at("/features/TEST_FEATURE/enabled").asBoolean(), is(true)),
                assertThat(the_returned_json().at("/features/TEST_FEATURE_2/description").asText(), is("TEST_FEATURE_2")),
                assertThat(the_returned_json().at("/features/TEST_FEATURE_2/enabled").asBoolean(), is(true))
        );

    }

}

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import de.otto.edison.testsupport.applicationdriver.SpringTestBase;
import de.otto.edison.testsupport.dsl.When;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.util.Optional;

import static java.util.Arrays.asList;
import static java.util.Optional.of;
import static org.springframework.http.HttpMethod.GET;
import static org.springframework.http.MediaType.parseMediaType;

public class FeatureTogglesApi extends SpringTestBase {

    private final static RestTemplate restTemplate = new RestTemplate();
    private final static ObjectMapper objectMapper = new ObjectMapper();
    private static String content = null;
    private static HttpStatus statusCode;

    public static When internal_toggles_is_retrieved_as(final String mediaType) throws IOException {
        getResource("http://localhost:8085/togglztest/internal/toggles", of(mediaType));
        return When.INSTANCE;
    }

    public static HttpStatus the_status_code() {
        return statusCode;
    }

    public static String the_returned_content() {
        return content;
    }

    public static JsonNode the_returned_json() {
        try {
            return objectMapper.readTree(content);
        } catch (IOException e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
    }

    private static void getResource(final String url, final Optional<String> mediaType) throws IOException {
        final HttpHeaders headers = new HttpHeaders();
        if (mediaType.isPresent()) {
            headers.setAccept(asList(parseMediaType(mediaType.get())));
        }

        final ResponseEntity<String> responseEntity = restTemplate.exchange(
                url,
                GET,
                new HttpEntity<>("parameters", headers), String.class
        );
        content = responseEntity.getBody();
        statusCode = responseEntity.getStatusCode();
    }

}
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
    @Test
    void dependentAssertions() {
        // Within a code block, if an assertion fails the
        // subsequent code in the same block will be skipped.
        assertAll("properties",
            () -> {
                String firstName = person.getFirstName();
                assertNotNull(firstName);

                // Executed only if the previous assertion is valid.
                assertAll("first name",
                    () -> assertTrue(firstName.startsWith("J")),
                    () -> assertTrue(firstName.endsWith("e"))
                );
            },
            () -> {
                // Grouped assertion, so processed independently
                // of results of first name assertions.
                String lastName = person.getLastName();
                assertNotNull(lastName);

                // Executed only if the previous assertion is valid.
                assertAll("last name",
                    () -> assertTrue(lastName.startsWith("D")),
                    () -> assertTrue(lastName.endsWith("e"))
                );
            }
        );
    }
--------------------------------------------------------------------------------------------------------
import static java.time.Duration.ofMillis;
import static java.time.Duration.ofMinutes;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTimeout;
import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.concurrent.CountDownLatch;

import example.domain.Person;
import example.util.Calculator;

import org.junit.jupiter.api.Test;

class AssertionsDemo {

    private final Calculator calculator = new Calculator();

    private final Person person = new Person("Jane", "Doe");

    @Test
    void standardAssertions() {
        assertEquals(2, calculator.add(1, 1));
        assertEquals(4, calculator.multiply(2, 2),
                "The optional failure message is now the last parameter");
        assertTrue('a' < 'b', () -> "Assertion messages can be lazily evaluated -- "
                + "to avoid constructing complex messages unnecessarily.");
    }

    @Test
    void groupedAssertions() {
        // In a grouped assertion all assertions are executed, and all
        // failures will be reported together.
        assertAll("person",
            () -> assertEquals("Jane", person.getFirstName()),
            () -> assertEquals("Doe", person.getLastName())
        );
    }

    @Test
    void dependentAssertions() {
        // Within a code block, if an assertion fails the
        // subsequent code in the same block will be skipped.
        assertAll("properties",
            () -> {
                String firstName = person.getFirstName();
                assertNotNull(firstName);

                // Executed only if the previous assertion is valid.
                assertAll("first name",
                    () -> assertTrue(firstName.startsWith("J")),
                    () -> assertTrue(firstName.endsWith("e"))
                );
            },
            () -> {
                // Grouped assertion, so processed independently
                // of results of first name assertions.
                String lastName = person.getLastName();
                assertNotNull(lastName);

                // Executed only if the previous assertion is valid.
                assertAll("last name",
                    () -> assertTrue(lastName.startsWith("D")),
                    () -> assertTrue(lastName.endsWith("e"))
                );
            }
        );
    }

    @Test
    void exceptionTesting() {
        Exception exception = assertThrows(ArithmeticException.class, () ->
            calculator.divide(1, 0));
        assertEquals("/ by zero", exception.getMessage());
    }

    @Test
    void timeoutNotExceeded() {
        // The following assertion succeeds.
        assertTimeout(ofMinutes(2), () -> {
            // Perform task that takes less than 2 minutes.
        });
    }

    @Test
    void timeoutNotExceededWithResult() {
        // The following assertion succeeds, and returns the supplied object.
        String actualResult = assertTimeout(ofMinutes(2), () -> {
            return "a result";
        });
        assertEquals("a result", actualResult);
    }

    @Test
    void timeoutNotExceededWithMethod() {
        // The following assertion invokes a method reference and returns an object.
        String actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);
        assertEquals("Hello, World!", actualGreeting);
    }

    @Test
    void timeoutExceeded() {
        // The following assertion fails with an error message similar to:
        // execution exceeded timeout of 10 ms by 91 ms
        assertTimeout(ofMillis(10), () -> {
            // Simulate task that takes more than 10 ms.
            Thread.sleep(100);
        });
    }

    @Test
    void timeoutExceededWithPreemptiveTermination() {
        // The following assertion fails with an error message similar to:
        // execution timed out after 10 ms
        assertTimeoutPreemptively(ofMillis(10), () -> {
            // Simulate task that takes more than 10 ms.
            new CountDownLatch(1).await();
        });
    }

    private static String greeting() {
        return "Hello, World!";
    }

}
--------------------------------------------------------------------------------------------------------
    @Test
    void testInAllEnvironments() {
        assumingThat("CI".equals(System.getenv("ENV")),
            () -> {
                // perform these assertions only on the CI server
                assertEquals(2, calculator.divide(4, 2));
            });

        // perform these assertions in all environments
        assertEquals(42, calculator.multiply(6, 7));
    }
--------------------------------------------------------------------------------------------------------
import java.security.SecureRandom;
import java.util.Calendar;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.lang3.StringUtils;

import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.JWSObject;
import com.nimbusds.jose.JWSSigner;
import com.nimbusds.jose.JWSVerifier;
import com.nimbusds.jose.Payload;
import com.nimbusds.jose.crypto.MACSigner;
import com.nimbusds.jose.crypto.MACVerifier;

/**
 * json web token 工具类 Created by mazhyb on 2016-01-25.
 */
public final class JWT {

	private JWT() {
	}

	/**
	 * api请求时
	 */
	public static final String API_TOKEN_KEY = "api-access-token";

	public static final byte[] SHARED_SECRET;

	static {
		SHARED_SECRET = new byte[32];
		SecureRandom random = new SecureRandom();
		random.nextBytes(SHARED_SECRET);
	}

	public static String newToken(JWTUser user) throws JOSEException {
		return newJWSObject(user).serialize();
	}

	public static JWSObject newJWSObject(JWTUser user) throws JOSEException {
		JWSSigner signer = new MACSigner(JWT.SHARED_SECRET);
		JWSObject jwsObject = new JWSObject(new JWSHeader(JWSAlgorithm.HS256), new Payload(user));
		jwsObject.sign(signer);
		return jwsObject;
	}

	public static boolean verify(JWSObject jwsObject) throws JOSEException {
		JWSVerifier verifier = new MACVerifier(JWT.SHARED_SECRET);
		return jwsObject.verify(verifier);
	}

	/**
	 * token有效期最大是默认24*3600秒（1天）
	 */
	public static final int EXP_TIMEOUT_SECOND = 86400;

	public static long newExp() {
		return newExp(EXP_TIMEOUT_SECOND);
	}

	/**
	 * 生成新的有效期
	 * 
	 * @param timeout
	 *            有效期多长时间，单位是秒
	 * @return
	 */
	public static long newExp(int timeout) {
		Calendar newexp = Calendar.getInstance();
		newexp.add(Calendar.SECOND, timeout);
		return newexp.getTimeInMillis();
	}

	public static JWTUser getJWTUser(String token) throws JWTException {
		if (StringUtils.isEmpty(token)) {
			throw new JWTException("没有找到token信息！");
		}
		try {
			JWSObject jwsObject = JWSObject.parse(token);
			if (JWT.verify(jwsObject)) {
				// 判断有效期，不在有效期内则直接抛出错误
				JWTUser user = new JWTUser(jwsObject.getPayload().toJSONObject());
				if (user.getExp() >= Calendar.getInstance().getTimeInMillis()) {
					return user;
				} else {
					throw new JWTException("token已经超过有效期！");
				}
			} else {
				throw new JWTException("token校验失败！");
			}
		} catch (Exception e) {
			throw new JWTException(e);
		}
	}

	public static JWTUser getJWTUser(HttpServletRequest request) throws JWTException {
		// 1. 从parameter中取
		String token = request.getParameter(API_TOKEN_KEY);
		if (StringUtils.isEmpty(token)) {
			// 2. 从header中取
			token = request.getHeader(API_TOKEN_KEY);
		}
		if (StringUtils.isEmpty(token)) {
			// 3. 从cookie中取
			Cookie[] cookies = request.getCookies();
			for (Cookie cookie : cookies) {
				if (API_TOKEN_KEY.equals(cookie.getName())) {
					token = cookie.getValue();
				}
			}
		}
		return getJWTUser(token);
	}

}
--------------------------------------------------------------------------------------------------------
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInfo;

@DisplayName("TestInfo Demo")
class TestInfoDemo {

    TestInfoDemo(TestInfo testInfo) {
        assertEquals("TestInfo Demo", testInfo.getDisplayName());
    }

    @BeforeEach
    void init(TestInfo testInfo) {
        String displayName = testInfo.getDisplayName();
        assertTrue(displayName.equals("TEST 1") || displayName.equals("test2()"));
    }

    @Test
    @DisplayName("TEST 1")
    @Tag("my-tag")
    void test1(TestInfo testInfo) {
        assertEquals("TEST 1", testInfo.getDisplayName());
        assertTrue(testInfo.getTags().contains("my-tag"));
    }

    @Test
    void test2() {
    }

}
--------------------------------------------------------------------------------------------------------
class TestReporterDemo {

    @Test
    void reportSingleValue(TestReporter testReporter) {
        testReporter.publishEntry("a status message");
    }

    @Test
    void reportKeyValuePair(TestReporter testReporter) {
        testReporter.publishEntry("a key", "a value");
    }

    @Test
    void reportMultipleKeyValuePairs(TestReporter testReporter) {
        Map<String, String> values = new HashMap<>();
        values.put("user name", "dk38");
        values.put("award year", "1974");

        testReporter.publishEntry(values);
    }

}
--------------------------------------------------------------------------------------------------------
@ExtendWith(RandomParametersExtension.class)
class MyRandomParametersTest {

    @Test
    void injectsInteger(@Random int i, @Random int j) {
        assertNotEquals(i, j);
    }

    @Test
    void injectsDouble(@Random double d) {
        assertEquals(0.0, d, 1.0);
    }

}
--------------------------------------------------------------------------------------------------------
@ParameterizedTest
@NullSource
@EmptySource
@ValueSource(strings = { " ", "   ", "\t", "\n" })
void nullEmptyAndBlankStrings(String text) {
    assertTrue(text == null || text.trim().isEmpty());
}
--------------------------------------------------------------------------------------------------------
@ParameterizedTest
@NullAndEmptySource
@ValueSource(strings = { " ", "   ", "\t", "\n" })
void nullEmptyAndBlankStrings(String text) {
    assertTrue(text == null || text.trim().isEmpty());
}

@ParameterizedTest
@EnumSource(ChronoUnit.class)
void testWithEnumSource(TemporalUnit unit) {
    assertNotNull(unit);
}

@ParameterizedTest
@EnumSource
void testWithEnumSourceWithAutoDetection(ChronoUnit unit) {
    assertNotNull(unit);
}


--------------------------------------------------------------------------------------------------------
@ParameterizedTest
@EnumSource(mode = EXCLUDE, names = { "ERAS", "FOREVER" })
void testWithEnumSourceExclude(ChronoUnit unit) {
    assertFalse(EnumSet.of(ChronoUnit.ERAS, ChronoUnit.FOREVER).contains(unit));
}
@ParameterizedTest
@EnumSource(mode = MATCH_ALL, names = "^.*DAYS$")
void testWithEnumSourceRegex(ChronoUnit unit) {
    assertTrue(unit.name().endsWith("DAYS"));
}

@ParameterizedTest
@MethodSource("range")
void testWithRangeMethodSource(int argument) {
    assertNotEquals(9, argument);
}

static IntStream range() {
    return IntStream.range(0, 20).skip(10);
}

@ParameterizedTest
@MethodSource
void testWithDefaultLocalMethodSource(String argument) {
    assertNotNull(argument);
}

static Stream<String> testWithDefaultLocalMethodSource() {
    return Stream.of("apple", "banana");
}

@ParameterizedTest
@MethodSource("stringIntAndListProvider")
void testWithMultiArgMethodSource(String str, int num, List<String> list) {
    assertEquals(5, str.length());
    assertTrue(num >=1 && num <=2);
    assertEquals(2, list.size());
}

static Stream<Arguments> stringIntAndListProvider() {
    return Stream.of(
        arguments("apple", 1, Arrays.asList("a", "b")),
        arguments("lemon", 2, Arrays.asList("x", "y"))
    );
}


import java.util.stream.Stream;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

class ExternalMethodSourceDemo {

    @ParameterizedTest
    @MethodSource("example.StringsProviders#tinyStrings")
    void testWithExternalMethodSource(String tinyString) {
        // test with tiny string
    }
}

class StringsProviders {

    static Stream<String> tinyStrings() {
        return Stream.of(".", "oo", "OOO");
    }
}



@ParameterizedTest
@ArgumentsSource(MyArgumentsProvider.class)
void testWithArgumentsSource(String argument) {
    assertNotNull(argument);
}
public class MyArgumentsProvider implements ArgumentsProvider {

    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
        return Stream.of("apple", "banana").map(Arguments::of);
    }
}


@ParameterizedTest
@ValueSource(strings = "SECONDS")
void testWithImplicitArgumentConversion(ChronoUnit argument) {
    assertNotNull(argument.name());
}


@ParameterizedTest
@ValueSource(strings = { "01.01.2017", "31.12.2017" })
void testWithExplicitJavaTimeConverter(
        @JavaTimeConversionPattern("dd.MM.yyyy") LocalDate argument) {

    assertEquals(2017, argument.getYear());
}


@DisplayName("Display name of container")
@ParameterizedTest(name = "{index} ==> fruit=''{0}'', rank={1}")
@CsvSource({ "apple, 1", "banana, 2", "'lemon, lime', 3" })
void testWithCustomDisplayNames(String fruit, int rank) {
}


--------------------------------------------------------------------------------------------------------
import static example.util.StringUtils.isPalindrome;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.DynamicContainer.dynamicContainer;
import static org.junit.jupiter.api.DynamicTest.dynamicTest;

import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.function.Function;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import example.util.Calculator;

import org.junit.jupiter.api.DynamicNode;
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.TestFactory;
import org.junit.jupiter.api.function.ThrowingConsumer;

class DynamicTestsDemo {

    private final Calculator calculator = new Calculator();

    // This will result in a JUnitException!
    @TestFactory
    List<String> dynamicTestsWithInvalidReturnType() {
        return Arrays.asList("Hello");
    }

    @TestFactory
    Collection<DynamicTest> dynamicTestsFromCollection() {
        return Arrays.asList(
            dynamicTest("1st dynamic test", () -> assertTrue(isPalindrome("madam"))),
            dynamicTest("2nd dynamic test", () -> assertEquals(4, calculator.multiply(2, 2)))
        );
    }

    @TestFactory
    Iterable<DynamicTest> dynamicTestsFromIterable() {
        return Arrays.asList(
            dynamicTest("3rd dynamic test", () -> assertTrue(isPalindrome("madam"))),
            dynamicTest("4th dynamic test", () -> assertEquals(4, calculator.multiply(2, 2)))
        );
    }

    @TestFactory
    Iterator<DynamicTest> dynamicTestsFromIterator() {
        return Arrays.asList(
            dynamicTest("5th dynamic test", () -> assertTrue(isPalindrome("madam"))),
            dynamicTest("6th dynamic test", () -> assertEquals(4, calculator.multiply(2, 2)))
        ).iterator();
    }

    @TestFactory
    DynamicTest[] dynamicTestsFromArray() {
        return new DynamicTest[] {
            dynamicTest("7th dynamic test", () -> assertTrue(isPalindrome("madam"))),
            dynamicTest("8th dynamic test", () -> assertEquals(4, calculator.multiply(2, 2)))
        };
    }

    @TestFactory
    Stream<DynamicTest> dynamicTestsFromStream() {
        return Stream.of("racecar", "radar", "mom", "dad")
            .map(text -> dynamicTest(text, () -> assertTrue(isPalindrome(text))));
    }

    @TestFactory
    Stream<DynamicTest> dynamicTestsFromIntStream() {
        // Generates tests for the first 10 even integers.
        return IntStream.iterate(0, n -> n + 2).limit(10)
            .mapToObj(n -> dynamicTest("test" + n, () -> assertTrue(n % 2 == 0)));
    }

    @TestFactory
    Stream<DynamicTest> generateRandomNumberOfTests() {

        // Generates random positive integers between 0 and 100 until
        // a number evenly divisible by 7 is encountered.
        Iterator<Integer> inputGenerator = new Iterator<Integer>() {

            Random random = new Random();
            int current;

            @Override
            public boolean hasNext() {
                current = random.nextInt(100);
                return current % 7 != 0;
            }

            @Override
            public Integer next() {
                return current;
            }
        };

        // Generates display names like: input:5, input:37, input:85, etc.
        Function<Integer, String> displayNameGenerator = (input) -> "input:" + input;

        // Executes tests based on the current input value.
        ThrowingConsumer<Integer> testExecutor = (input) -> assertTrue(input % 7 != 0);

        // Returns a stream of dynamic tests.
        return DynamicTest.stream(inputGenerator, displayNameGenerator, testExecutor);
    }

    @TestFactory
    Stream<DynamicNode> dynamicTestsWithContainers() {
        return Stream.of("A", "B", "C")
            .map(input -> dynamicContainer("Container " + input, Stream.of(
                dynamicTest("not null", () -> assertNotNull(input)),
                dynamicContainer("properties", Stream.of(
                    dynamicTest("length > 0", () -> assertTrue(input.length() > 0)),
                    dynamicTest("not empty", () -> assertFalse(input.isEmpty()))
                ))
            )));
    }

    @TestFactory
    DynamicNode dynamicNodeSingleTest() {
        return dynamicTest("'pop' is a palindrome", () -> assertTrue(isPalindrome("pop")));
    }

    @TestFactory
    DynamicNode dynamicNodeSingleContainer() {
        return dynamicContainer("palindromes",
            Stream.of("racecar", "radar", "mom", "dad")
                .map(text -> dynamicTest(text, () -> assertTrue(isPalindrome(text)))
        ));
    }
}

@Test
@Timeout(5) // Poll at most 5 seconds
void pollUntil() throws InterruptedException {
    while (asynchronousResultNotAvailable()) {
        Thread.sleep(250); // custom poll interval
    }
    // Obtain the asynchronous result and perform assertions
}


--------------------------------------------------------------------------------------------------------
@Execution(CONCURRENT)
class SharedResourcesDemo {

    private Properties backup;

    @BeforeEach
    void backup() {
        backup = new Properties();
        backup.putAll(System.getProperties());
    }

    @AfterEach
    void restore() {
        System.setProperties(backup);
    }

    @Test
    @ResourceLock(value = SYSTEM_PROPERTIES, mode = READ)
    void customPropertyIsNotSetByDefault() {
        assertNull(System.getProperty("my.prop"));
    }

    @Test
    @ResourceLock(value = SYSTEM_PROPERTIES, mode = READ_WRITE)
    void canSetCustomPropertyToApple() {
        System.setProperty("my.prop", "apple");
        assertEquals("apple", System.getProperty("my.prop"));
    }

    @Test
    @ResourceLock(value = SYSTEM_PROPERTIES, mode = READ_WRITE)
    void canSetCustomPropertyToBanana() {
        System.setProperty("my.prop", "banana");
        assertEquals("banana", System.getProperty("my.prop"));
    }
}
--------------------------------------------------------------------------------------------------------
# Setting Hystrix timeout for the chain in 900ms (we have 3 more chained service calls).
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=900
# This property sets the minimum number of requests in a rolling window that will trip the circuit.
hystrix.command.default.circuitBreaker.requestVolumeThreshold=5
--------------------------------------------------------------------------------------------------------
import feign.RequestLine;

import java.util.List;

public interface HolaService {

	@RequestLine("GET /api/hola-chaining")
	public List<String> hola();

}

import org.springframework.boot.context.embedded.ServletRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;

@Configuration
public class HystrixServletConfiguration {

    @Bean
    public ServletRegistrationBean jerseyServlet() {
        ServletRegistrationBean registration = new ServletRegistrationBean(new HystrixMetricsStreamServlet(), "/hystrix.stream");
        return registration;
    }
}

https://www.keycloak.org/extensions.html
https://www.keycloak.org/

		<!-- OpenTracing -->
		<dependency>
			<groupId>io.opentracing</groupId>
			<artifactId>opentracing-noop</artifactId>
			<version>${io.opentracing.version}</version>
		</dependency>
		<dependency>
			<groupId>io.opentracing.contrib</groupId>
			<artifactId>opentracing-spring-web-autoconfigure</artifactId>
			<version>${io.opentracing.contrib.spring.autoconfigure.version}</version>
		</dependency>
				<!-- OpenTracing implementation - Jaeger -->
		<dependency>
			<groupId>com.uber.jaeger</groupId>
			<artifactId>jaeger-core</artifactId>
			<version>${version.jaeger}</version>
		</dependency>
		
https://www.programcreek.com/java-api-examples/index.php?project_name=redhat-helloworld-msa%2Fola#

	<!-- feign -->
		<dependency>
			<groupId>io.github.openfeign.opentracing</groupId>
			<artifactId>feign-hystrix-opentracing</artifactId>
			<version>${openfeign.opentracing.version}</version>
		</dependency>
		<dependency>
			<groupId>io.github.openfeign</groupId>
			<artifactId>feign-jackson</artifactId>
			<version>${openfeign.version}</version>
		</dependency>
		<dependency>
			<groupId>io.github.openfeign</groupId>
			<artifactId>feign-httpclient</artifactId>
			<version>${openfeign.version}</version>
		</dependency>
--------------------------------------------------------------------------------------------------------
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <version>1.4.196</version>
</dependency>
--------------------------------------------------------------------------------------------------------
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.extension.RegisterExtension;
import com.baeldung.extensions.EmployeeDatabaseSetupExtension;

public class MultipleExtensionsUnitTest {

    @Order(1)
    @RegisterExtension
    static EmployeeDatabaseSetupExtension SECOND_DB =
      new EmployeeDatabaseSetupExtension("jdbc:h2:mem:DbTwo;DB_CLOSE_DELAY=-1", "org.h2.Driver", "sa", "");

    @Order(0)
    @RegisterExtension
    static EmployeeDatabaseSetupExtension FIRST_DB =
      new EmployeeDatabaseSetupExtension("jdbc:h2:mem:DbOne;DB_CLOSE_DELAY=-1", "org.h2.Driver", "sa", "");

    @RegisterExtension
    static EmployeeDatabaseSetupExtension LAST_DB =
      new EmployeeDatabaseSetupExtension("jdbc:h2:mem:DbLast;DB_CLOSE_DELAY=-1", "org.h2.Driver", "sa", "");

    @Test
    public void justDemonstratingTheIdea() {
        // empty test
    }
}


import java.sql.SQLException;

import org.apache.logging.log4j.Logger;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import com.baeldung.extensions.EmployeeDaoParameterResolver;
import com.baeldung.extensions.EmployeeDatabaseSetupExtension;
import com.baeldung.extensions.EnvironmentExtension;
import com.baeldung.extensions.IgnoreFileNotFoundExceptionExtension;
import com.baeldung.extensions.LoggingExtension;
import com.baeldung.helpers.Employee;
import com.baeldung.helpers.EmployeeJdbcDao;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith({ EnvironmentExtension.class, EmployeeDatabaseSetupExtension.class, EmployeeDaoParameterResolver.class })
@ExtendWith(LoggingExtension.class)
@ExtendWith(IgnoreFileNotFoundExceptionExtension.class)
public class EmployeesUnitTest {

    private EmployeeJdbcDao employeeDao;

    private Logger logger;

    public EmployeesUnitTest(EmployeeJdbcDao employeeDao) {
        this.employeeDao = employeeDao;
    }

    @Test
    public void whenAddEmployee_thenGetEmployee() throws SQLException {
        Employee emp = new Employee(1, "john");
        employeeDao.add(emp);
        assertEquals(1, employeeDao.findAll()
            .size());
    }

    @Test
    public void whenGetEmployees_thenEmptyList() throws SQLException {
        assertEquals(0, employeeDao.findAll()
            .size());
    }

    public void setLogger(Logger logger) {
        this.logger = logger;
    }

}
--------------------------------------------------------------------------------------------------------
package com.baeldung.extensions;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Savepoint;

import org.junit.jupiter.api.extension.AfterAllCallback;
import org.junit.jupiter.api.extension.AfterEachCallback;
import org.junit.jupiter.api.extension.BeforeAllCallback;
import org.junit.jupiter.api.extension.BeforeEachCallback;
import org.junit.jupiter.api.extension.ExtensionContext;

import com.baeldung.helpers.EmployeeJdbcDao;
import com.baeldung.helpers.JdbcConnectionUtil;

public class EmployeeDatabaseSetupExtension implements BeforeAllCallback, AfterAllCallback, BeforeEachCallback, AfterEachCallback {

    private Connection con;
    private EmployeeJdbcDao employeeDao;
    private Savepoint savepoint;

    public EmployeeDatabaseSetupExtension() {
        con = JdbcConnectionUtil.getConnection();
        employeeDao = new EmployeeJdbcDao(con);
    }

    public EmployeeDatabaseSetupExtension(String jdbcUrl, String driver, String username, String password) {
        con = JdbcConnectionUtil.getConnection(jdbcUrl, driver, username, password);
        employeeDao = new EmployeeJdbcDao(con);
    }

    @Override
    public void afterAll(ExtensionContext context) throws SQLException {
        if (con != null) {
            con.close();
        }
    }

    @Override
    public void beforeAll(ExtensionContext context) throws SQLException {
        employeeDao.createTable();

    }

    @Override
    public void afterEach(ExtensionContext context) throws SQLException {
        con.rollback(savepoint);
    }

    @Override
    public void beforeEach(ExtensionContext context) throws SQLException {
        con.setAutoCommit(false);
        savepoint = con.setSavepoint("before");
    }

}
--------------------------------------------------------------------------------------------------------
#h2 db
jdbc.driver=org.h2.Driver
jdbc.url=jdbc:h2:mem:myDb;DB_CLOSE_DELAY=-1
jdbc.user=sa
jdbc.password=

jdbc.properties

import org.junit.platform.launcher.LauncherDiscoveryRequest;
import org.junit.platform.launcher.TestExecutionListener;
import org.junit.platform.launcher.TestPlan;
import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
import org.junit.platform.launcher.core.LauncherFactory;
import org.junit.platform.launcher.listeners.SummaryGeneratingListener;

import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;

import java.io.PrintWriter;

import org.junit.platform.launcher.Launcher;

public class TestLauncher {
    public static void main(String[] args) {

        //@formatter:off
        LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()
                .selectors(selectClass("com.baeldung.EmployeesUnitTest"))
                .configurationParameter("junit.conditions.deactivate", "com.baeldung.extensions.*")
                .configurationParameter("junit.jupiter.extensions.autodetection.enabled", "true")
                .build();
        
        //@formatter:on

        TestPlan plan = LauncherFactory.create().discover(request);
        Launcher launcher = LauncherFactory.create();
        SummaryGeneratingListener summaryGeneratingListener = new SummaryGeneratingListener();
        launcher.execute(request, new TestExecutionListener[] { summaryGeneratingListener });
        launcher.execute(request);

        summaryGeneratingListener.getSummary()
            .printTo(new PrintWriter(System.out));

    }
}

    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-surefire-plugin</artifactId>
        <version>3.0.0-M4</version>
        <configuration>
          <argLine>-Djava.security.manager -Djava.security.policy=${basedir}/src/test/resources/java.policy</argLine>
        </configuration>
      </plugin>
	  
	  https://maven.apache.org/surefire/maven-surefire-plugin/examples/junit.html

https://dzone.com/articles/junit-listener
-Djunit.conditions.deactivate=<pattern>

If we want to register an extension for all tests in our application, we can do so by adding the fully qualified name to the /META-INF/services/org.junit.jupiter.api.extension.Extension file:

com.baeldung.extensions.LoggingExtension

https://www.baeldung.com/junit-5-extensions

For this mechanism to be enabled, we also need to set the junit.jupiter.extensions.autodetection.enabled configuration key to true. This can be done by starting the JVM with the –Djunit.jupiter.extensions.autodetection.enabled=true property, or by adding a configuration parameter to LauncherDiscoveryRequest:

      <dependency>
            <groupId>org.powermock</groupId>
            <artifactId>powermock-module-junit4</artifactId>
            <version>${powermock.version}</version>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>junit</groupId>
                    <artifactId>junit</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
		
		      <dependency>
            <groupId>org.powermock</groupId>
            <artifactId>powermock-api-mockito2</artifactId>
            <version>${powermock.version}</version>
            <scope>test</scope>
        </dependency>
--------------------------------------------------------------------------------------------------------
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.ParameterContext;
import org.junit.jupiter.api.extension.ParameterResolutionException;
import org.junit.jupiter.api.extension.ParameterResolver;

import com.baeldung.helpers.EmployeeJdbcDao;
import com.baeldung.helpers.JdbcConnectionUtil;

public class EmployeeDaoParameterResolver implements ParameterResolver {

    @Override
    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
        return parameterContext.getParameter()
            .getType()
            .equals(EmployeeJdbcDao.class);
    }

    @Override
    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
        return new EmployeeJdbcDao(JdbcConnectionUtil.getConnection());
    }

}
--------------------------------------------------------------------------------------------------------
import static org.junit.Assert.assertEquals;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

@TestMethodOrder(OrderAnnotation.class)
public class OrderAnnotationUnitTest {
    private static StringBuilder output = new StringBuilder("");
    
    @Test
    @Order(1)    
    public void firstTest() {
        output.append("a");
    }
    
    @Test
    @Order(2)    
    public void secondTest() {
        output.append("b");
    }
 
    @Test
    @Order(3)    
    public void thirdTest() {
        output.append("c");
    }
 
    @AfterAll
    public static void assertOutput() {
        assertEquals(output.toString(), "abc");
    }
}

import org.junit.jupiter.api.MethodDescriptor;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.MethodOrdererContext;

public class CustomOrder implements MethodOrderer{
    @Override
    public void orderMethods(MethodOrdererContext context) {
        context.getMethodDescriptors().sort((MethodDescriptor m1, MethodDescriptor m2)->m1.getMethod().getName().compareToIgnoreCase(m2.getMethod().getName()));
    }
}
--------------------------------------------------------------------------------------------------------

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.reflect.Whitebox;

public class AbstractInstanceFieldsUnitTest {

    @Test
    public void givenProtectedInstanceField_whenMockClassCountGt5_thenTestNonAbstractMethod() {

        // mock
        AbstractInstanceFields instClass = Mockito.mock(AbstractInstanceFields.class);
        Mockito
          .doCallRealMethod()
          .when(instClass)
          .testFunc();

        // set counter greater than 5
        instClass.count = 7;

        // compare the result
        Assertions.assertEquals("Overflow", instClass.testFunc());
    }

    @Test
    public void givenNonAbstractMethodAndPrivateField_whenPowerMockitoAndActiveFieldTrue_thenCorrectBehaviour() {

        AbstractInstanceFields instClass = PowerMockito.mock(AbstractInstanceFields.class);
        PowerMockito
          .doCallRealMethod()
          .when(instClass)
          .testFunc();
        Whitebox.setInternalState(instClass, "active", true);

        // compare the expected result with actual
        Assertions.assertEquals("Added", instClass.testFunc());
    }

}
--------------------------------------------------------------------------------------------------------
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import org.junit.runner.RunWith;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;

import java.time.LocalDateTime;

/**
 * Providing custom values for private methods using powermock
 *
 */
@RunWith(PowerMockRunner.class)
@PrepareForTest(AbstractPrivateMethods.class)
public class AbstractPrivateMethodsUnitTest {

    @Test
    public void givenNonAbstractMethodAndCallPrivateMethod_whenMockPrivateMethod_thenVerifyBehaviour() throws Exception {
        AbstractPrivateMethods mockClass = PowerMockito.mock(AbstractPrivateMethods.class);

        String dateTime = LocalDateTime
          .now()
          .toString();
        PowerMockito
          .doCallRealMethod()
          .when(mockClass)
          .defaultImpl();
        PowerMockito
          .doReturn(dateTime)
          .when(mockClass, "getCurrentDateTime");// .thenReturn(dateTime);
        String actual = mockClass.defaultImpl();
        Assertions.assertEquals(dateTime + "DEFAULT-1", actual);
    }

}
--------------------------------------------------------------------------------------------------------
hystrix:
  command:
    default:
      # Setting Hystrix timeout for the chain in 900ms (we have 3 more chained service calls).
      execution.isolation.thread.timeoutInMilliseconds: 900
      # This property sets the minimum number of requests in a rolling window that will trip the circuit.
      circuitBreaker.requestVolumeThreshold: 5

hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds Maximum 5 seconds？
No more than 5 seconds。
For example：
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=10000
but It's only 5 seconds;

hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 10000
ribbon:
  ConnectTimeout: 3000
  ReadTimeout: 10000
  
hystrix:
   metrics:
     enabled: foo
     polling-interval-ms: foo
--------------------------------------------------------------------------------------------------------
@KubernetesApplication(
        livenessProbe = @Probe(httpActionPath = "/actuator/info"),
        readinessProbe = @Probe(httpActionPath = "/actuator/health")
)
@EnableServiceMonitor(path = "/prometheus", interval = 20)
@EnableJaegerAgent(operatorEnabled = true)

 

 

 

# my global config
global:
  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.
  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.
  # scrape_timeout is set to the global default (10s).

# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.
rule_files:
# - "first_rules.yml"
# - "second_rules.yml"

# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.
scrape_configs:
  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
  - job_name: 'prometheus'
    # metrics_path defaults to '/metrics'
    # scheme defaults to 'http'.
    static_configs:
      - targets: ['127.0.0.1:9090']

  - job_name: 'spring-actuator'
    metrics_path: '/actuator/prometheus'
    scrape_interval: 5s
    static_configs:
      - targets: ['HOST_IP:8080']
 

 

 

<!-- Kubernetes library dependencies -->
<dependency>
    <groupId>io.dekorate</groupId>
    <artifactId>kubernetes-annotations</artifactId>
    <version>${dekorate.version}</version>
</dependency>
<dependency>
    <groupId>io.dekorate</groupId>
    <artifactId>dekorate-spring-boot</artifactId>
    <version>${dekorate.version}</version>
</dependency>
<dependency>
    <groupId>io.dekorate</groupId>
    <artifactId>kubernetes-spring-starter</artifactId>
    <version>${dekorate.version}</version>
</dependency>
<dependency>
    <groupId>io.dekorate</groupId>
    <artifactId>dekorate-core</artifactId>
    <version>${dekorate.version}</version>
</dependency>
<dependency>
    <groupId>io.dekorate</groupId>
    <artifactId>option-annotations</artifactId>
    <version>${dekorate.version}</version>
</dependency>
<dependency>
    <groupId>io.dekorate</groupId>
    <artifactId>core-junit</artifactId>
    <version>${dekorate.version}</version>
</dependency>
<dependency>
    <groupId>io.dekorate</groupId>
    <artifactId>kubernetes-junit</artifactId>
    <version>${dekorate.version}</version>
</dependency>
<dependency>
    <groupId>io.dekorate</groupId>
    <artifactId>prometheus-annotations</artifactId>
    <version>${dekorate.version}</version>
</dependency>
<dependency>
    <groupId>io.dekorate</groupId>
    <artifactId>jaeger-annotations</artifactId>
    <version>${dekorate.version}</version>
</dependency>
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
    <version>1.0.9</version>
</dependency>
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
    <version>1.0.9</version>
</dependency>

<!-- Testing -->
<dependency>
    <groupId>io.dekorate</groupId>
    <artifactId>kubernetes-junit-starter</artifactId>
    <version>${dekorate.version}</version>
    <scope>test</scope>
</dependency>
--------------------------------------------------------------------------------------------------------
    @Bean
    public Tracer tracer() {
        return io.jaegertracing.Configuration.fromEnv(applicationName)
                .withSampler(
                        io.jaegertracing.Configuration.SamplerConfiguration.fromEnv()
                                .withType(ConstSampler.TYPE)
                                .withParam(1))
                .withReporter(
                        io.jaegertracing.Configuration.ReporterConfiguration.fromEnv()
                                .withLogSpans(true)
                                .withFlushInterval(1000)
                                .withMaxQueueSize(10000)
                                .withSender(
                                        new KafkaSenderConfiguration(bootstrapServers, tracingTopic)
                                ))
                .getTracer();
    }

    @PostConstruct
    public void registerToGlobalTracer() {
        if (!GlobalTracer.isRegistered()) {
            GlobalTracer.registerIfAbsent(tracer());
        }
    }

    @PostConstruct
    public void setClientSupplierForStreams() {
        streamsBuilderFactory.setClientSupplier(new TracingKafkaClientSupplier(tracer()));
    }
--------------------------------------------------------------------------------------------------------
import com.codahale.metrics.MetricRegistry;
import com.codahale.metrics.Timer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * A filter that records some metrics:
 * - Counting http requests for different methods and status
 * - Measuring response rates and times for different methods
 *
 * Created by guido on 08.06.16.
 * @since 0.60.0
 */
@Component
public class HttpMetricsFilter implements Filter {

    private final MetricRegistry metricRegistry;

    @Autowired
    public HttpMetricsFilter(final MetricRegistry metricRegistry) {
        this.metricRegistry = metricRegistry;
    }

    @Override
    public void init(final FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(final ServletRequest request, final ServletResponse response, FilterChain chain) throws IOException, ServletException {
        final String method = ((HttpServletRequest) request).getMethod().toLowerCase();
        final Timer.Context context = metricRegistry.timer("timer.http." + method).time();
        try {
            chain.doFilter(request, response);
        } finally {
            if (response != null) {
                final int status = ((HttpServletResponse) response).getStatus();
                metricRegistry.counter("counter.http." + method + "." + status).inc();
                context.stop();
            }
        }
    }

    @Override
    public void destroy() {
    }

}
--------------------------------------------------------------------------------------------------------
@ConditionalOnProperty(
        prefix = "edison.metrics.graphite",
        name = {"host", "port", "prefix"})
--------------------------------------------------------------------------------------------------------https://www.programcreek.com/java-api-examples/index.php?project_name=snicoll-scratches%2Fspring-boot-daemon#
--------------------------------------------------------------------------------------------------------
import io.jmnarloch.spring.boot.rxjava.async.ObservableDeferredResult;
import org.springframework.core.MethodParameter;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.context.request.async.WebAsyncUtils;
import org.springframework.web.method.support.AsyncHandlerMethodReturnValueHandler;
import org.springframework.web.method.support.ModelAndViewContainer;
import io.reactivex.Observable;

/**
 * A specialized {@link AsyncHandlerMethodReturnValueHandler} that handles {@link Observable} return types.
 *
 * @author Jakub Narloch
 * @see ObservableDeferredResult
 */
public class ObservableReturnValueHandler implements AsyncHandlerMethodReturnValueHandler {

    @Override
    public boolean isAsyncReturnValue(Object returnValue, MethodParameter returnType) {
        return returnValue != null && supportsReturnType(returnType);
    }

    @Override
    public boolean supportsReturnType(MethodParameter returnType) {
        return Observable.class.isAssignableFrom(returnType.getParameterType());
    }

    @SuppressWarnings("unchecked")
    @Override
    public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {

        if (returnValue == null) {
            mavContainer.setRequestHandled(true);
            return;
        }

        final Observable<?> observable = Observable.class.cast(returnValue);
        WebAsyncUtils.getAsyncManager(webRequest)
                .startDeferredResultProcessing(new ObservableDeferredResult(observable), mavContainer);
    }
}

import io.reactivex.Observable;
import io.reactivex.observers.DisposableObserver;
import org.springframework.web.context.request.async.DeferredResult;

/**
 * A subscriber that sets the single value produced by the {@link Observable} on the {@link DeferredResult}.
 *
 * @author Jakub Narloch
 * @author Robert Danci
 * @see DeferredResult
 */
class DeferredResultObserver<T> extends DisposableObserver<T> implements Runnable {

    private final DeferredResult<T> deferredResult;

    public DeferredResultObserver(Observable<T> observable, DeferredResult<T> deferredResult) {
        this.deferredResult = deferredResult;
        this.deferredResult.onTimeout(this);
        this.deferredResult.onCompletion(this);
        observable.subscribe(this);
    }

    @Override
    public void onNext(T value) {
        deferredResult.setResult(value);
    }

    @Override
    public void onError(Throwable e) {
        deferredResult.setErrorResult(e);
    }

    @Override
    public void onComplete() {
    }

    @Override
    public void run() {
        this.dispose();
    }
}

import org.springframework.util.Assert;
import org.springframework.web.context.request.async.DeferredResult;
import io.reactivex.Single;

/**
 * A specialized {@link DeferredResult} that handles {@link Single} return type.
 *
 * @author Jakub Narloch
 * @see DeferredResult
 */
public class SingleDeferredResult<T> extends DeferredResult<T> {

    private static final Object EMPTY_RESULT = new Object();

    private final DeferredResultObserver<T> observer;

    public SingleDeferredResult(Single<T> single) {
        this(null, EMPTY_RESULT, single);
    }

    public SingleDeferredResult(long timeout, Single<T> single) {
        this(timeout, EMPTY_RESULT, single);
    }

    public SingleDeferredResult(Long timeout, Object timeoutResult, Single<T> single) {
        super(timeout, timeoutResult);
        Assert.notNull(single, "single can not be null");

        observer = new DeferredResultObserver<T>(single.toObservable(), this);
    }
}
--------------------------------------------------------------------------------------------------------
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class GetHashMac {
    public static final String MAC_REGEX = "([0-9A-Fa-f]{2}[:-]){5}[0-9A-Fa-f]{2}";
    public static final String MAC_REGEX_ZERO = "([0]{2}[:-]){5}[0]{2}";
    public static final String HASHED_MAC_REGEX = "[0-9a-f]{64}";

    private GetHashMac() {
        super();
    }

    public static boolean isValidHashMacFormat(String hashMac) {
        if (hashMac == null || hashMac.isEmpty()) {
            return false;
        }

        final Pattern hashedMacPattern = Pattern.compile(HASHED_MAC_REGEX);
        final Matcher matcher = hashedMacPattern.matcher(hashMac);
        return matcher.matches();
    }

    public static String getHashMac() {
        final String rawMac = getRawMac();
        if (rawMac == null || rawMac.isEmpty()) {
            return null;
        }

        final Pattern pattern = Pattern.compile(MAC_REGEX);
        final Pattern patternZero = Pattern.compile(MAC_REGEX_ZERO);
        final Matcher matcher = pattern.matcher(rawMac);
        String mac = "";
        while (matcher.find()) {
            mac = matcher.group(0);
            if (!patternZero.matcher(mac).matches()) {
                break;
            }
        }

        return hash(mac);
    }

    private static String getRawMac() {
        final StringBuilder ret = new StringBuilder();

        final String os = System.getProperty("os.name");
        String[] command = {"ifconfig", "-a"};
        if (os != null && !os.isEmpty() && os.toLowerCase().startsWith("win")) {
            command = new String[]{"getmac"};
        }

        try {
            final ProcessBuilder builder = new ProcessBuilder(command);
            final Process process = builder.start();
            try (final InputStream inputStream = process.getInputStream();
                 final InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
                 final BufferedReader br = new BufferedReader(inputStreamReader)) {
                String tmp;
                while ((tmp = br.readLine()) != null) {
                    ret.append(tmp);
                }

            }
        } catch (IOException e) {
            return null;
        }

        return ret.toString();
    }

    private static String hash(String mac) {
        if (mac == null || mac.isEmpty()) {
            return null;
        }

        final String ret;
        try {
            final MessageDigest md = MessageDigest.getInstance("SHA-256");
            final byte[] bytes = mac.getBytes("UTF-8");
            md.update(bytes);
            final byte[] bytesAfterDigest = md.digest();
            final StringBuilder sb = new StringBuilder();
            for (int i = 0; i < bytesAfterDigest.length; i++) {
                sb.append(Integer.toString((bytesAfterDigest[i] & 0xff) + 0x100, 16).substring(1));
            }

            ret = sb.toString();
        } catch (NoSuchAlgorithmException | UnsupportedEncodingException ex) {
            return null;
        }

        return ret;
    }
}
import org.springframework.boot.SpringApplication;
import org.springframework.boot.env.EnvironmentPostProcessor;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.util.ClassUtils;

public class KeyVaultEnvironmentPostProcessor implements EnvironmentPostProcessor {

    @Override
    public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {

        if (isKeyVaultEnabled(environment)) {
            final KeyVaultEnvironmentPostProcessorHelper helper =
                    new KeyVaultEnvironmentPostProcessorHelper(environment);
            helper.addKeyVaultPropertySource();
        }
    }

    private boolean isKeyVaultEnabled(ConfigurableEnvironment environment){
        if (environment.getProperty(Constants.AZURE_CLIENTID) == null) {
            // User doesn't want to enable Key Vault property initializer.
            return false;
        }
        return environment.getProperty(Constants.AZURE_KEYVAULT_ENABLED, Boolean.class, true)
                && isKeyVaultClientAvailable();
    }

    private boolean isKeyVaultClientAvailable(){
        return ClassUtils.isPresent("com.microsoft.azure.keyvault.KeyVaultClient",
                KeyVaultEnvironmentPostProcessor.class.getClassLoader());
    }
}


import javax.servlet.MultipartConfigElement;

import org.springframework.boot.web.servlet.MultipartConfigFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MultipartConfig {

    @Bean
    public MultipartConfigElement multipartConfigElement(){
        MultipartConfigFactory factory = new MultipartConfigFactory();
        factory.setMaxFileSize("10MB");
        factory.setMaxRequestSize("10MB");
        return factory.createMultipartConfig();
    }

}

import java.util.HashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.ModelAndView;

/**
 * 全局异常处理配置
 * @author ZSX
 */
@Configuration
public class MyExceptionHandler implements HandlerExceptionResolver {
	
	private final static Log logger = LogFactory.getLog(MyExceptionHandler.class);

	/**
	 * 重写解析异常的处理
	 */
	@Override
	public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,
			Exception ex) {
		Map<String, Object> model = new HashMap<String, Object>();  
        model.put("ex", ex);  
        
        System.out.println(ex);
        
        response.setStatus(601); // 统一做跳转到登录页的处理
        // 根据不同错误转向不同页面  
        if(ex instanceof NumberFormatException) { 
        	logger.error("监听到了NumberFormat异常");
            return new ModelAndView("/login", model);  
        }else if(ex instanceof NullPointerException) {  
        	logger.error("监听到了空指针异常");
            return new ModelAndView("/login", model);  
        } else {  
        	logger.error("监听到了 other");
            return new ModelAndView("/login", model);  
        }
	}
}

import java.util.Map;

import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.server.HandshakeInterceptor;

public class WebSocketHandshakeInterceptor implements HandshakeInterceptor {
	@Override
	public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse shr1, WebSocketHandler wsh,
			Map<String, Object> attributes) throws Exception {
		// 此处可以做一些权限认证的事情或者其他
		return true;
	}

	@Override
	public void afterHandshake(ServerHttpRequest shr, ServerHttpResponse shr1, WebSocketHandler wsh, Exception excptn) {

	}
}


    private Specification<User> whereSpec(final User sample){
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();
            if (sample.getId()!=null){
                predicates.add(cb.equal(root.<Long>get("id"), sample.getId()));
            }

            if (StringUtils.hasLength(sample.getUsername())){
                predicates.add(cb.equal(root.<String>get("username"),sample.getUsername()));
            }

            return cb.and(predicates.toArray(new Predicate[predicates.size()]));
        };
    }
	
	import com.fasterxml.jackson.annotation.JsonInclude;

/**
 * Created by kaenry on 2016/9/20.
 * RestResult
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class RestResult<T> {

    private boolean result;

    private String message;

    private T data;

    private RestResult() {}

    public static <T> RestResult<T> newInstance() {
        return new RestResult<>();
    }

    public boolean isResult() {
        return result;
    }

    public void setResult(boolean result) {
        this.result = result;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    @Override
    public String toString() {
        return "RestResult{" +
                "result=" + result +
                ", message='" + message + '\'' +
                ", data=" + data +
                '}';
    }
}

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.MongoDbFactory;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.SimpleMongoDbFactory;
import org.springframework.util.StringUtils;

import com.mongodb.MongoClient;
import com.mongodb.MongoClientURI;

/**
 * mongodb 配置类
 * 
 * @author leftso
 *
 */
@Configuration
public class MongoDBConfig {
	@Autowired
	MongoProperty mongoProperties;

	/**
	 * 注入mongodb的工厂类
	 * 
	 * @return
	 */
	@Bean
	public MongoDbFactory mongoDbFactory() {
		// uri格式mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]
		String mongoURI = "mongodb://" + mongoProperties.getHost();
		if (!StringUtils.isEmpty(mongoProperties.getUser())) {
			mongoURI = "mongodb://" + mongoProperties.getUser() + ":" + mongoProperties.getPwd() + "@"
					+ mongoProperties.getHost();
		}
		// 为了方便实现mongodb多数据库和数据库的负债均衡这里使用url方式创建工厂
		MongoClientURI mongoClientURI = new MongoClientURI(mongoURI);
		MongoClient mongoClient = new MongoClient(mongoClientURI);
		MongoDbFactory mongoDbFactory = new SimpleMongoDbFactory(mongoClient, mongoProperties.getName());
		// 注意:以下构造函数已经弃用:
		// SimpleMongoDbFactory(com.mongodb.Mongo mongo, String databaseName);
		// 弃用版本1.7
		// SimpleMongoDbFactory(com.mongodb.Mongo mongo, String databaseName,
		// UserCredentials credentials);弃用版本1.7
		// SimpleMongoDbFactory(com.mongodb.Mongo mongo, String databaseName,
		// UserCredentials credentials, String
		// authenticationDatabaseName);弃用版本1.7
		// SimpleMongoDbFactory(com.mongodb.MongoURI uri);弃用版本1.7
		return mongoDbFactory;
	}

	/**
	 * 获取操作实例
	 * 
	 * @param mongoDbFactory
	 * @return
	 */
	@Bean
	public MongoTemplate mongoTemplate(MongoDbFactory mongoDbFactory) {
		return new MongoTemplate(mongoDbFactory);
	}

}
--------------------------------------------------------------------------------------------------------
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.DefaultTokenServices;
import org.springframework.security.oauth2.provider.token.ResourceServerTokenServices;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;
import org.springframework.security.web.util.matcher.RequestMatcher;

/**
 * 资源服务端
 * 
 * @author leftso
 *
 */
@Configuration
@EnableResourceServer
public class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {

	@Value("${resource.id:spring-boot-application}")
	private String resourceId;

	@Override
	public void configure(ResourceServerSecurityConfigurer resources) {
		// @formatter:off
		resources.resourceId(resourceId);
		resources.tokenServices(defaultTokenServices());
		// @formatter:on
	}

	@Override
	public void configure(HttpSecurity http) throws Exception {
		// @formatter:off
		http.requestMatcher(new OAuthRequestedMatcher()).authorizeRequests().antMatchers(HttpMethod.OPTIONS).permitAll()
				.anyRequest().authenticated();
		// @formatter:on
	}

	private static class OAuthRequestedMatcher implements RequestMatcher {
		public boolean matches(HttpServletRequest request) {
			String auth = request.getHeader("Authorization");
			// Determine if the client request contained an OAuth Authorization
			boolean haveOauth2Token = (auth != null) && auth.startsWith("Bearer");
			boolean haveAccessToken = request.getParameter("access_token") != null;
			return haveOauth2Token || haveAccessToken;
		}
	}

	// ===================================================以下代码与认证服务器一致=========================================
	/**
	 * token存储,这里使用jwt方式存储
	 * 
	 * @param accessTokenConverter
	 * @return
	 */
	@Bean
	public TokenStore tokenStore() {
		TokenStore tokenStore = new JwtTokenStore(accessTokenConverter());
		return tokenStore;
	}

	/**
	 * Token转换器必须与认证服务一致
	 * 
	 * @return
	 */
	@Bean
	public JwtAccessTokenConverter accessTokenConverter() {
		JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter() {
//			/***
//			 * 重写增强token方法,用于自定义一些token返回的信息
//			 */
//			@Override
//			public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {
//				String userName = authentication.getUserAuthentication().getName();
//				User user = (User) authentication.getUserAuthentication().getPrincipal();// 与登录时候放进去的UserDetail实现类一直查看link{SecurityConfiguration}
//				/** 自定义一些token属性 ***/
//				final Map<String, Object> additionalInformation = new HashMap<>();
//				additionalInformation.put("userName", userName);
//				additionalInformation.put("roles", user.getAuthorities());
//				((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInformation);
//				OAuth2AccessToken enhancedToken = super.enhance(accessToken, authentication);
//				return enhancedToken;
//			}

		};
		accessTokenConverter.setSigningKey("123");// 测试用,授权服务使用相同的字符达到一个对称加密的效果,生产时候使用RSA非对称加密方式
		return accessTokenConverter;
	}

	/**
	 * 创建一个默认的资源服务token
	 * 
	 * @return
	 */
	@Bean
	public ResourceServerTokenServices defaultTokenServices() {
		final DefaultTokenServices defaultTokenServices = new DefaultTokenServices();
		defaultTokenServices.setTokenEnhancer(accessTokenConverter());
		defaultTokenServices.setTokenStore(tokenStore());
		return defaultTokenServices;
	}
	// ===================================================以上代码与认证服务器一致=========================================
}
--------------------------------------------------------------------------------------------------------
server.port=18080

spring.datasource.url=jdbc:sqlite:demo.db
spring.datasource.driverClassName=org.sqlite.JDBC
#spring.jpa.database=SQLite

spring.jpa.database-platform=SQLite
spring.jpa.show-sql=true
spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=update
spring.jpa.hibernate.naming-strategy=org.hibernate.cfg.ImprovedNamingStrategy
spring.jpa.properties.hibernate.dialect=com.enigmabridge.hibernate.dialect.SQLiteDialect
--------------------------------------------------------------------------------------------------------
import javax.jms.ConnectionFactory;
import javax.jms.JMSException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.boot.actuate.health.Status;
import org.springframework.stereotype.Component;

@Component
public class ActiveMQHealth implements HealthIndicator {

	private ConnectionFactory factory;

	@Autowired
	public ActiveMQHealth(ConnectionFactory factory) {
		this.factory = factory;
	}

	@Override
	public Health health() {
		try {
			factory.createConnection();
		} catch (JMSException e) {
			return new Health.Builder()
					.down(e)
					.build();
		}
		return new Health.Builder()
				.status(Status.UP + ": Successfully connected to the broker")
				.build();
	}
}
--------------------------------------------------------------------------------------------------------
case 22 :
				return "ssh";
			case 23 :
				return "telnet";
			case 25 :
				return "smtp";
			case 80 :
				return "http-get /";
			case 110 :
				return "pop3";
			case 119 :
				return "nntp";
			case 143 :
				return "imap";
			case 194 :
				return "irc";
			case 220 :
				return "imap";
			case 443 :
				return "https-get /";
			case 445 :
				return "smb";
			case 2401 :
				return "cvs";
			case 3050 :
				return "firebird";
			case 3306 :
				return "mysql";
			case 3690 :
				return "svn";
			case 5222 :
				return "xmpp";
			case 5269 :
				return "xmpp";
			case 5432 :
				return "postgres";
			case 8010 :
				return "xmpp";
			case 8080 :
				return "http-get /";
			default :
				//return "http-get /";
				return null;
--------------------------------------------------------------------------------------------------------

import javax.servlet.annotation.WebInitParam;
import javax.servlet.annotation.WebServlet;

import com.alibaba.druid.support.http.StatViewServlet;

/**
 * Druid的Servlet
 * @author Raye
 * @since 2016年10月7日14:13:39
 */
@SuppressWarnings("serial")
@WebServlet(urlPatterns = "/druid/*", 
initParams={
        @WebInitParam(name="allow",value="127.0.0.1,192.168.1.126"),// IP白名单 (没有配置或者为空，则允许所有访问)
        @WebInitParam(name="loginUsername",value="Raye"),// 用户名
        @WebInitParam(name="loginPassword",value="123456"),// 密码
        @WebInitParam(name="resetEnable",value="false")// 禁用HTML页面上的“Reset All”功能
})
public class DruidStatViewServlet extends StatViewServlet {


}
--------------------------------------------------------------------------------------------------------
cd file-source

curl -X POST -H "Content-Type: application/json" --data @file-source.json http://localhost:8083/connectors

kafka-console-consumer --bootstrap-server localhost:9092 --topic first-topic --from-beginning

curl http://localhost:8083/connectors
--------------------------------------------------------------------------------------------------------
adb -s 7f1c864e shell
-d - Direct an adb command to the only attached USB device. Returns an error when more than one USB device is attached.

-e - Direct an adb command to the only running emulator. Returns an error when more than one emulator is running.

adb kill-server
adb devices

adb devices | while read line
do
if [ ! "$line" = "" ] && [ `echo $line | awk '{print $2}'` = "device" ]
then
    device=`echo $line | awk '{print $1}'`
    echo "$device $@ ..."
    adb -s $device $@
fi
--------------------------------------------------------------------------------------------------------
buildscript {
    ext {
        springBootVersion = '2.0.4.RELEASE'
    }
    repositories {
        jcenter()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
    }
}

apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'

group = 'com.github.burkaa01'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '1.8'

repositories {
    mavenCentral()
    maven {
        url "http://packages.confluent.io/maven/"
    }
}

dependencies {
    // spring
    implementation 'org.springframework.boot:spring-boot-starter'

    // kafka
    implementation 'org.springframework.kafka:spring-kafka'
    implementation "org.apache.kafka:kafka-clients:2.1.0"
    implementation "org.apache.kafka:kafka-streams:2.1.0"
    implementation 'io.opentracing.contrib:opentracing-kafka-client:0.0.16'
    implementation 'io.opentracing.contrib:opentracing-kafka-streams:0.0.16'
    implementation 'io.opentracing.contrib:opentracing-kafka-spring:0.0.16'

    // jaeger
    implementation 'io.jaegertracing:jaeger-client:0.33.1'
}
--------------------------------------------------------------------------------------------------------
import java.util.LinkedList;
import java.util.List;

public class Exceptions {
    private Exceptions() {
    }

    /**
     * Throws the argument, return-type is RuntimeException so the caller can use a throw statement break out of the method
     */
    public static RuntimeException sneakyThrow(Throwable t) {
        return Exceptions.<RuntimeException>doThrow(t);
    }

    private static <T extends Throwable> T doThrow(Throwable ex) throws T {
        throw (T) ex;
    }
}

--------------------------------------------------------------------------------------------------------
public class EmployeeDaoParameterResolver implements ParameterResolver {
 
    @Override
    public boolean supportsParameter(ParameterContext parameterContext, 
      ExtensionContext extensionContext) throws ParameterResolutionException {
        return parameterContext.getParameter().getType()
          .equals(EmployeeJdbcDao.class);
    }
 
    @Override
    public Object resolveParameter(ParameterContext parameterContext, 
      ExtensionContext extensionContext) throws ParameterResolutionException {
        return new EmployeeJdbcDao();
    }
}
--------------------------------------------------------------------------------------------------------
    /**
     *
     * This is were the "magic" happens: it creates a Feign, which is a proxy interface for remote calling a
     * REST endpoint with Hystrix fallback support.
     */
    @Bean
    public HolaService holaService(Tracer tracer) {
        // bind current span to Hystrix thread
        TracingConcurrencyStrategy.register();

        return HystrixFeign.builder()
                .client(new TracingClient(new ApacheHttpClient(HttpClientBuilder.create().build()), tracer))
                .logger(new Logger.ErrorLogger()).logLevel(Logger.Level.BASIC)
                .decoder(new JacksonDecoder())
                .target(HolaService.class, "http://hola:8080/",
                        () -> Collections.singletonList("Hola response (fallback)"));
    }
--------------------------------------------------------------------------------------------------------
import org.junit.platform.runner.JUnitPlatform;
import org.junit.platform.suite.api.SelectPackages;
import org.junit.platform.suite.api.SuiteDisplayName;
import org.junit.runner.RunWith;

@RunWith(JUnitPlatform.class)
@SuiteDisplayName("JUnit Platform Suite Demo")
@SelectPackages("example")
public class JUnitPlatformSuiteDemo {
}
--------------------------------------------------------------------------------------------------------
   <plugins>
        <plugin>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>2.22.2</version>
            <configuration>
                <groups>acceptance | !feature-a</groups>
                <excludedGroups>integration, regression</excludedGroups>
            </configuration>
        </plugin>
    </plugins>
--------------------------------------------------------------------------------------------------------
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

@TestMethodOrder(OrderAnnotation.class)
class OrderedTestsDemo {

    @Test
    @Order(1)
    void nullValues() {
        // perform assertions against null values
    }

    @Test
    @Order(2)
    void emptyValues() {
        // perform assertions against empty values
    }

    @Test
    @Order(3)
    void validValues() {
        // perform assertions against valid values
    }

}
--------------------------------------------------------------------------------------------------------

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import com.alibaba.fastjson.JSONObject;

import seed.config.APIProperties;
import seed.consts.CodeConsts;
import seed.utils.RequestUtil;
import seed.utils.ResponseUtil;


public class JWTTokenInterceptor implements HandlerInterceptor {

    private static final Logger logger = LoggerFactory.getLogger(JWTTokenInterceptor.class);

    private APIProperties props;
    
    public APIProperties getProps() {
		return props;
	}
    
    public void setProps(APIProperties props) {
		this.props = props;
	}
    
    /**
     * 如果是api的请求，做过滤，否则不做过滤
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        final String url = request.getRequestURI();
        //路径没有以/api作前缀，则直接返回
        if(!url.startsWith(props.getPrefix())){
            return true;
        }
        //路径是否为不需要处理的路径
        for(String uri : this.props.getExcludeUrls()){
            if(url.startsWith(uri)){
                return true;
            }
        }
        try {
            JWTUser user = JWT.getJWTUser(request);
            if(user!=null){
                return true;
            }
        }catch(JWTException e){
            logger.error("校验token失败!",e);
        }
        JSONObject result = new JSONObject();
        result.put(CodeConsts.CODE_KEY, CodeConsts.CODE_UNLOGIN);
        result.put(CodeConsts.MSG_KEY, "未登陆！");
        ResponseUtil.json(response, RequestUtil.getJsonContentType(request), result);
        return false;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }

}
--------------------------------------------------------------------------------------------------------

package de.otto.edison.metrics.configuration;

import com.codahale.metrics.MetricRegistry;
import com.codahale.metrics.Slf4jReporter;
import com.ryantenney.metrics.spring.config.annotation.EnableMetrics;
import com.ryantenney.metrics.spring.config.annotation.MetricsConfigurerAdapter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import static com.codahale.metrics.Slf4jReporter.LoggingLevel.INFO;
import static java.util.concurrent.TimeUnit.MINUTES;
import static org.slf4j.LoggerFactory.getLogger;

@Configuration
@EnableMetrics
@EnableConfigurationProperties(MetricsProperties.class)
@ConditionalOnProperty(name = "edison.metrics.slf4j.logger")
public class Slf4JReporterConfiguration extends MetricsConfigurerAdapter {

    private final MetricsProperties.Slf4j slf4jProperties;

    @Autowired
    public Slf4JReporterConfiguration(final MetricsProperties metricsProperties) {
        this.slf4jProperties = metricsProperties.getSlf4j();
    }

    @Override
    public void configureReporters(final MetricRegistry metricRegistry) {
        Slf4jReporter
                .forRegistry(metricRegistry)
                .outputTo(getLogger(slf4jProperties.getLogger()))
                .withLoggingLevel(INFO)
                .build()
                .start(slf4jProperties.getPeriod(), MINUTES);
    }
import java.util.Arrays;

@Configuration
@EnableConfigurationProperties(LoggingProperties.class)
public class LoggingConfiguration {

    @Bean
    @ConditionalOnProperty(prefix = "edison.logging", name = "header.enabled")
    public LogHeadersToMDCFilter logHeadersToMDCFilter(final LoggingProperties properties) {
        return new LogHeadersToMDCFilter(Arrays.asList(properties.getHeader().getNames().split(",")));
    }
}



@JsonSerialize(using = ToStringSerializer.class)
--------------------------------------------------------------------------------------------------------
https://www.programcreek.com/java-api-examples/index.php?project_name=otto-de%2Fedison-microservice#
--------------------------------------------------------------------------------------------------------
./kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list

./kafka-consumer-groups.sh --bootstrap-server localhost:9092 --group <your group name> --describe

kafka-consumer-offset-checker.bat --group group-1 --topic testing-1 --zookeeper localhost:2181
--------------------------------------------------------------------------------------------------------
public class SimpleProducer {
public static void main(String[] args) throws InterruptedException {
    Properties props = new Properties();
    props.put("bootstrap.servers", "localhost:9094");
    props.put("acks", "all");
    props.put("retries", 0);
    props.put("batch.size", 16384);
    props.put("linger.ms", 1);
    props.put("buffer.memory", 33554432);
    props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
    props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

    Producer<String, String> producer = new KafkaProducer<>(props);
    for(int i = 0; i < 10; i++)
        producer.send(new ProducerRecord<String, String>("topic3", Integer.toString(i), Integer.toString(i)));

    producer.close();

}}

public class SimpleConsumer {

public static void main(String[] args) {
    Properties props = new Properties();
    props.put("bootstrap.servers", "localhost:9094");
    props.put("group.id", "test");
    props.put("zookeeper.connect", "localhost:2181");
    props.put("enable.auto.commit", "true");
    props.put("auto.commit.interval.ms", "1000");
    props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
    props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
    KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);
    consumer.subscribe(Arrays.asList("topic3", "topic2"));
    while (true) {
        ConsumerRecords<String, String> records = consumer.poll(100);
        for (ConsumerRecord<String, String> record : records)
            System.out.printf("offset = %d, key = %s, value = %s%n", record.offset(), record.key(), record.value());
    }
}}
--------------------------------------------------------------------------------------------------------
com.sun.security.auth.module.Krb5LoginModule required
useTicketCache=false
useKeyTab=true
storeKey=true
keyTab="path to the file.keytab"
principal="kafka/ip-10-197-17-69.eu-west-1.compute.internal@DOMAIN"

And try to change the consumer config:

security.protocol=SASL_PLAINTEXT
sasl.mechanism=GSSAPI
sasl.kerberos.service.name=kafka



cat >/root/client.properties<<EOF
security.protocol=SASL_SSL
sasl.kerberos.service.name=kafka
ssl.client.auth=none
ssl.truststore.location=/etc/cdep-ssl-conf/CA_STANDARD/truststore.jks
ssl.truststore.password=cloudera
EOF

cat >/root/jaas.conf<<EOF
KafkaClient {
com.sun.security.auth.module.Krb5LoginModule required
useKeyTab=true
storeKey=false
useTicketCache=true
keyTab="/cdep/keytabs/kafka.keytab"
principal="kafka@EXAMPLE.CLOUDERA.COM";
};
EOF

KAFKA_OPTS="-Djava.security.auth.login.config=/root/jaas.conf" kafka-console-producer --broker-list ${HOSTNAME}:9093 --topic test --producer.config /root/client.properties
--------------------------------------------------------------------------------------------------------
  @Bean
    @ConditionalOnMissingBean(CodecRegistry.class)
    public CodecRegistry codecRegistry() {
        return MongoClient.getDefaultCodecRegistry();
    }

    @Bean
    @Primary
    @ConditionalOnMissingBean(name = "mongoClient", value = MongoClient.class)
    public MongoClient mongoClient(final MongoProperties mongoProperties) {
        LOG.info("Creating MongoClient");
        return new MongoClient(mongoProperties.getServers(), getMongoCredentials(mongoProperties),
                mongoProperties.toMongoClientOptions(codecRegistry()));
    }

    @Bean
    @Primary
    @ConditionalOnMissingBean(name = "mongoDatabase", value = MongoDatabase.class)
    public MongoDatabase mongoDatabase(final MongoClient mongoClient, final MongoProperties mongoProperties) {
        return mongoClient.getDatabase(mongoProperties.getDb());
    }
	
	https://www.programcreek.com/java-api-examples/index.php?project_name=otto-de%2Fedison-microservice#
--------------------------------------------------------------------------------------------------------
netsh wlan show profile <profile> key=clear
--------------------------------------------------------------------------------------------------------
while pgrep &>/dev/null -f Tool-X; do sleep 60; done; shutdown -h now
--------------------------------------------------------------------------------------------------------
			return "ie7";
		} else if (agent.indexOf("msie 8") > 0) {
			return "ie8";
		} else if (agent.indexOf("msie 9") > 0) {
			return "ie9";
		} else if (agent.indexOf("msie 10") > 0) {
			return "ie10";
		} else if (agent.indexOf("msie") > 0) {
			return "ie";
		} else if (agent.indexOf("opera") > 0) {
			return "opera";
		} else if (agent.indexOf("opera") > 0) {
			return "opera";
		} else if (agent.indexOf("firefox") > 0) {
			return "firefox";
		} else if (agent.indexOf("webkit") > 0) {
			return "webkit";
		} else if (agent.indexOf("gecko") > 0 && agent.indexOf("rv:11") > 0) {
			return "ie11";
		} else {
			return "Others";
		}
	}
--------------------------------------------------------------------------------------------------------
import java.io.FilterWriter;
import java.io.IOException;
import java.io.Writer;

/**
 * Writer that wraps another writer and passes width-limited and
 * optionally-prefixed output to its subordinate. When lines are
 * wrapped they are automatically indented based on the start of the
 * line.
 */
public final class WrappedIndentingWriter extends FilterWriter {
    /** null-ok; optional prefix for every line */
    private final String prefix;

    /** &gt; 0; the maximum output width */
    private final int width;

    /** &gt; 0; the maximum indent */
    private final int maxIndent;

    /** &gt;= 0; current output column (zero-based) */
    private int column;

    /** whether indent spaces are currently being collected */
    private boolean collectingIndent;

    /** &gt;= 0; current indent amount */
    private int indent;

    /**
     * Constructs an instance.
     *
     * @param out non-null; writer to send final output to
     * @param width &gt;= 0; the maximum output width (not including
     * <code>prefix</code>), or <code>0</code> for no maximum
     * @param prefix non-null; the prefix for each line
     */
    public WrappedIndentingWriter(Writer out, int width, String prefix) {
        super(out);

        if (out == null) {
            throw new NullPointerException("out == null");
        }

        if (width < 0) {
            throw new IllegalArgumentException("width < 0");
        }

        if (prefix == null) {
            throw new NullPointerException("prefix == null");
        }

        this.width = (width != 0) ? width : Integer.MAX_VALUE;
        this.maxIndent = width >> 1;
        this.prefix = (prefix.length() == 0) ? null : prefix;

        bol();
    }

    /**
     * Constructs a no-prefix instance.
     *
     * @param out non-null; writer to send final output to
     * @param width &gt;= 0; the maximum output width (not including
     * <code>prefix</code>), or <code>0</code> for no maximum
     */
    public WrappedIndentingWriter(Writer out, int width) {
        this(out, width, "");
    }

    /** {@inheritDoc} */
    @Override
    public void write(int c) throws IOException {
        synchronized (lock) {
            if (collectingIndent) {
                if (c == ' ') {
                    indent++;
                    if (indent >= maxIndent) {
                        indent = maxIndent;
                        collectingIndent = false;
                    }
                } else {
                    collectingIndent = false;
                }
            }

            if ((column == width) && (c != '\n')) {
                out.write('\n');
                column = 0;
                /*
                 * Note: No else, so this should fall through to the next
                 * if statement.
                 */
            }

            if (column == 0) {
                if (prefix != null) {
                    out.write(prefix);
                }

                if (!collectingIndent) {
                    for (int i = 0; i < indent; i++) {
                        out.write(' ');
                    }
                    column = indent;
                }
            }

            out.write(c);

            if (c == '\n') {
                bol();
            } else {
                column++;
            }
        }
    }

    /** {@inheritDoc} */
    @Override
    public void write(char[] cbuf, int off, int len) throws IOException {
        synchronized (lock) {
            while (len > 0) {
                write(cbuf[off]);
                off++;
                len--;
            }
        }
    }

    /** {@inheritDoc} */
    @Override
    public void write(String str, int off, int len) throws IOException {
        synchronized (lock) {
            while (len > 0) {
                write(str.charAt(off));
                off++;
                len--;
            }
        }
    }

    /**
     * Indicates that output is at the beginning of a line.
     */
    private void bol() {
        column = 0;
        collectingIndent = (maxIndent != 0);
        indent = 0;
    }
}

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/**
 * Constants of type <code>CONSTANT_Utf8_info</code>.
 */
public final class Utf8Utils {
    /**
     * Converts a string into its Java-style UTF-8 form. Java-style UTF-8
     * differs from normal UTF-8 in the handling of character '\0' and
     * surrogate pairs.
     *
     * @param string non-null; the string to convert
     * @return non-null; the UTF-8 bytes for it
     */
    public static byte[] stringToUtf8Bytes(String string) {
        int len = string.length();
        byte[] bytes = new byte[len * 3]; // Avoid having to reallocate.
        int outAt = 0;

        for (int i = 0; i < len; i++) {
            char c = string.charAt(i);
            if ((c != 0) && (c < 0x80)) {
                bytes[outAt] = (byte) c;
                outAt++;
            } else if (c < 0x800) {
                bytes[outAt] = (byte) (((c >> 6) & 0x1f) | 0xc0);
                bytes[outAt + 1] = (byte) ((c & 0x3f) | 0x80);
                outAt += 2;
            } else {
                bytes[outAt] = (byte) (((c >> 12) & 0x0f) | 0xe0);
                bytes[outAt + 1] = (byte) (((c >> 6) & 0x3f) | 0x80);
                bytes[outAt + 2] = (byte) ((c & 0x3f) | 0x80);
                outAt += 3;
            }
        }

        byte[] result = new byte[outAt];
        System.arraycopy(bytes, 0, result, 0, outAt);
        return result;
    }

    private static final ThreadLocal<char[]> localBuffer =
            new ThreadLocal<char[]> () {
                @Override protected char[] initialValue() {
                    // A reasonably sized initial value
                    return new char[256];
                }
            };

    /**
     * Converts an array of UTF-8 bytes into a string.
     *
     * @param bytes non-null; the bytes to convert
     * @param start the start index of the utf8 string to convert
     * @param length the length of the utf8 string to convert, not including any null-terminator that might be present
     * @return non-null; the converted string
     */
    public static String utf8BytesToString(byte[] bytes, int start, int length) {
        char[] chars = localBuffer.get();
        if (chars == null || chars.length < length) {
            chars = new char[length];
            localBuffer.set(chars);
        }
        int outAt = 0;

        for (int at = start; length > 0; /*at*/) {
            int v0 = bytes[at] & 0xFF;
            char out;
            switch (v0 >> 4) {
                case 0x00: case 0x01: case 0x02: case 0x03:
                case 0x04: case 0x05: case 0x06: case 0x07: {
                    // 0XXXXXXX -- single-byte encoding
                    length--;
                    if (v0 == 0) {
                        // A single zero byte is illegal.
                        return throwBadUtf8(v0, at);
                    }
                    out = (char) v0;
                    at++;
                    break;
                }
                case 0x0c: case 0x0d: {
                    // 110XXXXX -- two-byte encoding
                    length -= 2;
                    if (length < 0) {
                        return throwBadUtf8(v0, at);
                    }
                    int v1 = bytes[at + 1] & 0xFF;
                    if ((v1 & 0xc0) != 0x80) {
                        return throwBadUtf8(v1, at + 1);
                    }
                    int value = ((v0 & 0x1f) << 6) | (v1 & 0x3f);
                    if ((value != 0) && (value < 0x80)) {
                        /*
                         * This should have been represented with
                         * one-byte encoding.
                         */
                        return throwBadUtf8(v1, at + 1);
                    }
                    out = (char) value;
                    at += 2;
                    break;
                }
                case 0x0e: {
                    // 1110XXXX -- three-byte encoding
                    length -= 3;
                    if (length < 0) {
                        return throwBadUtf8(v0, at);
                    }
                    int v1 = bytes[at + 1] & 0xFF;
                    if ((v1 & 0xc0) != 0x80) {
                        return throwBadUtf8(v1, at + 1);
                    }
                    int v2 = bytes[at + 2] & 0xFF;
                    if ((v2 & 0xc0) != 0x80) {
                        return throwBadUtf8(v2, at + 2);
                    }
                    int value = ((v0 & 0x0f) << 12) | ((v1 & 0x3f) << 6) |
                            (v2 & 0x3f);
                    if (value < 0x800) {
                        /*
                         * This should have been represented with one- or
                         * two-byte encoding.
                         */
                        return throwBadUtf8(v2, at + 2);
                    }
                    out = (char) value;
                    at += 3;
                    break;
                }
                default: {
                    // 10XXXXXX, 1111XXXX -- illegal
                    return throwBadUtf8(v0, at);
                }
            }
            chars[outAt] = out;
            outAt++;
        }

        return new String(chars, 0, outAt);
    }

    /**
     * Converts an array of UTF-8 bytes into a string.
     *
     * @param bytes non-null; the bytes to convert
     * @param start the start index of the utf8 string to convert
     * @param utf16Length the number of utf16 characters in the string to decode
     * @return non-null; the converted string
     */
    public static String utf8BytesWithUtf16LengthToString(@Nonnull byte[] bytes, int start, int utf16Length) {
        return utf8BytesWithUtf16LengthToString(bytes, start, utf16Length, null);
    }

    /**
     * Converts an array of UTF-8 bytes into a string.
     *
     * @param bytes non-null; the bytes to convert
     * @param start the start index of the utf8 string to convert
     * @param utf16Length the number of utf16 characters in the string to decode
     * @param readLength If non-null, the first element will contain the number of bytes read after the method exits
     * @return non-null; the converted string
     */
    public static String utf8BytesWithUtf16LengthToString(@Nonnull byte[] bytes, int start, int utf16Length,
                                                          @Nullable int[] readLength) {
        char[] chars = localBuffer.get();
        if (chars == null || chars.length < utf16Length) {
            chars = new char[utf16Length];
            localBuffer.set(chars);
        }
        int outAt = 0;

        int at = 0;
        for (at = start; utf16Length > 0; utf16Length--) {
            int v0 = bytes[at] & 0xFF;
            char out;
            switch (v0 >> 4) {
                case 0x00: case 0x01: case 0x02: case 0x03:
                case 0x04: case 0x05: case 0x06: case 0x07: {
                    // 0XXXXXXX -- single-byte encoding
                    if (v0 == 0) {
                        // A single zero byte is illegal.
                        return throwBadUtf8(v0, at);
                    }
                    out = (char) v0;
                    at++;
                    break;
                }
                case 0x0c: case 0x0d: {
                    // 110XXXXX -- two-byte encoding
                    int v1 = bytes[at + 1] & 0xFF;
                    if ((v1 & 0xc0) != 0x80) {
                        return throwBadUtf8(v1, at + 1);
                    }
                    int value = ((v0 & 0x1f) << 6) | (v1 & 0x3f);
                    if ((value != 0) && (value < 0x80)) {
                        /*
                         * This should have been represented with
                         * one-byte encoding.
                         */
                        return throwBadUtf8(v1, at + 1);
                    }
                    out = (char) value;
                    at += 2;
                    break;
                }
                case 0x0e: {
                    // 1110XXXX -- three-byte encoding
                    int v1 = bytes[at + 1] & 0xFF;
                    if ((v1 & 0xc0) != 0x80) {
                        return throwBadUtf8(v1, at + 1);
                    }
                    int v2 = bytes[at + 2] & 0xFF;
                    if ((v2 & 0xc0) != 0x80) {
                        return throwBadUtf8(v2, at + 2);
                    }
                    int value = ((v0 & 0x0f) << 12) | ((v1 & 0x3f) << 6) |
                        (v2 & 0x3f);
                    if (value < 0x800) {
                        /*
                         * This should have been represented with one- or
                         * two-byte encoding.
                         */
                        return throwBadUtf8(v2, at + 2);
                    }
                    out = (char) value;
                    at += 3;
                    break;
                }
                default: {
                    // 10XXXXXX, 1111XXXX -- illegal
                    return throwBadUtf8(v0, at);
                }
            }
            chars[outAt] = out;
            outAt++;
        }

        if (readLength != null && readLength.length > 0) {
            readLength[0] = at - start;
            readLength[0] = at - start;
        }
        return new String(chars, 0, outAt);
    }

    /**
     * Helper for {@link #utf8BytesToString}, which throws the right
     * exception for a bogus utf-8 byte.
     *
     * @param value the byte value
     * @param offset the file offset
     * @return never
     * @throws IllegalArgumentException always thrown
     */
    private static String throwBadUtf8(int value, int offset) {
        throw new IllegalArgumentException("bad utf-8 byte " + Hex.u1(value) +
                                           " at offset " + Hex.u4(offset));
    }
}

import javax.annotation.Nonnull;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;

/**
 * Class that takes a combined output destination and provides two
 * output writers, one of which ends up writing to the left column and
 * one which goes on the right.
 */
public final class TwoColumnOutput {
    /** non-null; underlying writer for final output */
    private final Writer out;

    /** &gt; 0; the left column width */
    private final int leftWidth;

    private final int rightWidth;

    private final String spacer;

    /**
     * Constructs an instance.
     *
     * @param out non-null; writer to send final output to
     * @param leftWidth &gt; 0; width of the left column, in characters
     * @param rightWidth &gt; 0; width of the right column, in characters
     * @param spacer non-null; spacer string to sit between the two columns
     */
    public TwoColumnOutput(@Nonnull Writer out, int leftWidth, int rightWidth,
                           @Nonnull String spacer) {

        if (leftWidth < 1) {
            throw new IllegalArgumentException("leftWidth < 1");
        }

        if (rightWidth < 1) {
            throw new IllegalArgumentException("rightWidth < 1");
        }

        this.out = out;
        this.leftWidth = leftWidth;
        this.rightWidth = rightWidth;
        this.spacer = spacer;
    }

    /**
     * Constructs an instance.
     *
     * @param out non-null; stream to send final output to
     * @param leftWidth &gt;= 1; width of the left column, in characters
     * @param rightWidth &gt;= 1; width of the right column, in characters
     * @param spacer non-null; spacer string to sit between the two columns
     */
    public TwoColumnOutput(OutputStream out, int leftWidth, int rightWidth,
                           String spacer) {
        this(new OutputStreamWriter(out), leftWidth, rightWidth, spacer);
    }

    private String[] leftLines = null;
    private String[] rightLines = null;
    public void write(String left, String right) throws IOException {
        leftLines = StringWrapper.wrapString(left, leftWidth, leftLines);
        rightLines = StringWrapper.wrapString(right, rightWidth, rightLines);
        int leftCount = leftLines.length;
        int rightCount = rightLines.length;

        for (int i=0; i<leftCount || i <rightCount; i++) {
            String leftLine = null;
            String rightLine = null;

            if (i < leftCount) {
                leftLine = leftLines[i];
                if (leftLine == null) {
                    leftCount = i;
                }
            }

            if (i < rightCount) {
                rightLine = rightLines[i];
                if (rightLine == null) {
                    rightCount = i;
                }
            }

            if (leftLine != null || rightLine != null) {
                int written = 0;
                if (leftLine != null) {
                    out.write(leftLine);
                    written = leftLine.length();
                }

                int remaining = leftWidth - written;
                if (remaining > 0) {
                    writeSpaces(out, remaining);
                }

                out.write(spacer);

                if (rightLine != null) {
                    out.write(rightLine);
                }

                out.write('\n');
            }
        }
    }

    /**
     * Writes the given number of spaces to the given writer.
     *
     * @param out non-null; where to write
     * @param amt &gt;= 0; the number of spaces to write
     */
    private static void writeSpaces(Writer out, int amt) throws IOException {
        while (amt > 0) {
            out.write(' ');
            amt--;
        }
    }
}

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

public class StringWrapper {
    /**
     * Splits the given string into lines using on any embedded newlines, and wrapping the text as needed to conform to
     * the given maximum line width.
     *
     * This uses and assumes unix-style newlines
     *
     * @param str The string to split
     * @param maxWidth The maximum length of any line
     * @param output If given, try to use this array as the return value. If there are more values than will fit
     *               into the array, a new array will be allocated and returned, while the given array will be filled
     *               with as many lines as would fit.
     * @return The split lines from the original, as an array of Strings. The returned array may be larger than the
     *         number of lines. If this is the case, the end of the split lines will be denoted by a null entry in the
     *         array. If there is no null entry, then the size of the array exactly matches the number of lines.
     *         The returned lines will not contain an ending newline
     */
    public static String[] wrapString(@Nonnull String str, int maxWidth, @Nullable String[] output) {
        if (output == null) {
            output = new String[(int)((str.length() / maxWidth) * 1.5d + 1)];
        }

        int lineStart = 0;
        int arrayIndex = 0;
        int i;
        for (i=0; i<str.length(); i++) {
            char c = str.charAt(i);

            if (c == '\n') {
                output = addString(output, str.substring(lineStart, i), arrayIndex++);
                lineStart = i+1;
            } else if (i - lineStart == maxWidth) {
                output = addString(output, str.substring(lineStart, i), arrayIndex++);
                lineStart = i;
            }
        }
        if (lineStart != i || i == 0) {
            output = addString(output, str.substring(lineStart), arrayIndex++, output.length+1);
        }

        if (arrayIndex < output.length) {
            output[arrayIndex] = null;
        }
        return output;
    }

    private static String[] addString(@Nonnull String[] arr, String str, int index) {
        if (index >= arr.length) {
            arr = enlargeArray(arr, (int)(Math.ceil((arr.length + 1) * 1.5)));
        }

        arr[index] = str;
        return arr;
    }

    private static String[] addString(@Nonnull String[] arr, String str, int index, int newLength) {
        if (index >= arr.length) {
            arr = enlargeArray(arr, newLength);
        }

        arr[index] = str;
        return arr;
    }

    private static String[] enlargeArray(String[] arr, int newLength) {
        String[] newArr = new String[newLength];
        System.arraycopy(arr, 0, newArr, 0, arr.length);
        return newArr;
    }
}

import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;

import java.io.PrintWriter;

public class SmaliHelpFormatter extends HelpFormatter {
    public void printHelp(String cmdLineSyntax, String header, Options options, Options debugOptions) {
        super.printHelp(cmdLineSyntax, header, options, "");
        if (debugOptions != null) {
            System.out.println();
            System.out.println("Debug Options:");
            PrintWriter pw = new PrintWriter(System.out);
            super.printOptions(pw, getWidth(), debugOptions, getLeftPadding(), getDescPadding());
            pw.flush();
        }
    }
}

import javax.annotation.Nonnull;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;

public class RandomAccessFileOutputStream extends OutputStream {
    private int filePosition;
    @Nonnull private final RandomAccessFile raf;

    public RandomAccessFileOutputStream(@Nonnull RandomAccessFile raf, int startFilePosition) {
        this.filePosition = startFilePosition;
        this.raf = raf;
    }

    @Override public void write(int b) throws IOException {
        raf.seek(filePosition);
        filePosition++;
        raf.write(b);
    }

    @Override public void write(byte[] b) throws IOException {
        raf.seek(filePosition);
        filePosition += b.length;
        raf.write(b);
    }

    @Override public void write(byte[] b, int off, int len) throws IOException {
        raf.seek(filePosition);
        filePosition += len;
        raf.write(b, off, len);
    }
}

import javax.annotation.Nonnull;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;

public class RandomAccessFileInputStream extends InputStream {
    private int filePosition;
    @Nonnull private final RandomAccessFile raf;

    public RandomAccessFileInputStream(@Nonnull RandomAccessFile raf, int filePosition) {
        this.filePosition = filePosition;
        this.raf = raf;
    }

    @Override public int read() throws IOException {
        raf.seek(filePosition);
        filePosition++;
        return raf.read();
    }

    @Override public int read(byte[] bytes) throws IOException {
        raf.seek(filePosition);
        int bytesRead = raf.read(bytes);
        filePosition += bytesRead;
        return bytesRead;
    }

    @Override public int read(byte[] bytes, int offset, int length) throws IOException {
        raf.seek(filePosition);
        int bytesRead = raf.read(bytes, offset, length);
        filePosition += bytesRead;
        return bytesRead;
    }

    @Override public long skip(long l) throws IOException {
        int skipBytes = Math.min((int)l, available());
        filePosition += skipBytes;
        return skipBytes;
    }

    @Override public int available() throws IOException {
        return (int)raf.length() - filePosition;
    }

    @Override public boolean markSupported() {
        return false;
    }
}


--------------------------------------------------------------------------------------------------------
import java.text.DecimalFormat;

public class NumberUtils {
    private static final int canonicalFloatNaN = Float.floatToRawIntBits(Float.NaN);
    private static final int maxFloat = Float.floatToRawIntBits(Float.MAX_VALUE);
    private static final int piFloat = Float.floatToRawIntBits((float)Math.PI);
    private static final int eFloat = Float.floatToRawIntBits((float)Math.E);

    private static final long canonicalDoubleNaN = Double.doubleToRawLongBits(Double.NaN);
    private static final long maxDouble = Double.doubleToLongBits(Double.MAX_VALUE);
    private static final long piDouble = Double.doubleToLongBits(Math.PI);
    private static final long eDouble = Double.doubleToLongBits(Math.E);

    private static final DecimalFormat format = new DecimalFormat("0.####################E0");

    public static boolean isLikelyFloat(int value) {
        // Check for some common named float values
        // We don't check for Float.MIN_VALUE, which has an integer representation of 1
        if (value == canonicalFloatNaN ||
                value == maxFloat ||
                value == piFloat ||
                value == eFloat) {
            return true;
        }

        // Check for some named integer values
        if (value == Integer.MAX_VALUE || value == Integer.MIN_VALUE) {
            return false;
        }


        // Check for likely resource id
        int packageId = value >> 24;
        int resourceType = value >> 16 & 0xff;
        int resourceId = value & 0xffff;
        if ((packageId == 0x7f || packageId == 1) && resourceType < 0x1f && resourceId < 0xfff) {
            return false;
        }

        // a non-canocical NaN is more likely to be an integer
        float floatValue = Float.intBitsToFloat(value);
        if (Float.isNaN(floatValue)) {
            return false;
        }

        // Otherwise, whichever has a shorter scientific notation representation is more likely.
        // Integer wins the tie
        String asInt = format.format(value);
        String asFloat = format.format(floatValue);

        // try to strip off any small imprecision near the end of the mantissa
        int decimalPoint = asFloat.indexOf('.');
        int exponent = asFloat.indexOf("E");
        int zeros = asFloat.indexOf("000");
        if (zeros > decimalPoint && zeros < exponent) {
            asFloat = asFloat.substring(0, zeros) + asFloat.substring(exponent);
        } else {
            int nines = asFloat.indexOf("999");
            if (nines > decimalPoint && nines < exponent) {
                asFloat = asFloat.substring(0, nines) + asFloat.substring(exponent);
            }
        }

        return asFloat.length() < asInt.length();
    }

    public static boolean isLikelyDouble(long value) {
        // Check for some common named double values
        // We don't check for Double.MIN_VALUE, which has a long representation of 1
        if (value == canonicalDoubleNaN ||
                value == maxDouble ||
                value == piDouble ||
                value == eDouble) {
            return true;
        }

        // Check for some named long values
        if (value == Long.MAX_VALUE || value == Long.MIN_VALUE) {
            return false;
        }

        // a non-canocical NaN is more likely to be an long
        double doubleValue = Double.longBitsToDouble(value);
        if (Double.isNaN(doubleValue)) {
            return false;
        }

        // Otherwise, whichever has a shorter scientific notation representation is more likely.
        // Long wins the tie
        String asLong = format.format(value);
        String asDouble = format.format(doubleValue);

        // try to strip off any small imprecision near the end of the mantissa
        int decimalPoint = asDouble.indexOf('.');
        int exponent = asDouble.indexOf("E");
        int zeros = asDouble.indexOf("000");
        if (zeros > decimalPoint && zeros < exponent) {
            asDouble = asDouble.substring(0, zeros) + asDouble.substring(exponent);
        } else {
            int nines = asDouble.indexOf("999");
            if (nines > decimalPoint && nines < exponent) {
                asDouble = asDouble.substring(0, nines) + asDouble.substring(exponent);
            }
        }

        return asDouble.length() < asLong.length();
    }
}

import java.util.Comparator;
import java.util.List;

public class LinearSearch {
    /**
     * Performs a linear search in a sorted list for key, starting at initialGuess
     *
     * @param list The sorted list to search
     * @param comparator The comparator to use
     * @param key The key to search for
     * @param initialGuess An initial guess of the location.
     * @return If found, the index of the item. If not found, -return + 1 is the index at which the item would be
     *         inserted
     */
    public static <T> int linearSearch(List<? extends T> list, Comparator<T> comparator, T key, int initialGuess) {
        int guess = initialGuess;
        if (guess >= list.size()) {
            guess = list.size()-1;
        }
        int comparison = comparator.compare(list.get(guess), key);
        if (comparison == 0) {
            return guess;
        }
        if (comparison < 0) {
            guess++;
            while (guess < list.size()) {
                comparison = comparator.compare(list.get(guess), key);
                if (comparison == 0) {
                    return guess;
                }
                if (comparison > 0) {
                    return -(guess+1);
                }
                guess++;
            }
            return -(list.size()+1);
        } else {
            guess--;
            while (guess >= 0) {
                comparison = comparator.compare(list.get(guess), key);
                if (comparison == 0) {
                    return guess;
                }
                if (comparison < 0) {
                    return -(guess+2);
                }
                guess--;
            }
            return -1;
        }
    }
}


import java.io.IOException;
import java.io.Writer;

public class IndentingWriter extends Writer {
    protected final Writer writer;
    protected final char[] buffer = new char[24];
    protected int indentLevel = 0;
    private boolean beginningOfLine = true;
    private static final String newLine = System.getProperty("line.separator");

    public IndentingWriter(Writer writer) {
        this.writer = writer;
    }

    protected void writeIndent() throws IOException {
        for (int i=0; i<indentLevel; i++) {
            writer.write(' ');
        }
    }

    @Override
    public void write(int chr) throws IOException {
        if (chr == '\n') {
            writer.write(newLine);
            beginningOfLine = true;
        } else {
            if (beginningOfLine) {
                writeIndent();
            }
            beginningOfLine = false;
            writer.write(chr);
        }
    }

    /**
     * Writes out a block of text that contains no newlines
     */
    private void writeLine(char[] chars, int start, int len) throws IOException {
        if (beginningOfLine && len > 0) {
            writeIndent();
            beginningOfLine = false;
        }
        writer.write(chars, start, len);
    }


    /**
     * Writes out a block of text that contains no newlines
     */
    private void writeLine(String str, int start, int len) throws IOException {
        if (beginningOfLine && len > 0) {
            writeIndent();
            beginningOfLine = false;
        }
        writer.write(str, start, len);
    }

    @Override
    public void write(char[] chars) throws IOException {
        write(chars, 0, chars.length);
    }

    @Override
    public void write(char[] chars, int start, int len) throws IOException {
        final int end = start+len;
        int pos = start;
        while (pos < end) {
            if (chars[pos] == '\n') {
                writeLine(chars, start, pos-start);

                writer.write(newLine);
                beginningOfLine = true;
                pos++;
                start = pos;
            } else {
                pos++;
            }
        }
        writeLine(chars, start, pos-start);
    }

    @Override
    public void write(String s) throws IOException {
        write(s, 0, s.length());
    }

    @Override
    public void write(String str, int start, int len) throws IOException {
        final int end = start+len;
        int pos = start;
        while (pos < end) {
            pos = str.indexOf('\n', start);
            if (pos == -1) {
                writeLine(str, start, end-start);
                return;
            } else {
                writeLine(str, start, pos-start);
                writer.write(newLine);
                beginningOfLine = true;
                start = pos+1;
            }
        }
    }

    @Override
    public Writer append(CharSequence charSequence) throws IOException {
        write(charSequence.toString());
        return this;
    }

    @Override
    public Writer append(CharSequence charSequence, int start, int len) throws IOException {
        write(charSequence.subSequence(start, len).toString());
        return this;
    }

    @Override
    public Writer append(char c) throws IOException {
        write(c);
        return this;
    }

    @Override
    public void flush() throws IOException {
        writer.flush();
    }

    @Override
    public void close() throws IOException {
        writer.close();
    }

    public void indent(int indentAmount) {
        this.indentLevel += indentAmount;
        if (indentLevel < 0) {
            indentLevel = 0;
        }
    }

    public void deindent(int indentAmount) {
        this.indentLevel -= indentAmount;
        if (indentLevel < 0) {
            indentLevel = 0;
        }
    }

    public void printUnsignedLongAsHex(long value) throws IOException {
        int bufferIndex = 23;
        do {
            int digit = (int)(value & 15);
            if (digit < 10) {
                buffer[bufferIndex--] = (char)(digit + '0');
            } else {
                buffer[bufferIndex--] = (char)((digit - 10) + 'a');
            }

            value >>>= 4;
        } while (value != 0);

        bufferIndex++;

        writeLine(buffer, bufferIndex, 24-bufferIndex);
    }

    public void printSignedLongAsDec(long value) throws IOException {
        int bufferIndex = 23;

        if (value < 0) {
            value *= -1;
            write('-');
        }

        do {
            long digit = value % 10;
            buffer[bufferIndex--] = (char)(digit + '0');

            value = value / 10;
        } while (value != 0);

        bufferIndex++;

        writeLine(buffer, bufferIndex, 24-bufferIndex);
    }

    public void printSignedIntAsDec(int value) throws IOException {
        int bufferIndex = 15;

        if (value < 0) {
            value *= -1;
            write('-');
        }

        do {
            int digit = value % 10;
            buffer[bufferIndex--] = (char)(digit + '0');

            value = value / 10;
        } while (value != 0);

        bufferIndex++;

        writeLine(buffer, bufferIndex, 16-bufferIndex);
    }

    public void printUnsignedIntAsDec(int value) throws IOException {
        int bufferIndex = 15;

        if (value < 0) {
            printSignedLongAsDec(value & 0xFFFFFFFFL);
        } else {
            printSignedIntAsDec(value);
        }
    }
}
--------------------------------------------------------------------------------------------------------

/**
 * Utilities for formatting numbers as hexadecimal.
 */
public final class Hex {
    /**
     * This class is uninstantiable.
     */
    private Hex() {
        // This space intentionally left blank.
    }

    /**
     * Formats a <code>long</code> as an 8-byte unsigned hex value.
     *
     * @param v value to format
     * @return non-null; formatted form
     */
    public static String u8(long v) {
        char[] result = new char[16];
        for (int i = 0; i < 16; i++) {
            result[15 - i] = Character.forDigit((int) v & 0x0f, 16);
            v >>= 4;
        }

        return new String(result);
    }

    /**
     * Formats an <code>int</code> as a 4-byte unsigned hex value.
     *
     * @param v value to format
     * @return non-null; formatted form
     */
    public static String u4(int v) {
        char[] result = new char[8];
        for (int i = 0; i < 8; i++) {
            result[7 - i] = Character.forDigit(v & 0x0f, 16);
            v >>= 4;
        }

        return new String(result);
    }

    /**
     * Formats an <code>int</code> as a 3-byte unsigned hex value.
     *
     * @param v value to format
     * @return non-null; formatted form
     */
    public static String u3(int v) {
        char[] result = new char[6];
        for (int i = 0; i < 6; i++) {
            result[5 - i] = Character.forDigit(v & 0x0f, 16);
            v >>= 4;
        }

        return new String(result);
    }

    /**
     * Formats an <code>int</code> as a 2-byte unsigned hex value.
     *
     * @param v value to format
     * @return non-null; formatted form
     */
    public static String u2(int v) {
        char[] result = new char[4];
        for (int i = 0; i < 4; i++) {
            result[3 - i] = Character.forDigit(v & 0x0f, 16);
            v >>= 4;
        }

        return new String(result);
    }

    /**
     * Formats an <code>int</code> as either a 2-byte unsigned hex value
     * (if the value is small enough) or a 4-byte unsigned hex value (if
     * not).
     *
     * @param v value to format
     * @return non-null; formatted form
     */
    public static String u2or4(int v) {
        if (v == (char) v) {
            return u2(v);
        } else {
            return u4(v);
        }
    }

    /**
     * Formats an <code>int</code> as a 1-byte unsigned hex value.
     *
     * @param v value to format
     * @return non-null; formatted form
     */
    public static String u1(int v) {
        char[] result = new char[2];
        for (int i = 0; i < 2; i++) {
            result[1 - i] = Character.forDigit(v & 0x0f, 16);
            v >>= 4;
        }

        return new String(result);
    }

    /**
     * Formats an <code>int</code> as a 4-bit unsigned hex nibble.
     *
     * @param v value to format
     * @return non-null; formatted form
     */
    public static String uNibble(int v) {
        char[] result = new char[1];

        result[0] = Character.forDigit(v & 0x0f, 16);
        return new String(result);
    }

    /**
     * Formats a <code>long</code> as an 8-byte signed hex value.
     *
     * @param v value to format
     * @return non-null; formatted form
     */
    public static String s8(long v) {
        char[] result = new char[17];

        if (v < 0) {
            result[0] = '-';
            v = -v;
        } else {
            result[0] = '+';
        }

        for (int i = 0; i < 16; i++) {
            result[16 - i] = Character.forDigit((int) v & 0x0f, 16);
            v >>= 4;
        }

        return new String(result);
    }

    /**
     * Formats an <code>int</code> as a 4-byte signed hex value.
     *
     * @param v value to format
     * @return non-null; formatted form
     */
    public static String s4(int v) {
        char[] result = new char[9];

        if (v < 0) {
            result[0] = '-';
            v = -v;
        } else {
            result[0] = '+';
        }

        for (int i = 0; i < 8; i++) {
            result[8 - i] = Character.forDigit(v & 0x0f, 16);
            v >>= 4;
        }

        return new String(result);
    }

    /**
     * Formats an <code>int</code> as a 2-byte signed hex value.
     *
     * @param v value to format
     * @return non-null; formatted form
     */
    public static String s2(int v) {
        char[] result = new char[5];

        if (v < 0) {
            result[0] = '-';
            v = -v;
        } else {
            result[0] = '+';
        }

        for (int i = 0; i < 4; i++) {
            result[4 - i] = Character.forDigit(v & 0x0f, 16);
            v >>= 4;
        }

        return new String(result);
    }

    /**
     * Formats an <code>int</code> as a 1-byte signed hex value.
     *
     * @param v value to format
     * @return non-null; formatted form
     */
    public static String s1(int v) {
        char[] result = new char[3];

        if (v < 0) {
            result[0] = '-';
            v = -v;
        } else {
            result[0] = '+';
        }

        for (int i = 0; i < 2; i++) {
            result[2 - i] = Character.forDigit(v & 0x0f, 16);
            v >>= 4;
        }

        return new String(result);
    }

    /**
     * Formats a hex dump of a portion of a <code>byte[]</code>. The result
     * is always newline-terminated, unless the passed-in length was zero,
     * in which case the result is always the empty string (<code>""</code>).
     *
     * @param arr non-null; array to format
     * @param offset &gt;= 0; offset to the part to dump
     * @param length &gt;= 0; number of bytes to dump
     * @param outOffset &gt;= 0; first output offset to print
     * @param bpl &gt;= 0; number of bytes of output per line
     * @param addressLength {2,4,6,8}; number of characters for each address
     * header
     * @return non-null; a string of the dump
     */
    public static String dump(byte[] arr, int offset, int length,
                              int outOffset, int bpl, int addressLength) {
        int end = offset + length;

        // twos-complement math trick: ((x < 0) || (y < 0)) <=> ((x|y) < 0)
        if (((offset | length | end) < 0) || (end > arr.length)) {
            throw new IndexOutOfBoundsException("arr.length " +
                                                arr.length + "; " +
                                                offset + "..!" + end);
        }

        if (outOffset < 0) {
            throw new IllegalArgumentException("outOffset < 0");
        }

        if (length == 0) {
            return "";
        }

        StringBuffer sb = new StringBuffer(length * 4 + 6);
        boolean bol = true;
        int col = 0;

        while (length > 0) {
            if (col == 0) {
                String astr;
                switch (addressLength) {
                    case 2:  astr = Hex.u1(outOffset); break;
                    case 4:  astr = Hex.u2(outOffset); break;
                    case 6:  astr = Hex.u3(outOffset); break;
                    default: astr = Hex.u4(outOffset); break;
                }
                sb.append(astr);
                sb.append(": ");
            } else if ((col & 1) == 0) {
                sb.append(' ');
            }
            sb.append(Hex.u1(arr[offset]));
            outOffset++;
            offset++;
            col++;
            if (col == bpl) {
                sb.append('\n');
                col = 0;
            }
            length--;
        }

        if (col != 0) {
            sb.append('\n');
        }

        return sb.toString();
    }
}
--------------------------------------------------------------------------------------------------------
import java.io.PrintStream;
import java.io.PrintWriter;

/**
 * Exception which carries around structured context.
 */
public class ExceptionWithContext
        extends RuntimeException {
    /** non-null; human-oriented context of the exception */
    private StringBuffer context;

    /**
     * Augments the given exception with the given context, and return the
     * result. The result is either the given exception if it was an
     * {@link ExceptionWithContext}, or a newly-constructed exception if it
     * was not.
     *
     * @param ex non-null; the exception to augment
     * @param str non-null; context to add
     * @return non-null; an appropriate instance
     */
    public static ExceptionWithContext withContext(Throwable ex, String str, Object... formatArgs) {
        ExceptionWithContext ewc;

        if (ex instanceof ExceptionWithContext) {
            ewc = (ExceptionWithContext) ex;
        } else {
            ewc = new ExceptionWithContext(ex);
        }

        ewc.addContext(String.format(str, formatArgs));
        return ewc;
    }

    /**
     * Constructs an instance.
     *
     * @param message human-oriented message
     */
    public ExceptionWithContext(String message, Object... formatArgs) {
        this(null, message, formatArgs);
    }

    /**
     * Constructs an instance.
     *
     * @param cause null-ok; exception that caused this one
     */
    public ExceptionWithContext(Throwable cause) {
        this(cause, null);
    }

    /**
     * Constructs an instance.
     *
     * @param message human-oriented message
     * @param cause null-ok; exception that caused this one
     */
    public ExceptionWithContext(Throwable cause, String message, Object... formatArgs) {
        super((message != null) ? formatMessage(message, formatArgs) :
              (cause != null) ? cause.getMessage() : null,
              cause);

        if (cause instanceof ExceptionWithContext) {
            String ctx = ((ExceptionWithContext) cause).context.toString();
            context = new StringBuffer(ctx.length() + 200);
            context.append(ctx);
        } else {
            context = new StringBuffer(200);
        }
    }

    private static String formatMessage(String message, Object... formatArgs) {
        if (message == null) {
            return null;
        }
        return String.format(message, formatArgs);
    }

    /** {@inheritDoc} */
    @Override
    public void printStackTrace(PrintStream out) {
        super.printStackTrace(out);
        out.println(context);
    }

    /** {@inheritDoc} */
    @Override
    public void printStackTrace(PrintWriter out) {
        super.printStackTrace(out);
        out.println(context);
    }

    /**
     * Adds a line of context to this instance.
     *
     * @param str non-null; new context
     */
    public void addContext(String str) {
        if (str == null) {
            throw new NullPointerException("str == null");
        }

        context.append(str);
        if (!str.endsWith("\n")) {
            context.append('\n');
        }
    }

    /**
     * Gets the context.
     *
     * @return non-null; the context
     */
    public String getContext() {
        return context.toString();
    }

    /**
     * Prints the message and context.
     *
     * @param out non-null; where to print to
     */
    public void printContext(PrintStream out) {
        out.println(getMessage());
        out.print(context);
    }

    /**
     * Prints the message and context.
     *
     * @param out non-null; where to print to
     */
    public void printContext(PrintWriter out) {
        out.println(getMessage());
        out.print(context);
    }
}
--------------------------------------------------------------------------------------------------------
    @SuppressWarnings("unchecked")
    private static Class classForName(String className) {
        try {
            ClassLoader cl = Thread.currentThread().getContextClassLoader();
            return Class.forName(className, false, cl);
        } catch (Throwable ex) {
            //ignore
        }
        return null;
    }
--------------------------------------------------------------------------------------------------------
import javax.servlet.http.HttpServletRequest;

public class RequestUtils {

    static String[] mobileAgents = {"iphone", "android", "phone", "mobile", "wap", "netfront", "java", "opera mobi",
            "opera mini", "ucweb", "windows ce", "symbian", "series", "webos", "sony", "blackberry", "dopod", "nokia",
            "samsung", "palmsource", "xda", "pieplus", "meizu", "midp", "cldc", "motorola", "foma", "docomo",
            "up.browser", "up.link", "blazer", "helio", "hosin", "huawei", "novarra", "coolpad", "webos", "techfaith",
            "palmsource", "alcatel", "amoi", "ktouch", "nexian", "ericsson", "philips", "sagem", "wellcom", "bunjalloo",
            "maui", "smartphone", "iemobile", "spice", "bird", "zte-", "longcos", "pantech", "gionee", "portalmmm",
            "jig browser", "hiptop", "benq", "haier", "^lct", "320x320", "240x320", "176x220", "w3c ", "acs-", "alav",
            "alca", "amoi", "audi", "avan", "benq", "bird", "blac", "blaz", "brew", "cell", "cldc", "cmd-", "dang",
            "doco", "eric", "hipt", "inno", "ipaq", "java", "jigs", "kddi", "keji", "leno", "lg-c", "lg-d", "lg-g",
            "lge-", "maui", "maxo", "midp", "mits", "mmef", "mobi", "mot-", "moto", "mwbp", "nec-", "newt", "noki",
            "oper", "palm", "pana", "pant", "phil", "play", "port", "prox", "qwap", "sage", "sams", "sany", "sch-",
            "sec-", "send", "seri", "sgh-", "shar", "sie-", "siem", "smal", "smar", "sony", "sph-", "symb", "t-mo",
            "teli", "tim-", "tsm-", "upg1", "upsi", "vk-v", "voda", "wap-", "wapa", "wapi", "wapp", "wapr", "webc",
            "winw", "winw", "xda", "xda-", "googlebot-mobile"};

    public static boolean isAjaxRequest(HttpServletRequest request) {
        String header = request.getHeader("X-Requested-With");
        return "XMLHttpRequest".equalsIgnoreCase(header);
    }

    public static boolean isMultipartRequest(HttpServletRequest request) {
        String contentType = request.getContentType();
        return contentType != null && contentType.toLowerCase().indexOf("multipart") != -1;
    }

    /**
     * 是否是手机浏览器
     *
     * @return
     */
    public static boolean isMoblieBrowser(HttpServletRequest request) {
        String ua = request.getHeader("User-Agent");
        if (ua == null) {
            return false;
        }
        ua = ua.toLowerCase();
        for (String mobileAgent : mobileAgents) {
            if (ua.indexOf(mobileAgent) >= 0) {
                return true;
            }
        }
        return false;
    }

    /**
     * 是否是微信浏览器
     *
     * @return
     */
    public static boolean isWechatBrowser(HttpServletRequest request) {
        String ua = request.getHeader("User-Agent");
        if (ua == null) {
            return false;
        }
        ua = ua.toLowerCase();
        if (ua.indexOf("micromessenger") > 0) {
            return true;
        }
        return false;
    }


    /**
     * 是否是PC版的微信浏览器
     *
     * @param request
     * @return
     */
    public static boolean isWechatPcBrowser(HttpServletRequest request) {
        String ua = request.getHeader("User-Agent");
        if (ua == null) {
            return false;
        }
        ua = ua.toLowerCase();
        if (ua.indexOf("windowswechat") > 0) {
            return true;
        }
        return false;
    }

    /**
     * 是否是IE浏览器
     *
     * @return
     */
    public static boolean isIEBrowser(HttpServletRequest request) {
        String ua = request.getHeader("User-Agent");
        if (ua == null) {
            return false;
        }

        ua = ua.toLowerCase();
        if (ua.indexOf("msie") > 0) {
            return true;
        }

        if (ua.indexOf("gecko") > 0 && ua.indexOf("rv:11") > 0) {
            return true;
        }
        return false;
    }

    public static String getIpAddress(HttpServletRequest request) {

        String ip = request.getHeader("X-requested-For");
        if (StringUtils.isBlank(ip) || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("X-Forwarded-For");
        }
        if (StringUtils.isBlank(ip) || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (StringUtils.isBlank(ip) || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (StringUtils.isBlank(ip) || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_CLIENT_IP");
        }
        if (StringUtils.isBlank(ip) || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_X_FORWARDED_FOR");
        }
        if (StringUtils.isBlank(ip) || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }

        if (ip != null && ip.contains(",")) {
            String[] ips = ip.split(",");
            for (int index = 0; index < ips.length; index++) {
                String strIp = ips[index];
                if (!("unknown".equalsIgnoreCase(strIp))) {
                    ip = strIp;
                    break;
                }
            }
        }

        return ip;
    }

    public static String getUserAgent(HttpServletRequest request) {
        return request.getHeader("User-Agent");
    }


    public static String getReferer(HttpServletRequest request) {
        return request.getHeader("Referer");
    }

}
--------------------------------------------------------------------------------------------------------
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import com.jfinal.log.Log;
import io.jboot.Jboot;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 类实例创建者创建者
 * Created by michael on 17/3/21.
 */
public class ClassKits {

    public static Log log = Log.getLog(ClassKits.class);
    private static final Map<Class, Object> singletons = new ConcurrentHashMap<>();


    /**
     * 获取单例
     *
     * @param clazz
     * @param <T>
     * @return
     */
    public static <T> T singleton(Class<T> clazz) {
        Object object = singletons.get(clazz);
        if (object == null) {
            synchronized (clazz) {
                object = singletons.get(clazz);
                if (object == null) {
                    object = newInstance(clazz);
                    if (object != null) {
                        singletons.put(clazz, object);
                    } else {
                        Log.getLog(clazz).error("cannot new newInstance!!!!");
                    }

                }
            }
        }

        return (T) object;
    }

    /**
     * 创建新的实例
     *
     * @param <T>
     * @param clazz
     * @return
     */
    public static <T> T newInstance(Class<T> clazz) {
        return newInstance(clazz, true);
    }


    public static <T> T newInstance(Class<T> clazz, boolean createdByGuice) {
        if (createdByGuice) {
            return Jboot.bean(clazz);
        } else {
            try {
                Constructor constructor = clazz.getDeclaredConstructor();
                constructor.setAccessible(true);
                return (T) constructor.newInstance();
            } catch (Exception e) {
                log.error("can not newInstance class:" + clazz + "\n" + e.toString(), e);
            }

            return null;
        }
    }

    /**
     * 创建新的实例
     *
     * @param <T>
     * @param clazzName
     * @return
     */
    public static <T> T newInstance(String clazzName) {
        try {
            Class<T> clazz = (Class<T>) Class.forName(clazzName, false, Thread.currentThread().getContextClassLoader());
            return newInstance(clazz);
        } catch (Exception e) {
            log.error("can not newInstance class:" + clazzName + "\n" + e.toString(), e);
        }

        return null;
    }


    public static Class<?> getUsefulClass(Class<?> clazz) {
        //ControllerTest$ServiceTest$$EnhancerByGuice$$40471411#hello
        //com.demo.blog.Blog$$EnhancerByCGLIB$$69a17158
        return clazz.getName().indexOf("$$EnhancerBy") == -1 ? clazz : clazz.getSuperclass();
    }


    /**
     * 类的set方法缓存，用于减少对类的反射工作
     */
    private static Multimap<Class<?>, Method> classMethodsCache = ArrayListMultimap.create();

    /**
     * 获取 某class 下的所有set 方法
     *
     * @param clazz
     * @return
     */
    public static Collection<Method> getClassSetMethods(Class clazz) {
        Collection<Method> setMethods = classMethodsCache.get(clazz);
        if (setMethods == null || setMethods.isEmpty()) {
            Method[] methods = clazz.getMethods();
            for (Method method : methods) {
                if (method.getName().startsWith("set")
                        && method.getName().length() > 3
                        && method.getParameterCount() == 1) {

                    classMethodsCache.put(clazz, method);

                }
            }
        }
        return setMethods;
    }
}
--------------------------------------------------------------------------------------------------------
sudo update-rc.d minidlna defaults
sudo update-rc.d minidlna enable
update-rc.d service_name defaults
update-rc.d -f service_name remove
--------------------------------------------------------------------------------------------------------
https://medium.com/@benmorel/creating-a-linux-service-with-systemd-611b5c8b91d6
--------------------------------------------------------------------------------------------------------
# start lighttpd web server
start(){
	echo -n "Starting "
        $lighttpd -f $conf 
	[ $? -eq 0 ] && echo " [ OK ] " || echo " [ FAILED ] "
}

# stop lighttpd web server
stop(){
        echo -n $"Stopping $prog "
        [ -f "$pidfile" ] && read line < "$pidfile"
        if [ -d "/proc/$line" -a -f $conf ]
        then
  	      pkill -KILL -u $user $prog
              [ $? -eq 0 ] && echo " [ OK ] " || echo " [ FAILED ] "
              [ -f "$pidfile" ] && rm -f "$pidfile"
	fi
}
--------------------------------------------------------------------------------------------------------
#!/bin/bash
#
# lighttpd     Startup script for the lighttpd server 
#
# chkconfig: - 85 15
# description: Lighttpd web server
#
# processname: lighttpd

# Source function library.
. /etc/rc.d/init.d/functions

conf="/etc/lighttpd/lighttpd.conf"
prog=lighttpd
lighttpd="/usr/sbin/lighttpd"
pidfile="/var/run/lighttpd.pid"
user="lighttpd"

# get custome config
if [ -f /etc/sysconfig/lighttpd ]; then
        . /etc/sysconfig/lighttpd
fi


start(){
}

stop(){
}

reload(){
}

status(){
}

case "$1" in
        start)
                start 
                ;;
        stop)
                stop 
                ;;
        restart)
                stop
                start
                ;;
        reload)
                reload
		;;
        status)
                status
                ;;
        *)
                echo $"Usage: $0 {start|stop|restart|reload|status}" 
esac
--------------------------------------------------------------------------------------------------------
import com.alibaba.fastjson.annotation.JSONField;
import com.alibaba.fastjson.annotation.JSONField;
--------------------------------------------------------------------------------------------------------
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.convert.converter.Converter;

import sample.ui.model.Message;
import sample.ui.repository.InMemoryMessageRespository;
import sample.ui.repository.MessageRepository;

/**
 * Initializes Message-related beans.
 *
 * @author Arnaldo Piccinelli
 */
@Configuration
public class MessageConfig {

	@Bean
	public MessageRepository messageRepository() {
		return new InMemoryMessageRespository();
	}

	@Bean
	public Converter<String, Message> messageConverter() {
		return new Converter<String, Message>() {
			@Override
			public Message convert(String id) {
				return messageRepository().findById(Long.valueOf(id));
			}
		};
	}

}
import javax.persistence.Column;
import javax.persistence.MappedSuperclass;

import org.hibernate.validator.constraints.NotEmpty;

/**
 * Simple JavaBean domain object adds a name property to <code>BaseEntity</code>
 * . Used as a base class for objects needing these properties.
 *
 * @author Ken Krebs
 * @author Juergen Hoeller
 */
@MappedSuperclass
public class NamedEntity extends BaseEntity {

	private static final long serialVersionUID = -1369326166767704974L;

	@Column(name = "name")
	@NotEmpty
	protected String name;

	public NamedEntity() {
		super();
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getName() {
		return this.name;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = super.hashCode();
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (!super.equals(obj))
			return false;
		if (getClass() != obj.getClass())
			return false;
		NamedEntity other = (NamedEntity) obj;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return this.getName();
	}
}
}
--------------------------------------------------------------------------------------------------------
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.webflow.config.AbstractFlowConfiguration;
import org.springframework.webflow.definition.registry.FlowDefinitionRegistry;
import org.springframework.webflow.engine.builder.support.FlowBuilderServices;
import org.springframework.webflow.executor.FlowExecutor;
import org.springframework.webflow.mvc.builder.MvcViewFactoryCreator;
import org.springframework.webflow.security.SecurityFlowExecutionListener;

import sample.ui.flow.UsersFlowHandler;

@Configuration
public class WebFlowConfig extends AbstractFlowConfiguration {

	@Autowired
	private WebMvcConfig webMvcConfig;

	@Autowired
	private List<ViewResolver> viewResolvers;

	// @Autowired
	// private MvcViewFactoryCreator mvcViewFactoryCreator;

	@Bean
	public FlowExecutor flowExecutor() {
		return getFlowExecutorBuilder(flowRegistry()).addFlowExecutionListener(new SecurityFlowExecutionListener(), "*")
				.build();
	}

	@Bean
	public FlowDefinitionRegistry flowRegistry() {
		return getFlowDefinitionRegistryBuilder(flowBuilderServices()).setBasePath("classpath*:/templates")
				.addFlowLocationPattern("/**/*-flow.xml").build();
	}

	@Bean
	public FlowBuilderServices flowBuilderServices() {
		return getFlowBuilderServicesBuilder().setViewFactoryCreator(mvcViewFactoryCreator())
				// .setValidator(validator())
				.setDevelopmentMode(true).build();
	}

	@Bean
	public MvcViewFactoryCreator mvcViewFactoryCreator() {
		viewResolvers.add(this.webMvcConfig.ajaxThymeleafViewResolver());

		MvcViewFactoryCreator factoryCreator = new MvcViewFactoryCreator();
		factoryCreator.setViewResolvers(viewResolvers);
		factoryCreator.setUseSpringBeanBinding(true);
		return factoryCreator;
	}

	// @Bean
	// public LocalValidatorFactoryBean validator() {
	// return new LocalValidatorFactoryBean();
	// }

	@Bean(name = "users/createUser")
	public UsersFlowHandler usersFlowHandler() {
		return new UsersFlowHandler();
	}
}

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.webflow.core.FlowException;
import org.springframework.webflow.execution.FlowExecutionOutcome;
import org.springframework.webflow.execution.repository.NoSuchFlowExecutionException;
import org.springframework.webflow.mvc.servlet.AbstractFlowHandler;

public class UsersFlowHandler extends AbstractFlowHandler {

	private static final String DEFAULT_URL = "/";

	@Override
	public String handleExecutionOutcome(FlowExecutionOutcome outcome, HttpServletRequest request,
			HttpServletResponse response) {
		return DEFAULT_URL;
	}

	@Override
	public String handleException(FlowException e, HttpServletRequest request, HttpServletResponse response) {
		if (e instanceof NoSuchFlowExecutionException) {
			return DEFAULT_URL;
		} else {
			// ModelAndView mav = new ModelAndView();
			// request.mav.addObject("exception", e);
			// mav.addObject("timestamp", new Date());
			// mav.addObject("url", req.getRequestURL());
			// mav.setViewName("exception");
			// return mav;

			throw e;
		}
	}
}
--------------------------------------------------------------------------------------------------------
import java.io.Serializable;

import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;
import org.springframework.stereotype.Component;

@Component
@Scope(proxyMode=ScopedProxyMode.TARGET_CLASS, value="session")
public class SpringAOPSessionScopedBean implements Serializable {
	private static final long serialVersionUID = 1L;
	public int counter=0;
	
	public String getCounter() {
		return String.valueOf(++counter);
	}
	
	public void setCounter(int counter) {
		this.counter = counter;
	}
}

import java.lang.reflect.Field;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class LoggingAspect {

	@Around("execution(public java.lang.String *.getCounter(..))")
	public Object logBefore(ProceedingJoinPoint joinPoint) throws Throwable {
		String msg = "(null) -> ";
		Object target = joinPoint.getTarget();
		try {
			Field counterField = target.getClass().getDeclaredField("counter");
			int counter = (int) counterField.get(target);
			msg = String.valueOf(counter) + " -> ";
		} catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		String s = (String)joinPoint.proceed();
		return msg + s;
	}

}
--------------------------------------------------------------------------------------------------------
import kafka.consumer.ConsumerConfig;
import kafka.consumer.ConsumerIterator;
import kafka.consumer.KafkaStream;
import kafka.javaapi.consumer.ConsumerConnector;
import kafka.serializer.StringDecoder;
import kafka.utils.VerifiableProperties;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

public class KafkaConsumer {

    public static void main(String[] args) {
        Properties props = new Properties();
        props.put("zookeeper.connect", "127.0.0.1:2181");
        //group 代表一个消费组
        props.put("group.id", "jd-group");
        props.put("zookeeper.session.timeout.ms", "4000");
        props.put("zookeeper.sync.time.ms", "200");
        props.put("auto.commit.interval.ms", "1000");
        props.put("auto.offset.reset", "smallest");
        props.put("serializer.class", "kafka.serializer.StringEncoder");

        ConsumerConfig config = new ConsumerConfig(props);

        ConsumerConnector consumer = kafka.consumer.Consumer.createJavaConsumerConnector(config);

        Map<String, Integer> topicCountMap = new HashMap<String, Integer>();
        topicCountMap.put("TestTopic", 1);

        StringDecoder keyDecoder = new StringDecoder(new VerifiableProperties());
        StringDecoder valueDecoder = new StringDecoder(new VerifiableProperties());

//        Map<String, List<KafkaStream<Object, Object>>> consumerMap =
//                consumer.createMessageStreams(topicCountMap, keyDecoder, valueDecoder);
//        KafkaStream<Object, Object> stream = consumerMap.get("TestTopic").get(0);
//        ConsumerIterator<Object, Object> it = stream.iterator();
//        while (it.hasNext()) {
//            System.out.println(it.next().message());
//        }
        System.out.println("finished");
    }  
}

import kafka.javaapi.producer.Producer;
import kafka.producer.KeyedMessage;
import kafka.producer.ProducerConfig;

import java.util.Properties;

public class KafkaProducer {

    public static void main(String[] args) {
        Properties props = new Properties();
        props.put("metadata.broker.list", "127.0.0.1:9092");
        props.put("serializer.class", "kafka.serializer.StringEncoder");
        props.put("key.serializer.class", "kafka.serializer.StringEncoder");
        props.put("request.required.acks","-1");

        Producer<String, String> producer = new Producer<String, String>(new ProducerConfig(props));

        int messageNo = 100;
        final int COUNT = 1000;
        while (messageNo < COUNT) {
            String key = String.valueOf(messageNo);
            String data = "hello kafka message " + key;
            producer.send(new KeyedMessage<String, String>("TestTopic", key ,data));
            System.out.println(data);
            messageNo ++;
        }
    }  
}  
--------------------------------------------------------------------------------------------------------
import org.hongxi.whatsmars.common.mongo.object.MongoDBConfig;
import org.hongxi.whatsmars.common.mongo.object.MongoDBCredential;
import org.hongxi.whatsmars.common.mongo.object.MongoDBDriver;
import com.mongodb.client.ListCollectionsIterable;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoCursor;
import com.mongodb.client.MongoDatabase;
import org.bson.Document;

import java.util.ArrayList;
import java.util.List;

/**
 * Author: qing
 * Date: 14-10-11
 */
public class MongoDBClient {

    protected MongoDBDriver mongoDBDriver;

    protected String databaseName;

    public void setMongoDBDriver(MongoDBDriver mongoDBDriver) {
        this.mongoDBDriver = mongoDBDriver;
    }



    public void setDatabaseName(String databaseName) {
        this.databaseName = databaseName;
    }

    public MongoCollection<Document> getCollection(String collectionName) {
        MongoDatabase db = mongoDBDriver.getDatabase(this.databaseName);
        return db.getCollection(collectionName);
    }

    public MongoDatabase getDatabase() {
        return mongoDBDriver.getDatabase(this.databaseName);
    }


    public static void main(String[] args) throws Exception{

        MongoDBDriver mongoDBDriver = new MongoDBDriver();
        try{
            MongoDBConfig mongoDBConfig = new MongoDBConfig();
            //mongoDBConfig.setAddresses("61.171.123.234:27017");
            mongoDBConfig.setAddresses("61.171.123.234:27017");
            List<MongoDBCredential> credentials = new ArrayList<MongoDBCredential>();
            MongoDBCredential credential = new MongoDBCredential();
            credential.setDatabaseName("whatsmars-common");
            credential.setUsername("whatsmars");
            //credential.setPassword("haodai.com");
            credential.setPassword("passwordiscommon");
            credentials.add(credential);
            mongoDBConfig.setCredentials(credentials);
            mongoDBDriver.setConfiguration(mongoDBConfig);
            mongoDBDriver.init();
            MongoDBClient client = new MongoDBClient();
            client.setDatabaseName("whatsmars-common");
            client.setMongoDBDriver(mongoDBDriver);
            ListCollectionsIterable<Document> documents = client.getDatabase().listCollections();
            MongoCursor<Document> it = documents.iterator();
            while (it.hasNext()) {
                Document item = it.next();
                System.out.println(item.toJson());
            }
            it.close();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            mongoDBDriver.close();
        }
    }


}

import org.hongxi.whatsmars.common.mongo.object.MongoDBConfig;
import org.hongxi.whatsmars.common.ImageSizeEnum;
import org.hongxi.whatsmars.common.mongo.object.MongoDBCredential;
import org.hongxi.whatsmars.common.mongo.object.MongoDBDriver;
import com.mongodb.BasicDBObject;
import com.mongodb.DBCursor;
import com.mongodb.DBObject;
import com.mongodb.gridfs.GridFS;
import com.mongodb.gridfs.GridFSDBFile;
import com.mongodb.gridfs.GridFSInputFile;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.RandomStringUtils;
import org.imgscalr.Scalr;

import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.stream.ImageInputStream;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.zip.Adler32;

/**
 * Author: qing
 * Date: 14-10-11
 */
public class GridFSClient extends MongoDBClient{

    private GridFS _gridFS = null;

    private Object lock = new Object();

    protected static final String[] IMAGE_FORMAT = {"jpg","jpeg","png"};


    public void setMongoDBDriver(MongoDBDriver mongoDBDriver) {
        this.mongoDBDriver = mongoDBDriver;
    }

    public GridFS getInstance() {
        if(_gridFS != null) {
            return _gridFS;
        }
        synchronized (lock) {
            if(_gridFS != null) {
                return _gridFS;
            }
            _gridFS = new GridFS(mongoDBDriver.getDB(this.databaseName));
            return _gridFS;
        }

    }

    public void close() {
        mongoDBDriver.close();
    }

    /**
     *
     * @param inputStream 文件流
     * @param format 文件格式，“pdf”，“png”等，不包含后缀符号“.”
     * @return
     */
    public String saveFile(InputStream inputStream,String format,String uid) {
        try {
            GridFS gridFS = getInstance();

            //随机生成文件名称，多次重试
            String filename = this.randomFileName();
            //如果有文件重复，则重新生成filename
            while (true) {
                GridFSDBFile _current = gridFS.findOne(filename);
                //如果文件不存在，则保存操作
                if (_current == null) {
                    break;
                }
                filename = this.randomFileName();
            }

            GridFSInputFile file = gridFS.createFile(inputStream, filename);
            if(format != null) {
                file.put("format", format);
            }
            if(uid != null) {
                file.put("uid",uid);
            }
            file.put("content-type","application/octet-stream");
            file.save();
            return concat(filename,format);
        }catch (Exception e) {

            throw new RuntimeException(e);
        } finally {
            try{
                inputStream.close();
            }catch (Exception ex) {
                //
            }
        }
    }

    private String concat(String filename,String format) {
        if(format == null) {
            return filename;
        }
        if(format.startsWith(".")) {
            return filename + format;
        }
        return filename + "." + format;
    }

    private String randomFileName() {
        return RandomStringUtils.random(32, true, true).toLowerCase();
    }

    public void delete(String filename) {
        GridFS gridFS = getInstance();
        gridFS.remove(filename);
    }

    public InputStream getFile(String filename) {
        GridFS gridFS = getInstance();
        GridFSDBFile _current = gridFS.findOne(filename);
        if(_current == null) {
            return null;
        }
        return _current.getInputStream();
    }

    public InputStream getImage(String filename,String path) throws Exception{
        //获取最大边,等比缩放
        if(ImageSizeEnum.valueOfPath(path) == null) {
            return null;
        }

        GridFS gridFS = getInstance();
        GridFSDBFile _current = gridFS.findOne(filename);
        if(_current == null) {
            return null;
        }

        int size = ImageSizeEnum.valueOfPath(path).size;

        int max = (Integer)_current.get("max");//图片的实际尺寸

        InputStream result = null;
        //裁剪
        if(size < max) {
            InputStream inputStream = _current.getInputStream();
            BufferedImage image = ImageIO.read(inputStream);

            inputStream.close();
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            BufferedImage thumbnail = Scalr.resize(image, size);//保留最大尺寸
            String format = (String) _current.get("format");
            ImageIO.write(thumbnail, format, bos);
            result = new ByteArrayInputStream(bos.toByteArray());
        } else {
            result = _current.getInputStream();
        }

        return result;
    }


    /**
     *
     * @param inputStream 输入流
     * @return
     * @throws Exception
     */
    public String saveImage(InputStream inputStream,String uid) throws Exception{

        BundleEntry bundleEntry = this.drain(inputStream);
        if(bundleEntry == null) {
            throw new RuntimeException("file isn't a image!");
        }

        ByteArrayInputStream bis = bundleEntry.inputStream;

        String _currentFileName = this.isExistedImage(bundleEntry);

        //如果文件md5已存在
        if(_currentFileName != null) {
            return _currentFileName;
        }

        String format = bundleEntry.format;
        GridFS gridFS = getInstance();
        String filename = this.randomFileName();
        //检测文件名称
        while(true){
            GridFSDBFile _current = gridFS.findOne(filename);
            //如果文件不存在，则保存操作
            if (_current == null) {
                break;
            }
            //否则，重新生成文件名称
            filename = randomFileName();
        }
        //图片处理
        bis.reset();

        //保存原图
        GridFSInputFile _inputFile = gridFS.createFile(bis, filename);
        if(uid != null) {
            _inputFile.put("uid", uid);
        }
        _inputFile.put("max",bundleEntry.max);
        _inputFile.put("crc",bundleEntry.crc);
        _inputFile.put("format",format);
        _inputFile.put("md5_source",bundleEntry.md5);
        _inputFile.save();

        return concat(filename,format);

    }

    private String isExistedImage(BundleEntry entry) {
        GridFS gridFS = getInstance();
        DBObject query = new BasicDBObject();
        query.put("crc",entry.crc);
        query.put("md5_source",entry.md5);
        GridFSDBFile _current = gridFS.findOne(query);
        //根据MD5值查询，检测是否存在
        if(_current == null) {
            return null;
        }
        String format = (String)_current.get("format");
        if(format.startsWith(".")) {
            return _current.getFilename() + format;
        }
        return _current.getFilename() + "." + format;
    }

    /**
     * 因为图片的stream需要reset，所以需要将流全部汲取
     * @param inputStream
     * @return
     * @throws Exception
     */
    protected BundleEntry drain(InputStream inputStream) throws Exception{
        //
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        //计算源文件的md5、crc，以防止图片的重复上传
        Adler32 crc = new Adler32();
        try{
            while(true) {
                int _c = inputStream.read();
                if(_c == -1) {
                    break;
                }
                bos.write(_c);
                crc.update(_c);
            }

        }catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            inputStream.close();
        }

        //第一步：图片格式
        List<String> formats = new ArrayList<String>();//
        ImageInputStream imageInputStream = ImageIO.createImageInputStream(new ByteArrayInputStream(bos.toByteArray()));
        imageInputStream.mark();
        try {
            Iterator<ImageReader> it = ImageIO.getImageReaders(imageInputStream);
            while (it.hasNext()) {
                ImageReader reader = it.next();
                String format  = reader.getFormatName().toLowerCase();
                if(ArrayUtils.contains(IMAGE_FORMAT, format)) {
                    formats.add(format);
                }
            }
        }catch (Exception ex) {
            //
        }

        //如果格式不合法，则直接返回
        if(formats.isEmpty()) {
            try {
                imageInputStream.close();
            } catch (Exception e) {
                //
            }
            return null;
        }

        String md5 = DigestUtils.md5Hex(bos.toByteArray());//求原始图片的MD5，和crc
        System.out.println("md5:" + md5);
        imageInputStream.reset();

        BufferedImage image = ImageIO.read(imageInputStream);

        //获取最大边,等比缩放
        int max = Math.max(image.getHeight(), image.getWidth());

        bos = new ByteArrayOutputStream();
        //如果尺寸超过最大值，则resize
        if(max > ImageSizeEnum.PIXELS_MAX.size) {
            max = ImageSizeEnum.PIXELS_MAX.size;
        }
        String format = formats.get(0);
        BufferedImage thumbnail = Scalr.resize(image, max);//保留最大尺寸
        ImageIO.write(thumbnail, format, bos);

        return new BundleEntry(new ByteArrayInputStream(bos.toByteArray()),md5,crc.getValue(),format,max);
    }


    protected class BundleEntry {
        String md5;
        long crc;
        String format;
        int max;
        ByteArrayInputStream inputStream;
        BundleEntry(ByteArrayInputStream inputStream,String md5,long crc,String format,int max) {
            this.md5 = md5;
            this.crc = crc;
            this.inputStream = inputStream;
            this.format = format;
            this.max = max;
        }
    }



    public static void main(String[] args) throws Exception{

        MongoDBDriver mongoDBDriver = new MongoDBDriver();
        try {
            GridFSClient client = new GridFSClient();
            MongoDBConfig mongoDBConfig = new MongoDBConfig();
            //mongoDBConfig.setAddresses("61.172.238.149:27017");
            mongoDBConfig.setAddresses("61.172.240.58:27017");
            List<MongoDBCredential> credentials = new ArrayList<MongoDBCredential>();
            MongoDBCredential credential = new MongoDBCredential();
            credential.setDatabaseName("whatsmars-fs");
            credential.setUsername("whatsmars");
            //credential.setPassword("haodai.com");
            credential.setPassword("passwordisfs");
            credentials.add(credential);
            mongoDBConfig.setCredentials(credentials);
            mongoDBDriver.setConfiguration(mongoDBConfig);
            mongoDBDriver.init();
            client.setDatabaseName("whatsmars-fs");
            client.setMongoDBDriver(mongoDBDriver);
            testUpload(client);
            //testClear(client.getInstance());
            //testGetImage(client.getInstance(),"xhgcguccxumuyl9hzdombgfvzgriv7rf",null);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            mongoDBDriver.close();
        }

    }


    protected static void testClear(GridFS gridFS) {
        DBCursor cursor = gridFS.getFileList();
        while (cursor.hasNext()) {
            DBObject dbObject = cursor.next();
            String filename = (String)cursor.next().get("filename");
            System.out.println(filename);
            System.out.println(dbObject.toString());
            gridFS.remove(filename);
        }
        cursor.close();
    }


    protected static void testUpload(GridFSClient client) throws Exception{
        FileInputStream inputStream = new FileInputStream(new File("/data/tmp/222222222.jpg"));

        try {

            String filename = client.saveImage(inputStream, null);
            System.out.println(filename);
            String source = filename.substring(0,filename.lastIndexOf("."));
            System.out.println(source);
            InputStream result = client.getImage(source, "x4");
            if(result == null) {
                System.out.println("not found!");
            }
            //vejibw36famkscjyksgke7bugzonnyan

            FileOutputStream outputStream = new FileOutputStream("/data/tmp/" + filename);
            while (true) {
                int i = result.read();
                if( i == -1) {
                    break;
                }
                outputStream.write(i);
            }
            outputStream.flush();
            outputStream.close();
            result.close();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            inputStream.close();
        }

    }

    protected static void testGetImage(GridFS gridFS,String filename,String path) {
        DBObject query = new BasicDBObject();
        query.put("md5_source","9e131ae4ed7337d4712650229b827725");
        GridFSDBFile file = gridFS.findOne(query);
        if(file != null) {
            System.out.println(file.getFilename());
        }
    }

}
--------------------------------------------------------------------------------------------------------
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

/**
 * Created by jenny on 4/15/15.
 */
public class ValidateCodeUtils {

    private static final int WIDTH = 85;
    private static final int HEIGHT = 40;


    /**
     * 生成验证码图片
     * @return key为code字符串，value位图片
     */
    public static Map.Entry<String,BufferedImage> generate() {

        BufferedImage image = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB); //在内存中创建图象
        Graphics2D g = image.createGraphics(); //获取图形上下文

        //设定背景色
        g.setColor(getRandColor(200, 250));
        g.fillRect(0, 0, WIDTH, HEIGHT);
        g.setFont(new Font("Times New Roman", Font.PLAIN, 18));  //设定字体
        //随机产生155条干扰线，使图象中的认证码不易被其它程序探测到
        g.setColor(getRandColor(160, 200));

        Random random = new Random(); //生成随机类

        for (int i = 0; i < 155; i++) {
            int x = random.nextInt(WIDTH);
            int y = random.nextInt(HEIGHT);
            int xl = random.nextInt(12);
            int yl = random.nextInt(12);
            g.drawLine(x, y, x + xl, y + yl);
        }

        StringBuffer sb = new StringBuffer(); //取随机产生的认证码(4位数字)

        for (int i = 0; i < 4; i++) {
            String code = String.valueOf(random.nextInt(10));
            sb.append(code);
            //将认证码显示到图象中
            g.setColor(new Color(20 + random.nextInt(110), 20 + random.nextInt(110), 20 + random.nextInt(110)));
            g.drawString(code, 13 * i + 18, 27);
        }

        Map<String,BufferedImage> map = new HashMap<String, BufferedImage>();
        map.put(sb.toString(),image);

        return map.entrySet().iterator().next();
    }

    /*
     * 给定范围获得随机颜色
     */
    private static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }

}
--------------------------------------------------------------------------------------------------------
import java.io.IOException;
import java.io.InputStream;

/**
 * Created by shenhongxi on 16/4/11.
 * Extends InputStream to be more efficient reading lines during HTTP header processing.
 */
public class SocketInputStream extends InputStream {

    /**
     * Underlying input stream.
     */
    private InputStream input;

    /**
     * Internal buffer.
     */
    protected byte[] buf;


    /**
     * Last valid byte.
     */
    protected int count;


    /**
     * Position in the buffer.
     */
    protected int pos;

    public SocketInputStream(InputStream input, int bufferSize) {
        this.input = input;
        this.buf = new byte[bufferSize];
    }

    // input => buf => HttpRequestLine
    public void readRequestLine(HttpRequestLine requestLine) throws IOException {
        // Recycling check
        if (requestLine.methodEnd != 0)
            requestLine.recycle();

        // Checking for a blank line

        // Reading the method name

        // Reading URI

        // Reading protocol
    }

    // input => buf => HttpHeader
    public void readHeader(HttpHeader header) throws IOException {
        // Recycling check
        if (header.nameEnd != 0)
            header.recycle();

        // Checking for a blank line

        // Reading the header name

        // Reading the header value (which can be spanned over multiple lines)
    }

    @Override
    public int read() throws IOException {
        if (pos >= count) {
            fill();
            if (pos >= count)
                return -1;
        }
        return buf[pos++] & 0xff;
    }

    /**
     * Fill the internal buffer using data from the undelying input stream.
     */
    protected void fill()
            throws IOException {
        pos = 0;
        count = 0;
        int nRead = input.read(buf, 0, buf.length);
        if (nRead > 0) {
            count = nRead;
        }
    }
}
--------------------------------------------------------------------------------------------------------
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();

import com.mongodb.Mongo;
import com.mongodb.WriteConcern;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.mongodb.config.AbstractMongoConfiguration;
import org.springframework.data.mongodb.core.convert.CustomConversions;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;
import java.util.List;

/**
 * @author Oliver Gierke
 */
@Configuration
@ComponentScan
@EnableMongoRepositories
class ApplicationConfig extends AbstractMongoConfiguration {

	@Autowired
	private List<Converter<?, ?>> converters;

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.mongodb.config.AbstractMongoConfiguration#getDatabaseName()
	 */
	@Override
	protected String getDatabaseName() {
		return "e-store";
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.mongodb.config.AbstractMongoConfiguration#mongo()
	 */
	@Override
	public Mongo mongo() throws Exception {

		Mongo mongo = new Mongo();
		mongo.setWriteConcern(WriteConcern.SAFE);

		return mongo;
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.mongodb.config.AbstractMongoConfiguration#customConversions()
	 */
	@Override
	public CustomConversions customConversions() {
		return new CustomConversions(converters);
	}
}
--------------------------------------------------------------------------------------------------------

#!/bin/sh

app_name="whatsmars-spring-boot"
app_profiles="dev"

mvn clean package -Dmaven.test.skip=true

nohup java -Xmx1024m -Xms1024m -XX:-PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -XX:+PrintTenuringDistribution -XX:+HeapDumpOnOutOfMemoryError -Xloggc:./gc.log -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 -jar target/${app_name}.jar --spring.profiles.active=${app_profiles} >./console.log 2>&1 &


#!/usr/bin/env bash
# 此脚本在本地执行
# 默认发布到测试主机 t1234x.add.bjyz.toutiao.im
# 传入参数prod，则发布到正式环境的4台主机 "t2001x.add.bjyz.toutiao.im" "t2002x.add.bjyz.toutiao.im" "t2003x.add.bjhc.toutiao.im" "t2004x.add.bjhc.toutiao.im

app_profiles=${1:-"test"}
app_name=${2:-"whatsmars-spring-boot"}
remote_deploy_path="/data/toutiao"
remote_deploy_user=toutiao
host_file=host_${app_profiles}.txt

if [ ! -e $host_file ]; then
    echo "host file not exists, path:${host_file}"
    exit 1
fi

remote_deploy_hosts=(`cat ${host_file} | tr '\n' ' '`)
echo "deploy env => $app_profiles, to => ${remote_deploy_hosts[@]}:${remote_deploy_path}"

# 打包
project_path="$(cd `dirname $0`; pwd)/.."
cd ${project_path}
mvn clean package -Dmaven.test.skip=true

# 部署
now=`date +"%Y%m%d%H%M%S"`
jar_path="${project_path}/target/${app_name}.jar"
for host in ${remote_deploy_hosts[@]}; do
    echo "start deploy ${jar_path} to $host"
    ssh ${remote_deploy_user}@${host} "${remote_deploy_path}/stop.sh"
    ssh ${remote_deploy_user}@${host} "mkdir -p ${remote_deploy_path}/deploy_backup; mv ${remote_deploy_path}/${app_name}.jar ${remote_deploy_path}/deploy_backup/${app_name}-${now}.jar"
    scp ${jar_path} ${remote_deploy_user}@${host}:${remote_deploy_path}/
    ssh ${remote_deploy_user}@${host} "cd ${remote_deploy_path}/ ; ./start.sh ${app_profiles}"
    echo "deploy ${host} ok"
    sleep 10
done
echo "done."


#!/usr/bin/env bash

echo "restart whatsmars-spring-boot ..."
cd /data/toutiao
./stop.sh
./start.sh
echo "done."


#!/usr/bin/env bash

app_name="whatsmars-spring-boot"

process_no=`ps -ef|grep java|grep ${app_name} | awk '{print $2}'`
if test -n "${process_no}"
then
  kill -SIGTERM ${process_no}
  sleep 2
fi

process_no_again=`ps -ef|grep java|grep ${app_name} | awk '{print $2}'`
if test -n "${process_no_again}"
then
  echo "Process ${process_no_again} is still running."
  kill -9 ${process_no_again}
  echo "Process ${process_no_again} has been killed.(-9)"
else
  echo "Process ${process_no} has been killed."
fi
--------------------------------------------------------------------------------------------------------
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

/**
 * <p>
 * The BCryptPasswordEncoderUtil class assists engineers during application construction. It is not intended for use in
 * a 'live' application.
 * </p>
 * <p>
 * The class uses a BCryptPasswordEncoder to encrypt clear text values using it's native hashing algorithm. This utility
 * may be used to create encrypted password values in a database initialization script used for unit testing or local
 * machine development.
 * </p>
 * 
 * @author Matt Warman
 *
 */
public class BCryptPasswordEncoderUtil {

    /**
     * The Logger for this Class.
     */
    private static final Logger logger = LoggerFactory.getLogger(BCryptPasswordEncoderUtil.class);

    /**
     * The format for encoder messages.
     */
    private static final String ENCODED_FORMAT = "Argument: %s \tEncoded: %s \n";

    /**
     * A Writer for printing messages to the console.
     */
    private transient Writer writer;

    /**
     * Uses a BCryptPasswordEncoder to hash the clear text value.
     * 
     * @param clearText A String of clear text to be encrypted.
     * @return The encrypted (hashed) value.
     */
    public String encode(final String clearText) {
        final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        return encoder.encode(clearText);
    }

    /**
     * Facilitates gathering user input and invoking the class behavior.
     * 
     * @param args An array of command line input values. (not used)
     */
    public static void main(final String... args) {

        final BCryptPasswordEncoderUtil encoderUtil = new BCryptPasswordEncoderUtil();

        for (final String arg : args) {
            final String encodedText = encoderUtil.encode(arg);
            final String message = String.format(ENCODED_FORMAT, arg, encodedText);
            encoderUtil.write(message);
        }

        encoderUtil.close();

    }

    /**
     * Writes a message to the console.
     * 
     * @param str A String message value.
     */
    private void write(final String str) {

        try {
            if (writer == null) {
                writer = new OutputStreamWriter(System.out);
            }
            writer.write(str);
        } catch (IOException ioe) {
            logger.error("Writer cannot write.", ioe);
            System.exit(1);
        }
    }

    /**
     * Closes all system resources and prepares for application termination.
     */
    private void close() {
        try {
            if (writer != null) {
                writer.close();
            }
        } catch (IOException ioe) {
            logger.error("Problem closing resources.", ioe);
            System.exit(1);
        }
    }

}
--------------------------------------------------------------------------------------------------------
int next_number(int num){

  int digits[10];
  int x,y,i;
  for(i=0; i<10; i++)
     digits[i]=0;

  int divisor = 10;
  int multiplier = 1;
 /* While we have processed all digis of the number */
  while(num){
    /* get the rightmost digit in the number */
     x = num %divisor;

    /* Store it for sorting and finding next higher number than pivot */
     digits[x]++;

    /* Get the left digit of rightmost digit i.e x */
     y = (num % (divisor *10))/divisor;

 /* If left digit is less than right one,
     this digit needs to be swapped */
     if(y !=0  && y<x){
         for(i=y; i<10; i++){
          /* search for number which is least greater than y pivot */
            if(digits[i] !=0){
               digits[i]--;
               digits[y]++;
               break;
             }
          }
          /* Swap that digit with pivot i.e y */
          num  =  num /100;
          num = num *100 + i*10 ;
          break;
      }
      else{
       /* If left digit is greater than right one, 
          just remove the last digit and continue. */
          num = num/divisor;
          multiplier *= 10;
      }
   }
 /* If all the digits are in sorted order, there is no number possible */
  if(num == 0)
       return -1;

  /* Restore the number without digits  after pivot */
   num = num * multiplier;
   int temp = 0;
 /*Calculate the number with digits after pivot in non increasing order */
   for(i=0;i<10;){
       while(digits[i] != 0){
           temp = temp + (i) * multiplier;
           digits[i]--;
           multiplier/=10;
       }
       i++;
    }
    return num + temp;
} 
--------------------------------------------------------------------------------------------------------
import io.netty.bootstrap.Bootstrap;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.autoconfigure.condition.SearchStrategy;
import org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration.EmbeddedServletContainerCustomizerBeanPostProcessorRegistrar;
import org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;

/**
 * {@link org.springframework.boot.autoconfigure.EnableAutoConfiguration Auto-configuration} for an embedded servlet containers.
 *
 * @author Danny Thomas
 */
@Order(Ordered.HIGHEST_PRECEDENCE)
@Configuration
@ConditionalOnWebApplication
@Import(EmbeddedServletContainerCustomizerBeanPostProcessorRegistrar.class)
public class NettyEmbeddedServletContainerAutoConfiguration {
    @Configuration
    @ConditionalOnClass({Bootstrap.class})
    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
    public static class EmbeddedNetty {
        @Bean
        public NettyEmbeddedServletContainerFactory nettyEmbeddedServletContainerFactory() {
            return new NettyEmbeddedServletContainerFactory();
        }
    }
}
--------------------------------------------------------------------------------------------------------
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+08:00")
--------------------------------------------------------------------------------------------------------
import org.esco.demo.ssc.security.AuthoritiesConstants;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler;
import org.springframework.security.access.expression.method.MethodSecurityExpressionHandler;
import org.springframework.security.access.hierarchicalroles.RoleHierarchy;
import org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl;
import org.springframework.security.access.vote.RoleHierarchyVoter;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration;

@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true, jsr250Enabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {

	@Bean
	public RoleHierarchyVoter roleHierarchyVoter() {
		return new RoleHierarchyVoter(roleHierarchy());
	}

	@Bean
	public RoleHierarchy roleHierarchy() {
		RoleHierarchyImpl rhi = new RoleHierarchyImpl();
		rhi.setHierarchy(AuthoritiesConstants.ADMIN + " > " + AuthoritiesConstants.USER + " "
				+ AuthoritiesConstants.USER + " > " + AuthoritiesConstants.ANONYMOUS);
		return rhi;
	}

	// @Bean
	// public PermissionEvaluator permissionEvaluator() {
	// return new CustomPermissionEvaluator();
	// }

	@Override
	protected MethodSecurityExpressionHandler createExpressionHandler() {
		DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler();
		// expressionHandler.setPermissionEvaluator(permissionEvaluator());
		expressionHandler.setRoleHierarchy(roleHierarchy());
		return expressionHandler;
	}
}
--------------------------------------------------------------------------------------------------------
import org.apache.activemq.ActiveMQConnectionFactory;
import org.apache.activemq.command.ActiveMQQueue;
import org.apache.activemq.command.ActiveMQTopic;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.annotation.EnableJms;
import org.springframework.jms.connection.CachingConnectionFactory;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.listener.DefaultMessageListenerContainer;
import org.springside.examples.quickstart.jms.NotifyMessageListener;

import javax.jms.MessageListener;
import javax.jms.Queue;
import javax.jms.Topic;

/**
 * Created by Ivan on 2015/11/25.
 */
@Configuration
@EnableJms
public class ActiveMQConfiguration {
    @Value("${spring.activemq.broker-url}")
    private String brokerURL;

    @Bean
    public ActiveMQConnectionFactory connectionFactory()
    {
        return new ActiveMQConnectionFactory(brokerURL);
    }

    @Bean
    public CachingConnectionFactory cachingConnectionFactory()
    {
        CachingConnectionFactory cachingConnectionFactory=new CachingConnectionFactory();
        cachingConnectionFactory.setTargetConnectionFactory(connectionFactory());
        cachingConnectionFactory.setSessionCacheSize(10);
        return cachingConnectionFactory;
    }

    @Bean
    public JmsTemplate jmsTemplate()
    {
        JmsTemplate jmsTemplate=new JmsTemplate();
        jmsTemplate.setConnectionFactory(cachingConnectionFactory());
        return jmsTemplate;
    }

    @Bean(name = "notifyQueue")
    public Queue queue() {
        return new ActiveMQQueue("q.notify");
    }

    @Bean(name = "notifyTopic")
    public Topic topic() {
        return new ActiveMQTopic("t.notify");
    }

    @Bean
    public DefaultMessageListenerContainer queueContainer() {
        DefaultMessageListenerContainer queueContainer = new DefaultMessageListenerContainer();
        queueContainer.setConnectionFactory(connectionFactory());
        queueContainer.setDestination(queue());
        queueContainer.setMessageListener(notifyMessageListener());
        queueContainer.setConcurrentConsumers(10);
        return queueContainer;
    }

    @Bean
    public DefaultMessageListenerContainer topicContainer() {
        DefaultMessageListenerContainer topicContainer = new DefaultMessageListenerContainer();
        topicContainer.setConnectionFactory(connectionFactory());
        topicContainer.setDestination(topic());
        topicContainer.setMessageListener(notifyMessageListener());
        return topicContainer;
    }

    @Bean
    public MessageListener notifyMessageListener() {
        return new NotifyMessageListener();
    }
}
--------------------------------------------------------------------------------------------------------
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.servlet.ModelAndView;
import wang.raye.admin.model.AdminUser;
import wang.raye.admin.model.WebResult;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.util.List;


/**
 * 安全认证的aop拦截器
 * Created by Raye on 2017/3/29.
 */
@Aspect
@Component
public class SecurityAspect {
    /** 登录的地址，不对登录进行拦截*/
    private static final String LOGINURL = "/admin/login";
    /** 注销的地址，不对注销进行拦截*/
    private static final String LOGINOUTURL = "/admin/loginout";
    @Pointcut("execution(public * wang.raye.admin.controller..*.*(..))")
    public void verification() {
    }

    @Around("verification()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();

        HttpServletRequest request = attributes.getRequest();
        HttpSession session = request.getSession();


        String uri = request.getRequestURI();
        if(uri.lastIndexOf("/") == uri.length()-1){
            uri = uri.substring(0,uri.length()-1);
        }
        System.out.println("进入拦截器:"+uri);
        if(LOGINURL.equals(uri)){
            //不拦截的
            return pjp.proceed();
        }
        if((session.getAttribute("loginUser") == null || session.getAttribute("authorities") == null) ){
            Class returnType = ((MethodSignature) pjp.getSignature()).getReturnType();
            if(returnType == String.class || returnType == ModelAndView.class){
                //返回到登录页面
                return "/nologin";
            }else{
                //返回没有权限的json
                return WebResult.noLogin();
            }

        }
        AdminUser user = (AdminUser) session.getAttribute("loginUser");
        //判断是否有权限
        List<String> authorities = (List<String>) session.getAttribute("authorities");
        if(authorities.contains(uri) || -1 == user.getId() || LOGINOUTURL.equals(uri)) {
            return pjp.proceed();
        }else{
            Class returnType = ((MethodSignature) pjp.getSignature()).getReturnType();
            if(returnType == String.class || returnType == ModelAndView.class){
                //返回到登录页面
                return "/303";
            }else{
                //返回没有权限的json
                return WebResult.noAuthority();
            }
        }
    }
}
--------------------------------------------------------------------------------------------------------
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class LiteralTools
{
    public static byte parseByte(String byteLiteral)
            throws NumberFormatException {
        if (byteLiteral == null) {
            throw new NumberFormatException("string is null");
        }
        if (byteLiteral.length() == 0) {
            throw new NumberFormatException("string is blank");
        }

        char[] byteChars;
        if (byteLiteral.toUpperCase().endsWith("T")) {
            byteChars = byteLiteral.substring(0, byteLiteral.length()-1).toCharArray();
        } else {
            byteChars = byteLiteral.toCharArray();
        }

        int position = 0;
        int radix = 10;
        boolean negative = false;
        if (byteChars[position] == '-') {
            position++;
            negative = true;
        }

        if (byteChars[position] == '0') {
            position++;
            if (position == byteChars.length) {
                return 0;
            } else if (byteChars[position] == 'x' || byteChars[position] == 'X') {
                radix = 16;
                position++;
            } else if (Character.digit(byteChars[position], 8) >= 0) {
                radix = 8;
            }
        }

        byte result = 0;
        byte shiftedResult;
        int digit;
        byte maxValue = (byte)(Byte.MAX_VALUE / (radix / 2));

        while (position < byteChars.length) {
            digit = Character.digit(byteChars[position], radix);
            if (digit < 0) {
                throw new NumberFormatException("The string contains invalid an digit - '" + byteChars[position] + "'");
            }
            shiftedResult = (byte)(result * radix);
            if (result > maxValue) {
                throw new NumberFormatException(byteLiteral + " cannot fit into a byte");
            }
            if (shiftedResult < 0 && shiftedResult >= -digit) {
                throw new NumberFormatException(byteLiteral + " cannot fit into a byte");
            }
            result = (byte)(shiftedResult + digit);
            position++;
        }

        if (negative) {
            //allow -0x80, which is = 0x80
            if (result == Byte.MIN_VALUE) {
                return result;
            } else if (result < 0) {
                throw new NumberFormatException(byteLiteral + " cannot fit into a byte");
            }
            return (byte)(result * -1);
        } else {
            return result;
        }
    }

    public static short parseShort(String shortLiteral)
            throws NumberFormatException {
        if (shortLiteral == null) {
            throw new NumberFormatException("string is null");
        }
        if (shortLiteral.length() == 0) {
            throw new NumberFormatException("string is blank");
        }

        char[] shortChars;
        if (shortLiteral.toUpperCase().endsWith("S")) {
            shortChars = shortLiteral.substring(0, shortLiteral.length()-1).toCharArray();
        } else {
            shortChars = shortLiteral.toCharArray();
        }

        int position = 0;
        int radix = 10;
        boolean negative = false;
        if (shortChars[position] == '-') {
            position++;
            negative = true;
        }

        if (shortChars[position] == '0') {
            position++;
            if (position == shortChars.length) {
                return 0;
            } else if (shortChars[position] == 'x' || shortChars[position] == 'X') {
                radix = 16;
                position++;
            } else if (Character.digit(shortChars[position], 8) >= 0) {
                radix = 8;
            }
        }

        short result = 0;
        short shiftedResult;
        int digit;
        short maxValue = (short)(Short.MAX_VALUE / (radix / 2));

        while (position < shortChars.length) {
            digit = Character.digit(shortChars[position], radix);
            if (digit < 0) {
                throw new NumberFormatException("The string contains invalid an digit - '" + shortChars[position] + "'");
            }
            shiftedResult = (short)(result * radix);
            if (result > maxValue) {
                throw new NumberFormatException(shortLiteral + " cannot fit into a short");
            }
            if (shiftedResult < 0 && shiftedResult >= -digit) {
                throw new NumberFormatException(shortLiteral + " cannot fit into a short");
            }
            result = (short)(shiftedResult + digit);
            position++;
        }

        if (negative) {
            //allow -0x8000, which is = 0x8000
            if (result == Short.MIN_VALUE) {
                return result;
            } else if (result < 0) {
                throw new NumberFormatException(shortLiteral + " cannot fit into a short");
            }
            return (short)(result * -1);
        } else {
            return result;
        }
    }

    public static int parseInt(String intLiteral)
            throws NumberFormatException {
        if (intLiteral == null) {
            throw new NumberFormatException("string is null");
        }
        if (intLiteral.length() == 0) {
            throw new NumberFormatException("string is blank");
        }

        char[] intChars = intLiteral.toCharArray();
        int position = 0;
        int radix = 10;
        boolean negative = false;
        if (intChars[position] == '-') {
            position++;
            negative = true;
        }

        if (intChars[position] == '0') {
            position++;
            if (position == intChars.length) {
                return 0;
            } else if (intChars[position] == 'x' || intChars[position] == 'X') {
                radix = 16;
                position++;
            } else if (Character.digit(intChars[position], 8) >= 0) {
                radix = 8;
            }
        }

        int result = 0;
        int shiftedResult;
        int digit;
        int maxValue = Integer.MAX_VALUE / (radix / 2);

        while (position < intChars.length) {
            digit = Character.digit(intChars[position], radix);
            if (digit < 0) {
                throw new NumberFormatException("The string contains an invalid digit - '" + intChars[position] + "'");
            }
            shiftedResult = result * radix;
            if (result > maxValue) {
                throw new NumberFormatException(intLiteral + " cannot fit into an int");
            }
            if (shiftedResult < 0 && shiftedResult >= -digit) {
                throw new NumberFormatException(intLiteral + " cannot fit into an int");
            }
            result = shiftedResult + digit;
            position++;
        }

        if (negative) {
            //allow -0x80000000, which is = 0x80000000
            if (result == Integer.MIN_VALUE) {
                return result;
            } else if (result < 0) {
                throw new NumberFormatException(intLiteral + " cannot fit into an int");
            }
            return result * -1;
        } else {
            return result;
        }
    }

    public static long parseLong(String longLiteral)
            throws NumberFormatException {
        if (longLiteral == null) {
            throw new NumberFormatException("string is null");
        }
        if (longLiteral.length() == 0) {
            throw new NumberFormatException("string is blank");
        }

        char[] longChars;
        if (longLiteral.toUpperCase().endsWith("L")) {
            longChars = longLiteral.substring(0, longLiteral.length()-1).toCharArray();
        } else {
            longChars = longLiteral.toCharArray();
        }

        int position = 0;
        int radix = 10;
        boolean negative = false;
        if (longChars[position] == '-') {
            position++;
            negative = true;
        }

        if (longChars[position] == '0') {
            position++;
            if (position == longChars.length) {
                return 0;
            } else if (longChars[position] == 'x' || longChars[position] == 'X') {
                radix = 16;
                position++;
            } else if (Character.digit(longChars[position], 8) >= 0) {
                radix = 8;
            }
        }

        long result = 0;
        long shiftedResult;
        int digit;
        long maxValue = Long.MAX_VALUE / (radix / 2);

        while (position < longChars.length) {
            digit = Character.digit(longChars[position], radix);
            if (digit < 0) {
                throw new NumberFormatException("The string contains an invalid digit - '" + longChars[position] + "'");
            }
            shiftedResult = result * radix;
            if (result > maxValue) {
                throw new NumberFormatException(longLiteral + " cannot fit into a long");
            }
            if (shiftedResult < 0 && shiftedResult >= -digit) {
                throw new NumberFormatException(longLiteral + " cannot fit into a long");
            }
            result = shiftedResult + digit;
            position++;
        }

        if (negative) {
            //allow -0x8000000000000000, which is = 0x8000000000000000
            if (result == Long.MIN_VALUE) {
                return result;
            } else if (result < 0) {
                throw new NumberFormatException(longLiteral + " cannot fit into a long");
            }
            return result * -1;
        } else {
            return result;
        }
    }

    private static Pattern specialFloatRegex = Pattern.compile("((-)?infinityf)|(nanf)", Pattern.CASE_INSENSITIVE);
    public static float parseFloat(String floatString) {
        Matcher m = specialFloatRegex.matcher(floatString);
        if (m.matches()) {
            //got an infinity
            if (m.start(1) != -1) {
                if (m.start(2) != -1) {
                    return Float.NEGATIVE_INFINITY;
                } else {
                    return Float.POSITIVE_INFINITY;
                }
            } else {
                return Float.NaN;
            }
        }
        return Float.parseFloat(floatString);
    }

    private static Pattern specialDoubleRegex = Pattern.compile("((-)?infinityd?)|(nand?)", Pattern.CASE_INSENSITIVE);
    public static double parseDouble(String doubleString) {
        Matcher m = specialDoubleRegex.matcher(doubleString);
        if (m.matches()) {
            //got an infinity
            if (m.start(1) != -1) {
                if (m.start(2) != -1) {
                    return Double.NEGATIVE_INFINITY;
                } else {
                    return Double.POSITIVE_INFINITY;
                }
            } else {
                return Double.NaN;
            }
        }
        return Double.parseDouble(doubleString);
    }

    public static byte[] longToBytes(long value) {
        byte[] bytes = new byte[8];

        for (int i=0; value != 0; i++) {
            bytes[i] = (byte)value;
            value = value >>> 8;
        }
        return bytes;
    }

    public static byte[] intToBytes(int value) {
        byte[] bytes = new byte[4];

        for (int i=0; value != 0; i++) {
            bytes[i] = (byte)value;
            value = value >>> 8;
        }
        return bytes;
    }

    public static byte[] shortToBytes(short value) {
        byte[] bytes = new byte[2];

        bytes[0] = (byte)value;
        bytes[1] = (byte)(value >>> 8);
        return bytes;
    }

    public static byte[] floatToBytes(float value) {
        return intToBytes(Float.floatToRawIntBits(value));
    }

    public static byte[] doubleToBytes(double value) {
        return longToBytes(Double.doubleToRawLongBits(value));
    }

    public static byte[] charToBytes(char value) {
        return shortToBytes((short)value);
    }

    public static byte[] boolToBytes(boolean value) {
        if (value) {
            return new byte[] { 0x01 };
        } else {
            return new byte[] { 0x00 };
        }
    }

    public static void checkInt(long value) {
        if (value > 0xFFFFFFFF || value < -0x80000000) {
            throw new NumberFormatException(Long.toString(value) + " cannot fit into an int");
        }
    }

    public static void checkShort(long value) {
        if (value > 0xFFFF | value < -0x8000) {
            throw new NumberFormatException(Long.toString(value) + " cannot fit into a short");
        }
    }

    public static void checkByte(long value) {
        if (value > 0xFF | value < -0x80) {
            throw new NumberFormatException(Long.toString(value) + " cannot fit into a byte");
        }
    }

    public static void checkNibble(long value) {
        if (value > 0x0F | value < -0x08) {
            throw new NumberFormatException(Long.toString(value) + " cannot fit into a nibble");
        }
    }
}
--------------------------------------------------------------------------------------------------------
git commit --allow-empty -m "$p"
--------------------------------------------------------------------------------------------------------
/** 
 * Calculates and stores prime integers for quick and inexpensive lookups.
 *
 * Running times:
 *  - Looking up pre-calculated prime:            O(1)
 *  - Calculating the next prime in the sequence: O(N)
 *  - Calculating a prime out of sequence:        O(N^2)
 *
 * Memory usage:
 *  - 1/2 bit for each digit
 *  - Example: Memory to store all primes up to the number 64 costs 32 bits (1 int)
 * 
 * TODO Convert all ints to longs, overload methods to receive ints.
 * 
 * @author derv
 */
public class Primes {
	
	/** 
	 * Size of an integer in Java.
	 * Standard on all JVMs, but put here for explicitness.
	 */
	private final int INT_SIZE = 32;
	
	/**
	 * The most-recently-calculated prime (in sequence)
	 * All numbers equal to or less than currentPrime are already in the bitmap.
	 */
	private long currentPrime = 1;
	
	/** 
	 * Bitmap tracking which integers are prime.
	 * We know even numbers will not be prime (excluding 2).
	 *
	 * Example:
	 * First element's 7 (LSBs): ...  1   1   1   0   1    1    0
	 * These bits translate to:  ... [3] [5] [7] [9] [11] [13] [15]
	 * 1 indicates number is prime, 0 means number is not prime.
	 * We can easily check if a number is a prime by ANDing with the appropriate bit.
	 */
	private int[] oddBitmap;
	
	/** Initializes bitmap. */
	public Primes() { 
		oddBitmap = new int[1];
	}

	/** 
	 * Initializes bitmap to contain all primes up to capcity.
	 * @param capacity The highest prime to pre-calculate.
	 */
	public Primes(long capacity) {
		// Initialize array to hold all the incoming bits.
		// Code will resize the bitmap on the fly, but this prevents that slow-down.
		int bitmapSize = (int) ((capacity - 3) / 64) + 1;
		oddBitmap = new int[bitmapSize];
		// Generate bitmap for primes up (and possibly beyond) to the given number
		isPrime(capacity);
	}
	/**
	 * Initializes bitmap to contain all primes up to capacity.
	 * @param capacity The highest prime to pre-calculate.
	 */
	public Primes(int capacity) { 
		this( (long) capacity);
	}

	
	/** 
	 * Calculates the next prime in sequence and adds to bitmap.
	 * @return The next prime in the sequence.
	 */
	public long nextPrime() {
		// First prime must be 2. This requires some ugly hacking.
		if (currentPrime < 2) {
			currentPrime += 2;
			return 2;
		} else if (currentPrime == 3) {
			currentPrime -= 2; // isPrime will increase currentPrime by 2.
		}
		while (!isPrime(currentPrime));
		return currentPrime - 2;
	}
	
	/** 
	 * Adds a number (prime or not) to the bitmap.
	 * Doubles bitmap size as needed.
	 * @param n The number to add.
	 * @param prime True if n is prime, false otherwise.
	 */
	private void addNumber(long n, boolean prime) {
		long oddIndex = ((n - 3) / 2); // '3' is the first bit, ignore evens.
		int row = (int) (oddIndex / 32);
		int col = (int) (oddIndex % 32);
		if (row >= oddBitmap.length) {
			// We need to increase the size of the bitmap
			// Increase by 2x current size
			int[] newBitmap = new int[oddBitmap.length * 2];
			System.arraycopy(oddBitmap, 0, newBitmap, 0, oddBitmap.length);
			for (int i = oddBitmap.length; i < newBitmap.length; i++) {
				newBitmap[i] = 0;
			}
			oddBitmap = newBitmap;
		}
		int i = (prime ? 1 : 0);
		i = i << col;
		oddBitmap[row] = (oddBitmap[row] | i);
	}

	/** 
	 * Performs the O(n) computation to see if a number is prime.
	 * @param n The number to check if prime or not.
	 * @return True if n is prime, false otherwise.
	 */
	private boolean calculatePrime(long n) {
		// Ignore multiples of 2 (except 2).
		if (n < 2)      return false;
		if (n == 2)     return true;
		if (n % 2 == 0) return false;
		long maxFactor = (long) Math.sqrt(n); // Highest unique factor of n
		// Only check odd factors.
		for (long i = 3; i <= maxFactor; i += 2) {
			// If is a factor, then n is not prime.
			if (n % i == 0) return false;
		}
		return true;
	}

	/** Array of all single bit masks. */
	public static final int[] BIT_MASKS = {
		2 ^ 0,  2 ^ 1,  2 ^ 2,  2 ^ 3,  2 ^ 4, 
		2 ^ 5,  2 ^ 6,  2 ^ 7,  2 ^ 8,  2 ^ 9, 
		2 ^ 10, 2 ^ 11, 2 ^ 12, 2 ^ 13, 2 ^ 14, 
		2 ^ 15, 2 ^ 16, 2 ^ 17, 2 ^ 18, 2 ^ 19, 
		2 ^ 20, 2 ^ 21, 2 ^ 22, 2 ^ 23, 2 ^ 24, 
		2 ^ 25, 2 ^ 26, 2 ^ 27, 2 ^ 28, 2 ^ 29,
		2 ^ 30, 2 ^ 31
	};
	
	/** 
	 * Performs the O(n) computation to see if a number is prime.
	 * Only checks prime factors, ignores non-prime factors.
	 * @param n The number to check if prime or not.
	 * @return True if n is prime, false otherwise.
	 */
	private boolean newcalculatePrime(int n) {
		// Ignore multiples of 2 (except 2).
		if (n < 2)      return false;
		if (n == 2)     return true;
		if (n % 2 == 0) return false;
		long maxFactor = (long) Math.sqrt(n); // Highest possible factor of n.
		long current = 1;
		int currentRow = 0, currentCol = 0;
		while (current <= maxFactor) {
			current += 2;
			if (currentCol >= INT_SIZE) {
				currentRow++;
				currentCol = 0;
			}
			if ( (oddBitmap[currentRow] & BIT_MASKS[currentCol]) == 0) {
				currentCol++;
				continue;
			}
			if (n % current == 0) return false;
		}
		return true;
	}
	
	/** 
	 * Checks if n is a prime. 
	 * Calculates all primes up to n if they haven't been calculated yet.
	 * @param n The number to check for primality.
	 * @return True if number is prime, false otherwise.
	 */
	public boolean isPrime(long n) {
		// Fill bitmap with all primes up to n (if needed)
		while (currentPrime <= n) {
			currentPrime += 2;
			addNumber(currentPrime, calculatePrime(currentPrime));
		}
		// Check for even numbers
		if (n < 2)      return false;
		if (n == 2)     return true;
		if (n % 2 == 0) return false;
		// Find prime in bitmap
		long oddIndex = (n - 3) / 2; // '3' is the first bit, ignore evens.
		int row = (int) (oddIndex / 32);
		int col = (int) (oddIndex % 32);
		int i = 1 << col; // Create bitmask for current col index
		return (oddBitmap[row] & i) > 0;
	}
	/** 
	 * Checks if n is a prime. 
	 * Calculates all primes up to n if they haven't been calculated yet.
	 * @param n The number to check for primality.
	 * @return True if number is prime, false otherwise.
	 */
	public boolean isPrime(int n) {
		return isPrime( (long) n );
	}

	/** Displays bitmap. */
	public void printBitmap() {
		// Highest row that may contain at least 1 bit.
		long maxRow = (((currentPrime - 1) / 2) / 32);
		System.out.print("Bitmap of odd primes (from 3 to " + (currentPrime - 2) + "):\n\t");
		// Iterate over every row in bitmap (except non-calculated rows)
		for (int row = 0; row < oddBitmap.length && row <= maxRow; row++) {
			int temp = 1; // Will be shifted to check for bits in bitmap
			// Iterate over every bit in this row
			for (int i = 0; i < INT_SIZE; i++) {
				boolean prime = (temp & oddBitmap[row]) > 0;
				System.out.print( prime ? "1" : "0" );
				temp = temp << 1; // Shift to next bit
			}
			System.out.print("\n\t");
		}
		System.out.println();
	}
}
--------------------------------------------------------------------------------------------------------
#!/usr/bin/python

import math

def get_period(n):
	s = math.sqrt(n)
	result = []
	temp = s
	for i in xrange(0, 17):
		next_fract = int(temp)
		result.append(next_fract)
		temp = 1 / (temp - int(temp))
	result = result[:find_repeats(result[1:])]
	print "sqrt(%d)=[%d;(%s)]" % (n, result[0], ','.join(str(x) for x in result[1:]))
	return result[1:]

def find_repeats(l):
	for i in xrange(1, len(l) / 2):
		if equal(l[:i], l[i:i+i]):
			if is_repeating(l, l[:i]):
				return i + 1
	return -1

def is_repeating(l, subl):
	for i, value in enumerate(l):
		if value != subl[i % len(subl)]: return False
		if i > len(subl) * 3: break
	return True
		
def equal(one, two):
	for i, value in enumerate(one):
		if i >= len(two): break
		if value != two[i]: return False
	return True
	

count = 0
n = 1
ncount = 0
while True:
	n += 1
	if math.sqrt(n) == int(math.sqrt(n)): continue
	ncount += 1
	if ncount > 10000: break
	if len(get_period(n)) % 2 != 0:
		count += 1
print count

--------------------------------------------------------------------------------------------------------
#!/usr/bin/python

from sys import stdout
import math

"""
	Yields next decimal place of a division
	Keeps track of leading zeros and current place.
	
	Ignores leading whole integers; only
	cares about what's after the decimal point
"""
class DecimalDiv:
	"""
		Strips leading integers (ensures x < y)
		Counts leading zeros. Initializes place.
	"""
	def __init__(self, numerator, denom, subtract = True):
		self.x = numerator
		self.y = denom
		self.subtract = subtract
		
		while self.x >= self.y:
			self.x -= self.y
		self.leading_zeros = self.count_zeros()
		self.place = self.leading_zeros
	
	"""
		Returns number of leading zeros in decimal
	"""
	def count_zeros(self):
		# log is unreliable (e.g. when n = 13)
		# return math.floor(math.log(self.y, self.x))
		zeros = 0
		while self.x * 10 < self.y:
			self.x *= 10
			zeros += 1
		return zeros
	
	"""
		Returns next decimal (by diving num/denom).
		Returns None when there is nothing 
		left to divide (numerator is 0)
	"""
	def next(self):
		if self.x == 0:
			return None
		
		quotient = 0
		if self.x < self.y:
			self.x *= 10
		
		# The actual division happens here
		while self.x >= self.y:
			quotient += 1
			self.x -= self.y
		
		self.place += 1
		return quotient


"""
	Not exactly a "test", simply calculates atan(1/5)
	at the 6th step of the series.  This is for error-checking
	and to ensure the number of zeros in the decimal are correct
"""
def test():
	n = 11
	d = DecimalDiv(16, n * pow(5, n))
	x = d.next()
	while x != None:
		stdout.write(str(x))
		stdout.flush()
		x = d.next()
	print '',

if __name__ == '__main__':
	test()
--------------------------------------------------------------------------------------------------------
#!/usr/bin/python

from div import DecimalDiv
from sys import stdout

# Number of digits to keep held in cache before printing
CACHE_SIZE = 7

class Pi:
	def __init__(self):
		# Lists contain DecimalDiv objects. These objects give individual
		# decimals for the atan(1/5) and atan(1/239) calculations.
		self.atan5   = []
		self.atan239 = []

		# The current step in the atan series.  The series adds
		# and subtracts from "n", which increases by 2 every step
		# i.e. 1/5, 3/5^3, 5/5^5, etc..
		self.atan5step   = 1
		self.atan239step = 1
		
		# List of last X digits calculated. This acts as a cache
		# of the most-recently calculated digits of PI. These digits
		# are subject to change due to left-to-right addition
		self.lastX = []
		
		# Current depth (current decimal place being calculated)
		self.place = 0
		
		# Create the atan(1/5) generator
		d = DecimalDiv(16, self.atan5step * pow(5, self.atan5step), subtract=False)
		self.atan5.append(d)
		
		# Create the atan(1/239) generator
		d = DecimalDiv(4, self.atan239step * pow(239, self.atan239step), subtract=True)
		self.atan239.append(d)
	
	
	"""
		Adds up all digits current in place at self.place,
		uses the DecimalDiv objects in the given "lst"
		Returns this resulting total.
		Also, creates new DecimalDiv objects as needed.
	"""
	def add_list(self, lst, atan = 5):
		to_remove = []
		result = 0
		# Iterate over every item in the list
		# Each item represents a piece of the atan(1/5) or 
		# atan(1/239) series. The items are is decreasing order
		for i, div in enumerate(lst):
			# We only care if the calculation is currently at the 
			# decimal place we are calculating
			if div.place == self.place:
				# Get the next digit, add to result
				# Remove DecimalDiv if it no longer produces digits (numerator became 0 and next() returned None)
				dec = div.next()
				if dec == None:
					to_remove.append(div)
				elif div.subtract:
					result -= dec
				else:
					result += dec
				
				# If this is the last item in the list, we need to 
				# create a new DecimalDiv to generate future digits
				if i == len(lst) - 1:
					if atan == 5:
						self.atan5step += 2
						step = self.atan5step
						mult = 16
					elif atan == 239:
						self.atan239step += 2
						step = self.atan239step
						mult = 4
					d = DecimalDiv(mult, 
								step * pow(atan, step),
								subtract = not div.subtract)
					lst.append(d)
				
		# Remove "dead" DecimalDivs (no longer generating digits)
		# For example, 1/5 will generate 0.2 and that's it,
		# whereas 1/3 will generate 0.3333 infinitely
		for remove in to_remove:
			lst.remove(remove)
		return result

	"""
		Returns the next digit of PI
		Does not include the leading "3.", starts at "14159..."
	"""
	def next(self):
		# We will use lastX to hold the last X digits calculated
		# This is required as we are doing left-to-right addition
		# and previously-computed digits are subject to change
		# Example: first digit is 2 ("3.2") and next digit is (-5)
		# By propigating the -5, we end up with "3.15", and the 2
		# ended up changing.
		while len(self.lastX) <= CACHE_SIZE:
			# Add everything in the atan(1/5) and atan(1/239) series
			# Only adds decimals from these series that are currently
			# at the same place we are calculating.
			current  = self.add_list(self.atan5, atan=5)
			current += self.add_list(self.atan239, atan=239)
			self.lastX.insert(0, current)
			self.place += 1
		
		# Digits should be between 0 and 9.
		# It's possible the addition of digits are negative or >10
		# So we have to propigate the carry-over down the cache.
		for i in xrange(0, len(self.lastX) - 1):
			# If number is greater than 10, propigation increases
			# the previous digit
			while self.lastX[i] >= 10:
				self.lastX[i+1] += 1
				self.lastX[i] -= 10
			# If number is negative, propigation decreases the
			# previous digit
			while self.lastX[i] < 0:
				self.lastX[i+1] -= 1
				self.lastX[i] += 10
		
		# Once the cache is full, remove the last item (FIFO)
		last = self.lastX.pop(-1)
		return last


########
# TEST #
########

# Open file containing first 100k digits of pi, for comparison
f = open('test.txt', 'r')
test = f.read()
f.close()

# Create Pi object which will generate the digits
pi = Pi()
pistr = '3.'
stdout.write('3.')

try:
	i = 0
	while True:
		# Get the next digit
		pistr = str(pi.next())
		# Print it
		stdout.write(pistr)
		stdout.flush()
		# Compare with the precomputed 100k digits to ensure 
		# we are calculating the correct digits
		if len(test) > i - 3 and pistr != test[i + 2]:
			# If inconsistent, show digit number and display info
			print "\nmismatched at character %d, %s should be %s" % (i + 1, pistr, test[i + 2])
			break
		i += 1
except KeyboardInterrupt:
	print '\n\nCalculated %d digits' % (pi.place + 1)

print ''
exit(0)

--------------------------------------------------------------------------------------------------------
https://www.kitploit.com/2018/05/reverseapk-quickly-analyze-and-reverse.html
--------------------------------------------------------------------------------------------------------
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;
import org.springside.modules.beanvalidator.BeanValidators;
import org.springside.modules.mapper.JsonMapper;
import org.springside.modules.web.MediaTypes;

import javax.validation.ConstraintViolationException;
import java.util.Map;

/**
 * 自定义ExceptionHandler，专门处理Restful异常.
 * 
 * @author calvin
 */
// 会被Spring-MVC自动扫描，但又不属于Controller的annotation。
@ControllerAdvice
public class RestExceptionHandler extends ResponseEntityExceptionHandler {
	private JsonMapper jsonMapper = new JsonMapper();

	/**
	 * 处理RestException.
	 */
	@ExceptionHandler(value = { RestException.class })
	public final ResponseEntity<?> handleException(RestException ex, WebRequest request) {
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.parseMediaType(MediaTypes.TEXT_PLAIN_UTF_8));
		return handleExceptionInternal(ex, ex.getMessage(), headers, ex.status, request);
	}

	/**
	 * 处理JSR311 Validation异常.
	 */
	@ExceptionHandler(value = { ConstraintViolationException.class })
	public final ResponseEntity<?> handleException(ConstraintViolationException ex, WebRequest request) {
		Map<String, String> errors = BeanValidators.extractPropertyAndMessage(ex.getConstraintViolations());
		String body = jsonMapper.toJson(errors);
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.parseMediaType(MediaTypes.TEXT_PLAIN_UTF_8));
		return handleExceptionInternal(ex, body, headers, HttpStatus.BAD_REQUEST, request);
	}
}
--------------------------------------------------------------------------------------------------------
   @Bean
    public DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() {
        DefaultAdvisorAutoProxyCreator daap = new DefaultAdvisorAutoProxyCreator();
        daap.setProxyTargetClass(true);
        return daap;
    }
--------------------------------------------------------------------------------------------------------
    @Bean
    MessageListenerAdapter creditApplicationApprovedMessageListener(CreditApplicationApprovedEventReceiver receiver) {
        MessageListenerAdapter messageListenerAdapter = new MessageListenerAdapter(receiver, "receiveMessage");
        messageListenerAdapter.setSerializer(new Jackson2JsonRedisSerializer<CreditApplicationApprovedEvent>(CreditApplicationApprovedEvent.class));
        return messageListenerAdapter;
    }

    @Bean
    MessageListenerAdapter creditApplicationDeclinedMessageListener(CreditApplicationDeclinedEventReceiver receiver) {
        MessageListenerAdapter messageListenerAdapter = new MessageListenerAdapter(receiver, "receiveMessage");
        messageListenerAdapter.setSerializer(new Jackson2JsonRedisSerializer<CreditApplicationDeclinedEvent>(CreditApplicationDeclinedEvent.class));
        return messageListenerAdapter;
    }

    @Bean
    MessageListenerAdapter customerCreatedMessageListener(CustomerCreatedEventReceiver receiver) {
        MessageListenerAdapter messageListenerAdapter = new MessageListenerAdapter(receiver, "receiveMessage");
        messageListenerAdapter.setSerializer(new Jackson2JsonRedisSerializer<CustomerCreatedEvent>(CustomerCreatedEvent.class));
        return messageListenerAdapter;
    }
--------------------------------------------------------------------------------------------------------
import io.netty.channel.Channel;

import java.net.SocketAddress;

public class NettyUtil {

    /**
     * 获取Channel的远程IP地址
     * @param channel
     * @return
     */
    public static String parseChannelRemoteAddr(final Channel channel) {
        if (null == channel) {
            return "";
        }
        SocketAddress remote = channel.remoteAddress();
        final String addr = remote != null ? remote.toString() : "";

        if (addr.length() > 0) {
            int index = addr.lastIndexOf("/");
            if (index >= 0) {
                return addr.substring(index + 1);
            }

            return addr;
        }

        return "";
    }
}
--------------------------------------------------------------------------------------------------------
import com.quark.common.entity.User;
import org.springframework.cache.annotation.CacheConfig;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
@CacheConfig(cacheNames = "users")
public interface UserDao extends JpaRepository<User,Integer> ,JpaSpecificationExecutor {

    User findByUsername(String username);

    User findByEmail(String email);

    @Query(value = "select u.id, u.username , u.icon from quark_user u where DATE_SUB(CURDATE(), INTERVAL 30 DAY) <=DATE(u.init_time) ORDER BY u.id DESC limit 12" ,nativeQuery = true)
    List<Object> findNewUser();

}
--------------------------------------------------------------------------------------------------------
    class Solution {
        public int solution(final int[] A) {
            final int N = A.length;
            final Set<Integer> set = new HashSet<>();
            for (int a : A) {
                if (a > 0) {
                    set.add(a);
                }
            }
            for (int i = 1; i <= N + 1; i++) {
                if (!set.contains(i)) {
                    return i;
                }
            }
            return 0;
        }
    }
--------------------------------------------------------------------------------------------------------
int N = A.length;
Set<Integer> set = new HashSet<>();
for (int a : A) {
    if (a > 0) {
        set.add(a);
    }
}
for (int i = 1; i <= N + 1; i++) {
    if (!set.contains(i)) {
        return i;
    }
}
--------------------------------------------------------------------------------------------------------
import com.auth0.spring.security.api.JwtWebSecurityConfigurer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;


@Configuration
@EnableWebSecurity(debug = true)
public class AppConfig extends WebSecurityConfigurerAdapter {

    @Value(value = "${auth0.apiAudience}")
    private String apiAudience;
    @Value(value = "${auth0.issuer}")
    private String issuer;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        JwtWebSecurityConfigurer
                .forRS256(apiAudience, issuer)
                .configure(http)
                .authorizeRequests()
                .antMatchers(HttpMethod.GET, "/login").permitAll()
                .antMatchers(HttpMethod.GET, "/photos/**").hasAuthority("read:photos")
                .antMatchers(HttpMethod.POST, "/photos/**").hasAuthority("create:photos")
                .antMatchers(HttpMethod.PUT, "/photos/**").hasAuthority("update:photos")
                .antMatchers(HttpMethod.DELETE, "/photos/**").hasAuthority("delete:photos")
                .anyRequest().authenticated();
    }

}
--------------------------------------------------------------------------------------------------------
import com.embedler.moon.graphql.boot.sample.schema.TodoSchema;
import com.oembedler.moon.graphql.boot.GraphQLContext;
import com.oembedler.moon.graphql.engine.relay.RelayNode;
import com.oembedler.moon.graphql.engine.stereotype.*;
import org.springframework.beans.factory.annotation.Autowired;

/**
 * @author <a href="mailto:java.lang.RuntimeException@gmail.com">oEmbedler Inc.</a>
 */
@GraphQLObject("Root")
public class RootObjectType {

    @GraphQLNonNull
    @GraphQLField("version")
    @GraphQLDescription("Root query version number")
    public static final String VERSION = "0.9.0.2";

    @Autowired
    @GraphQLIgnore
    private TodoSchema todoSchema;

    @GraphQLField
    public UserObjectType viewer() {
        return todoSchema.getTheOnlyUser();
    }

    @GraphQLField
    public RelayNode node(@GraphQLID @GraphQLNonNull @GraphQLIn("id") final String id) {
        return new UserObjectType();
    }
}
--------------------------------------------------------------------------------------------------------

import org.springframework.boot.autoconfigure.condition.ConditionOutcome;
import org.springframework.boot.autoconfigure.condition.SpringBootCondition;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.context.annotation.ConfigurationCondition;
import org.springframework.core.type.AnnotatedTypeMetadata;
import org.springframework.util.StringUtils;

import java.util.Map;

/**
 * Condition that checks whether the specified bean by placeholder like: ${bean.name:defaultName} exists.
 * Spring's ConditionalOnMissingBean does not support placeholder resolution.
 */
public class OnMissingBeanCondition extends SpringBootCondition implements ConfigurationCondition {


    @Override
    public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
        Map<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());
        String beanName = ((String[]) beanAttributes.get("name"))[0];
        if(StringUtils.isEmpty(beanName)) {
            throw new IllegalStateException("OnMissingBeanCondition can't detect bean name!");
        }
        boolean missingBean = !context.getBeanFactory().containsBean(context.getEnvironment().resolveRequiredPlaceholders(beanName));
        return missingBean ? ConditionOutcome.match(beanName + " not found") : ConditionOutcome.noMatch(beanName + " found");
    }

    @Override
    public ConfigurationPhase getConfigurationPhase() {
        return ConfigurationPhase.REGISTER_BEAN;
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.net.URLEncoder;

/**
 * Author: qing
 * Date: 14-11-7
 */
public class ExceptionHandler implements HandlerExceptionResolver {

    @Override
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
        ModelAndView mav = new ModelAndView();

        try{
            mav.setViewName("redirect:/error.jhtml?messages=" + URLEncoder.encode(ex.getMessage(),"utf-8"));
        } catch (Exception e) {
            mav.setViewName("redirect:/error.jhtml");
        }

        return mav;
    }
}
--------------------------------------------------------------------------------------------------------
public enum Permission
{
	// user role
	USER("user:*", "user query,view,edit,add,delete"),
	USER_VIEW("user:view", "user query,view"),
	ROLE("role:*", "role query,view,edit,add,delete"),
	ROLE_VIEW("role:view", "role query,view"),

	// license
	LICENSE("license:setting", "license:setting");

	private String abbreviation;

	private String description;

	private Permission(String abbreviation, String description)
	{

		this.abbreviation = abbreviation;
		this.description = description;
	}

	public String getAbbreviation()
	{

		return this.abbreviation;
	}

	public String getDescription()
	{

		return this.description;
	}
}
--------------------------------------------------------------------------------------------------------
import java.util.Collections;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.embedded.ServletListenerRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configurers.GlobalAuthenticationConfigurerAdapter;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.JdbcUserDetailsManager;
import org.springframework.security.web.authentication.RememberMeServices;
import org.springframework.security.web.authentication.rememberme.InMemoryTokenRepositoryImpl;
import org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl;
import org.springframework.security.web.authentication.rememberme.PersistentTokenBasedRememberMeServices;
import org.springframework.security.web.session.HttpSessionEventPublisher;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;

/**
 * Class containing all security methods and beans.
 *
 * @author Arnaldo Piccinelli
 */
@Configuration
@EnableWebSecurity
@Order(Ordered.HIGHEST_PRECEDENCE)
public class MultiHttpSecurityConfig {

	private static final String[] UNSECURED_RESOURCE_LIST = new String[] { "/resources/**", "/assets/**", "/css/**",
			"/webjars/**", "/images/**", "/dandelion/**", "/js/**" };

	private static final String[] UNAUTHORIZED_RESOURCE_LIST = new String[] { "/test.html", "/", "/unauthorized*",
			"/error*", "/users*", "/accessDenied" };

	@Configuration
	@Profile({ "dev" })
	protected static class InMemoryPersistentTokenRememberMeSetup {
		@Value("${rememberMeToken}")
		private String rememberMeToken;

		@Value("${rememberMeParameter}")
		private String rememberMeParameter;

		@Bean
		public RememberMeServices getRememberMeServices() {
			PersistentTokenBasedRememberMeServices services = new PersistentTokenBasedRememberMeServices(
					rememberMeToken, new BasicRememberMeUserDetailsService(), new InMemoryTokenRepositoryImpl());
			services.setParameter(rememberMeParameter);
			return services;
		}

		public class BasicRememberMeUserDetailsService implements UserDetailsService {
			@Override
			public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
				return new User(username, "", Collections.<GrantedAuthority> emptyList());
			}
		}
	}

	@Configuration
	@Profile({ "test", "live" })
	protected static class JdbcPersistentTokenRememberMeSetup {
		@Value("${rememberMeToken}")
		private String rememberMeToken;

		@Value("${rememberMeParameter}")
		private String rememberMeParameter;

		@Autowired
		private DataSource dataSource;

		@Bean
		public RememberMeServices getRememberMeServices() {
			JdbcUserDetailsManager jdbcUserDetailsManager = new JdbcUserDetailsManager();
			jdbcUserDetailsManager.setDataSource(dataSource);

			JdbcTokenRepositoryImpl jdbcTokenRepositoryImpl = new JdbcTokenRepositoryImpl();
			jdbcTokenRepositoryImpl.setDataSource(dataSource);

			PersistentTokenBasedRememberMeServices services = new PersistentTokenBasedRememberMeServices(
					rememberMeToken, jdbcUserDetailsManager, jdbcTokenRepositoryImpl);
			services.setParameter(rememberMeParameter);
			return services;
		}
	}

	@Order(Ordered.HIGHEST_PRECEDENCE)
	@Configuration
	protected static class ExternalAuthenticationSecurity extends GlobalAuthenticationConfigurerAdapter {
		@Autowired
		private DataSource dataSource;

		@Override
		public void init(AuthenticationManagerBuilder auth) throws Exception {
			//@formatter:off
			String authoritiesByUsernameQuery = "select username, authority from user_authorities " +
					"inner join users on user_authorities.user_id = users.id " +
					"inner join authorities on user_authorities.authority_id = authorities.id " +
					"where username = ?";

			JdbcUserDetailsManager userDetailsService = new JdbcUserDetailsManager();
			userDetailsService.setDataSource(dataSource);
			userDetailsService.setAuthoritiesByUsernameQuery(authoritiesByUsernameQuery);
			PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

			auth
				.userDetailsService(userDetailsService)
					.passwordEncoder(passwordEncoder)
				.and()
					.jdbcAuthentication()
						.authoritiesByUsernameQuery(authoritiesByUsernameQuery)
						.passwordEncoder(passwordEncoder)
						.dataSource(dataSource)
			;
			//@formatter:on
		}
	}

	@Configuration
	@Order(1)
	@Profile({ "live" })
	public static class LiveWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {
		@Value("${rememberMeToken}")
		private String rememberMeToken;

		@Value("${spring.profiles.active}")
		private String activeProfile;

		@Autowired
		RememberMeServices rememberMeServices;

		@Override
		public void configure(WebSecurity web) throws Exception {
			//@formatter:off
			web
				.ignoring()
					.antMatchers(UNSECURED_RESOURCE_LIST);
			//@formatter:on
		}

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			//@formatter:off
			http
				.headers()
					.frameOptions()
						.sameOrigin()
			.and()
				.authorizeRequests()
					.antMatchers(UNAUTHORIZED_RESOURCE_LIST)
						.permitAll()
					.antMatchers("/git", "/manage", "/manage/**")
						.hasRole("ADMIN")
					.anyRequest()
						.authenticated()
			.and()
				.formLogin()
					.loginPage("/login")
					.permitAll()
			.and()
				.headers()
					.cacheControl()
				.and()
					.frameOptions()
						.deny()
			.and()
				.exceptionHandling()
					.accessDeniedPage("/access?error")
			.and()
				.rememberMe()
					.useSecureCookie(true)
					.tokenValiditySeconds(60 * 60 * 24 * 10) // 10 days
					.rememberMeServices(rememberMeServices)
					.key(rememberMeToken)
			.and()
				.logout()
					.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))
					.logoutSuccessUrl("/?logout")
			.and()
				.sessionManagement()
					.maximumSessions(1)
					.expiredUrl("/login?expired");
			// @formatter:on
		}
	}

	@Configuration
	@Order(1)
	@Profile({ "dev", "test" })
	public static class NonLiveWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {
		@Value("${rememberMeToken}")
		private String rememberMeToken;

		@Value("${spring.profiles.active}")
		private String activeProfile;

		@Autowired
		RememberMeServices rememberMeServices;

		@Override
		public void configure(WebSecurity web) throws Exception {
			//@formatter:off
			web
				.ignoring()
					.antMatchers(UNSECURED_RESOURCE_LIST);
			//@formatter:on
		}

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			//@formatter:off
			http
				.headers()
					.frameOptions()
						.sameOrigin()
			.and()
				.authorizeRequests()
					.antMatchers(UNAUTHORIZED_RESOURCE_LIST)
						.permitAll()
					.antMatchers("/git", "/manage", "/manage/**")
						.permitAll()
					.anyRequest()
						.authenticated()
			.and()
				.formLogin()
					.loginPage("/login")
					.permitAll()
			.and()
				.headers()
					.cacheControl()
				.and()
					.frameOptions()
						.deny()
			.and()
				.exceptionHandling()
					.accessDeniedPage("/access?error")
			.and()
				.rememberMe()
					.useSecureCookie(true)
					.tokenValiditySeconds(60 * 60 * 24 * 10) // 10 days
					.rememberMeServices(rememberMeServices)
					.key(rememberMeToken)
			.and()
				.logout()
					.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))
					.logoutSuccessUrl("/?logout")
			.and()
				.sessionManagement()
					.maximumSessions(1)
					.expiredUrl("/login?expired");
			// @formatter:on
		}
	}

	// Register HttpSessionEventPublisher
	@Bean
	public static ServletListenerRegistrationBean<HttpSessionEventPublisher> httpSessionEventPublisher() {
		return new ServletListenerRegistrationBean<HttpSessionEventPublisher>(new HttpSessionEventPublisher());
	}
}
--------------------------------------------------------------------------------------------------------

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import org.apache.catalina.connector.Connector;
import org.apache.coyote.http11.Http11NioProtocol;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;
import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.core.io.ClassPathResource;
import org.springframework.util.FileCopyUtils;

/**
 * Configuration class that allows for Tomcat access via HTTP (test only) and
 * HTTPS.
 *
 * @author Arnaldo Piccinelli
 */
@Configuration
@EnableConfigurationProperties
public class TomcatConfig {

	@Profile({ "test" })
	public static class MultiTomcatConfig {

		@Value("${ssl.keystore.file}")
		private String sslKeystoreFile;

		@Value("${ssl.keystore.password}")
		private String sslKeystorePassword;

		@Value("${ssl.keystore.type}")
		private String sslKeystoreType;

		@Value("${ssl.keystore.alias}")
		private String sslKeystoreAlias;

		@Value("${tls.port}")
		private int tlsPort;

		@Bean
		public EmbeddedServletContainerFactory getServletContainer() {
			TomcatEmbeddedServletContainerFactory tomcat = new TomcatEmbeddedServletContainerFactory();
			tomcat.addAdditionalTomcatConnectors(createSslConnector());
			return tomcat;
		}

		private Connector createSslConnector() {
			Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol");
			Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();
			try {
				connector.setScheme("https");
				connector.setSecure(true);
				connector.setPort(tlsPort);

				File keystore = getKeyStoreFile();
				File truststore = keystore;

				protocol.setSSLEnabled(true);
				protocol.setKeystoreFile(keystore.getAbsolutePath());
				protocol.setKeystorePass(sslKeystorePassword);
				protocol.setTruststoreFile(truststore.getAbsolutePath());
				protocol.setTruststorePass(sslKeystorePassword);
				protocol.setKeyAlias(sslKeystoreAlias);
				return connector;
			} catch (IOException ex) {
				throw new IllegalStateException(
						"can't access keystore: [" + "keystore" + "] or truststore: [" + "keystore" + "]", ex);
			}
		}

		private File getKeyStoreFile() throws IOException {
			ClassPathResource resource = new ClassPathResource(sslKeystoreFile);
			try {
				return resource.getFile();
			} catch (Exception ex) {
				File temp = File.createTempFile("keystore", ".tmp");
				FileCopyUtils.copy(resource.getInputStream(), new FileOutputStream(temp));
				return temp;
			}
		}

	}
}
--------------------------------------------------------------------------------------------------------
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


public class JbootRequestContext {
    private static ThreadLocal<HttpServletRequest> requests = new ThreadLocal<>();
    private static ThreadLocal<HttpServletResponse> responses = new ThreadLocal<>();


    public static void handle(HttpServletRequest req, HttpServletResponse response) {
        requests.set(req);
        responses.set(response);
    }

    public static HttpServletRequest getRequest() {
        return requests.get();
    }

    public static HttpServletResponse getResponse() {
        return responses.get();
    }

    public static void release() {
        requests.remove();
        responses.remove();
    }


    public static <T> T getRequestAttr(String key) {
        HttpServletRequest request = requests.get();
        if (request == null) {
            return null;
        }

        return (T) request.getAttribute(key);
    }

    public static void setRequestAttr(String key, Object value) {
        HttpServletRequest request = requests.get();
        if (request == null) {
            return;
        }

        request.setAttribute(key, value);
    }

}
--------------------------------------------------------------------------------------------------------
    public static String escapeHtml(String text) {
        if (isBlank(text))
            return text;

        return text.replace("<", "&lt;").replace(">", "&gt;").replace("\"", "&quot;").replace("'", "&#x27;").replace("/", "&#x2F;");
    }
--------------------------------------------------------------------------------------------------------

    /**
     * 是否是手机浏览器
     *
     * @return
     */
    public static boolean isMoblieBrowser(HttpServletRequest request) {
        String ua = request.getHeader("User-Agent");
        if (ua == null) {
            return false;
        }
        ua = ua.toLowerCase();
        for (String mobileAgent : mobileAgents) {
            if (ua.indexOf(mobileAgent) >= 0) {
                return true;
            }
        }
        return false;
    }

    /**
     * 是否是微信浏览器
     *
     * @return
     */
    public static boolean isWechatBrowser(HttpServletRequest request) {
        String ua = request.getHeader("User-Agent");
        if (ua == null) {
            return false;
        }
        ua = ua.toLowerCase();
        if (ua.indexOf("micromessenger") > 0) {
            return true;
        }
        return false;
    }
--------------------------------------------------------------------------------------------------------
import io.jboot.config.annotation.PropertyConfig;


@PropertyConfig(prefix = "jboot.schedule")
public class JbooScheduleConfig {
    private String cron4jFile = "cron4j.properties";
    private int poolSize = Runtime.getRuntime().availableProcessors() * 8;


    public String getCron4jFile() {
        return cron4jFile;
    }

    public void setCron4jFile(String cron4jFile) {
        this.cron4jFile = cron4jFile;
    }

    public int getPoolSize() {
        return poolSize;
    }

    public void setPoolSize(int poolSize) {
        this.poolSize = poolSize;
    }
}
--------------------------------------------------------------------------------------------------------
	@Configuration
	@Order(-20)
	protected static class LoginConfig extends WebSecurityConfigurerAdapter {

		@Autowired
		private AuthenticationManager authenticationManager;

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			// @formatter:off
			http.formLogin().loginPage("/login").permitAll().and().requestMatchers()
					.antMatchers("/login", "/oauth/authorize", "/oauth/confirm_access").and().authorizeRequests()
					.anyRequest().authenticated();
			// @formatter:on
		}

		@Override
		protected void configure(AuthenticationManagerBuilder auth) throws Exception {
			auth.parentAuthenticationManager(authenticationManager);
		}
	}
--------------------------------------------------------------------------------------------------------
/**
 *
 * @author hantsy
 */
@Configuration
public class Jackson2ObjectMapperConfig {
        
    @Bean
    public Jackson2ObjectMapperBuilder objectMapperBuilder(JsonComponentModule jsonComponentModule) {
   
        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
            builder
    //                .serializerByType(ZonedDateTime.class, new JsonSerializer<ZonedDateTime>() {
    //                    @Override
    //                    public void serialize(ZonedDateTime zonedDateTime, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException, JsonProcessingException {
    //                        jsonGenerator.writeString(DateTimeFormatter.ISO_ZONED_DATE_TIME.format(zonedDateTime));
    //                    }
    //                })
                .serializationInclusion(JsonInclude.Include.NON_EMPTY)
                .featuresToDisable(
                        SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,
                        DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES,
                        DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES
                )
                .featuresToEnable(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)
                .indentOutput(true)
                .modulesToInstall(jsonComponentModule);
    
        return builder;
    } 
    
}
--------------------------------------------------------------------------------------------------------
	public static ZonedDateTime getZonedDateTime(Object value) {
		ZonedDateTime dateTime;
		if (value instanceof ZonedDateTime) {
			dateTime = ZonedDateTime.class.cast(value);
		} else {
			dateTime = parseZonedDateTime(value.toString());
		}
		return dateTime;
	}

	public static ZonedDateTime parseZonedDateTime(String dateString) {
		ZonedDateTime dateTime;
		try {
			long epoch = Long.parseLong(dateString);

			dateTime = Instant.ofEpochMilli(epoch).atOffset(ZoneOffset.ofTotalSeconds(0))
					.toZonedDateTime();
		} catch (NumberFormatException e) {
			// try ZonedDateTime instead
			dateTime = ZonedDateTime.parse(dateString);
		}

		return dateTime;
	}
--------------------------------------------------------------------------------------------------------
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.cloud.gateway.handler.predicate.RoutePredicateFactory;

/**
 * @author Spencer Gibb
 */
public class RoutePredicateFactoryUtils {
	private static final Log logger = LogFactory.getLog(RoutePredicateFactory.class);

	public static void traceMatch(String prefix, Object desired, Object actual, boolean match) {
		if (logger.isTraceEnabled()) {
			String message = String.format("%s \"%s\" %s against value \"%s\"",
					prefix, desired, match ? "matches" : "does not match", actual);
			logger.trace(message);
		}
	}
}
--------------------------------------------------------------------------------------------------------
import com.google.common.base.Optional;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;

public class DomainUsernamePasswordAuthenticationProvider implements AuthenticationProvider {

    private TokenService tokenService;
    private ExternalServiceAuthenticator externalServiceAuthenticator;

    public DomainUsernamePasswordAuthenticationProvider(TokenService tokenService, ExternalServiceAuthenticator externalServiceAuthenticator) {
        this.tokenService = tokenService;
        this.externalServiceAuthenticator = externalServiceAuthenticator;
    }

    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        Optional<String> username = (Optional) authentication.getPrincipal();
        Optional<String> password = (Optional) authentication.getCredentials();

        if (!username.isPresent() || !password.isPresent()) {
            throw new BadCredentialsException("Invalid Domain User Credentials");
        }

        AuthenticationWithToken resultOfAuthentication = externalServiceAuthenticator.authenticate(username.get(), password.get());
        String newToken = tokenService.generateNewToken();
        resultOfAuthentication.setToken(newToken);
        tokenService.store(newToken, resultOfAuthentication);

        return resultOfAuthentication;
    }

    @Override
    public boolean supports(Class<?> authentication) {
        return authentication.equals(UsernamePasswordAuthenticationToken.class);
    }
}
--------------------------------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd">
    <!-- 14400 == 4 hours
         No disk storage
         Unlimited memory for elements
         Elements are evicted by Spring scheduled task
         by default run every 30 minutes
     -->
    <cache name="restApiAuthTokenCache" eternal="false" maxElementsInMemory="0" overflowToDisk="false"
           timeToLiveSeconds="14400" memoryStoreEvictionPolicy="LRU">
        <persistence strategy="none"/>
    </cache>
</ehcache>
--------------------------------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8" ?><gpx version="1.0" creator="GPSLogger 103 - http://gpslogger.mendhak.com/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.topografix.com/GPX/1/0" xsi:schemaLocation="http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd"><time>2019-10-03T20:26:03.000Z</time><trk><trkseg><trkpt lat="59.958738333333336" lon="30.400466666666663"><ele>-31.5</ele><time>2019-10-03T20:26:03.000Z</time><course>0.0</course><speed>0.0</speed><geoidheight>18.0</geoidheight><src>gps</src><hdop>6.26</hdop><vdop>1.00</vdop><pdop>6.34</pdop></trkpt>
<trkpt lat="59.954496666666664" lon="30.407616666666666"><ele>-36.2</ele><time>2019-10-03T20:31:00.000Z</time><course>201.54</course><speed>2.3378685</speed><geoidheight>18.0</geoidheight><src>gps</src><hdop>3.19</hdop><vdop>1.00</vdop><pdop>3.34</pdop></trkpt>
<trkpt lat="59.951800000000006" lon="30.40981"><ele>102.4</ele><time>2019-10-03T20:34:32.000Z</time><course>0.0</course><speed>0.0</speed><geoidheight>18.0</geoidheight><src>gps</src><hdop>1.89</hdop><vdop>0.97</vdop><pdop>2.13</pdop></trkpt>
<trkpt lat="59.947044999999996" lon="30.409908333333338"><ele>103.6</ele><time>2019-10-03T20:39:21.000Z</time><course>253.62</course><speed>2.2359533</speed><geoidheight>18.0</geoidheight><src>gps</src><hdop>1.97</hdop><vdop>1.00</vdop><pdop>2.21</pdop></trkpt>
<trkpt lat="59.94224166666666" lon="30.410753333333332"><ele>307.9</ele><time>2019-10-03T20:44:15.000Z</time><course>227.29</course><speed>0.7267878</speed><geoidheight>18.0</geoidheight><src>gps</src><hdop>0.88</hdop><vdop>0.83</vdop><pdop>1.21</pdop></trkpt>
<trkpt lat="59.93798166666667" lon="30.410875"><ele>307.3</ele><time>2019-10-03T20:47:57.000Z</time><course>181.25</course><speed>1.6759355</speed><geoidheight>18.0</geoidheight><src>gps</src><hdop>2.24</hdop><vdop>0.99</vdop><pdop>2.45</pdop></trkpt>
</trkseg></trk></gpx>	RestTemplateBuilder builder = optional.orElse(new RestTemplateBuilder());
--------------------------------------------------------------------------------------------------------	RestTemplateBuilder builder = optional.orElse(new RestTemplateBuilder());
		RestTemplate template = builder.build();
		template.setErrorHandler(new NoOpResponseErrorHandler());
		template.getMessageConverters().add(new ByteArrayHttpMessageConverter() {
			@Override
			public boolean supports(Class<?> clazz) {
				return true;
			}
		});
--------------------------------------------------------------------------------------------------------
Описание для Linux CLI Launcher

Are you sick of all those colorful and chaotic launchers?
Did Icons, App Drawer and Dock bother you enough?
Do you miss those times when you could do whatever you wanted with a simple command?
Then, T-UI Launcher and its Linux-like CLI (Command Line Interface) is exactly what you need.


Features:
∙ T-UI commands (like uninstall, open, sms, ..)
∙ Native Android/Linux commands
∙ aliases, use your favourite commands faster
∙ suggestions, to help you compose your commands
∙ RSS reader
∙ in-app notes, for your to-do list
∙ reply to your notifications directly from your launcher
∙ online theme repository, share your own setup with the community
∙ TUIXT, in-app text editor
∙ extremely highly customizable launcher
∙ CLI music player
∙ full Linux-like CLI interface


Some T-UI commands:
∙ uninstall [app]
∙ sms [contact] [text]
∙ call [contact]
∙ calc [expression]
∙ search [google, playstore, youtube, files]
∙ wifi
∙ flash
∙ share [file]
∙ mv / cp [file] [dest]
+ many other Linux commands

Useful links:
Wiki -> https://goo.gl/5znteK
Google+ community -> https://goo.gl/aoMnXX
GitHub -> https://goo.gl/As4JG6
Twitter -> https://goo.gl/pgWs8V
Telegram -> https://goo.gl/sqy2ft

--------------------------------------------------------------------------------------------------------
import java.util.TreeMap;

public class RomanNumberUtils {
    private final static TreeMap<Long, String> map = new TreeMap<Long, String>();

    static {
        map.put(1000L, "M");
        map.put(900L, "CM");
        map.put(500L, "D");
        map.put(400L, "CD");
        map.put(100L, "C");
        map.put(90L, "XC");
        map.put(50L, "L");
        map.put(40L, "XL");
        map.put(10L, "X");
        map.put(9L, "IX");
        map.put(5L, "V");
        map.put(4L, "IV");
        map.put(1L, "I");
    }

    public final static String toRoman(Long number) {
        Long l =  map.floorKey(number);
        if ( number == l ) {
            return map.get(number);
        }
        return map.get(l) + toRoman(number-l);
    }
}
--------------------------------------------------------------------------------------------------------

import com.exercise.domain.enumeration.Permission;
import com.exercise.service.ConverterService;
import com.exercise.service.utils.DecimalNumberUtils;
import com.exercise.service.utils.RomanNumberUtils;
import com.exercise.web.response.ConverterResponse;
import org.springframework.stereotype.Component;

import com.exercise.exception.NumberConvertException;

@Component
public class ConverterServiceImpl implements ConverterService {

	@Override
	public ConverterResponse hexaToBinario(String number) throws NumberConvertException {
		Long value = DecimalNumberUtils.hexaToDecimal(number);
		String result = toBinario(value);
		return new ConverterResponse(number, result, Permission.BINARIO);
	}

	@Override
	public ConverterResponse hexaToHexa(String number) throws NumberConvertException {
		Long value = DecimalNumberUtils.hexaToDecimal(number);
		String result = toHexa(value);
		return new ConverterResponse(number, result, Permission.HEXADECIMAL);
	}

	@Override
	public ConverterResponse hexaToRomano(String number) throws NumberConvertException {
		Long value = DecimalNumberUtils.hexaToDecimal(number);
		String result = toRomano(value);
		return new ConverterResponse(number, result, Permission.ROMANO);
	}

	@Override
	public ConverterResponse hexaToDecimal(String number) throws NumberConvertException {
		Long value = DecimalNumberUtils.hexaToDecimal(number);
		String result = toDecimal(value);
		return new ConverterResponse(number, result, Permission.DECIMAL);
	}

	@Override
	public ConverterResponse binarioToBinario(String number) throws NumberConvertException {
		Long value = DecimalNumberUtils.binaryToDecimal(number);
		String result = toBinario(value);
		return new ConverterResponse(number, result, Permission.BINARIO);
	}

	@Override
	public ConverterResponse binarioToHexa(String number) throws NumberConvertException {
		Long value = DecimalNumberUtils.binaryToDecimal(number);
		String result = toHexa(value);
		return new ConverterResponse(number, result, Permission.HEXADECIMAL);
	}

	@Override
	public ConverterResponse binarioToRomano(String number) throws NumberConvertException {
		Long value = DecimalNumberUtils.binaryToDecimal(number);
		String result = toRomano(value);
		return new ConverterResponse(number, result, Permission.ROMANO);
	}

	@Override
	public ConverterResponse binarioToDecimal(String number) throws NumberConvertException {
		Long value = DecimalNumberUtils.binaryToDecimal(number);
		String result = toDecimal(value);
		return new ConverterResponse(number, result, Permission.DECIMAL);
	}

	@Override
	public ConverterResponse decimalToBinario(String number) throws NumberConvertException {
		Long value = DecimalNumberUtils.stringToDecimal(number);
		String result = toBinario(value);
		return new ConverterResponse(number, result, Permission.BINARIO);
	}

	@Override
	public ConverterResponse decimalToHexa(String number) throws NumberConvertException {
		Long value = DecimalNumberUtils.stringToDecimal(number);
		String result = toHexa(value);
		return new ConverterResponse(number, result, Permission.HEXADECIMAL);
	}

	@Override
	public ConverterResponse decimalToRomano(String number) throws NumberConvertException {
		Long value = DecimalNumberUtils.stringToDecimal(number);
		String result = toRomano(value);
		return new ConverterResponse(number, result, Permission.ROMANO);
	}

	@Override
	public ConverterResponse decimalToDecimal(String number) throws NumberConvertException {
		Long value = DecimalNumberUtils.stringToDecimal(number);
		String result = toDecimal(value);
		return new ConverterResponse(number, result, Permission.DECIMAL);
	}

	private String toBinario(Long value) throws NumberConvertException {
		if (value != null) {
			return Long.toBinaryString(value);
		}

		throw new NumberConvertException("cant convert");
	}

	private String toHexa(Long value) throws NumberConvertException {
		if (value != null) {
			return Long.toHexString(value).toUpperCase();
		}

		throw new NumberConvertException("cant convert");
	}

	private String toRomano(Long value) throws NumberConvertException {
		if (value != null) {
			return RomanNumberUtils.toRoman(value);
		}

		throw new NumberConvertException("cant convert");
	}

	private String toDecimal(Long value) throws NumberConvertException {
		if (value != null) {
			return String.valueOf(value);
		}

		throw new NumberConvertException("cant convert");
	}
}
--------------------------------------------------------------------------------------------------------
import com.exercise.security.user.DummyUser;
import com.exercise.service.UserService;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.Collections;

public class AuthenticationFilter extends UsernamePasswordAuthenticationFilter {

    private AuthenticationManager authManager;
    private UserService userService;

    /**
     * Listen for auth path on url
     * @param authManager
     */
    public AuthenticationFilter(AuthenticationManager authManager,
                                UserService userService) {
        this.authManager = authManager;
        this.userService = userService;
    }

    @Override
    protected boolean requiresAuthentication(HttpServletRequest request, HttpServletResponse response) {
        return true;
    }

    /**
     *  Get credentials from request
     *  Create auth object (contains credentials) which will be used by auth manager
     *  Authentication manager authenticate the user, and use UserDetialsServiceImpl::loadUserByUsername() method to load the user
     * @param request
     * @param response
     * @return
     * @throws AuthenticationException
     */

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) {
        DummyUser creds = readBasicAuthorization(request);
        String username = creds.getUsername();
        String password = creds.getPassword();
        Authentication authToken = new UsernamePasswordAuthenticationToken(username, password, Collections.EMPTY_LIST);
        try {
            return authManager.authenticate(authToken);
        } catch (AuthenticationException ex) {
            throw ex;
        }
    }

    /**
     * Generate token if success auth
     * @param request
     * @param response
     * @param chain
     * @param auth
     */
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                            FilterChain chain, Authentication auth)
            throws IOException, ServletException {
        SecurityContextHolder.getContext().setAuthentication(auth);
        chain.doFilter(request, response);
    }

    private DummyUser readBasicAuthorization(HttpServletRequest request) {
        final String authorization = request.getHeader(HttpHeaders.AUTHORIZATION);
        DummyUser creds = new DummyUser();

        if (authorization != null && authorization.toLowerCase().startsWith("basic")) {
            // Authorization: Basic base64credentials
            String base64Credentials = authorization.substring("Basic".length()).trim();
            byte[] credDecoded = Base64.getDecoder().decode(base64Credentials);
            String credentials = new String(credDecoded, StandardCharsets.UTF_8);
            // credentials = username:password
            final String[] values = credentials.split(":", 2);
            if (values.length > 1) {
                creds.setUsername(values[0]);
                creds.setPassword(values[1]);
            }
        }

        return creds;
    }
}
--------------------------------------------------------------------------------------------------------
@Test(expected = UnsupportedOperationException.class)
public void encodableMimeTypesIsImmutable() {
  MimeType textJavascript = new MimeType("text", "javascript", StandardCharsets.UTF_8);
  Jackson2JsonEncoder encoder = new Jackson2JsonEncoder(new ObjectMapper(), textJavascript);
  encoder.getMimeTypes().add(new MimeType("text", "ecmascript"));
}
--------------------------------------------------------------------------------------------------------
import com.exercise.exception.NumberConvertException;

import javax.persistence.Entity;
import java.util.Arrays;

/**
 * The Permission enumeration.
 */
public enum Permission {
    BINARIO("BINARIO"),
    HEXADECIMAL("HEXADECIMAL"),
    DECIMAL("DECIMAL"),
    ROMANO("ROMANO"),
    MASTER("MASTER");

    private String code;

    Permission(String code) {
        this.code = code;
    }

    @Override
    public String toString() {
        return name().toUpperCase();
    }

    public static Permission byCode(String code) throws NumberConvertException {
        return Arrays.stream(Permission.values())
                .filter(e -> e.code.equalsIgnoreCase(code))
                .findFirst()
                .orElseThrow(() -> new NumberConvertException(String.format("Unsupported type %s.", code)));
    }
}
--------------------------------------------------------------------------------------------------------
User-agent: *
Allow: /*.js
Allow: /*.css
Disallow: /bitrix/
Disallow: /bitrix/tools/
Disallow: /_exploits/
Disallow: /_download/
Disallow: /blog/search.php
Disallow: /bitrix/exturl.php
Disallow: /begun/
Disallow: /admin/
Disallow: /software/download/
Disallow: /tools/_services/download/
Disallow: /bitrix/tools/
Disallow: /search/
Disallow: /forum/view_profile.php
Disallow: /forum/search/
Disallow: /forum/topic/new/
Disallow: /forum/topic/add/
Disallow: /forum/subscr_list.php
Disallow: /forum/send_message.php 
Disallow: /forum/search.php
Disallow: /forum/search/
Disallow: /forum/new_topic.php 
Disallow: /forum/move.php
Disallow: /forum/active.php
Disallow: /forum/forum_auth.php
Disallow: /forum/forum_posts.asp
Disallow: /blog/video/
Disallow: /blog/company/search.php
Disallow: /blog/personal/search.php
Disallow: /bitrix/tools

User-agent: yandex
Disallow: /bitrix/
Disallow: /bitrix/tools/
Disallow: /_exploits/
Disallow: /_download/
Disallow: /blog/search.php
Disallow: /bitrix/exturl.php
Disallow: /begun/
Disallow: /admin/
Disallow: /software/download/
Disallow: /tools/_services/download/
Disallow: /bitrix/tools/
Disallow: /search/
Disallow: /forum/view_profile.php
Disallow: /forum/search/
Disallow: /forum/topic/new/
Disallow: /forum/topic/add/
Disallow: /forum/subscr_list.php
Disallow: /forum/send_message.php 
Disallow: /forum/search.php
Disallow: /forum/search/
Disallow: /forum/new_topic.php 
Disallow: /forum/move.php
Disallow: /forum/active.php
Disallow: /forum/forum_auth.php
Disallow: /forum/forum_posts.asp
Disallow: /blog/video/
Disallow: /blog/company/search.php
Disallow: /blog/personal/search.php
Disallow: /bitrix/tools
Clean-param: rules
Clean-param: user_list
Clean-param: register
Clean-param: auth 
Clean-param: backurl 
Clean-param: order 
Clean-param: set_filter 
Clean-param: arrFilter 
Clean-param: ACTION
Clean-param: el_id
Clean-param: back_url
Clean-param: sec_id
Clean-param: utm_source
Clean-param: utm_medium
Clean-param: post
Clean-param: x
Clean-param: MARK
Clean-param: rate
Clean-param: y
Clean-param: r2
Clean-param: r1
Clean-param: TB_iframe
Clean-param: goto
Clean-param: cof
Clean-param: cx
Clean-param: height
Clean-param: width
Clean-param: year
Clean-param: month
Clean-param: R2
Clean-param: R1
Clean-param: category
Clean-param: country
Clean-param: login
Clean-param: delete_trackback_id
Clean-param: sessid
Clean-param: auth_service_id
Clean-param: auth_service_error

Host: https://www.securitylab.ru

User-agent: Mozilla/4.0 (compatible; Netcraft Web Server Survey)  
Disallow: /

User-agent: Exabot
Disallow: /

User-agent: NetCraft
Disallow: /

User-agent: Aport
Disallow: /

User-agent: Flexum
Disallow: /

User-agent: OmniExplorer_Bot
Disallow: /

User-agent: FreeFind
Disallow: /

User-agent: BecomeBot
Disallow: /

User-agent: Nutch
Disallow: /

User-agent: Jetbot/1.0
Disallow: /

User-agent: Jetbot
Disallow: /

User-agent: WebVac
Disallow: /

User-agent: Stanford
Disallow: /

User-agent: naver
Disallow: /

User-agent: dumbot
Disallow: /

User-agent: Hatena Antenna
Disallow: /

User-agent: grub-client
Disallow: /

User-agent: grub
Disallow: /

User-agent: looksmart
Disallow: /

User-agent: WebZip
Disallow: /

User-agent: larbin
Disallow: /

User-agent: b2w/0.1
Disallow: /

User-agent: Copernic
Disallow: /

User-agent: psbot
Disallow: /

User-agent: Python-urllib
Disallow: /

User-agent: NetMechanic
Disallow: /

User-agent: URL_Spider_Pro
Disallow: /

User-agent: CherryPicker
Disallow: /

User-agent: EmailCollector
Disallow: /

User-agent: EmailSiphon
Disallow: /

User-agent: WebBandit
Disallow: /

User-agent: EmailWolf
Disallow: /

User-agent: ExtractorPro
Disallow: /

User-agent: CopyRightCheck
Disallow: /

User-agent: Crescent
Disallow: /

User-agent: SiteSnagger
Disallow: /

User-agent: ProWebWalker
Disallow: /

User-agent: CheeseBot
Disallow: /

User-agent: LNSpiderguy
Disallow: /

User-agent: ia_archiver
Disallow: /

User-agent: ia_archiver/1.6
Disallow: /

User-agent: Gigabot
Disallow: /

User-agent: Gigbase
Disallow: /

User-agent: Yanga
Disallow: /
  
User-agent: Indy Library
Disallow: /

User-agent: WebCopier	
Disallow: /

User-agent: Netcraft
Disallow: /

User-agent: dotbot
Disallow: /

Sitemap: http://www.securitylab.ru/sitemap_index.xml

User-agent: ProCogSEOBot
Disallow: /

User-agent: MeMoNewsBot
Disallow: /

User-agent: TweetedTimes Bot
Disallow: /

User-agent: MJ12bot
Disallow: /

User-agent: PaperLiBot
Disallow: /

User-agent: rogerbot
Disallow: /

User-agent: TweetmemeBot
Disallow: /

User-agent: Socialradarbot
Disallow: /

User-agent: BazQuxBot
Disallow: /

User-agent: CompSpyBot
Disallow: /

User-agent: imrbot
Disallow: /

User-agent: Diffbot
Disallow: /

User-agent: msnbot  
Crawl-delay: 5 
 
User-agent: bingbot 
Crawl-delay: 5

User-agent: AhrefsBot
Disallow: /
--------------------------------------------------------------------------------------------------------


server.tomcat.basedir=my-tomcat
server.tomcat.accesslog.enabled=true
server.tomcat.accesslog.pattern=%t %a "%r" %s (%D ms)

server.tomcat.remote-ip-header=x-your-remote-ip-header
server.tomcat.protocol-header=x-your-protocol-header
--------------------------------------------------------------------------------------------------------
@Bean
public ServletWebServerFactory servletContainer() {
    TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory();
    tomcat.addAdditionalTomcatConnectors(createSslConnector());
    return tomcat;
}

private Connector createSslConnector() {
    Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol");
    Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();
    try {
        File keystore = new ClassPathResource("keystore").getFile();
        File truststore = new ClassPathResource("keystore").getFile();
        connector.setScheme("https");
        connector.setSecure(true);
        connector.setPort(8443);
        protocol.setSSLEnabled(true);
        protocol.setKeystoreFile(keystore.getAbsolutePath());
        protocol.setKeystorePass("changeit");
        protocol.setTruststoreFile(truststore.getAbsolutePath());
        protocol.setTruststorePass("changeit");
        protocol.setKeyAlias("apitester");
        return connector;
    }
    catch (IOException ex) {
        throw new IllegalStateException("can't access keystore: [" + "keystore"
                + "] or truststore: [" + "keystore" + "]", ex);
    }
}
--------------------------------------------------------------------------------------------------------


server.tomcat.mbeanregistry.enabled=true


--------------------------------------------------------------------------------------------------------
@Bean
public UndertowServletWebServerFactory servletWebServerFactory() {
    UndertowServletWebServerFactory factory = new UndertowServletWebServerFactory();
    factory.addBuilderCustomizers(new UndertowBuilderCustomizer() {

        @Override
        public void customize(Builder builder) {
            builder.addHttpListener(8080, "0.0.0.0");
        }

    });
    return factory;
}

@Bean
public ServerEndpointExporter serverEndpointExporter() {
    return new ServerEndpointExporter();
}
--------------------------------------------------------------------------------------------------------
@Component
public class JerseyConfig extends ResourceConfig {

    public JerseyConfig() {
        register(Endpoint.class);
        setProperties(Collections.singletonMap("jersey.config.server.response.setStatusOverSendError", true));
    }

}
--------------------------------------------------------------------------------------------------------
static class ProxyCustomizer implements RestTemplateCustomizer {

    @Override
    public void customize(RestTemplate restTemplate) {
        HttpHost proxy = new HttpHost("proxy.example.com");
        HttpClient httpClient = HttpClientBuilder.create().setRoutePlanner(new DefaultProxyRoutePlanner(proxy) {

            @Override
            public HttpHost determineProxy(HttpHost target, HttpRequest request, HttpContext context)
                    throws HttpException {
                if (target.getHostName().equals("192.168.0.5")) {
                    return null;
                }
                return super.determineProxy(target, request, context);
            }

        }).build();
        restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory(httpClient));
    }

}
--------------------------------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <include resource="org/springframework/boot/logging/logback/defaults.xml" />
    <property name="LOG_FILE" value="${LOG_FILE:-${LOG_PATH:-${LOG_TEMP:-${java.io.tmpdir:-/tmp}}/}spring.log}"/>
    <include resource="org/springframework/boot/logging/logback/file-appender.xml" />
    <root level="INFO">
        <appender-ref ref="FILE" />
    </root>
</configuration>
--------------------------------------------------------------------------------------------------------
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
--------------------------------------------------------------------------------------------------------
dependencies {
    compile 'org.springframework.boot:spring-boot-starter-web'
    compile 'org.springframework.boot:spring-boot-starter-log4j2'
}

configurations {
    all {
        exclude group: 'org.springframework.boot', module: 'spring-boot-starter-logging'
    }
}
--------------------------------------------------------------------------------------------------------
@Bean
@ConfigurationProperties("app.datasource")
public DataSource dataSource() {
    return DataSourceBuilder.create().build();
}



app.datasource.jdbc-url=jdbc:mysql://localhost/test
app.datasource.username=dbuser
app.datasource.password=dbpass
app.datasource.maximum-pool-size=30

@Bean
@ConfigurationProperties("app.datasource")
public HikariDataSource dataSource() {
    return DataSourceBuilder.create().type(HikariDataSource.class).build();
}

@Bean
@Primary
@ConfigurationProperties("app.datasource")
public DataSourceProperties dataSourceProperties() {
    return new DataSourceProperties();
}

@Bean
@ConfigurationProperties("app.datasource.configuration")
public HikariDataSource dataSource(DataSourceProperties properties) {
    return properties.initializeDataSourceBuilder().type(HikariDataSource.class).build();
}
--------------------------------------------------------------------------------------------------------
@Bean
@Primary
@ConfigurationProperties("app.datasource.first")
public DataSourceProperties firstDataSourceProperties() {
    return new DataSourceProperties();
}

@Bean
@Primary
@ConfigurationProperties("app.datasource.first.configuration")
public HikariDataSource firstDataSource() {
    return firstDataSourceProperties().initializeDataSourceBuilder().type(HikariDataSource.class).build();
}

@Bean
@ConfigurationProperties("app.datasource.second")
public BasicDataSource secondDataSource() {
    return DataSourceBuilder.create().type(BasicDataSource.class).build();
}
--------------------------------------------------------------------------------------------------------
public class HibernateAwareObjectMapper extends ObjectMapper {
    public HibernateAwareObjectMapper() {
        // This for Hibernate 5; change 5 to 4 or 3 if you need to support
        // Hibernate 4 or Hibernate 3 instead
        registerModule(new Hibernate5Module());
    }
}
--------------------------------------------------------------------------------------------------------
@Entity
@Table(name = "ta_trainee", uniqueConstraints = {@UniqueConstraint(columnNames = {"id"})})
@JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="@traineeId")
public class Trainee extends BusinessObject {

@Entity
@Table(name = "ta_bodystat", uniqueConstraints = {@UniqueConstraint(columnNames = {"id"})})
@JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="@bodyStatId")
public class BodyStat extends BusinessObject {
--------------------------------------------------------------------------------------------------------
@ManyToOne
@JoinColumn(name="Key")
@JsonBackReference
private LgcyIsp Key;


@OneToMany(mappedBy="LgcyIsp ")
@JsonManagedReference
private List<Safety> safety;
--------------------------------------------------------------------------------------------------------
@Bean
public LocalContainerEntityManagerFactoryBean customerEntityManagerFactory(
        EntityManagerFactoryBuilder builder) {
    return builder
            .dataSource(customerDataSource())
            .packages(Customer.class)
            .persistenceUnit("customers")
            .build();
}
--------------------------------------------------------------------------------------------------------
/**
 * 
 */
package com.quantum.steps;

import com.qmetry.qaf.automation.step.QAFTestStepProvider;
import com.qmetry.qaf.automation.ui.WebDriverTestBase;
import com.qmetry.qaf.automation.ui.webdriver.QAFExtendedWebElement;
import com.qmetry.qaf.automation.util.StringUtil;
import com.quantum.utils.*;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;
import io.appium.java_client.android.AndroidDriver;
import io.appium.java_client.ios.IOSDriver;


/**
 * @author chirag.jayswal
 *
 */
@QAFTestStepProvider
public class CalcStepsDefs {

	@When("clear Calculator")
	public void clearCalculator() {

		new QAFExtendedWebElement("btn.clear").click();
	}


	@When("add \"(.+)\" to \"(.+)\"")
	public void addInto(long l1, long l2) {

		DriverUtils.getAppiumDriver().findElementByAccessibilityId(String.valueOf(l1)).click();
		new QAFExtendedWebElement("btn.plus").click();
		DriverUtils.getAppiumDriver().findElementByAccessibilityId(String.valueOf(l2)).click();
		new QAFExtendedWebElement("btn.equal").click();;


	}



	@Then("result should be \"(.+)\"")
	public void resultShouldBe(long l1) {
		new QAFExtendedWebElement("input.box").verifyText("in:" + String.valueOf(l1));
	}

	@Then("I switch to frame \"(.*?)\"")
	public static void switchToFrame(String nameOrIndex) {
		if (StringUtil.isNumeric(nameOrIndex)) {
			int index = Integer.parseInt(nameOrIndex);
			new WebDriverTestBase().getDriver().switchTo().frame(index);
		} else {
			new WebDriverTestBase().getDriver().switchTo().frame(nameOrIndex);
		}
	}

	@Then("I switch to \"(.*?)\" frame by element")
	public static void switchToFrameByElement(String loc) {
		new WebDriverTestBase().getDriver().switchTo().frame(new QAFExtendedWebElement(loc));
	}

	@When("I am using an AppiumDriver")
	public void testForAppiumDriver() {
		if (ConfigurationUtils.getBaseBundle().getPropertyValue("driver.name").contains("Remote"))
			ConsoleUtils.logWarningBlocks("Driver is an instance of QAFExtendedWebDriver");
		else if (AppiumUtils.getAppiumDriver() instanceof IOSDriver)
			ConsoleUtils.logWarningBlocks("Driver is an instance of IOSDriver");
		else if (AppiumUtils.getAppiumDriver() instanceof AndroidDriver)
			ConsoleUtils.logWarningBlocks("Driver is an instance of AndroidDriver");
	}

}

import java.util.List;

import org.openqa.selenium.JavascriptExecutor;

import com.qmetry.qaf.automation.step.QAFTestStepProvider;
import com.qmetry.qaf.automation.ui.WebDriverTestBase;
import com.qmetry.qaf.automation.ui.webdriver.QAFExtendedWebElement;
import com.quantum.utils.DeviceUtils;

import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

@QAFTestStepProvider
public class GoogleStepDefs {
	@Given("^I am on Google Search Page$")
	public void I_am_on_Google_Search_Page() throws Throwable {
		new WebDriverTestBase().getDriver().get("http://www.google.com/");
	}

	@When("^I search for \"([^\"]*)\"$")
	public void I_search_for(String searchKey) throws Throwable {
		QAFExtendedWebElement searchBoxElement = new QAFExtendedWebElement("search.text.box");
		QAFExtendedWebElement searchBtnElement = new QAFExtendedWebElement("search.button");

		searchBoxElement.clear();
		searchBoxElement.sendKeys(searchKey);
		// Web and mobile elements are sometimes different so we have done two things we
		// used multiple/alternate locator strategy for finding the element.
		// We also used Javascript click because the element was getting hidden in
		// Desktop Web due to suggestions and was not clickable. This java script click
		// will work for both desktop and mobile in this case.
		JavascriptExecutor js = (JavascriptExecutor) DeviceUtils.getQAFDriver();
		js.executeScript("arguments[0].click();", searchBtnElement);

	}

	@Then("^it should have \"([^\"]*)\" in search results$")
	public void it_should_have_in_search_results(String result) throws Throwable {
		QAFExtendedWebElement searchResultElement = new QAFExtendedWebElement("partialLink=" + result);
		searchResultElement.verifyPresent(result);
	}

	@Then("^it should have following search results:$")
	public void it_should_have_all_in_search_results(List<String> results) {
		QAFExtendedWebElement searchResultElement;
		for (String result : results) {
			searchResultElement = new QAFExtendedWebElement("partialLink=" + result);
			searchResultElement.verifyPresent(result);
		}
	}
}
--------------------------------------------------------------------------------------------------------
import java.util.List;

import org.springframework.cloud.skipper.domain.Repository;
import org.springframework.data.repository.PagingAndSortingRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;
import org.springframework.data.rest.core.annotation.RestResource;

/**
 * @author Mark Pollack
 * @author Ilayaperumal Gopinathan
 */
@RepositoryRestResource(path = "repositories", collectionResourceRel = "repositories")
public interface RepositoryRepository extends PagingAndSortingRepository<Repository, Long> {

	Repository findByName(@Param("name") String name);

	/**
	 * Get all the repositories with their repository order in descending order.
	 *
	 * @return the list of repositories
	 */
	@RestResource(exported = false)
	List<Repository> findAllByOrderByRepoOrderDesc();

	@Override
	@RestResource(exported = false)
	Repository save(Repository repository);

	@Override
	@RestResource(exported = false)
	void delete(Long id);

	@Override
	@RestResource(exported = false)
	void delete(Repository deployer);

	@Override
	@RestResource(exported = false)
	void deleteAll();

}
import org.junit.rules.TestWatcher;
import org.junit.runner.Description;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author Mark Pollack
 */
public class LogTestNameRule extends TestWatcher {

	private final static Logger log = LoggerFactory.getLogger("junit.logTestName");

	@Override
	protected void starting(Description description) {
		log.info("Starting Test {}", description.getMethodName());
	}

	@Override
	protected void finished(Description description) {
		log.info("Finished Test {}", description.getMethodName());
	}
}
--------------------------------------------------------------------------------------------------------
@Info(category = Category.MISC,
	description = "Automatically steals everything from all chests you\n"
		+ "open.",
	name = "AutoSteal")
--------------------------------------------------------------------------------------------------------
package com.paragon.mailingcontour.commons.actuator.configuration;

import com.paragon.mailingcontour.commons.actuator.property.ApiStatusProperty;
import com.paragon.mailingcontour.commons.actuator.property.GracefulShutdownProperty;
import com.paragon.mailingcontour.commons.annotation.UnitTest;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import io.opentracing.contrib.spring.tracer.configuration.TracerRegisterAutoConfiguration;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.mockito.MockitoAnnotations;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.autoconfigure.cache.CachesEndpointAutoConfiguration;
import org.springframework.boot.actuate.autoconfigure.health.HealthContributorAutoConfiguration;
import org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration;
import org.springframework.boot.actuate.autoconfigure.metrics.cache.CacheMetricsAutoConfiguration;
import org.springframework.boot.actuate.autoconfigure.metrics.web.servlet.WebMvcMetricsAutoConfiguration;
import org.springframework.boot.actuate.health.HealthEndpoint;
import org.springframework.boot.actuate.metrics.MetricsEndpoint;
import org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;
import org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;
import org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration;
import org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration;
import org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration;
import org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;
import org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;
import org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration;
import org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration;
import org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.lang.NonNull;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestPropertySource;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.mockito.Mockito.reset;

@UnitTest(
        classes = {
                ApiStatusConfigurationTest.TestConfiguration.class,
                ApiStatusConfiguration.class,
                MetricsEndpoint.class,
                SimpleMeterRegistry.class
        },
        classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD,
        exclude = {
                IntegrationAutoConfiguration.class,
                KafkaAutoConfiguration.class,
                DataSourceAutoConfiguration.class,
                JpaRepositoriesAutoConfiguration.class,
                TaskExecutionAutoConfiguration.class,
                RedisAutoConfiguration.class,
                RedisRepositoriesAutoConfiguration.class,
                SpringDataWebAutoConfiguration.class,
                MetricsAutoConfiguration.class,
                WebMvcMetricsAutoConfiguration.class,
                UserDetailsServiceAutoConfiguration.class,
                RestTemplateAutoConfiguration.class,
                DataSourceTransactionManagerAutoConfiguration.class,
                HibernateJpaAutoConfiguration.class,
                JacksonAutoConfiguration.class,
                CacheAutoConfiguration.class,
                CacheMetricsAutoConfiguration.class,
                CachesEndpointAutoConfiguration.class,
                HealthContributorAutoConfiguration.class,
                TracerRegisterAutoConfiguration.class
        }
)
class ApiStatusConfigurationTest {

    @MockBean
    private HealthEndpoint healthEndpoint;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @AfterEach
    void close() {
        reset(this.healthEndpoint);
    }

    @Nested
    @TestPropertySource(
            properties = {
                    "mailing-contour.api-status.shutdown.enabled=true"
            }
    )
    //@ContextConfiguration(initializers = EnableApiStatusConfigurationTest.DefaultApplicationContextInitializer.class)
    public class EnableApiStatusConfigurationTest {

        @Autowired
        private ApplicationContext context;

        @Test
        void test_shouldRegister_gracefulShutdownHealthIndicator() {
            // then
            assertThat(this.context.containsBean("gracefulShutdownHealthIndicator"), is(true));
        }

        @Test
        void test_shouldNotRegister_gracefulShutdownHealthIndicator_IfDisabled() {
            // given
//        this.context.registerBean(HealthEndpoint.class, this.healthContributorRegistry, this.healthEndpointGroups);
//
//        this.context.registerBean(ApiStatusProperty.class, this::getApiStatusProperty);
//        this.context.registerBean(GracefulShutdownProperty.class, () -> new GracefulShutdownProperty().setEnabled(false));
//
//        this.context.register(ApiStatusConfiguration.class);
//        this.context.register(MetricsEndpoint.class);
//        this.context.register(SimpleMeterRegistry.class);
//        this.context.register(MockClock.class);

            // when
//        TestPropertyValues.of("api-status.shutdown.enabled=false").applyTo(this.context);
//        this.context.refresh();

            // then
            assertThat(this.context.containsBean("gracefulShutdownHealthIndicator"), is(false));
        }

//        /**
//         * Default {@link ApplicationContextInitializer} implementation
//         */
//        public class DefaultApplicationContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext> {
//            /**
//             * {@inheritDoc}
//             *
//             * @see ApplicationContextInitializer
//             */
//            @Override
//            public void initialize(@NonNull final ConfigurableApplicationContext applicationContext) {
//                applicationContext.getEnvironment().getSystemProperties().put("mailing-contour.api-status.shutdown.enabled", "true");
//            }
//        }
    }

    @EnableConfigurationProperties({
            ApiStatusProperty.class,
            GracefulShutdownProperty.class
    })
    public static class TestConfiguration {
    }
}
--------------------------------------------------------------------------------------------------------
Importing: `pgp < KEYS` or `gpg --import KEYS`
--------------------------------------------------------------------------------------------------------
#!/usr/bin/env bash

readonly checksum_directory='documentation/build/checksum'
readonly current="${checksum_directory}/current-checksum.txt"
readonly published="${checksum_directory}/published-checksum.txt"
readonly github_pages_url='https://raw.githubusercontent.com/junit-team/junit5/gh-pages/docs/snapshot/published-checksum.txt'

#
# always generate current sums
#
echo "Generating checksum file ${current}..."
mkdir --parents "${checksum_directory}"
md5sum documentation/documentation.gradle.kts > "${current}"
md5sum $(find documentation/src -type f) >> "${current}"
# skip module junit-bom because it doesn't contain relevant documentation
md5sum $(find junit-jupiter-api -wholename '**/src/main/java/*.java') >> "${current}"
md5sum $(find junit-jupiter-engine -wholename '**/src/main/java/*.java') >> "${current}"
md5sum $(find junit-jupiter-migrationsupport -wholename '**/src/main/java/*.java') >> "${current}"
md5sum $(find junit-jupiter-params -wholename '**/src/main/java/*.java') >> "${current}"
md5sum $(find junit-platform-commons -wholename '**/src/main/java/*.java') >> "${current}"
md5sum $(find junit-platform-console -wholename '**/src/main/java/*.java') >> "${current}"
# skip module junit-platform-console-standalone because it doesn't contain relevant documentation
md5sum $(find junit-platform-engine -wholename '**/src/main/java/*.java') >> "${current}"
md5sum $(find junit-platform-launcher -wholename '**/src/main/java/*.java') >> "${current}"
md5sum $(find junit-platform-runner -wholename '**/src/main/java/*.java') >> "${current}"
md5sum $(find junit-platform-suite-api -wholename '**/src/main/java/*.java') >> "${current}"
md5sum $(find junit-platform-testkit -wholename '**/src/main/java/*.java') >> "${current}"
md5sum $(find junit-vintage-engine -wholename '**/src/main/java/*.java') >> "${current}"
# skip module platform-tests because it doesn't contain relevant documentation
# skip module platform-tooling-support-tests because it doesn't contain relevant documentation
sort --output "${current}" "${current}"
echo
md5sum "${current}"

#
# compare current with published sums
#
curl --silent --output "${published}" "${github_pages_url}"
md5sum "${published}"
if cmp --silent "${current}" "${published}" ; then
  #
  # no changes detected: we're done
  #
  echo
  echo "Already published documentation with same source checksum."
  echo
else
  #
  # update checksum file and trigger new documentation build and upload
  #
  echo
  echo "Creating and publishing documentation..."
  echo
  cp --force "${current}" "${published}"
  ./gradlew --scan gitPublishPush
fi
--------------------------------------------------------------------------------------------------------
import com.github.ralfstuckert.junit.jupiter.spring.ticket.Ticket;
import com.github.ralfstuckert.junit.jupiter.spring.ticket.TicketRepository;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.data.mongodb.core.MongoTemplate;
import com.github.ralfstuckert.junit.jupiter.extension.mongo.MongoCleanup;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;


@MongoCleanup(Ticket.class)
@ExtendWith(SpringExtension.class)
@SpringBootTest
public class TicketRepositoryIT {

	@Autowired
	private TicketRepository repository;
	@Autowired
	private MongoTemplate mongoTemplate;

	@Test
    @DisplayName("Test the findsByTicketId() method")
	public void testSaveAndFindTicket() throws Exception {
		Ticket ticket1 = new Ticket("1", "blabla");
		repository.save(ticket1);
		Ticket ticket2 = new Ticket("2", "hihi");
		repository.save(ticket2);

		assertEquals(ticket1, repository.findByTicketId("1"));
		assertEquals(ticket2, repository.findByTicketId("2"));
		assertNull(repository.findByTicketId("3"));
	}

	@Test
    @DisplayName("Ensure that there is a unique index on the ticket ID")
	public void testSaveNewTicketWithExistingTicketId() throws Exception {
        repository.save(new Ticket("1", "blabla"));
	    assertThrows(DuplicateKeyException.class, () -> {
            repository.save(new Ticket("1", "hihi"));
        });
	}

}
--------------------------------------------------------------------------------------------------------
import java.io.IOException;
import java.io.InputStream;

import org.springframework.core.io.AbstractResource;

/**
 * {@link org.springframework.core.io.Resource} implementation to create an operating
 * system process process and capture its output.
 *
 * @author Mike Heath
 */
public class ProcessOutputResource extends AbstractResource {

	private final ProcessBuilder processBuilder;

	public ProcessOutputResource(String... command) {
		processBuilder = new ProcessBuilder(command);
	}

	@Override
	public String getDescription() {
		return processBuilder.toString();
	}

	@Override
	public InputStream getInputStream() throws IOException {
		return processBuilder.start().getInputStream();
	}

	@Override
	public String toString() {
		return getDescription();
	}
}
--------------------------------------------------------------------------------------------------------
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.Charset;

import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;
import org.zeroturnaround.zip.ZipUtil;

import org.springframework.cloud.skipper.domain.Package;
import org.springframework.cloud.skipper.domain.PackageMetadata;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.util.FileSystemUtils;
import org.springframework.util.StreamUtils;
import org.springframework.util.StringUtils;

/**
 * @author Mark Pollack
 * @author Ilayaperumal Gopinathan
 */
public class DefaultPackageWriter implements PackageWriter {

	private Yaml yaml;

	public DefaultPackageWriter() {
		DumperOptions dumperOptions = new DumperOptions();
		dumperOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
		dumperOptions.setPrettyFlow(true);
		this.yaml = new Yaml(dumperOptions);
	}

	@Override
	public File write(Package pkg, File targetDirectory) {
		PackageMetadata packageMetadata = pkg.getMetadata();
		File tmpDir = TempFileUtils.createTempDirectory("skipper" + packageMetadata.getName()).toFile();
		File rootPackageDir = new File(tmpDir,
				String.format("%s-%s", packageMetadata.getName(), packageMetadata.getVersion()));
		rootPackageDir.mkdir();
		writePackage(pkg, rootPackageDir);
		if (!pkg.getDependencies().isEmpty()) {
			File packagesDir = new File(rootPackageDir, "packages");
			packagesDir.mkdir();
			for (Package dependencyPkg : pkg.getDependencies()) {
				File packageDir = new File(packagesDir, dependencyPkg.getMetadata().getName());
				packageDir.mkdir();
				writePackage(dependencyPkg, packageDir);
			}
		}
		File targetZipFile = PackageFileUtils.calculatePackageZipFile(pkg.getMetadata(), targetDirectory);
		ZipUtil.pack(rootPackageDir, targetZipFile, true);
		FileSystemUtils.deleteRecursively(tmpDir);
		return targetZipFile;
	}

	private void writePackage(Package pkg, File directory) {
		String packageMetadata = generatePackageMetadata(pkg.getMetadata());
		writeText(new File(directory, "package.yml"), packageMetadata);
		if (pkg.getConfigValues() != null && StringUtils.hasText(pkg.getConfigValues().getRaw())) {
			writeText(new File(directory, "values.yml"), pkg.getConfigValues().getRaw());
		}
		if (!pkg.getTemplates().isEmpty()) {
			File templateDir = new File(directory, "templates/");
			templateDir.mkdirs();
			File templateFile = new File(templateDir, pkg.getMetadata().getName() + ".yml");
			writeText(templateFile, getDefaultTemplate());
		}
	}

	private String getDefaultTemplate() {
		Resource resource = new ClassPathResource("/org/springframework/cloud/skipper/io/generic-template.yml");
		String genericTempateData = null;
		try {
			genericTempateData = StreamUtils.copyToString(resource.getInputStream(), Charset.defaultCharset());
		}
		catch (IOException e) {
			throw new IllegalArgumentException("Can't load generic template", e);
		}
		return genericTempateData;
	}

	private void writeText(File target, String body) {
		try (OutputStream stream = new FileOutputStream(target)) {
			StreamUtils.copy(body, Charset.forName("UTF-8"), stream);
		}
		catch (Exception e) {
			throw new IllegalStateException("Cannot write file " + target, e);
		}
	}

	private String generatePackageMetadata(PackageMetadata packageMetadata) {
		return yaml.dump(packageMetadata);
	}

}
--------------------------------------------------------------------------------------------------------
<dependency>
    <groupId>org.jbehave</groupId>
    <artifactId>jbehave-core</artifactId>
    <version>4.1</version>
    <scope>test</scope>
</dependency>

public class IncreaseSteps {
    private int counter;
    private int previousValue;
 
    @Given("a counter")
    public void aCounter() {
    }
 
    @Given("the counter has any integral value")
    public void counterHasAnyIntegralValue() {
        counter = new Random().nextInt();
        previousValue = counter;
    }
 
    @When("the user increases the counter")
    public void increasesTheCounter() {
        counter++;
    }
 
    @Then("the value of the counter must be 1 greater than previous value")
    public void theValueOfTheCounterMustBe1Greater() {
        assertTrue(1 == counter - previousValue);
    }
}

Scenario: when a user increases a counter, its value is increased by 1
 
Given a counter
And the counter has any integral value
When the user increases the counter
Then the value of the counter must be 1 greater than previous value


public class IncreaseStoryLiveTest extends JUnitStories {
 
    @Override
    public Configuration configuration() {
        return new MostUsefulConfiguration()
          .useStoryLoader(new LoadFromClasspath(this.getClass()))
          .useStoryReporterBuilder(new StoryReporterBuilder()
            .withCodeLocation(codeLocationFromClass(this.getClass()))
            .withFormats(CONSOLE));
    }
 
    @Override
    public InjectableStepsFactory stepsFactory() {
        return new InstanceStepsFactory(configuration(), new IncreaseSteps());
    }
 
    @Override
    protected List<String> storyPaths() {
        return Arrays.asList("increase.story");
    }
 
}
--------------------------------------------------------------------------------------------------------
import org.panda_lang.framework.design.architecture.Application;
import org.panda_lang.framework.language.interpreter.messenger.PandaMessenger;
import org.panda_lang.panda.Panda;
import org.panda_lang.panda.PandaConstants;
import org.panda_lang.panda.PandaFactory;
import org.panda_lang.panda.manager.ModuleManager;
import org.panda_lang.panda.shell.PandaShell;
import org.panda_lang.utilities.commons.function.ThrowingRunnable;
import org.tinylog.configuration.Configuration;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;

import java.io.File;
import java.util.Optional;

@Command(name = "panda", version = "Panda " + PandaConstants.VERSION)
public final class PandaCommand implements ThrowingRunnable {

    private final PandaShell shell;

    @Parameters(index = "0", paramLabel = "<script>", description = "script to load")
    private File script;

    @Option(names = { "--version", "-V" }, versionHelp = true, description = "display current version of panda")
    private boolean versionInfoRequested;

    @Option(names = { "--help", "-H" }, usageHelp = true, description = "display help message")
    private boolean usageHelpRequested;

    @Option(names = { "--level", "-L" }, description = "set level of logging", paramLabel="<level>")
    private String level;

    public PandaCommand(PandaShell shell) {
        this.shell = shell;
    }

    @Override
    public void run() throws Exception {
        CommandLine commandLine = new CommandLine(this);

        if (level != null) {
            Configuration.set("level", level);
        }

        if (usageHelpRequested) {
            CommandLine.usage(this, System.out);
        }

        if (versionInfoRequested) {
            commandLine.printVersionHelp(System.out);
        }

        if (script == null) {
            return;
        }

        if (script.getName().endsWith("panda.hjson")) {
            ModuleManager moduleManager = new ModuleManager(new PandaMessenger(shell.getLogger()), script.getParentFile());
            moduleManager.install(script);
            moduleManager.run(script);
            return;
        }

        Panda panda = new PandaFactory().createPanda(shell.getLogger());
        Optional<Application> application = panda.getLoader().load(script, script.getParentFile());

        if (!application.isPresent()) {
            shell.getLogger().error("Cannot load application");
            return;
        }

        application.get().launch();
    }

}
--------------------------------------------------------------------------------------------------------

import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

/**
 * {@code ZipFileIterator} is used to iterate over all entries in a given {@code zip} or
 * {@code jar} file and returning the {@link InputStream} of these entries.
 * <p>
 * It is possible to specify an (optional) entry name filter.
 * <p>
 * The most efficient way of iterating is used, see benchmark in test classes.
 *
 * @author <a href="mailto:rmuller@xiam.nl">Ronald K. Muller</a>
 * @since annotation-detector 3.0.0
 */
final class ZipFileIterator {

    private final ZipFile zipFile;
    private final String[] entryNameFilter;
    private final Enumeration<? extends ZipEntry> entries;

    private ZipEntry current;

    /**
     * Create a new {@code ZipFileIterator} instance.
     * 
     * @param zipFile The ZIP file used to iterate over all entries
     * @param entryNameFilter (optional) file name filter. Only entry names starting with
     * one of the specified names in the filter are returned
     */
    ZipFileIterator(final ZipFile zipFile, final String[] entryNameFilter) throws IOException {
        this.zipFile = zipFile;
        this.entryNameFilter = entryNameFilter;

        this.entries = zipFile.entries();
    }

    public ZipEntry getEntry() {
        return current;
    }

    @SuppressWarnings("emptyblock")
    public InputStream next() throws IOException {
        while (entries.hasMoreElements()) {
            current = entries.nextElement();
            if (accept(current)) {
                return zipFile.getInputStream(current);
            }
        }
        // no more entries in this ZipFile, so close ZipFile
        try {
            // zipFile is never null here
            zipFile.close();
        } catch (IOException ex) {
            // suppress IOException, otherwise close() is called twice
        }
        return null;
    }

    private boolean accept(final ZipEntry entry) {
        if (entry.isDirectory()) {
            return false;
        }
        if (entryNameFilter == null) {
            return true;
        }
        for (final String filter : entryNameFilter) {
            if (entry.getName().startsWith(filter)) {
                return true;
            }
        }
        return false;
    }

}
--------------------------------------------------------------------------------------------------------
/**
 * Represents the size of thumb nails that the API can return.
 *
 * @author Original Author is Dropbox
 * @since infomas-asl 3.0.2
 */
public enum ThumbSize {

    /**
     * Will have at most a 32 width or 32 height, maintaining its original aspect ratio.
     */
    ICON_32x32("small"),

    /**
     * 64 width or 64 height, with original aspect ratio.
     */
    ICON_64x64("medium"),

    /**
     * 128 width or 128 height, with original aspect ratio.
     */
    ICON_128x128("large"),

    /**
     * 256 width or 256 height, with original aspect ratio.
     */
    ICON_256x256("256x256"),

    /**
     * Will either fit within a 320 x 240 rectangle or a 240 x 320 rectangle, whichever
     * results in a larger image.
     */
    BESTFIT_320x240("320x240_bestfit"),

    /**
     * Fits within 480x320 or 320x480.
     */
    BESTFIT_480x320("480x320_bestfit"),

    /**
     * Fits within 640x480 or 480x640.
     */
    BESTFIT_640x480("640x480_bestfit"),

    /**
     * Fits within 960x640 or 640x960.
     */
    BESTFIT_960x640("960x640_bestfit"),

    /**
     * Fits within 1024x768 or 768x1024.
     */
    BESTFIT_1024x768("1024x768_bestfit");

    private final String size;

    private ThumbSize(final String size) {
        this.size = size;
    }

    /**
     * Return the identifier if this size, used in the REST API Request.
     */
    public String toAPISize() {
        return size;
    }
}

/**
 * Represents the image format of thumbnails that the API can return.
 *
 * @author Original Author is Dropbox
 * @author <a href="mailto:rmuller@xiam.nl">Ronald K. Muller</a> (refactoring)
 * @since infomas-asl 3.0.2
 */
public enum ThumbFormat {

    /**
     * The PNG Image format.
     */
    PNG("image/png", ".png"),

    /**
     * The JPEG Image format.
     */
    JPEG("image/jpeg", ".jpg");

    private final String mimeType;
    private final String extension;

    private ThumbFormat(final String mimeType, final String extension) {
        this.mimeType = mimeType;
        this.extension = extension;
    }

    /**
     * Return the <a href="http://en.wikipedia.org/wiki/Internet_media_type">MIME Type</a>
     * of this image format.
     */
    public String getMimeType() {
        return mimeType;
    }

    /**
     * Return the default file extension of this image format.
     */
    public String getDefaultExtension() {
        return extension;
    }
}
--------------------------------------------------------------------------------------------------------
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * {@code ChunkedInputStream}.
 * <p>
 * Usage:
 * <pre>
 * final ChunkedInputStream chunked = new ChunkedInputStream((in), chunkSize);
 * while (chunked.nextChunk()) {
 *     // read and process chunked input stream as a normal input stream, any close()
 *     // operation is ignored
 * }
 * // do not need to close the chunked input stream (closed by instance itself)
 * </pre>
 * 
 * @author <a href="mailto:rmuller@xiam.nl">Ronald K. Muller</a>
 * @since infomas-asl 3.0.2
 */
final class ChunkedInputStream extends FilterInputStream {

    private final int chunkSize;
    private int remaining;
    private boolean closed;
    
    /**
     * Create a new {@code ChunkedInputStream} instance.
     * 
     * @param in The underlying input stream
     * @param chunkSize The chunk size in bytes
     */
    ChunkedInputStream(final InputStream in, final int chunkSize) {
        super(in);
        this.chunkSize = chunkSize;
    }

    /**
     * Return {@code true} if the next chunk of data can be read. If {@code false}
     * the underlying input stream is read fully and automatically closed by this
     * {@code ChunkedInputStream}.
     */
    public boolean nextChunk() throws IOException {
        if (closed) {
            return false;
        } else {
            remaining = chunkSize;
            return true;
        }
    }
    
    @Override
    public int read() throws IOException {
        if (remaining == 0) {
            return -1;
        }
        final int c = super.read();
        if (c < 0) {
            closeSource();
            return -1;
        } else {
            --remaining;
            return c;
        }
    }

    @Override
    public int read(final byte[] buffer, final int offset, final int length) 
        throws IOException {
        
        if (remaining == 0) {
            return -1;
        }
        final int max = Math.min(remaining, length);
        final int actual = super.read(buffer, offset, max);
        if (actual < 0) {
            closeSource();
        } else {
            remaining -= actual;
        }
        return actual;
    }

    @Override
    public void close() throws IOException {
        // do NOT close underlying stream! This is done by closeSource()
    }

    // private
    
    private void closeSource() throws IOException {
        try {
            in.close();
        } finally {
            closed = true;
        }
    }
}
--------------------------------------------------------------------------------------------------------
   mvn dependency:sources
    mvn dependency:resolve -Dclassifier=javadoc
--------------------------------------------------------------------------------------------------------
/**
 * Class for timing stuff...
 * 
 * Uses System.nanoTime for precision, but returnes values in miliseconds.
 * 
 * @author Eugen
 */
public class StopWatch {

	protected long ini, end;

	/**
	 * Constrcucts and sets the stopwatch to current time.
	 */
	public StopWatch() {
		reset();
	}

	/**
	 * Sets the stopwatch to current time
	 */
	public void reset() {
		ini = end = System.nanoTime();
	}

	/**
	 * Marks the end of measuring with the current time
	 */
	public void stop() {
		end = System.nanoTime();
	}

	/**
	 * Gets the difference between last reset and last stop, in miliseconds.
	 */
	public long getMeasure() {
		return (end - ini) / 1000000;
	}

	/**
	 * Calls stop() then getMeasure()
	 */
	public long stopAndGet() {
		stop();
		return getMeasure();
	}

	/**
	 * Call stop and then returnes the measure as a nice string
	 */
	public String stopAndShow() {
		stop();
		return toString();
	}

	@Override
	public String toString() {
		return usToString(getMeasure());
	}

	private String usToString(long us) {
		long totalSecs = us / 1000000;
		int hours = (int) (totalSecs / 3600);
		int mins = (int) (totalSecs / 60) % 60;
		int secs = (int) (totalSecs % 60);
		int ms = (int) (us % 1000000) / 1000;
		us = us % 1000;

		StringBuilder out = new StringBuilder();
		if (hours > 0) {
			out.append(hours).append(" hour ");
		}
		if (mins > 0) {
			out.append(mins).append(" min ");
		}
		if (secs > 0) {
			out.append(secs).append(" sec ");
		}
		if (ms > 0) {
			out.append(ms).append(" ms ");
		}
		if (us > 0) {
			out.append(us).append(" us ");
		}
		return out.toString().trim();
	}

}
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Calendar;

/**
 * A class that writes to a file if the logging flag is set and/or to the stdout
 * if the testing flag is set.
 * 
 * @author Eugen
 * 
 */
public class LogWriter {

	private BufferedWriter log;
	public static final String DATE_FORMAT_NOW = "dd.MM.yyyy HH:mm:ss";

	private boolean logging;
	private boolean testing;

	/**
	 * Constructor
	 * 
	 * @param filename
	 *            name of file where to write log.
	 */
	public LogWriter(String filename, boolean logging, boolean testing) {
		this.logging = logging;
		this.testing = testing;
		if (logging) {
			try {
				File folder = new File("log");
				folder.mkdir();
				log = new BufferedWriter(new FileWriter("log/" + filename));
				writeToLog("Log file: " + folder.getCanonicalPath()
						+ File.separator + filename);
			} catch (Exception e) {
				throw new RuntimeException("Faild to make the log file...", e);
			}
		}
	}

	/**
	 * Writes string to log.
	 * 
	 * @param text
	 *            Input text for writing
	 */
	public void writeToLog(String text, boolean forceToScreen) {
		if (logging) {
			try {
				log.write(now() + " " + text + "\n");
				log.flush();
			} catch (IOException e) {
				// logging error... so what xD
			}
		}
		if (testing || forceToScreen) {
			System.out.println(text);
		}
	}

	public void writeToLog(String text) {
		writeToLog(text, false);
	}

	/**
	 * Adds "ERROR: " in front of the given string and forces the output to
	 * screen [calls writeToLog("ERROR: "+error, true)]
	 * 
	 * @param error
	 *            Msn to print/log
	 */
	public void error(String error) {
		writeToLog("ERROR: " + error, true);
	}

	/**
	 * 
	 * This method returns current time in format set by DATE_FORMAT_NOW
	 */
	public static String now() {
		Calendar cal = Calendar.getInstance();
		SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT_NOW);
		return sdf.format(cal.getTime());

	}

	/**
	 * Closes log
	 */
	public void close() {
		try {
			log.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

}
--------------------------------------------------------------------------------------------------------

import com.ubirch.protocol.ProtocolException;
import com.ubirch.protocol.ProtocolMessage;
import com.ubirch.protocol.ProtocolSigner;

import java.security.SignatureException;

/**
 * Protocol encoder interface.
 *
 * @param <T> the target type to encode to
 * @author Matthias L. Jugel
 */
abstract class ProtocolEncoder<T> {
    /**
     * Encode a protocol message into the target type.
     *
     * @param pm     the protocol message to encode from
     * @param signer a protocol signer taking care of the crypto operations to sign the final message
     * @return the encoded and signed message
     * @throws ProtocolException  if the encoding fails for some reason
     * @throws SignatureException if the signature cannot be created
     */
    abstract T encode(ProtocolMessage pm, ProtocolSigner signer) throws ProtocolException, SignatureException;

    /**
     * Re-assemble the protocol message into the target type.
     *
     * @param pm the protocol message to encode from
     * @return the encoded message with the existing signature
     * @throws ProtocolException if the message cannot be encoded from the input
     */
    abstract T encode(ProtocolMessage pm) throws ProtocolException;

    void checkProtocolMessage(ProtocolMessage pm) throws ProtocolException {
        if (pm.getSignature() == null) {
            throw new ProtocolException("missing signature");
        }
        if (pm.getSigned() == null) {
            throw new ProtocolException("missing signed data");
        }

        int protocolVersion = pm.getVersion();
        if (protocolVersion != ProtocolMessage.SIGNED && protocolVersion != ProtocolMessage.CHAINED) {
            throw new ProtocolException(String.format("unknown protocol version: 0x%x", pm.getVersion()));
        }
    }
}
import com.ubirch.protocol.ProtocolException;
import com.ubirch.protocol.ProtocolMessage;
import com.ubirch.protocol.ProtocolVerifier;

import java.security.InvalidKeyException;
import java.security.SignatureException;

/**
 * Protocol decoder interface is the basis for protocol decoders.
 * Generally they will decode to a {@link ProtocolMessage}, but in case of a verification, may also
 * return a special envelope type with extra information.
 *
 * @param <T> the type of the source message
 * @author Matthias L. Jugel
 */
abstract class ProtocolDecoder<T> {
    /**
     * Decode and verify this message.
     *
     * @param message  the message to decode
     * @param verifier a {@link ProtocolVerifier} that takes care of cryptographically verifying the message signature
     * @return the decoded and verified data as an envelope type
     * @throws ProtocolException  if some json processing issue occurs, or the crypto functions fail (no signature verification)
     * @throws SignatureException if the signature verification cannot be done for some reason
     */
    public ProtocolMessage decode(T message, ProtocolVerifier verifier) throws ProtocolException, SignatureException {
        ProtocolMessage pm = decode(message);
        try {
            if (!verifier.verify(pm.getUUID(), pm.getSigned(), 0, pm.getSigned().length, pm.getSignature())) {
                throw new SignatureException(String.format("signature verification failed: %s", pm));
            }
            return pm;
        } catch (InvalidKeyException e) {
            throw new ProtocolException("invalid key", e);
        }
    }

    /**
     * Decode a protocol messsage without decoding, just taking the pieces apart.
     *
     * @param message the message to decode
     * @return the decoded message as a {@link ProtocolMessage}
     * @throws ProtocolException if json decoding fails
     */
    abstract ProtocolMessage decode(T message) throws ProtocolException;
}


import com.fasterxml.jackson.databind.ObjectMapper;
import com.ubirch.protocol.ProtocolException;
import com.ubirch.protocol.ProtocolMessage;
import com.ubirch.protocol.ProtocolSigner;
import org.msgpack.core.MessagePack;
import org.msgpack.core.MessagePacker;
import org.msgpack.jackson.dataformat.MessagePackFactory;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.SignatureException;

/**
 * The default msgpack protocol encoder.
 *
 * @author Matthias L. Jugel
 */
public class MsgPackProtocolEncoder extends ProtocolEncoder<byte[]> {
    private static MessagePack.PackerConfig config = new MessagePack.PackerConfig().withStr8FormatSupport(false);
    private static MsgPackProtocolEncoder instance = new MsgPackProtocolEncoder();

    public static MsgPackProtocolEncoder getEncoder() {
        return instance;
    }

    /**
     * Encodes this protocol message into the msgpack format. Modifies the given ProtocolMessage, filling
     * in the signature and encoded bytes.
     *
     * @param pm     the protocol message to encode and sign
     * @param signer the protocol signer
     * @return the msgpack encoded message as bytes
     * \
     */
    @Override
    public byte[] encode(ProtocolMessage pm, ProtocolSigner signer) throws ProtocolException, SignatureException {
        if (pm == null || signer == null) {
            throw new IllegalArgumentException("message or signer null");
        }

        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream(255);
            MessagePacker packer = config.newPacker(out);

            packer.packArrayHeader(5 + (pm.getVersion() & 0x0f) - 2);
            packer.packInt(pm.getVersion());
            packer.packBinaryHeader(16).addPayload(UUIDUtil.uuidToBytes(pm.getUUID()));
            switch (pm.getVersion()) {
                case ProtocolMessage.CHAINED:
                    packer.packBinaryHeader(64);
                    byte[] chainSignature = pm.getChain();
                    if (chainSignature == null) {
                        packer.addPayload(new byte[64]);
                    } else {
                        packer.addPayload(chainSignature);
                    }
                    break;
                case ProtocolMessage.SIGNED:
                    break;
                default:
                    throw new ProtocolException(String.format("unknown protocol version: 0x%x", pm.getVersion()));
            }
            packer.packInt(pm.getHint());
            packer.flush(); // make sure everything is in the byte buffer

            // write the payload
            ObjectMapper mapper = new ObjectMapper(new MessagePackFactory());
            mapper.writeValue(out, pm.getPayload());
            packer.close(); // also closes out

            // sign the message
            byte[] dataToSign = out.toByteArray();
            byte[] signature = signer.sign(pm.getUUID(), dataToSign, 0, dataToSign.length);
            pm.setSigned(dataToSign);
            pm.setSignature(signature);

            return encode(pm);
        } catch (InvalidKeyException e) {
            throw new ProtocolException("invalid key", e);
        } catch (IOException e) {
            throw new ProtocolException("msgpack encoding failed", e);
        } catch (NullPointerException e) {
            throw new ProtocolException("msgpack encoding failed: field null?", e);
        }
    }

    public byte[] encode(ProtocolMessage pm) throws ProtocolException {
        checkProtocolMessage(pm);

        ByteArrayOutputStream out = new ByteArrayOutputStream(255);
        MessagePacker packer = config.newPacker(out);

        try {
            packer.writePayload(pm.getSigned());
            if (pm.getVersion() == 1) {
                packer.packRawStringHeader(pm.getSignature().length);
            } else {
                packer.packBinaryHeader(pm.getSignature().length);
            }
            packer.writePayload(pm.getSignature());

            packer.flush();
            packer.close();
        } catch (IOException e) {
            throw new ProtocolException("msgpack encoding failed", e);
        }

        return out.toByteArray();
    }
}

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.*;
import com.ubirch.protocol.ProtocolException;
import com.ubirch.protocol.ProtocolMessage;
import org.msgpack.core.*;
import org.msgpack.jackson.dataformat.MessagePackFactory;
import org.msgpack.value.*;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.*;

/**
 * The default msgpack ubirch protocol decoder.
 *
 * @author Matthias L. Jugel
 */
public class MsgPackProtocolDecoder extends ProtocolDecoder<byte[]> {
    private static final int PAYLOAD_OFFSET = 2;
    private final static MsgPackProtocolDecoder instance = new MsgPackProtocolDecoder();

    public static MsgPackProtocolDecoder getDecoder() {
        return instance;
    }

    private ObjectMapper mapper;

    @SuppressWarnings("WeakerAccess")
    MsgPackProtocolDecoder() {
        mapper = new ObjectMapper(new MessagePackFactory());
        mapper.configure(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS, true);
    }

    /**
     * Decode a a protocol message from it's raw data.
     *
     * @param message the raw protocol message in msgpack format
     * @return the decoded protocol message
     * @throws ProtocolException if the decoding failed
     */
    @SuppressWarnings("checkstyle:FallThrough")
    @Override
    public ProtocolMessage decode(byte[] message) throws ProtocolException {
        boolean legacyPayloadDecoding = false;
        ByteArrayInputStream in = new ByteArrayInputStream(message);

        MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(in);
        ProtocolMessage pm = new ProtocolMessage();
        try {
            ValueType envelopeType = unpacker.getNextFormat().getValueType();
            int envelopeLength = unpacker.unpackArrayHeader();
            if (envelopeLength > 4 && envelopeLength < 7) {
                pm.setVersion(unpacker.unpackInt());

                int protocolVersion = pm.getVersion() >> 4;
                switch (protocolVersion) {
                    case 1:
                        legacyPayloadDecoding = true;
                    case ProtocolMessage.ubirchProtocolVersion:
                        break;
                    default:
                        throw new ProtocolException(String.format("unknown protocol version: %d", protocolVersion));
                }

                pm.setUUID(UUIDUtil.bytesToUUID(unpacker.readPayload(unpacker.unpackRawStringHeader())));
                switch (pm.getVersion() & 0x0F) {
                    case ProtocolMessage.CHAINED & 0x0F:
                        pm.setChain(unpacker.readPayload(unpacker.unpackRawStringHeader()));
                        break;
                    case ProtocolMessage.SIGNED & 0x0F:
                        break;
                    default:
                        throw new ProtocolException(String.format("unknown protocol type: 0x%04x", pm.getVersion() & 0x0F));
                }
                pm.setHint(unpacker.unpackInt());
                if (!legacyPayloadDecoding) {
                    pm.setPayload(mapper.readTree(message).get(envelopeLength - PAYLOAD_OFFSET));
                    unpacker.skipValue();
                } else {
                    pm.setPayload(decodePayload(unpacker));
                }

                // finally store the signed data and signature for later verification
                pm.setSigned(Arrays.copyOfRange(message, 0, (int) unpacker.getTotalReadBytes()));
                pm.setSignature(unpacker.readPayload(unpacker.unpackRawStringHeader()));

                return pm;
            } else {
                throw new ProtocolException(String.format("unknown msgpack envelope format: %s[%d]", envelopeType.name(), envelopeLength));
            }
        } catch (MessagePackException e) {
            throw new ProtocolException("msgpack decoding failed", e);
        } catch (IOException e) {
            throw new ProtocolException(String.format("msgpack data corrupt at position %d", unpacker.getTotalReadBytes()), e);
        }
    }

    private JsonNode decodePayload(MessageUnpacker unpacker) throws IOException {
        MessageFormat mf = unpacker.getNextFormat();
        switch (mf.getValueType()) {
            case NIL:
                unpacker.unpackNil();
                return NullNode.getInstance();
            case BOOLEAN:
                return BooleanNode.valueOf(unpacker.unpackBoolean());
            case INTEGER:
                if (mf == MessageFormat.UINT64) {
                    return BigIntegerNode.valueOf(unpacker.unpackBigInteger());
                }
                return LongNode.valueOf(unpacker.unpackLong());
            case FLOAT:
                return DoubleNode.valueOf(unpacker.unpackDouble());
            case STRING: {
                int length = unpacker.unpackRawStringHeader();
                ImmutableStringValue stringValue = ValueFactory.newString(unpacker.readPayload(length), true);
                if (stringValue.isRawValue()) {
                    return BinaryNode.valueOf(stringValue.asRawValue().asByteArray());
                } else {
                    return TextNode.valueOf(stringValue.asString());
                }
            }
            case BINARY: {
                int length = unpacker.unpackBinaryHeader();
                return BinaryNode.valueOf(unpacker.readPayload(length));
            }
            case ARRAY: {
                int size = unpacker.unpackArrayHeader();
                List<JsonNode> array = new ArrayList<>(size);
                for (int i = 0; i < size; i++) {
                    array.add(decodePayload(unpacker));
                }
                return new ArrayNode(null, array);
            }
            case MAP: {
                int size = unpacker.unpackMapHeader();
                Map<String, JsonNode> kvs = new HashMap<>(size);
                for (int i = 0; i < size; i++) {
                    JsonNode kn = decodePayload(unpacker);
                    String key = kn.isBinary() ? new String(kn.binaryValue()) : kn.asText();
                    kvs.put(key, decodePayload(unpacker));
                }
                return new ObjectNode(null, kvs);
            }
            case EXTENSION: {
                ExtensionTypeHeader extHeader = unpacker.unpackExtensionTypeHeader();
                return BinaryNode.valueOf(unpacker.readPayload(extHeader.getLength()));
            }
            default:
                throw new MessageNeverUsedFormatException("Unknown value type");
        }
    }
}

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.ubirch.protocol.ProtocolException;
import com.ubirch.protocol.ProtocolMessage;
import com.ubirch.protocol.ProtocolMessageViews;
import com.ubirch.protocol.ProtocolSigner;

import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.SignatureException;

/**
 * Simpe JSON protocol encoder.
 *
 * @author Matthias L. Jugel
 */
@SuppressWarnings("WeakerAccess")
public class JSONProtocolEncoder extends ProtocolEncoder<String> {
    private static JSONProtocolEncoder instance = new JSONProtocolEncoder();
    private ObjectMapper mapper = new ObjectMapper();

    public JSONProtocolEncoder() {
        mapper.configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true);
        mapper.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true);
        mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false);
        mapper.setConfig(mapper.getSerializationConfig().withView(ProtocolMessageViews.Default.class));
    }

    public static JSONProtocolEncoder getEncoder() {
        return instance;
    }

    @Override
    public String encode(ProtocolMessage pm, ProtocolSigner signer) throws ProtocolException, SignatureException {
        if (pm == null || signer == null) {
            throw new IllegalArgumentException("message or signer null");
        }

        try {
            pm.setSigned(mapper.writeValueAsBytes(pm.getPayload()));
            pm.setSignature(signer.sign(pm.getUUID(), pm.getSigned(), 0, pm.getSigned().length));
            return encode(pm);
        } catch (InvalidKeyException e) {
            throw new ProtocolException("invalid key", e);
        } catch (JsonProcessingException e) {
            throw new ProtocolException("json encoding failed", e);
        }
    }

    @Override
    public String encode(ProtocolMessage pm) throws ProtocolException {
        checkProtocolMessage(pm);

        try {
            pm.setSignature(pm.getSignature());
            return new String(mapper.writeValueAsBytes(pm), StandardCharsets.UTF_8);
        } catch (JsonProcessingException e) {
            throw new ProtocolException("json encoding failed", e);
        }
    }
}
--------------------------------------------------------------------------------------------------------
(function(root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.Class = factory();
    }
}(this, function() {

    function Class() {
        if (this === ((typeof root !== 'undefined') ? root : window)) {
            return new Class();
        }
    }

    Class.prototype.extend = function(params) {
        for (var x in params) {
            this[x] = params[x];
        }
        var fn = function() {};
        fn.prototype = this;
        return fn;
    };
    
    return Class;
}));
--------------------------------------------------------------------------------------------------------
<?xml version="1.0"?>
<!DOCTYPE suppressions PUBLIC
		"-//Checkstyle//DTD SuppressionFilter Configuration 1.2//EN"
		"https://checkstyle.org/dtds/suppressions_1_2.dtd">
<suppressions>
	<suppress files="SpringApplicationTests\.java" checks="FinalClass" />
	<suppress files=".+Configuration\.java" checks="HideUtilityClassConstructor" />
	<suppress files=".+Application\.java" checks="HideUtilityClassConstructor" />
	<suppress files="SignalUtils\.java" checks="IllegalImport" />
	<suppress files="OrderedFilter\.java" checks="InterfaceIsType" />
	<suppress files="OrderedWebFilter\.java" checks="InterfaceIsType" />
	<suppress files="[\\/]src[\\/]test[\\/]java[\\/]cli[\\/]command[\\/]" checks="ImportControl" />
	<suppress files="[\\/]src[\\/]main[\\/]java[\\/]sample[\\/]" checks="ImportControl" />
	<suppress files="[\\/]src[\\/]test[\\/]java[\\/]sample[\\/]" checks="ImportControl" />
	<suppress files="[\\/]src[\\/]test[\\/]java[\\/]" checks="Javadoc*" />
	<suppress files="[\\/]src[\\/]test[\\/]java[\\/]" checks="NonEmptyAtclauseDescription" />
	<suppress files="[\\/]autoconfigure[\\/]" checks="JavadocType" />
	<suppress files="[\\/]autoconfigure[\\/]" checks="JavadocVariable" />
	<suppress files="[\\/]spring-boot-docs[\\/]" checks="JavadocType" />
	<suppress files="[\\/]spring-boot-smoke-tests[\\/]" checks="JavadocType" />
	<suppress files="[\\/]spring-boot-smoke-tests[\\/]" checks="ImportControl" />
	<suppress files="[\\/]spring-boot-deployment-tests[\\/]" checks="JavadocType" />
	<suppress files="[\\/]spring-boot-integration-tests[\\/]" checks="JavadocType" />
	<suppress files="Ansi.*\.java" checks="JavadocVariable" />
	<suppress files="Ansi.*\.java" checks="JavadocStyle" />
	<suppress files="LogLevel\.java" checks="JavadocVariable" />
	<suppress files="HelpMojo\.java" checks=".*"/>
	<suppress files="[\\/]org.springframework.boot.configurationprocessor.json[\\/].*\.java$" checks=".*" />
	<suppress files="TripType\.java" checks="JavadocVariable" />
	<suppress files="Rating\.java" checks="JavadocVariable" />
	<suppress files="Direction\.java" checks="JavadocVariable" />
	<suppress files="JooqExamples\.java" checks="AvoidStaticImport" />
	<suppress files="LoggingApplicationListenerIntegrationTests\.java" checks="IllegalImport" />
	<suppress files="SpringBootJoranConfiguratorTests\.java" checks="IllegalImport" />
	<suppress files="EmbeddedMongoAutoConfiguration\.java" checks="IllegalImport" />
	<suppress files="LogbackMetricsAutoConfiguration\.java" checks="IllegalImport" />
	<suppress files="RemoteUrlPropertyExtractorTests\.java" checks="IllegalImport" />
	<suppress files="SampleLogbackApplication\.java" checks="IllegalImport" />
	<suppress files="FlywayAutoConfigurationTests\.java" checks="IllegalImport" />
	<suppress files="[\\/]src[\\/]test[\\/]java[\\/]org[\\/]springframework[\\/]boot[\\/]test[\\/]rule[\\/]" checks="SpringJUnit5" />
	<suppress files="OutputCaptureRuleTests" checks="SpringJUnit5" />
	<suppress files="SampleJUnitVintageApplicationTests" checks="SpringJUnit5" />
	<suppress files="[\\/]spring-boot-docs[\\/]" checks="SpringJavadoc" message="\@since" />
	<suppress files="[\\/]spring-boot-smoke-tests[\\/]" checks="SpringJavadoc" message="\@since" />
</suppressions>
--------------------------------------------------------------------------------------------------------
import java.awt.*;
import java.awt.image.BufferedImage;

public class ImageTools {

    public static final int EXCLUDED_BACKGROUND_RGB = new Color(255, 255, 100).getRGB();

    public static BufferedImage blankImage(final BufferedImage image) {
        Graphics2D graphics = image.createGraphics();
        graphics.setPaint(Color.white);
        graphics.fillRect(0, 0, image.getWidth(), image.getHeight());
        return image;
    }

    public static int fadeElement(final int i) {
        final Color color = new Color(i);
        return new Color(fade(color.getRed()), fade(color.getGreen()), fade(color.getBlue())).getRGB();
    }

    public static int fadeExclusion(final int i) {
        final Color color = new Color(i);
        if (color.getRed() > 245 && color.getGreen() > 245 && color.getBlue() > 245) {
            return EXCLUDED_BACKGROUND_RGB;
        }
        return fadeElement(i);
    }

    private static int fade(final int i) {
        return i + ((255 - i) * 3 / 5);
    }

    public static BufferedImage deepCopy(BufferedImage image) {
        return new BufferedImage(image.getColorModel(), image.copyData(null), image.getColorModel().isAlphaPremultiplied(), null);
    }
}

import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadPoolExecutor;

public class BlockingHandler implements RejectedExecutionHandler {

    @Override
    public void rejectedExecution(final Runnable r, final ThreadPoolExecutor executor) {
        try {
            if (!executor.isShutdown()) {
                executor.getQueue().put(r);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
--------------------------------------------------------------------------------------------------------
//import io.swagger.annotations.*;
import info.rori.lunchbox.api.v1.model.LunchOffer;
import info.rori.lunchbox.api.v1.repository.LunchOfferRepository;
import info.rori.lunchbox.api.v1.util.TypeConverter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.servers.Server;
import io.swagger.v3.oas.annotations.OpenAPIDefinition;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.info.Info;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import java.time.LocalDate;
import java.util.List;

/**
 * Stellt die Mittagsangebote in der REST-API bereit.
 */
@OpenAPIDefinition(
	    info = @Info(
	            title = "Lunchbox API v1",
	            version = "1.2.0",
	            description = "API für die Abfrage von Mittagsangeboten"
	    ),
	    servers = @Server(url = "http://localhost:8080/api/v1")
	)
@Path("/lunchOffer")
@Produces(MediaType.APPLICATION_JSON)
public class LunchOfferResource {

    private LunchOfferRepository repo = new LunchOfferRepository();

    @GET
    @Operation(summary = "Liefert alle Mittagsangebote, ggf. gefiltert nach Gültigkeits-Tag",
               responses = {
                    @ApiResponse(responseCode = "200", content = @Content(
                        array = @ArraySchema( schema = @Schema(implementation = LunchOffer.class)
                    ))),
                    @ApiResponse(responseCode = "400", description = "Bad Request - der Parameter 'day' ist nicht valide"),
                    @ApiResponse(responseCode = "500", description = "Serverfehler")
               })
    public List<LunchOffer> get(
            @QueryParam("day")
            @Parameter(description = "Tag, an dem die Mittagsangebote gültig sein sollen. Format: 'YYYY-MM-DD' (ISO 8601)", required = false)
            String dayString) {

        LocalDate day = null;
        if (dayString != null) {
            day = TypeConverter.toDate(dayString);
            if (day == null)
                throw new BadRequestException("'day' ist nicht valide");
        }

        if (day == null)
            return repo.findAll();
        else
            return repo.findByDay(day);
    }

    @GET
    @Path("{id : \\d+}")
    @Operation(summary = "Liefert das Mittagsangebot mit der angegebenen ID",
               responses = {
                    @ApiResponse(responseCode = "200", content = @Content(
                        schema = @Schema(implementation = LunchOffer.class)
                    )),
                    @ApiResponse(responseCode = "404", description = "Unter der angegebenen ID existiert kein Mittagsangebot"),
                    @ApiResponse(responseCode = "500", description = "Serverfehler")
               })
    public LunchOffer getById(
            @PathParam("id")
            @Parameter(description = "ID des gesuchten Mittagsangebots", required = true)
            int id) {
        return repo.findById(id);
    }

}

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import javax.xml.bind.annotation.adapters.XmlAdapter;

public class LocalDateAdapter extends XmlAdapter<String, LocalDate> {

    @Override
    public LocalDate unmarshal(String dateString) throws Exception {
        return LocalDate.parse(dateString, DateTimeFormatter.ISO_DATE);
    }

    @Override
    public String marshal(LocalDate localDate) throws Exception {
        return DateTimeFormatter.ISO_DATE.format(localDate);
    }
}
--------------------------------------------------------------------------------------------------------
	public static boolean isPalindrome(String candidate) {
		int length = candidate.length();
		for (int i = 0; i < length / 2; i++) {
			if (candidate.charAt(i) != candidate.charAt(length - (i + 1))) {
				return false;
			}
		}
		return true;
	}
--------------------------------------------------------------------------------------------------------
import com.sambrannen.spring.events.service.EventService;
import com.sambrannen.spring.events.web.EventsController;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

/**
 * Central configuration for the <em>Spring Events</em> sample application,
 * powered by Spring Boot.
 *
 * @author Sam Brannen
 * @since 1.0
 */
@SpringBootApplication(scanBasePackageClasses = { EventService.class, EventsController.class })
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

	@Autowired
	void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
		// @formatter:off
		auth.inMemoryAuthentication()
			.passwordEncoder(new BCryptPasswordEncoder())
			.withUser("admin")
				// "test" is encoded using BCryptPasswordEncoder
				.password("$2a$10$ygTOAyJCpUirdPv9NufL9.IEBz1OHwSdD88Faf/0ZE6.MxWEsTWjW")
				.roles("ADMIN", "ACTUATOR");
		// @formatter:on
	}
}
--------------------------------------------------------------------------------------------------------
import static org.springframework.http.HttpMethod.GET;

import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

/**
 * Web security configuration for the Spring Events application.
 *
 * @author Sam Brannen
 * @since 1.0
 */
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Configuration
	@Order(1)
	public static class HttpBasicWebSecurityConfig extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.mvcMatcher("/events/**")
				.authorizeRequests()
					.mvcMatchers(GET, "/**").permitAll()
					.mvcMatchers("/**").hasRole("ADMIN")
					.and()
				.csrf().disable()
				.httpBasic();
		}
	}

	@Configuration
	@Order(2)
	public static class FormLoginWebSecurityConfig extends WebSecurityConfigurerAdapter {

		@Override
		public void configure(WebSecurity web) {
			web.ignoring().mvcMatchers("/", "/favicon.ico", "/css/**", "/images/**");
		}

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.authorizeRequests()
					.mvcMatchers("/form**", "/h2-console/**").hasRole("ADMIN")
					.and()
				.csrf().disable()
				.formLogin();
		}
	}

}
--------------------------------------------------------------------------------------------------------
    @ApiOperation(value="获取用户详细信息", notes="根据url的id来获取用户详细信息")
    @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long")
    @RequestMapping(value="/{id}", method=RequestMethod.GET)
    public User getUser(@PathVariable Long id) {
        return new User();
    }
--------------------------------------------------------------------------------------------------------
import net.javacrumbs.shedlock.core.LockProvider;
import net.javacrumbs.shedlock.provider.jedis.JedisLockProvider;
import net.javacrumbs.shedlock.spring.ScheduledLockConfiguration;
import net.javacrumbs.shedlock.spring.ScheduledLockConfigurationBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import redis.clients.jedis.JedisPool;

import java.time.Duration;

/**
 * @author : 披荆斩棘
 * @date : 2017/6/22
 */
@Configuration
public class BeanConfig {


    /**
     * 配置锁
     *
     * @param jedisPool
     * @return
     */
    @Bean
    public LockProvider lockProvider ( JedisPool jedisPool ) {
        return new JedisLockProvider( jedisPool, "aidijing-scheduling" );
    }


    /**
     * 计划任务分布式锁配置,保证在多个实例下,任务只在一台机器上运行.
     *
     * @param lockProvider
     * @return
     */
    @Bean
    public ScheduledLockConfiguration taskScheduler ( LockProvider lockProvider ) {
        return ScheduledLockConfigurationBuilder
                .withLockProvider( lockProvider )
                .withPoolSize( 30 )
                .withDefaultLockAtMostFor( Duration.ofHours( 24 ) )
                .build();
    }
}
--------------------------------------------------------------------------------------------------------
import org.apache.commons.collections4.CollectionUtils;

import java.io.Serializable;
import java.util.*;
import java.util.stream.Collectors;

/**
 * 递归工具
 *
 * @author : 披荆斩棘
 * @date : 2017/7/7
 */
public final class RecursionUtils {

	/**
	 * 递归得到所有父子主键
	 *
	 * @param models      implements {@link ParentChildrenRecursion}
	 * @param idContainer 存储id
	 * @return 父子主键
	 */
	public static List< Serializable > listIds ( List< ? extends ParentChildrenRecursion > models ,
												 List< Serializable > idContainer ) {
		if ( CollectionUtils.isEmpty( models ) ) {
			return idContainer;
		}
		for ( ParentChildrenRecursion model : models ) {
			idContainer.add( model.getId() );
			if ( CollectionUtils.isNotEmpty( model.getChildren() ) ) {
				listIds( model.getChildren() , idContainer );
			}
		}
		return idContainer;
	}

	/**
	 * list转换为有层级关系的list,默认从顶级开始
	 * <pre>
	 *
	 *   before :
	 *   element | element | element | element | element | element
	 *
	 *   after :
	 *                          root
	 *   children | children children | children children children
	 *   ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...
	 *   RecursionUtils.listToTree(list);
	 *   [
	 *      {
	 *          "id": 1,
	 *          "parentId": 0,
	 *          "permissionName": "角色管理",
	 *          "children": [{
	 *              "id": 2,
	 *              "parentId": 1,
	 *              "permissionName": "角色列表",,
	 *              "children": [{
	 *                     "id": 3,
	 *                     "parentId": 2,
	 *                     "permissionName": "修改角色",
	 *                     "children": []
	 *                }]
	 *           }]
	 *      }
	 *   ]
	 *
	 * </pre>
	 *
	 * @param list implements {@link ParentChildrenRecursion}
	 * @return 有层级关系list
	 */
	public static List listToTree ( List< ? extends ParentChildrenRecursion > list ) {
		return tree( list.get( 0 ).rootId() , swap( list ) );
	}

	/**
	 * {@link #listToTree(List)},指定从某个层级开始
	 * <pre>
	 *   RecursionUtils.listToTree(list);
	 *   [
	 *      {
	 *          "id": 1,
	 *          "parentId": 0,
	 *          "permissionName": "角色管理",
	 *          "children": [{
	 *              "id": 2,
	 *              "parentId": 1,
	 *              "permissionName": "角色列表",,
	 *              "children": [{
	 *                     "id": 3,
	 *                     "parentId": 2,
	 *                     "permissionName": "修改角色",
	 *                     "children": []
	 *                }]
	 *           }]
	 *      },
	 *   ]
	 *   RecursionUtils.listToTree(list,1);
	 *      [
	 *          {
	 *              "id": 2,
	 *               "parentId": 1,
	 *               "permissionName": "角色列表",
	 *               "children": [{
	 *                  "id": 3,
	 *                   "parentId": 2,
	 *                   "permissionName": "修改角色",
	 *                   "children": []
	 *              }]
	 *          }
	 *      ]
	 * </pre>
	 */
	public static List listToTree ( List< ? extends ParentChildrenRecursion > list ,
									Serializable parentId ) {
		return tree( parentId , swap( list ) );
	}

	private static Map< Serializable, List< ParentChildrenRecursion > > swap ( List< ? extends ParentChildrenRecursion > list ) {
		if ( CollectionUtils.isEmpty( list ) ) {
			return Collections.emptyMap();
		}
		Map< Serializable, List< ParentChildrenRecursion > > content = new HashMap<>();
		list.forEach( element -> {
			List resources = content.get( element.getParentId() );
			if ( CollectionUtils.isEmpty( resources ) ) {
				resources = new ArrayList<>();
			}
			resources.add( element );
			content.put( element.getParentId() , resources );
		} );
		return content;
	}


	/**
	 * @see #listToTree(List , Serializable)
	 */
	public static List treeInnerFindParent ( List< ? extends ParentChildrenRecursion > list ,
											 Serializable parentId ) {
		if ( CollectionUtils.isEmpty( list ) ) {
			return Collections.EMPTY_LIST;
		}
		for ( ParentChildrenRecursion element : list ) {
			if ( Objects.equals( element.getParentId() , parentId ) ) {
				return list;
			}
			return treeInnerFindParent( element.getChildren() , parentId );
		}
		return Collections.EMPTY_LIST;
	}

	/**
	 * <pre>
	 *     RecursionUtils.treeInnerFindOneself(list,0L) = null
	 * </pre>
	 */
	public static < T extends ParentChildrenRecursion > T treeInnerFindOneself ( List< ? extends ParentChildrenRecursion > list ,
																				 Serializable oneselfId ) {
		if ( CollectionUtils.isEmpty( list ) ) {
			return null;
		}
		for ( ParentChildrenRecursion element : list ) {
			if ( Objects.equals( element.getId() , oneselfId ) ) {
				return ( T ) element;
			}
			final T oneself = innerFindOneself( Collections.singletonList( element ) , oneselfId );
			if ( Objects.nonNull( oneself ) ) {
				return oneself;
			}
		}
		return null;
	}

	public static < T extends ParentChildrenRecursion > T innerFindOneself ( List< ? extends ParentChildrenRecursion > list ,
																			 Serializable oneselfId ) {
		if ( CollectionUtils.isEmpty( list ) ) {
			return null;
		}
		if ( Objects.equals( list.get( 0 ).rootId() , oneselfId ) ) {
			return null;
		}
		for ( ParentChildrenRecursion element : list ) {
			if ( Objects.equals( element.getId() , oneselfId ) ) {
				return ( T ) element;
			}
			final List< ? extends ParentChildrenRecursion > children = element.getChildren();
			if ( CollectionUtils.isNotEmpty( children ) ) {
				return innerFindOneself( children , oneselfId );
			}
		}
		return null;
	}


	/**
	 * 规整
	 *
	 * @param parentId : 上级ID
	 * @param content
	 * @return
	 */
	private static List< ? extends ParentChildrenRecursion > tree ( Serializable parentId ,
																	Map< Serializable, List< ParentChildrenRecursion > > content ) {
		List< ParentChildrenRecursion > container = new ArrayList<>();
		List< ParentChildrenRecursion > children  = content.get( parentId );
		if ( CollectionUtils.isNotEmpty( children ) ) {
			children.forEach( element -> {
				element.setChildren( tree( element.getId() , content ) );
				container.add( element );
			} );
		}
		return container;
	}


	/**
	 * 层级关系的list转换为平行的list
	 * <p>
	 * 现在是一个层级关系的 树形 结构
	 * <pre>
	 *                          root
	 *   children | children children | children children children
	 *   ... ... ... ... ... ... ... ... ... ... ... ... ... ... ...
	 *   转换为平行的,也就是普通的链表
	 *   element | element | element | element | element | element
	 * </pre>
	 *
	 * @param trees     implements {@link ParentChildrenRecursion}
	 * @param container 存储
	 * @return
	 */
	public static List elementTreeToList ( List< ? extends ParentChildrenRecursion > trees ,
										   List< ParentChildrenRecursion > container ) {
		if ( CollectionUtils.isEmpty( trees ) ) {
			return container;
		}
		for ( ParentChildrenRecursion tree : trees ) {
			container.add( tree );
			if ( CollectionUtils.isNotEmpty( tree.getChildren() ) ) {
				elementTreeToList( tree.getChildren() , container );
			}
		}
		// 清空 children 内容
		return container.parallelStream()
						.map( element -> element.setChildren( null ) )
						.collect( Collectors.toList() );
	}

	/**
	 * @see #elementTreeToList(List , List)
	 */
	public static List elementTreeToList ( ParentChildrenRecursion tree ,
										   List< ParentChildrenRecursion > container ) {
		return elementTreeToList( Arrays.asList( tree ) , container );
	}

	/**
	 * 找到这个列表中,这个元素的所有子元素
	 *
	 * @param list          : 这个元素的关系列表
	 * @param thisElementId : 这个元素的主键
	 * @return
	 */
	public static List findListInnerThisAllChildrenToList ( List< ? extends ParentChildrenRecursion > list ,
															Serializable thisElementId ) {
		// 1. 组织树形结构关系
		final List trees = listToTree( list );
		// 2. 在这个树形结构中,找到自己及以下的树形关系
		final ParentChildrenRecursion thisElementTree = treeInnerFindOneself( trees , thisElementId );
		// 3. 变成一个list
		return elementTreeToList( thisElementTree , new ArrayList<>() );
	}


	public interface ParentChildrenRecursion < T > {

		/**
		 * root ID 默认是0 Long类型
		 * <p>
		 * <b>注意 : 如果实体主键 {@link #getId()} 是Integer 类型</b>,那么你需要自行重写该方法,返回0,而不是0L
		 *
		 * @return default 0L
		 */
		default Serializable rootId () {
			return 0L;
		}

		/**
		 * 主键
		 *
		 * @return id
		 */
		Serializable getId ();

		/**
		 * 父级主键
		 *
		 * @return
		 */
		Serializable getParentId ();

		/**
		 * 子
		 *
		 * @return
		 */
		List< T > getChildren ();

		T setChildren ( List< T > children );


	}
}

import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.interceptor.TransactionAspectSupport;

/**
 * Spring 事务管理工具类
 *
 * @author : 披荆斩棘
 * @date : 2016/12/23
 */
public abstract class TransactionUtils {

    /**
     * 手动进行回滚事务.
     * 接口中如果 try catch 异常无法回滚时,这手动调用回滚处理
     */
    public static void rollback () {
        TransactionStatus transactionStatus = TransactionAspectSupport.currentTransactionStatus();
        if ( null != transactionStatus ) {
            transactionStatus.setRollbackOnly();
        }
    }
}
--------------------------------------------------------------------------------------------------------
import lombok.Getter;
import lombok.Setter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.ChannelRegistration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.messaging.support.ChannelInterceptor;
import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;

import java.util.Objects;

/**
 * Spring WebSocket 配置,默认不开启
 * <a href="https://spring.io/guides/gs/messaging-stomp-websocket/">example</a>
 * 如何配置? yml中示例如下
 * <pre>
 *      aidijing:
 *        web-socket:
 *          enabled: true
 *          client-broker-destination-prefixes: /topic
 *          server-application-destination-prefixes: /app
 *          stomp-endpoints-paths: /aidijing
 *
 * </pre>
 * <img src="https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/images/message-flow-simple-broker.png"/>
 * <p>
 * <img src="https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/images/message-flow-broker-relay.png"/>
 * <p>
 * 拦截器配置,如果要想对 WebSocket 通信进行拦截,比如做些认证处理,那么实现{@link org.springframework.messaging.support.ChannelInterceptor},并注入到Spring上下文中即可
 * 示例 :
 * <pre>
 *      <code>@Configuration</code>
 *      public class SpringWebSocketSecurityConfig {
 *          <code>@Bean</code>
 *          public ChannelInterceptor channelInterceptor () {
 *              return new JwtWebSocketInterceptorAdapter();
 *          }
 *      }
 * </pre>
 *
 * @author pijingzhanji
 */
@Configuration
@EnableWebSocketMessageBroker
@Getter
@Setter
@ConfigurationProperties( prefix = "aidijing.web-socket" )
@ConditionalOnExpression( "${aidijing.web-socket.enabled:false}" )
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {

	private String[] clientBrokerDestinationPrefixes      = { "/topic" };
	private String[] serverApplicationDestinationPrefixes = { "/app" };
	private String[] stompEndpointsPaths                  = { "/aidijing" };
	/**
	 * WebSocket拦截器
	 */
	@Autowired( required = false )
	private ChannelInterceptor channelInterceptor;


	/**
	 * 通道
	 *
	 * @param registration
	 */
	@Override
	public void configureClientInboundChannel ( ChannelRegistration registration ) {
		if ( Objects.nonNull( channelInterceptor ) ) {
			registration.interceptors( channelInterceptor );
		}

	}

	/**
	 * 定义消息代理,设置消息连接请求的各种规范信息.
	 *
	 * @param config 消息代理注册
	 */
	@Override
	public void configureMessageBroker ( MessageBrokerRegistry config ) {
		// Server前缀,指服务端接收地址的前缀,意思就是说客户端给服务端发消息的地址的前缀
		config.setApplicationDestinationPrefixes( serverApplicationDestinationPrefixes );
		// Client前缀,表示客户端订阅地址的前缀信息,也就是客户端接收服务端消息的地址的前缀信息
		config.enableSimpleBroker( clientBrokerDestinationPrefixes );
	}

	/**
	 *
	 * <pre>
	 *    var stompClient = null;
	 *    var brokerDestinationPrefixes = "服务器端配置的订阅前缀";
	 *    var serverApplicationDestinationPrefixes = "服务器端配置的接收前缀";
	 *    var serverEndpoint = "/aidijing"; // 服务端配置的端点
	 *
	 *    // 连接
	 *    function connect() {
	 *        var socket = new SockJS(serverEndpoint);
	 *        stompClient = Stomp.over(socket);
	 *        stompClient.connect({}, function (frame) {
	 *            setConnected(true);
	 *            // 订阅的时候,加上前缀 {@link #CLIENT_SUBSCRIBE_PREFIXES}
	 *            stompClient.subscribe( brokerDestinationPrefixes + '/greetings', function (greeting) {
	 *                showGreeting(JSON.parse(greeting.body).content);
	 *            });
	 *        });
	 *    }
	 *    // 发送消息
	 *    function sendName() {
	 *        stompClient.send( serverApplicationDestinationPrefixes + "/hello", {}, JSON.stringify({'name': '披荆斩棘'}));
	 *    }
	 *
	 * </pre>
	 */

	/**
	 * 配置端点注册中心,接收客户端的连接
	 *
	 * @param registry 端点注册中心
	 */
	@Override
	public void registerStompEndpoints ( StompEndpointRegistry registry ) {
		/* 在指定的映射路径上为Web套接字端点注册一个STOMP. */
		// 表示添加了一个 /aidijing 端点,客户端就可以通过这个端点来进行连接.
		// aidijing
		registry.addEndpoint( stompEndpointsPaths )
				.withSockJS(); // 开启SockJS支持
	}


}

/**
 * 大概处理流程
 * <p>
 * {@link org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler}
 * {@link org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#handleMessage}
 * ... ... ...
 * 处理返回值,然后发送消息
 * {@link org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#handleReturnValue(Object , org.springframework.core.MethodParameter , org.springframework.web.method.support.ModelAndViewContainer , org.springframework.web.context.request.NativeWebRequest)}
 * {@link org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#handleReturnValue}
 * <p>
 * 注解简介 : org.springframework.messaging.handler.annotation 包下
 * <p>
 * {@link org.springframework.messaging.handler.annotation.Payload} : 消息体内容
 * {@link org.springframework.messaging.handler.annotation.Header}  : 得到某个header内容
 * {@link org.springframework.messaging.handler.annotation.DestinationVariable} 类似于 @{@link org.springframework.web.bind.annotation.PathVariable}
 * <a href="https://stackoverflow.com/questions/27047310/path-variables-in-spring-websockets-sendto-mapping">example</a>
 * <a href="https://stackoverflow.com/questions/30464230/spring-websocket-reply-to-user-message-flow">example</a>
 * <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#websocket-stomp-destination-separator">document</a>
 */
--------------------------------------------------------------------------------------------------------
	// 创建机器标识符
	private static int createMachineIdentifier () {
		// build a 2-byte machine piece based on NICs info
		int machinePiece;
		try {
			StringBuilder                   stringBuilder     = new StringBuilder();
			Enumeration< NetworkInterface > networkInterfaces = NetworkInterface.getNetworkInterfaces();
			while ( networkInterfaces.hasMoreElements() ) {
				NetworkInterface networkInterface = networkInterfaces.nextElement();
				stringBuilder.append( networkInterface.toString() );
				byte[] mac = networkInterface.getHardwareAddress();
				if ( mac != null ) {
					ByteBuffer byteBuffer = ByteBuffer.wrap( mac );
					try {
						stringBuilder.append( byteBuffer.getChar() );
						stringBuilder.append( byteBuffer.getChar() );
						stringBuilder.append( byteBuffer.getChar() );
					} catch ( BufferUnderflowException shortHardwareAddressException ) { //NOPMD
						// mac with less than 6 bytes. continue
					}
				}
			}
			machinePiece = stringBuilder.toString().hashCode();
		} catch ( Throwable t ) {
			// exception sometimes happens with IBM JVM, use random
			machinePiece = new SecureRandom().nextInt();
		}
		return machinePiece;
	}
--------------------------------------------------------------------------------------------------------
@Cacheable( key = "T(java.lang.String).valueOf(#id)" )

	@Caching(
		evict = {
			@CacheEvict( value = CACHE_USER_LIST_PAGE_NAME_PREFIX, allEntries = true, condition = "#result != null" )
		},
		put = {
			@CachePut( key = "T(java.lang.String).valueOf(#user.id)", condition = "#result != null" )
		}
	)
--------------------------------------------------------------------------------------------------------
import com.aidijing.common.annotation.Log;
import com.aidijing.common.util.CollectionProUtils;
import com.aidijing.common.util.JsonUtils;
import com.aidijing.common.util.RequestUtils;
import com.aidijing.manage.bean.domain.SystemLog;
import com.aidijing.manage.bean.domain.enums.NoticeType;
import com.aidijing.manage.service.SystemLogService;
import org.apache.commons.lang3.ArrayUtils;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;
import java.util.*;

/**
 * 日志处理
 * {@link Log} 注解的方法执行过程将会被记录到数据库
 *
 * @author pijingzhanji
 */
@Aspect
@Component
public class LogAspect {

	@Autowired
	private SystemLogService systemLogService;

	@Around( value = "@annotation(com.aidijing.common.annotation.Log)" )
	public Object logHandle ( ProceedingJoinPoint joinPoint ) throws Throwable {
		Method method = currentMethod( joinPoint , joinPoint.getSignature().getName() );
		Log    log    = method.getAnnotation( Log.class );
		if ( Objects.isNull( log ) ) {
			return joinPoint.proceed();
		}
		return logHandle( joinPoint , method , log );
	}

	private Object logHandle ( ProceedingJoinPoint joinPoint , Method method , Log log ) throws Throwable {
		// 异常日志信息
		String actionLog = null;
		// 是否执行异常
		boolean isException = false;
		// 接收时间戳
		long endTime;
		// 开始时间戳
		long startTime = System.currentTimeMillis();

		try {
			return joinPoint.proceed();
		} catch ( Throwable throwable ) {
			isException = true;
			actionLog = throwable.getMessage();
			throw throwable;
		} finally {
			endTime = System.currentTimeMillis();
			// 日志处理
			logHandle( joinPoint , method , log , actionLog , startTime , endTime , isException );
		}
	}

	private void logHandle ( ProceedingJoinPoint joinPoint ,
							 Method method ,
							 Log log ,
							 String actionLog ,
							 long startTime , long endTime ,
							 boolean isException ) {

		List< Map< String, Object > > args = Collections.emptyList();
		if ( ArrayUtils.isNotEmpty( joinPoint.getArgs() ) ) {
			args = new ArrayList<>( joinPoint.getArgs().length );
			for ( Object arg : joinPoint.getArgs() ) {
				args.add( CollectionProUtils.hashMapExpectedPuts( 2 ,
																  "parameterType" , arg.getClass().getCanonicalName() ,
																  "parameterValue" , arg
				) );

			}
		}

		SystemLog systemLog = new SystemLog();

		if ( ContextUtils.isLogin() ) {
			systemLog
				// 后台管理用户ID
				.setUserId( ContextUtils.getUserId() )
				// 后台管理用户真实姓名
				.setUserRealName( ContextUtils.getUser().getRealName() );
		}

		systemLog
			// 操作日志(也用于可以存储异常栈信息,或者运行的sql)
			.setActionLog( actionLog )
			// 操作ip地址
			.setActionIpAddress( RequestUtils.getRequestIp() )
			// 操作描述
			.setActionDescription( log.description() )
			// 动作开始时间
			.setActionStartTime( new Date( startTime ) )
			// 动作结束时间
			.setActionEndTime( new Date( endTime ) )
			// 总执行时间
			.setActionTotalTime( endTime - startTime )
			// 操作类
			.setActionClass( joinPoint.getTarget().getClass().getName() )
			// 操作方法
			.setActionMethod( method.getName() )
			// 方法参数
			.setActionArgs( JsonUtils.toCustomizationJson( args ) )
			// 是否异常
			.setException( isException )
			// 通知类型(SMS:短信,MAIL:邮箱)
			.setNoticeType( NoticeType.valueOf( log.noticeType().getValue() ) )
			// 异常是否警报
			.setExceptionWarn( log.warn() );

		systemLogService.asyncSave( systemLog );

	}


	/**
	 * 获取目标类的所有方法，找到当前要执行的方法
	 */
	private Method currentMethod ( ProceedingJoinPoint joinPoint , String methodName ) {
		Method[] methods      = joinPoint.getTarget().getClass().getMethods();
		Method   resultMethod = null;
		for ( Method method : methods ) {
			if ( method.getName().equals( methodName ) ) {
				resultMethod = method;
				break;
			}
		}
		return resultMethod;
	}
}
--------------------------------------------------------------------------------------------------------
package com.paragon.mailingcontour.commons.redis.service.impl;

import com.aidijing.cache.client.JedisClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.exceptions.JedisDataException;

/**
 * 单机情况使用 try-with-resources 自动关闭
 * 集群情况下就不能使用这种方式
 *
 * @author pijingzhanji
 */
@Component
public class JedisClientPool implements JedisClient {

    @Autowired
    private JedisPool jedisPool;


    @Override
    public String get ( String key ) {
        try ( Jedis jedis = jedisPool.getResource() ) {
            return jedis.get( key );
        }
    }

    @Override
    public String set ( String key, String value ) {
        try ( Jedis jedis = jedisPool.getResource() ) {
            return jedis.set( key, value );
        }
    }

    @Override
    public Long incr ( String key ) throws JedisDataException {
        try ( Jedis jedis = jedisPool.getResource() ) {
            return jedis.incr( key );
        }
    }


    @Override
    public Long del ( final String... keys ) {
        try ( Jedis jedis = jedisPool.getResource() ) {
            return jedis.del( keys );
        }
    }


    @Override
    public Long expire ( String key, int second ) {
        try ( Jedis jedis = jedisPool.getResource() ) {
            return jedis.expire( key, second );
        }
    }

    @Override
    public String setex ( String key, String value, int second ) {
        try ( Jedis jedis = jedisPool.getResource() ) {
            return jedis.setex( key, second, value );
        }
    }
}
--------------------------------------------------------------------------------------------------------
import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;

import java.io.IOException;

/**
 * <pre>
 *     aidijing:
 *       redis:
 *         host: 127.0.0.1
 *         port: 6379
 *         password: 123456
 *         timeout: 60
 *         database: 1
 * </pre>
 *
 * @author : 披荆斩棘
 * @date : 2017/5/15
 */
@Getter
@Setter
@ToString
@Configuration
@ConfigurationProperties( prefix = "aidijing.redis" )
public class RedisConfig {

    private static final String  REDISSON_ADDRESS_PREFIX = "redis://";
    private              String  host                    = "127.0.0.1";
    private              Integer port                    = 6379;
    private              Integer timeout                 = 60;
    private              String  password                = null;
    private              Integer database                = 0;

    /**
     * <a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95">redisson文档</a>
     *
     * @return
     * @throws IOException
     */
    @Bean( destroyMethod = "shutdown" )
    public RedissonClient redisson () throws IOException {
        Config config = new Config();
        config.useSingleServer()
              .setAddress( this.getRedissonAddress( host , port ) )
              .setPassword( password )
              .setDatabase( database );
        return Redisson.create( config );
    }

    private String getRedissonAddress ( String host , Integer port ) {
        return REDISSON_ADDRESS_PREFIX + host + ":" + port;
    }


    @Bean
    public JedisPoolConfig jedisPoolConfig () {
		return new JedisPoolConfig();
    }

    @Bean
    public JedisPool jedisPool () {
        return new JedisPool( jedisPoolConfig() , host , port , timeout , password , database );
    }

    @Bean
    public RedisConnectionFactory redisConnectionFactory () {
        JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory();
        jedisConnectionFactory.setHostName( host );
        jedisConnectionFactory.setPort( port );
        jedisConnectionFactory.setPassword( password );
        jedisConnectionFactory.setDatabase( database );
        return jedisConnectionFactory;
    }


    @Bean
    public RedisTemplate< String, Object > redisTemplate () {
        Jackson2JsonRedisSerializer< Object > valueSerializer = jackson2JsonRedisSerializer();
        StringRedisSerializer                 keySerializer   = new StringRedisSerializer();
        RedisTemplate< String, Object >       redisTemplate   = new RedisTemplate<>();
        redisTemplate.setConnectionFactory( redisConnectionFactory() );
        redisTemplate.setKeySerializer( keySerializer );
        redisTemplate.setValueSerializer( valueSerializer );
        redisTemplate.setHashKeySerializer( keySerializer );
        redisTemplate.setHashValueSerializer( valueSerializer );
        return redisTemplate;
    }


    @Bean
    public Jackson2JsonRedisSerializer< Object > jackson2JsonRedisSerializer () {
        Jackson2JsonRedisSerializer< Object > jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>( Object.class );
        ObjectMapper                          objectMapper                = Jackson2ObjectMapperBuilder.json().build();
        objectMapper.setVisibility( PropertyAccessor.ALL , JsonAutoDetect.Visibility.ANY );
        objectMapper.enableDefaultTyping( ObjectMapper.DefaultTyping.NON_FINAL );
        jackson2JsonRedisSerializer.setObjectMapper( objectMapper );
        return jackson2JsonRedisSerializer;
    }
}
--------------------------------------------------------------------------------------------------------
import com.aidijing.common.util.DateUtils;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mobile.device.Device;
import org.springframework.security.core.userdetails.UserDetails;

import java.io.Serializable;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * @author pijingzhanji
 */
public class JwtTokenUtil implements Serializable {

	private static final long   serialVersionUID   = - 3301605591108950415L;
	/** 用户名key **/
	private static final String CLAIM_KEY_USERNAME = "sub";
	/** 用户模型的用户代理(终端)key **/
	private static final String CLAIM_KEY_AUDIENCE = "audience";
	/** token创建时间key **/
	private static final String CLAIM_KEY_CREATED  = "created";
	private static final String AUDIENCE_UNKNOWN   = "unknown";
	/** 用户模型的用户代理(终端)浏览器端 value **/
	private static final String AUDIENCE_WEB       = "web";
	/** 用户模型的用户代理(终端)手机端 value **/
	private static final String AUDIENCE_MOBILE    = "mobile";
	/** 用户模型的用户代理(终端)平板 value **/
	private static final String AUDIENCE_TABLET    = "tablet";

	/** 签名密钥 **/
	@Value( "${jwt.secret:#{ T(java.util.UUID).randomUUID().toString()}}" )
	private String  secret;
	/** token过期时间 **/
	@Value( "${jwt.expiration:3600}" )
	private Integer expiration;
	/** header key **/
	@Value( "${jwt.header:Authorization}" )
	private String  tokenHeaderKey;

	/**
	 * 根据token得到用户名
	 *
	 * @param token
	 * @return
	 */
	public String getUsernameFromToken ( String token ) {
		String username;
		try {
			final Claims claims = getClaimsFromToken( token );
			username = claims.getSubject();
		} catch ( Exception e ) {
			username = null;
		}
		return username;
	}

	/**
	 * 得到token的开始时间(或者说创建时间)
	 *
	 * @param token
	 * @return
	 */
	public Date getCreatedDateFromToken ( String token ) {
		Date created;
		try {
			final Claims claims = getClaimsFromToken( token );
			created = new Date( ( Long ) claims.get( CLAIM_KEY_CREATED ) );
		} catch ( Exception e ) {
			created = null;
		}
		return created;
	}

	/**
	 * 得到token过期时间
	 *
	 * @param token
	 * @return
	 */
	public Date getExpirationDateFromToken ( String token ) {
		Date expiration;
		try {
			final Claims claims = getClaimsFromToken( token );
			expiration = claims.getExpiration();
		} catch ( Exception e ) {
			expiration = null;
		}
		return expiration;
	}

	/**
	 * @param token
	 * @return
	 */
	public String getAudienceFromToken ( String token ) {
		String audience;
		try {
			final Claims claims = getClaimsFromToken( token );
			audience = ( String ) claims.get( CLAIM_KEY_AUDIENCE );
		} catch ( Exception e ) {
			audience = null;
		}
		return audience;
	}

	/**
	 * @param token
	 * @return
	 */
	private Claims getClaimsFromToken ( String token ) {
		Claims claims;
		try {
			claims = Jwts.parser()
						 .setSigningKey( secret ) // 签名密钥
						 .parseClaimsJws( token ) // token
						 .getBody();
		} catch ( Exception e ) {
			claims = null;
		}
		return claims;
	}

	/**
	 * 生成过期时间
	 *
	 * @return
	 */
	private Date generateExpirationDate () {
		return DateUtils.addSecond( new Date() , expiration );
	}

	/**
	 * token是否过期
	 *
	 * @param token
	 * @return expiration > 当前时间
	 */
	private Boolean isTokenExpired ( String token ) {
		final Date expiration = getExpirationDateFromToken( token );
		return expiration.before( new Date() );
	}

	/**
	 * 当前时间 > 密码最后重置时间
	 *
	 * @param created
	 * @param lastPasswordReset
	 * @return created > lastPasswordReset
	 */
	private Boolean isCreatedBeforeLastPasswordReset ( Date created , Date lastPasswordReset ) {
		return ( lastPasswordReset != null && created.before( lastPasswordReset ) );
	}

	/**
	 * <p>终端</p>
	 *
	 * @param device : 模型的用户代理或设备提交当前请求
	 * @return
	 */
	private String generateAudience ( Device device ) {
		String audience = AUDIENCE_UNKNOWN;
		if ( device.isNormal() ) {
			audience = AUDIENCE_WEB;
		} else if ( device.isTablet() ) {
			audience = AUDIENCE_TABLET;
		} else if ( device.isMobile() ) {
			audience = AUDIENCE_MOBILE;
		}
		return audience;
	}

	/**
	 * 是否忽略token过期(移动设备则会忽略)
	 *
	 * @param token
	 * @return
	 */
	private Boolean ignoreTokenExpiration ( String token ) {
		String audience = getAudienceFromToken( token );
		// 如果是移动设备则忽略
		return ( AUDIENCE_TABLET.equals( audience ) || AUDIENCE_MOBILE.equals( audience ) );
	}

	/**
	 * 构建token
	 *
	 * @param userDetails
	 * @param device
	 * @return
	 */
	public String generateToken ( UserDetails userDetails , Device device ) {
		Map< String, Object > claims = new HashMap<>();
		claims.put( CLAIM_KEY_USERNAME , userDetails.getUsername() );
		claims.put( CLAIM_KEY_AUDIENCE , generateAudience( device ) );
		claims.put( CLAIM_KEY_CREATED , new Date() );
		return generateToken( claims );
	}

	/**
	 * 构建token
	 *
	 * @param claims
	 * @return
	 */
	String generateToken ( Map< String, Object > claims ) {
		return Jwts.builder()
				   .setClaims( claims )
				   .setExpiration( generateExpirationDate() )
				   .signWith( SignatureAlgorithm.HS512 , secret )
				   .compact();
	}

	/**
	 * token是否可以刷新
	 *
	 * @param token
	 * @param lastPasswordReset : 密码重置日期
	 * @return
	 */
	public Boolean canTokenBeRefreshed ( String token , Date lastPasswordReset ) {
		final Date created = getCreatedDateFromToken( token );
		return ! isCreatedBeforeLastPasswordReset( created , lastPasswordReset )
			&& ( ! isTokenExpired( token ) || ignoreTokenExpiration( token ) );
	}

	/**
	 * 刷新token
	 *
	 * @param token
	 * @return
	 */
	public String refreshToken ( String token ) {
		String refreshedToken;
		try {
			final Claims claims = getClaimsFromToken( token );
			claims.put( CLAIM_KEY_CREATED , new Date() );
			refreshedToken = generateToken( claims );
		} catch ( Exception e ) {
			refreshedToken = null;
		}
		return refreshedToken;
	}

	/**
	 * 验证token
	 *
	 * @param token
	 * @param userDetails
	 * @return
	 */
	public Boolean validateToken ( String token , UserDetails userDetails ) {
		BasicJwtUser user     = ( BasicJwtUser ) userDetails;
		final String username = this.getUsernameFromToken( token );
		final Date   created  = this.getCreatedDateFromToken( token );
		return ( username.equals( user.getUsername() ) // 用户名校验
			&& ! isTokenExpired( token )           // token有效期校验
			&& ! isCreatedBeforeLastPasswordReset( created , user.getLastPasswordResetDate() ) // 密码是否被修改
		);
	}
}
--------------------------------------------------------------------------------------------------------
	public Boolean validateToken ( String token , UserDetails userDetails ) {
		BasicJwtUser user     = ( BasicJwtUser ) userDetails;
		final String username = this.getUsernameFromToken( token );
		final Date   created  = this.getCreatedDateFromToken( token );
		return ( username.equals( user.getUsername() ) // 用户名校验
			&& ! isTokenExpired( token )           // token有效期校验
			&& ! isCreatedBeforeLastPasswordReset( created , user.getLastPasswordResetDate() ) // 密码是否被修改
		);
	}
	
		public String getUsernameFromToken ( String token ) {
		String username;
		try {
			final Claims claims = getClaimsFromToken( token );
			username = claims.getSubject();
		} catch ( Exception e ) {
			username = null;
		}
		return username;
	}
	
		private Claims getClaimsFromToken ( String token ) {
		Claims claims;
		try {
			claims = Jwts.parser()
						 .setSigningKey( secret ) // 签名密钥
						 .parseClaimsJws( token ) // token
						 .getBody();
		} catch ( Exception e ) {
			claims = null;
		}
		return claims;
	}
		public Date getCreatedDateFromToken ( String token ) {
		Date created;
		try {
			final Claims claims = getClaimsFromToken( token );
			created = new Date( ( Long ) claims.get( CLAIM_KEY_CREATED ) );
		} catch ( Exception e ) {
			created = null;
		}
		return created;
	}
--------------------------------------------------------------------------------------------------------
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.math.NumberUtils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 字符串操作工具类
 */
public class StringUtil {

    /**
     * 字符串分隔符
     */
    public static final String SEPARATOR = String.valueOf((char) 29);

    /**
     * 判断字符串是否非空
     */
    public static boolean isNotEmpty(String str) {
        return StringUtils.isNotEmpty(str);
    }

    /**
     * 判断字符串是否为空
     */
    public static boolean isEmpty(String str) {
        return StringUtils.isEmpty(str);
    }

    /**
     * 若字符串为空，则取默认值
     */
    public static String defaultIfEmpty(String str, String defaultValue) {
        return StringUtils.defaultIfEmpty(str, defaultValue);
    }

    /**
     * 替换固定格式的字符串（支持正则表达式）
     */
    public static String replaceAll(String str, String regex, String replacement) {
        Pattern p = Pattern.compile(regex);
        Matcher m = p.matcher(str);
        StringBuffer sb = new StringBuffer();
        while (m.find()) {
            m.appendReplacement(sb, replacement);
        }
        m.appendTail(sb);
        return sb.toString();
    }

    /**
     * 是否为数字（整数或小数）
     */
    public static boolean isNumber(String str) {
        return NumberUtils.isNumber(str);
    }

    /**
     * 是否为十进制数（整数）
     */
    public static boolean isDigits(String str) {
        return NumberUtils.isDigits(str);
    }

    /**
     * 将驼峰风格替换为下划线风格
     */
    public static String camelhumpToUnderline(String str) {
        Matcher matcher = Pattern.compile("[A-Z]").matcher(str);
        StringBuilder builder = new StringBuilder(str);
        for (int i = 0; matcher.find(); i++) {
            builder.replace(matcher.start() + i, matcher.end() + i, "_" + matcher.group().toLowerCase());
        }
        if (builder.charAt(0) == '_') {
            builder.deleteCharAt(0);
        }
        return builder.toString();
    }

    /**
     * 将下划线风格替换为驼峰风格
     */
    public static String underlineToCamelhump(String str) {
        Matcher matcher = Pattern.compile("_[a-z]").matcher(str);
        StringBuilder builder = new StringBuilder(str);
        for (int i = 0; matcher.find(); i++) {
            builder.replace(matcher.start() - i, matcher.end() - i, matcher.group().substring(1).toUpperCase());
        }
        if (Character.isUpperCase(builder.charAt(0))) {
            builder.replace(0, 1, String.valueOf(Character.toLowerCase(builder.charAt(0))));
        }
        return builder.toString();
    }

    /**
     * 分割固定格式的字符串
     */
    public static String[] splitString(String str, String separator) {
        return StringUtils.splitByWholeSeparator(str, separator);
    }

    /**
     * 将字符串首字母大写
     */
    public static String firstToUpper(String str) {
        return Character.toUpperCase(str.charAt(0)) + str.substring(1);
    }

    /**
     * 将字符串首字母小写
     */
    public static String firstToLower(String str) {
        return Character.toLowerCase(str.charAt(0)) + str.substring(1);
    }

    /**
     * 转为帕斯卡命名方式（如：FooBar）
     */
    public static String toPascalStyle(String str, String seperator) {
        return StringUtil.firstToUpper(toCamelhumpStyle(str, seperator));
    }

    /**
     * 转为驼峰命令方式（如：fooBar）
     */
    public static String toCamelhumpStyle(String str, String seperator) {
        return StringUtil.underlineToCamelhump(toUnderlineStyle(str, seperator));
    }

    /**
     * 转为下划线命名方式（如：foo_bar）
     */
    public static String toUnderlineStyle(String str, String seperator) {
        str = str.trim().toLowerCase();
        if (str.contains(seperator)) {
            str = str.replace(seperator, "_");
        }
        return str;
    }

    /**
     * 转为显示命名方式（如：Foo Bar）
     */
    public static String toDisplayStyle(String str, String seperator) {
        String displayName = "";
        str = str.trim().toLowerCase();
        if (str.contains(seperator)) {
            String[] words = StringUtil.splitString(str, seperator);
            for (String word : words) {
                displayName += StringUtil.firstToUpper(word) + " ";
            }
            displayName = displayName.trim();
        } else {
            displayName = StringUtil.firstToUpper(str);
        }
        return displayName;
    }
}
--------------------------------------------------------------------------------------------------------
import com.mongodb.Mongo;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;

import java.io.IOException;

import cz.jirutka.spring.embedmongo.EmbeddedMongoBuilder;

/**
 * @author woemler
 */
@Configuration
@Profile({ "dev", "default" })
@ComponentScan(basePackages = { "me.woemler.springblog.services" })
@EnableMongoRepositories(basePackages = "me.woemler.springblog.repositories")
public class EmbeddedDataSourceConfig {

    @Bean(destroyMethod = "close")
    public Mongo mongo() throws IOException {
        return new EmbeddedMongoBuilder().build();
    }

    @Bean
    public MongoTemplate mongoTemplate(Mongo mongo){
        return new MongoTemplate(mongo, "blog");
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.web.config.EnableSpringDataWebSupport;
import org.springframework.hateoas.config.EnableEntityLinks;
import org.springframework.hateoas.config.EnableHypermediaSupport;
import org.springframework.http.MediaType;
import org.springframework.web.servlet.config.annotation.ContentNegotiationConfigurer;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

/**
 * @author woemler
 */

@Configuration
@EnableWebMvc
@EnableHypermediaSupport(type = { EnableHypermediaSupport.HypermediaType.HAL })
@EnableEntityLinks
@ComponentScan(basePackages = { "me.woemler.springblog.controllers", "me.woemler.springblog.services" })
@EnableSpringDataWebSupport
public class TestWebAppConfig extends WebMvcConfigurerAdapter {

	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry){
		registry.addResourceHandler("/static/**").addResourceLocations("/static/");
	}
	
	@Bean
	public InternalResourceViewResolver jspViewResolver(){
		InternalResourceViewResolver resolver = new InternalResourceViewResolver();
		resolver.setPrefix("/WEB-INF/views/");
		resolver.setSuffix(".jsp");
		return resolver;
	}
	
	@Override
	public void configureContentNegotiation(ContentNegotiationConfigurer configurer){
		configurer.defaultContentType(MediaType.APPLICATION_JSON);
	}
}
--------------------------------------------------------------------------------------------------------
      <dependency>
            <groupId>de.flapdoodle.embed</groupId>
            <artifactId>de.flapdoodle.embed.mongo</artifactId>
            <version>1.50.5</version>
        </dependency>
		
		     <dependency>
            <groupId>cz.jirutka.spring</groupId>
            <artifactId>embedmongo-spring</artifactId>
            <version>1.3.1</version>
        </dependency>
--------------------------------------------------------------------------------------------------------
@DataMongoTest
@ExtendWith(SpringExtension.class)
public class MongoDbSpringIntegrationTest {
    @DisplayName("given object to save"
        + " when save object using MongoDB template"
        + " then object is saved")
    @Test
    public void test(@Autowired MongoTemplate mongoTemplate) {
        // given
        DBObject objectToSave = BasicDBObjectBuilder.start()
            .add("key", "value")
            .get();
 
        // when
        mongoTemplate.save(objectToSave, "collection");
 
        // then
        assertThat(mongoTemplate.findAll(DBObject.class, "collection")).extracting("key")
            .containsOnly("value");
    }
}

class ManualEmbeddedMongoDbIntegrationTest {
    private MongodExecutable mongodExecutable;
    private MongoTemplate mongoTemplate;
 
    @AfterEach
    void clean() {
        mongodExecutable.stop();
    }
 
    @BeforeEach
    void setup() throws Exception {
        String ip = "localhost";
        int port = 27017;
 
        IMongodConfig mongodConfig = new MongodConfigBuilder().version(Version.Main.PRODUCTION)
            .net(new Net(ip, port, Network.localhostIsIPv6()))
            .build();
 
        MongodStarter starter = MongodStarter.getDefaultInstance();
        mongodExecutable = starter.prepare(mongodConfig);
        mongodExecutable.start();
        mongoTemplate = new MongoTemplate(new MongoClient(ip, port), "test");
    }
 
    @DisplayName("given object to save"
        + " when save object using MongoDB template"
        + " then object is saved")
    @Test
    void test() throws Exception {
        // given
        DBObject objectToSave = BasicDBObjectBuilder.start()
            .add("key", "value")
            .get();
 
        // when
        mongoTemplate.save(objectToSave, "collection");
 
        // then
        assertThat(mongoTemplate.findAll(DBObject.class, "collection")).extracting("key")
            .containsOnly("value");
    }
}
--------------------------------------------------------------------------------------------------------
#!/bin/sh
# vim: set ts=4:
set -o errexit

cd "$(dirname "$0")/.."

if [ "$TRAVIS_PULL_REQUEST" != 'false' ]; then
	echo 'This is a pull request, skipping deploy.'; exit 0
fi

if [ -z "$BINTRAY_API_KEY" ]; then
	echo '$BINTRAY_API_KEY is not set, skipping deploy.'; exit 0
fi

if [ "$TRAVIS_BRANCH" != 'master' ]; then
	echo 'This is not the master branch, skipping deploy.'; exit 0
fi

if [ "${TRAVIS_BUILD_NUMBER}.8" != "$TRAVIS_JOB_NUMBER" ]; then
	echo 'This is not the build job we are looking for, skipping deploy.'; exit 0
fi

echo '==> Deploying artifact to JFrog OSS Maven repository'
mvn deploy --settings .maven-bintray.xml -Dgpg.skip=true -DskipTests=true
--------------------------------------------------------------------------------------------------------
@EnableWebMvc
@Configuration
public class RestContextConfig extends WebMvcConfigurerAdapter {

    @Override
    public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {
        resolvers.add( exceptionHandlerExceptionResolver() ); // resolves @ExceptionHandler
        resolvers.add( restExceptionResolver() );
    }

    @Bean
    public RestHandlerExceptionResolver restExceptionResolver() {
        return RestHandlerExceptionResolver.builder()
                .messageSource( httpErrorMessageSource() )
                .defaultContentType(MediaType.APPLICATION_JSON)
                .addErrorMessageHandler(EmptyResultDataAccessException.class, HttpStatus.NOT_FOUND)
                .addHandler(MyException.class, new MyExceptionHandler())
                .build();
    }

    @Bean
    public MessageSource httpErrorMessageSource() {
        ReloadableResourceBundleMessageSource m = new ReloadableResourceBundleMessageSource();
        m.setBasename("classpath:/org/example/messages");
        m.setDefaultEncoding("UTF-8");
        return m;
    }

    @Bean
    public ExceptionHandlerExceptionResolver exceptionHandlerExceptionResolver() {
        ExceptionHandlerExceptionResolver resolver = new ExceptionHandlerExceptionResolver();
        resolver.setMessageConverters(HttpMessageConverterUtils.getDefaultHttpMessageConverters());
        return resolver;
    }
}

https://github.com/jirutka/spring-rest-exception-handler/tree/master/src/main/java/cz/jirutka/spring/exhandler
--------------------------------------------------------------------------------------------------------
    /**
     * Returns default {@link HttpMessageConverter} instances, i.e.:
     *
     * <ul>
     *     <li>{@linkplain ByteArrayHttpMessageConverter}</li>
     *     <li>{@linkplain StringHttpMessageConverter}</li>
     *     <li>{@linkplain ResourceHttpMessageConverter}</li>
     *     <li>{@linkplain Jaxb2RootElementHttpMessageConverter} (when JAXB is present)</li>
     *     <li>{@linkplain MappingJackson2HttpMessageConverter} (when Jackson 2.x is present)</li>
     *     <li>{@linkplain org.springframework.http.converter.json.MappingJacksonHttpMessageConverter}
     *         (when Jackson 1.x is present and 2.x not)</li>
     * </ul>
     *
     * <p>Note: It does not return all of the default converters defined in Spring, but just thus
     * usable for exception responses.</p>
     */
    @SuppressWarnings("deprecation")
    public static List<HttpMessageConverter<?>> getDefaultHttpMessageConverters() {

        List<HttpMessageConverter<?>> converters = new ArrayList<>();

        StringHttpMessageConverter stringConverter = new StringHttpMessageConverter(Charset.forName("UTF-8"));
        stringConverter.setWriteAcceptCharset(false); // See SPR-7316

        converters.add(new ByteArrayHttpMessageConverter());
        converters.add(stringConverter);
        converters.add(new ResourceHttpMessageConverter());

        if (isJaxb2Present()) {
            converters.add(new Jaxb2RootElementHttpMessageConverter());
        }
        if (isJackson2Present()) {
            converters.add(new MappingJackson2HttpMessageConverter());

        } else if (isJacksonPresent()) {
            try {
                Class<?> clazz = Class.forName("org.springframework.http.converter.json.MappingJacksonHttpMessageConverter");
                converters.add((HttpMessageConverter<?>) clazz.newInstance());

            } catch (ClassNotFoundException ex) {
                // Ignore it, this class is not available since Spring 4.1.0.
            } catch (InstantiationException | IllegalAccessException ex) {
                throw new IllegalStateException(ex);
            }
        }
        return converters;
    }
--------------------------------------------------------------------------------------------------------
import com.jayway.asyncservlet.domain.RepoListDto;
import com.jayway.asyncservlet.domain.RepoListService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.util.concurrent.ListenableFutureCallback;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.context.request.async.DeferredResult;

@RestController
class AsyncController {
    private static final Logger log = LoggerFactory.getLogger(AsyncController.class);

    @Autowired
    private RepoListService repoListService;

    @RequestMapping("/async")
    DeferredResult<ResponseEntity<?>> async(@RequestParam("q") String query) {
        DeferredResult<ResponseEntity<?>> deferredResult = new DeferredResult<>();
        ListenableFuture<RepoListDto> repositoryListDto = repoListService.search(query);
        repositoryListDto.addCallback(
                new ListenableFutureCallback<RepoListDto>() {
                    @Override
                    public void onSuccess(RepoListDto result) {
                        ResponseEntity<RepoListDto> responseEntity = new ResponseEntity<>(result, HttpStatus.OK);
                        deferredResult.setResult(responseEntity);
                    }

                    @Override
                    public void onFailure(Throwable t) {
                        log.error("Failed to fetch result from remote service", t);
                        ResponseEntity<Void> responseEntity = new ResponseEntity<>(HttpStatus.SERVICE_UNAVAILABLE);
                        deferredResult.setResult(responseEntity);
                    }
                }
        );
        return deferredResult;
    }
}

    @Bean
    AsyncRestTemplate asyncRestTemplate() {
        return new AsyncRestTemplate();
    }
	
	import com.jayway.asyncservlet.domain.RepoDto;
import com.jayway.asyncservlet.domain.RepoListDto;
import org.springframework.http.ResponseEntity;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.util.concurrent.ListenableFutureAdapter;

import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.function.Function;
import java.util.stream.Collectors;

class RepositoryListDtoAdapter extends ListenableFutureAdapter<RepoListDto, ResponseEntity<GitHubItems>> {

    private final String query;

    public RepositoryListDtoAdapter(String query, ListenableFuture<ResponseEntity<GitHubItems>> gitHubItems) {
        super(gitHubItems);
        this.query = query;
    }

    @Override
    protected RepoListDto adapt(ResponseEntity<GitHubItems> responseEntity) throws ExecutionException {
        GitHubItems gitHubItems = responseEntity.getBody();
        List<RepoDto> repoDtos = gitHubItems.items().stream().map(toRepositoryDto).collect(Collectors.toList());
        return new RepoListDto(query, gitHubItems.totalCount(), repoDtos);
    }

    private static Function<GitHubItem, RepoDto> toRepositoryDto = item -> {
        GitHubOwner owner = item.owner();
        return new RepoDto(item.fullName(), item.getUrl(), item.description(), owner.userName(), owner.url(), owner.avatarUrl());
    };
}
--------------------------------------------------------------------------------------------------------
import org.apache.commons.codec.digest.DigestUtils;
import org.springframework.jdbc.core.JdbcTemplate;
import org.sqlite.SQLiteDataSource;

import javax.sql.DataSource;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;

public class Application {
    private static final String QUERY = "SELECT filename FROM attachment WHERE mime_type = 'image/jpeg';";
    private static final String MESSAGE_DB_FILE_NAME = "3d0d7e5fb2ce288813306e4d4636395e047a3d28";

    public static void main(String[] args) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(createDataSource());
        getImagePaths(jdbcTemplate).forEach(copyFiles);
    }

    static DataSource createDataSource() {
        SQLiteDataSource dataSource = new SQLiteDataSource();
        dataSource.setUrl("jdbc:sqlite:" + MESSAGE_DB_FILE_NAME);
        return dataSource;
    }

    static Stream<String> getImagePaths(JdbcTemplate jdbcTemplate) {
        List<String> imagePaths = jdbcTemplate.queryForList(QUERY, String.class);
        System.out.println("Found " + imagePaths.size() + " images");
        return imagePaths.stream();
    }

    static Function<String, Path> toPath = Paths::get;
    static UnaryOperator<String> adjustPath = s -> s.replaceFirst("~/", "MediaDomain-");
    static UnaryOperator<String> toSha1 = DigestUtils::sha1Hex;
    static UnaryOperator<String> extractFileName = s -> s.substring(s.lastIndexOf("/") + 1);

    static Consumer<String> copyFiles = s -> {
        try {
            Path sha1 = adjustPath.andThen(toSha1).andThen(toPath).apply(s);
            Path fileName = toPath.compose(extractFileName).apply(s);
            System.out.println("copy " + sha1 + " to " + fileName);
            Files.copy(sha1, fileName, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    };
}
--------------------------------------------------------------------------------------------------------
mvn jetty:run-war

curl -H "Cookie: SESSION=12b70435-9e6a-4e67-b544-01394dd59da0" localhost:8081

import io.netty.handler.codec.http.FullHttpRequest;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpObjectAggregator;
import io.netty.handler.codec.http.HttpServerCodec;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import reactor.core.Environment;
import reactor.core.Reactor;
import reactor.core.composable.Stream;
import reactor.core.spec.Reactors;
import reactor.net.NetServer;
import reactor.net.config.ServerSocketOptions;
import reactor.net.netty.NettyServerSocketOptions;
import reactor.net.netty.tcp.NettyTcpServer;
import reactor.net.tcp.spec.TcpServerSpec;
import reactor.spring.context.config.EnableReactor;

import java.nio.file.Path;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicReference;

import static reactor.event.selector.Selectors.$;

/**
 * Simple Spring Boot app to start a Reactor+Netty-based REST API server for thumbnailing uploaded images.
 */
@EnableAutoConfiguration
@Configuration
@ComponentScan
@EnableReactor
public class ImageThumbnailerApp {

	@Bean
	public Reactor reactor(Environment env) {
		Reactor reactor = Reactors.reactor(env, Environment.THREAD_POOL);

		// Register our thumbnailer on the Reactor
		reactor.receive($("thumbnail"), new BufferedImageThumbnailer(250));

		return reactor;
	}

	@Bean
	public ServerSocketOptions serverSocketOptions() {
		return new NettyServerSocketOptions()
				.pipelineConfigurer(pipeline -> pipeline.addLast(new HttpServerCodec())
				                                        .addLast(new HttpObjectAggregator(16 * 1024 * 1024)));
	}

	@Bean
	public NetServer<FullHttpRequest, FullHttpResponse> restApi(Environment env,
	                                                            ServerSocketOptions opts,
	                                                            Reactor reactor,
	                                                            CountDownLatch closeLatch) throws InterruptedException {
		AtomicReference<Path> thumbnail = new AtomicReference<>();

		NetServer<FullHttpRequest, FullHttpResponse> server = new TcpServerSpec<FullHttpRequest, FullHttpResponse>(
				NettyTcpServer.class)
				.env(env).dispatcher("sync").options(opts)
				.consume(ch -> {
					// filter requests by URI via the input Stream
					Stream<FullHttpRequest> in = ch.in();

					// serve image thumbnail to browser
					in.filter((FullHttpRequest req) -> ImageThumbnailerRestApi.IMG_THUMBNAIL_URI.equals(req.getUri()))
					  .when(Throwable.class, ImageThumbnailerRestApi.errorHandler(ch))
					  .consume(ImageThumbnailerRestApi.serveThumbnailImage(ch, thumbnail));

					// take uploaded data and thumbnail it
					in.filter((FullHttpRequest req) -> ImageThumbnailerRestApi.THUMBNAIL_REQ_URI.equals(req.getUri()))
					  .when(Throwable.class, ImageThumbnailerRestApi.errorHandler(ch))
					  .consume(ImageThumbnailerRestApi.thumbnailImage(ch, thumbnail, reactor));

					// shutdown this demo app
					in.filter((FullHttpRequest req) -> "/shutdown".equals(req.getUri()))
					  .consume(req -> closeLatch.countDown());
				})
				.get();

		server.start().await();

		return server;
	}

	@Bean
	public CountDownLatch closeLatch() {
		return new CountDownLatch(1);
	}

	public static void main(String... args) throws InterruptedException {
		ApplicationContext ctx = SpringApplication.run(ImageThumbnailerApp.class, args);

		// Reactor's TCP servers are non-blocking so we have to do something to keep from exiting the main thread
		CountDownLatch closeLatch = ctx.getBean(CountDownLatch.class);
		closeLatch.await();
	}

}
--------------------------------------------------------------------------------------------------------
import io.netty.buffer.ByteBuf;
import io.netty.handler.codec.http.*;
import reactor.core.Reactor;
import reactor.event.Event;
import reactor.function.Consumer;
import reactor.net.NetChannel;

import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.concurrent.atomic.AtomicReference;

import static io.netty.handler.codec.http.HttpHeaders.Names.*;
import static io.netty.handler.codec.http.HttpResponseStatus.*;
import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;

/**
 * A helper class that contains the necessary Consumers for handling HTTP requests.
 */
public class ImageThumbnailerRestApi {

  public static final String IMG_THUMBNAIL_URI = "/image/thumbnail.jpg";
  public static final String THUMBNAIL_REQ_URI = "/thumbnail";

  /**
   * Accept an image upload via POST and notify a Reactor that the image needs to be thumbnailed. Asynchronously respond
   * to the client when the thumbnailing has completed.
   *
   * @param channel
   *     the channel on which to send an HTTP response
   * @param thumbnail
   *     a reference to the shared thumbnail path
   * @param reactor
   *     the Reactor on which to publish events
   *
   * @return a consumer to handle HTTP requests
   */
  public static Consumer<FullHttpRequest> thumbnailImage(NetChannel<FullHttpRequest, FullHttpResponse> channel,
                                                         AtomicReference<Path> thumbnail,
                                                         Reactor reactor) {
    return req -> {
      if (req.getMethod() != HttpMethod.POST) {
        channel.send(badRequest(req.getMethod() + " not supported for this URI"));
        return;
      }

      // write to a temp file
      Path imgIn = null;
      try {
        imgIn = readUpload(req.content());
      } catch (IOException e) {
        throw new IllegalStateException(e.getMessage(), e);
      }

      // Asynchronously thumbnail the image to 250px on the long side
      reactor.sendAndReceive("thumbnail", Event.wrap(imgIn), ev -> {
        thumbnail.set(ev.getData());
        channel.send(redirect());
      });
    };
  }

  /**
   * Respond to GET requests and serve the thumbnailed image, a reference to which is kept in the given {@literal
   * AtomicReference}.
   *
   * @param channel
   *     the channel on which to send an HTTP response
   * @param thumbnail
   *     a reference to the shared thumbnail path
   *
   * @return a consumer to handle HTTP requests
   */
  public static Consumer<FullHttpRequest> serveThumbnailImage(NetChannel<FullHttpRequest, FullHttpResponse> channel,
                                                              AtomicReference<Path> thumbnail) {
    return req -> {
      if (req.getMethod() != HttpMethod.GET) {
        channel.send(badRequest(req.getMethod() + " not supported for this URI"));
      } else {
        try {
          channel.send(serveImage(thumbnail.get()));
        } catch (IOException e) {
          throw new IllegalStateException(e.getMessage(), e);
        }
      }
    };
  }

  /**
   * Respond to errors occurring on a Reactor by redirecting them to the client via an HTTP 500 error response.
   *
   * @param channel
   *     the channel on which to send an HTTP response
   *
   * @return a consumer to handle HTTP requests
   */
  public static Consumer<Throwable> errorHandler(NetChannel<FullHttpRequest, FullHttpResponse> channel) {
    return ev -> {
      DefaultFullHttpResponse resp = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,
                                                                 HttpResponseStatus.INTERNAL_SERVER_ERROR);
      resp.content().writeBytes(ev.getMessage().getBytes());
      resp.headers().set(HttpHeaders.Names.CONTENT_TYPE, "text/plain");
      resp.headers().set(HttpHeaders.Names.CONTENT_LENGTH, resp.content().readableBytes());
      channel.send(resp);
    };
  }

  ////////////////////////// HELPER METHODS //////////////////////////
  /*
   * Read POST uploads and write them to a temp file, returning the Path to that file.
   */
  private static Path readUpload(ByteBuf content) throws IOException {
    byte[] bytes = new byte[content.readableBytes()];
    content.readBytes(bytes);
    content.release();

    // write to a temp file
    Path imgIn = Files.createTempFile("upload", ".jpg");
    Files.write(imgIn, bytes);

    imgIn.toFile().deleteOnExit();

    return imgIn;
  }

  /*
   * Create an HTTP 400 bad request response.
   */
  public static FullHttpResponse badRequest(String msg) {
    DefaultFullHttpResponse resp = new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST);
    resp.content().writeBytes(msg.getBytes());
    resp.headers().set(CONTENT_TYPE, "text/plain");
    resp.headers().set(CONTENT_LENGTH, resp.content().readableBytes());
    return resp;
  }

  /*
   * Create an HTTP 301 redirect response.
   */
  public static FullHttpResponse redirect() {
    DefaultFullHttpResponse resp = new DefaultFullHttpResponse(HTTP_1_1, MOVED_PERMANENTLY);
    resp.headers().set(CONTENT_LENGTH, 0);
    resp.headers().set(LOCATION, IMG_THUMBNAIL_URI);
    return resp;
  }

  /*
   * Create an HTTP 200 response that contains the data of the thumbnailed image.
   */
  public static FullHttpResponse serveImage(Path path) throws IOException {
    DefaultFullHttpResponse resp = new DefaultFullHttpResponse(HTTP_1_1, OK);

    RandomAccessFile f = new RandomAccessFile(path.toString(), "r");
    resp.headers().set(CONTENT_TYPE, "image/jpeg");
    resp.headers().set(CONTENT_LENGTH, f.length());

    byte[] bytes = Files.readAllBytes(path);
    resp.content().writeBytes(bytes);

    return resp;
  }

}
--------------------------------------------------------------------------------------------------------
	@Bean
	public SecurityProperties securityProperties() {
		SecurityProperties security = new SecurityProperties();
		security.getBasic().setPath(""); // empty so home page is unsecured
		return security;
	}
--------------------------------------------------------------------------------------------------------
    @Bean
    @Override
    public DataSource dataSource() {
        JndiObjectFactoryBean factoryBean = new JndiObjectFactoryBean();
        factoryBean.setJndiName("java:comp/env/jdbc/myds");
        factoryBean.setExpectedType(DataSource.class);
        return (DataSource) factoryBean.getObject();
    }
--------------------------------------------------------------------------------------------------------
# Before running this demo, make sure that "Remote Login" is enabled on your macbook!

sudo ifconfig lo0 alias 127.0.0.2 up
sudo ifconfig lo0 alias 127.0.0.3 up

# Simulate a "remote" cluster with 3 nodes

ccm create -v 3.0.0 -n 3 ssh_demo
ccm start

# Establish port forwardings to each node:
# node 1 -> localhost:19042
# node 2 -> localhost:29042
# node 3 -> localhost:39042

node1="127.0.0.1"
node2="127.0.0.2"
node3="127.0.0.3"

# Caution: these tunnels will be automatically closed if idle for more than 5 minutes!

ssh -f -L 19042:localhost:9042 $node1 sleep 300
ssh -f -L 29042:localhost:9042 $node2 sleep 300
ssh -f -L 39042:localhost:9042 $node3 sleep 300

# Check that the ports are open:
 netstat -atp tcp | egrep "(19042|29042|39042)"

# Now, test the driver!

# Only when you are done testing, close all SSH tunnels:
killall ssh
--------------------------------------------------------------------------------------------------------
import java.util.HashSet;
import java.util.Set;

import static java.util.Arrays.asList;

public abstract class RSQLOperators {

    public static final ComparisonOperator
            EQUAL = new ComparisonOperator("=="),
            NOT_EQUAL = new ComparisonOperator("!="),
            GREATER_THAN = new ComparisonOperator("=gt=", ">"),
            GREATER_THAN_OR_EQUAL = new ComparisonOperator("=ge=", ">="),
            LESS_THAN = new ComparisonOperator("=lt=", "<"),
            LESS_THAN_OR_EQUAL = new ComparisonOperator("=le=", "<="),
            IN = new ComparisonOperator("=in=", true),
            NOT_IN = new ComparisonOperator("=out=", true);


    public static Set<ComparisonOperator> defaultOperators() {
        return new HashSet<>(asList(EQUAL, NOT_EQUAL, GREATER_THAN, GREATER_THAN_OR_EQUAL,
                                    LESS_THAN, LESS_THAN_OR_EQUAL, IN, NOT_IN));
    }
}

public enum LogicalOperator {

    AND (";"),
    OR  (",");

    private final String symbol;

    private LogicalOperator(String symbol) {
        this.symbol = symbol;
    }

    @Override
    public String toString() {
        return symbol;
    }
}
--------------------------------------------------------------------------------------------------------
import cz.jirutka.spring.boot.inheritchannel.EnableServletInheritChannel;
import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;
import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;
import org.springframework.boot.context.embedded.jetty.JettyEmbeddedServletContainerFactory;
import org.springframework.boot.context.embedded.jetty.JettyServerCustomizer;

/**
 * {@link EmbeddedServletContainerCustomizer} to add {@link InheritChannelJettyServerCustomizer}
 * into auto-configured embedded Jetty servlet container.
 *
 * @see EnableServletInheritChannel @EnableServletInheritChannel
 */
public class InheritChannelJettyServletContainerCustomizer implements EmbeddedServletContainerCustomizer {

    public void customize(ConfigurableEmbeddedServletContainer container) {
        if (container instanceof JettyEmbeddedServletContainerFactory)  {
            JettyEmbeddedServletContainerFactory factory = (JettyEmbeddedServletContainerFactory) container;

            // Ensure that the customizer is added only once.
            for (JettyServerCustomizer customizer : factory.getServerCustomizers()) {
                if (customizer instanceof InheritChannelJettyServerCustomizer) {
                    return;
                }
            }
            factory.addServerCustomizers(new InheritChannelJettyServerCustomizer());
        }
    }
}
public class InheritChannelJettyServerCustomizer implements JettyServerCustomizer {

    protected static final Log LOG = LogFactory.getLog(InheritChannelJettyServerCustomizer.class);

    /**
     * Convert the first {@link ServerConnector} of the <tt>server</tt> to
     * {@link InheritChannelServerConnector} or add a new one if does not have any.
     *
     * @param server the server to customize.
     */
    public void customize(Server server) {
        // Note: This method returns a copy of the internal array of connectors
        // and normally should contain single ServerConnector.
        Connector[] connectors = server.getConnectors();

        if (connectors.length > 1) {
            LOG.warn("Server has more than one Connector, only the first one will inherit channel");
        }

        if (connectors.length > 0) {
            Connector connector = connectors[0];
            // This should not happen.
            Assert.isInstanceOf(ServerConnector.class, connector);

            connectors[0] = new InheritChannelServerConnector((ServerConnector) connector);
        } else {
            connectors = new Connector[]{ new InheritChannelServerConnector(server) };
        }

        server.setConnectors(connectors);
    }
}
--------------------------------------------------------------------------------------------------------

import groovy.transform.CompileStatic
import org.hibernate.validator.HibernateValidator
import org.hibernate.validator.cfg.ConstraintDef
import org.springframework.beans.factory.BeanFactory
import spock.lang.Specification
import spock.lang.Unroll

import javax.validation.Validation

@Unroll
class SpELAssertValidatorIT extends Specification {

    def beanFactory = Mock(BeanFactory)


    def "validate #entity with @SpELAssert(value = '#value')"() {
        given:
            def constraint = new SpELAssertDef(value: value)
        expect:
            assert isValid(constraint, entity as StubEntity) == expected,
                    "if '$value', then entity $entity should ${expected ? '' : '*not*'} be valid"
        where:
            value                               | entity               || expected
            "a == b"                            | [a: 42,    b: 42]    || true
            "a == b"                            | [a: 0,     b: 66]    || false
            "a.equals(b)"                       | [a: 'foo', b: 'foo'] || true
            "!c"                                | [c: []]              || true
            "a"                                 | [c: []]              || false
            "c"                                 | [c: ['foo']]         || true
            "c.contains('foo')"                 | [c: ['foo']]         || true
            "sayHello(a).equals('hello, Jan!')" | [a: 'Jan']           || true
            "sayHello(a).equals('hello, Dan!')" | [a: 'Jan']           || false
    }

    def "validate #entity with @SpELAssert(value = '#value', applyIf = '#applyIf')"() {
        given:
            def constraint = new SpELAssertDef(value: value, applyIf: applyIf)
        expect:
            assert isValid(constraint, entity as StubEntity) == expected,
                    "if '$value' and '$applyIf' or not '$applyIf', " +
                    "then entity $entity should ${expected ? '' : '*not*'} be valid"
        where:
            value                               | applyIf   | entity               || expected
            "a > b"                             | 'a == 42' | [a: 42,    b: 24]    || true
            "a > b"                             | 'a == 42' | [a: 0,     b: 66]    || true
            "a == b"                            | 'a == 42' | [a: 42,    b: 66]    || false
            "a.equals('foo')"                   | 'b'       | [a: 'bar', b: false] || true
            "a.equals('foo')"                   | 'b'       | [a: 'foo', b: 1]     || true
            "a == 66"                           | 'b'       | [a: 0,     b: true]  || false
    }

    def "validate #entity with @SpELAssert(value = '#value', helpers = Helpers)"() {
        given:
            def constraint = new SpELAssertDef(value: value, helpers: [Helpers])
        expect:
            assert isValid(constraint, entity as StubEntity) == expected,
                    "if $value, then entity $entity should ${expected ? '' : '*not*'} be valid"
        where:
            value                 | entity      || expected
            "#isEven(a)"          | [a: 2]      || true
            "#countChars(a) == 4" | [a: 'cool'] || true
            "#isEven(a)"          | [a: 1]      || false
    }

    def "validate #entity with @SpELAssert(value = '#value') using Spring bean"() {
        setup:
            def constraint = new SpELAssertDef(value: value)
            def validator = createValidator(StubEntity, constraint, true)
        and:
            1 * beanFactory.getBean('stubBean') >> new StubBean()
        expect:
            validator.validate(entity as StubEntity).isEmpty() == expected
        where:
            value                      | entity         || expected
            '@stubBean.isValid(#this)' | [a: 42, b: 42] || true
            '@stubBean.isValid(#this)' | [a: 66, b: 42] || false
    }


    ////////// Helpers //////////

    def isValid(ConstraintDef constraintDef, entity) {
        createValidator(StubEntity, constraintDef).validate(entity).isEmpty()
    }

    def createValidator(Class type, ConstraintDef constraint, boolean customConstraintFactory = false) {
        def cfg = Validation.byProvider(HibernateValidator).configure()
        cfg.addMapping( cfg.createConstraintMapping().with { mapping ->
            mapping.type(type).constraint(constraint); mapping
        })
        if (customConstraintFactory) {
            cfg.constraintValidatorFactory {
                new SpELAssertValidator(beanFactory: beanFactory)
            }
        }
        cfg.buildValidatorFactory().validator
    }


    @CompileStatic
    class SpELAssertDef extends ConstraintDef<SpELAssertDef, SpELAssert> {

        SpELAssertDef() {
            super(SpELAssert)
        }

        def setValue(String value) {
            addParameter('value', value)
        }

        def setApplyIf(String applyIf) {
            addParameter('applyIf', applyIf)
        }

        def setHelpers(Class[] helpers) {
            addParameter('helpers', helpers)
        }
    }

    @CompileStatic
    static class StubEntity {

        Object a
        Object b
        Collection c

        // not needed for Groovy, just to be more clear for non-Groovy devs
        Object getA() { a }
        Object getB() { b }
        Collection getC() { c }

        String sayHello(String name) {
            "hello, ${name}!"
        }
    }

    @CompileStatic
    static class StubBean {

        boolean isValid(StubEntity entity) {
            entity.a == entity.b
        }
    }

    @CompileStatic
    static class Helpers {

        static boolean isEven(int value) {
            value % 2 == 0
        }
        static boolean isOdd(int value) {
            value % 2 != 0
        }
        static int countChars(String value) {
            value.toCharArray().length
        }
    }
}

import org.springframework.core.convert.TypeDescriptor
import org.springframework.expression.TypeConverter
import spock.lang.Specification
import spock.lang.Unroll

@Unroll
class RelaxedBooleanTypeConverterDecoratorTest extends Specification {

    def parentConverter = Mock(TypeConverter)
    def converter = new RelaxedBooleanTypeConverterDecorator(parentConverter)


    def 'canConvert: returns true for #sourceType.simpleName -> Boolean'() {
        setup:
            0 * parentConverter.canConvert(*_)
        expect:
            converter.canConvert(type(sourceType), type(Boolean))
        where:
            sourceType << [Number, Collection, Object[]]
    }

    def 'canConvert: delegates to parent when target type is not boolean'() {
        when:
            converter.canConvert(type(String), type(Number))
        then:
            1 * parentConverter.canConvert(type(String), type(Number))
    }


    def 'convertValue: converts #value to #expected'() {
        expect:
            converter.convertValue(value, type(value.class), type(Boolean)) == expected
        where:
            value               || expected
            0                   || false
            1                   || true
            42                  || true
            0L                  || false
            1L                  || true
            []                  || false
            ['list']            || true
            [].toArray()        || false
            ['array'].toArray() || true
    }

    def 'convertValue: delegates to parent when target type is not boolean'() {
        when:
            converter.convertValue('42', type(String), type(Number))
        then:
            1 * parentConverter.convertValue('42', type(String), type(Number))
    }


    ////////// Helpers //////////

    def type(obj) {
        if (obj instanceof Class) {
            TypeDescriptor.valueOf(obj)
        } else {
            TypeDescriptor.forObject(obj)
        }
    }
}
--------------------------------------------------------------------------------------------------------
import org.jivesoftware.smack.XMPPConnection;
import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;
import org.kohsuke.args4j.Option;

import java.util.ArrayList;
import java.util.List;

import static java.lang.System.*;

public class Main {

    @Argument(required=true,
             metaVar="MODE", usage="export, or import")
    private List<String> mode = new ArrayList<String>();

    @Option(name="-u", aliases="--username", required=true, metaVar="NAME",
            usage="Username; usually the portion of JID before at (@) sign, but some severs uses whole JID as an username.")
    private String username;

    @Option(name="-s", aliases="--service", required=true, metaVar="HOST",
            usage="Service (domain) name; the portion of JID after at (@) sign.")
    private String serviceName;

    @Option(name="-w", aliases="--password", required=true,
            metaVar="PASS", usage="Password")
    private String password;

    @Option(name="-h", aliases="--host", metaVar="HOST",
            usage="Server hostname (default is same as service name)")
    private String host;

    @Option(name="-p", aliases="--port",
            metaVar="PORT", usage="Server port (default is 5222)")
    private int port = 5222;

    @Option(name="-f", aliases="--file",
            metaVar="PATH", usage="Roster file path (default is stdout/stdin)")
    private String file;

    @Option(name="--help", usage="Show help")
    private boolean help;


    public static void main(String[] args) throws Exception {
        new Main().doMain(args);
    }


    public void doMain(String[] args) throws Exception {
        CmdLineParser parser = new CmdLineParser(this);

        try {
            parser.parseArgument(args);

        } catch (CmdLineException ex) {
            if (help || args.length == 0) {
                printUsage(parser);
                exit(0);
            } else {
                err.println("Error: " + ex.getMessage());
                exit(1);
            }
        }

        Command command = null;
        if (mode.contains("export")) {
            command = new RosterGet(IOSupport.createOutput(file));

        } else if (mode.contains("import")) {
            command = new RosterPut(IOSupport.createInput(file));

        } else {
            err.println("Unknown mode: " + mode.get(0));
            exit(1);
        }

        XMPPConnection conn = XMPPConnectionFactory.connectAndLogin(username, serviceName, password, host, port);
        command.work(conn);
    }

    private void printUsage(CmdLineParser parser) {
        out.println();
        out.println("Usage:");
        parser.printUsage(out);
        out.println();
        out.println("Example:");
        out.println(" roster-migrate export -u kevin@flynn.com -w top-secret -h talk.google.com -p 5222 -f export.txt");
    }
}
--------------------------------------------------------------------------------------------------------
import java.util.Collection;
import java.util.HashSet;

import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.provider.AuthorizationRequest;
import org.springframework.security.oauth2.provider.approval.TokenServicesUserApprovalHandler;

/**
 * @author Dave Syer
 * 
 */
public class SparklrUserApprovalHandler extends TokenServicesUserApprovalHandler {

	private Collection<String> autoApproveClients = new HashSet<String>();

	private boolean useTokenServices = true;

	/**
	 * @param useTokenServices the useTokenServices to set
	 */
	public void setUseTokenServices(boolean useTokenServices) {
		this.useTokenServices = useTokenServices;
	}

	/**
	 * @param autoApproveClients the auto approve clients to set
	 */
	public void setAutoApproveClients(Collection<String> autoApproveClients) {
		this.autoApproveClients = autoApproveClients;
	}

	/**
	 * Allows automatic approval for a white list of clients in the implicit grant case.
	 * 
	 * @param authorizationRequest The authorization request.
	 * @param userAuthentication the current user authentication
	 * 
	 * @return Whether the specified request has been approved by the current user.
	 */
	public boolean isApproved(AuthorizationRequest authorizationRequest, Authentication userAuthentication) {

		// If we are allowed to check existing approvals this will short circuit the decision
		if (useTokenServices && super.isApproved(authorizationRequest, userAuthentication)) {
			return true;
		}

		if (!userAuthentication.isAuthenticated()) {
			return false;
		}

		String flag = authorizationRequest.getApprovalParameters().get(AuthorizationRequest.USER_OAUTH_APPROVAL);
		boolean approved = flag != null && flag.toLowerCase().equals("true");

		return approved
				|| (authorizationRequest.getResponseTypes().contains("token") && autoApproveClients
						.contains(authorizationRequest.getClientId()));
	}

}
--------------------------------------------------------------------------------------------------------
import java.util.BitSet;
import java.util.HashSet;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;

/**
 * Stateful generator of id attributes. It's stateful since it remembers the generated ids. Thus a new instance of it
 * should be used for each document.
 * 
 * @version $Id$
 * @since 1.6M1
 */
public class IdGenerator
{
    /**
     * Id allowed characters {@link BitSet}.
     */
    private static final BitSet ALLOWED = new BitSet(256);
    static {
        // digits
        for (int i = '0'; i <= '9'; i++) {
            ALLOWED.set(i);
        }

        // alpha
        for (int i = 'a'; i <= 'z'; i++) {
            ALLOWED.set(i);
        }
        for (int i = 'A'; i <= 'Z'; i++) {
            ALLOWED.set(i);
        }

        ALLOWED.set(':');
        ALLOWED.set('_');
        ALLOWED.set('.');
        ALLOWED.set('-');
    }

    /**
     * A table of hex digits.
     */
    private static final char[] HEXDIGIT =
    {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

    /**
     * Contains the already generated ids.
     */
    private Set<String> generatedIds = new HashSet<String>();

    /**
     * Same as {@link #generateUniqueId(String, String)} but with a fixed prefix of "I".
     * 
     * @param text the text used to generate the unique id
     * @return the unique id. For example "Hello world" will generate "IHelloworld".
     */
    public String generateUniqueId(String text)
    {
        // Note: We always use a prefix (and a prefix with alpha characters) so that the generated id is a valid HTML id
        // (since HTML id must start with an alpha prefix).
        return generateUniqueId("I", text);
    }

    /**
     * Generate a unique id attribute using the passed text as the seed value. The generated id complies with the XHTML
     * specification. Extract from <a href="http://www.w3.org/TR/xhtml1/#C_8">XHTML RFC</a>:
     * <p>
     * <code> When defining fragment identifiers to be backward-compatible, only strings matching the pattern
     * [A-Za-z][A-Za-z0-9:_.-]* should be used.</code>
     * </p>
     * 
     * @param prefix the prefix of the identifier. Has to match [a-zA-Z].
     * @param text the text used to generate the unique id
     * @return the unique id. For example "Hello world" will generate prefix + "Helloworld".
     */
    public String generateUniqueId(String prefix, String text)
    {
        // Verify that the passed prefix contains only alpha characters since the generated id must be a valid HTML id.
        if (StringUtils.isEmpty(prefix) || !StringUtils.isAlpha(prefix)) {
            throw new IllegalArgumentException("The prefix [" + prefix
                + "] should only contain alphanumerical characters and not be empty.");
        }

        String idPrefix = (prefix != null ? prefix : "") + normalizeId(text);

        int occurence = 0;
        String id = idPrefix;
        while (this.generatedIds.contains(id)) {
            occurence++;
            id = idPrefix + "-" + occurence;
        }

        // Save the generated id so that the next call to this method will not generate the same id.
        this.generatedIds.add(id);

        return id;
    }

    /**
     * Normalize passed string into valid string.
     * <ul>
     * <li>Remove white spaces: Clean white space since otherwise they'll get transformed into 20 by the below and thus
     * for "Hello world" we would get "Hello20world" for the id. It's nicer to get "Helloworld".</li>
     * <li>Convert all non allowed characters. See {@link #ALLOWED} for allowed characters.</li>
     * </ul>
     * 
     * @param stringToNormalize the string to normalize
     * @return the normalized string
     */
    private String normalizeId(String stringToNormalize)
    {
        int len = stringToNormalize.length();
        int bufLen = len * 2;
        if (bufLen < 0) {
            bufLen = Integer.MAX_VALUE;
        }
        StringBuffer outBuffer = new StringBuffer(bufLen);

        for (int x = 0; x < len; x++) {
            char c = stringToNormalize.charAt(x);

            if (ALLOWED.get(c)) {
                outBuffer.append(c);
            } else if (!Character.isWhitespace(c)) {
                int nibble;
                boolean skip = true;

                nibble = (c >> 12) & 0xF;
                if (nibble != 0) {
                    skip = false;
                    outBuffer.append(toHex(nibble));
                }

                nibble = (c >> 8) & 0xF;
                if (!skip || nibble != 0) {
                    skip = false;
                    outBuffer.append(toHex(nibble));
                }

                nibble = (c >> 4) & 0xF;
                if (!skip || nibble != 0) {
                    outBuffer.append(toHex(nibble));
                }

                outBuffer.append(toHex(c & 0xF));
            }
        }

        return outBuffer.toString();
    }

    /**
     * Convert a nibble to a hex character.
     * 
     * @param nibble the nibble to convert.
     * @return hex character
     */
    private char toHex(int nibble)
    {
        return HEXDIGIT[(nibble & 0xF)];
    }

    /**
     * Remove the saved previously generated id to make it available again.
     * 
     * @param id the id to remove from the generated ids.
     */
    public void remove(String id)
    {
        this.generatedIds.remove(id);
    }

    /**
     * Reset the known generated ids.
     */
    public void reset()
    {
        this.generatedIds.clear();
    }
}
--------------------------------------------------------------------------------------------------------
 *
 * @author Jakub Jirutka <jakub@jirutka.cz>
 */
public interface Paginator <T> extends Iterable<T> {

    /**
     * Go to the page, i.e. fetch data and change state of this Paginator.
     *
     * @param page page number
     * @throws IllegalArgumentException if page number is less then 1.
     */
    void goToPage(int page) throws IllegalArgumentException;

    /**
     * Go to next page, i.e. fetch data and change state of this Paginator.
     */
    void goToNextPage();

    /**
     * Go to previous page, i.e. fetch data and change state of this Paginator.
     */
    void goToPreviousPage();

    /**
     * @return current page number
     */
    int page();

    /**
     * @return next page number
     */
    int nextPage();

    /**
     * @return previous page number
     */
    int prevPage();

    /**
     * @return <tt>true</tt> if Paginator is on the first page,
     *         <tt>false</tt> otherwise
     */
    boolean isFirstPage();

    /**
     * @return <tt>true</tt> if Paginator is on the last page,
     *         <tt>false</tt> otherwise
     */
    boolean isLastPage();

    /**
     * How many items to return per once.
     *
     * @return items per page
     */
    int getItemsPerPage();

    /**
     * How many items to return per once.
     *
     * @param items items per page
     */
    void setItemsPerPage(int items);

}
--------------------------------------------------------------------------------------------------------
import cz.jirutka.commons.persistence.Persistable;
import java.io.Serializable;
import java.util.List;

/**
 * Contract for the Generic DAO that provides common operations on datastore.
 *
 * @author Jakub Jirutka <jakub@jirutka.cz>
 * @version 2012-06-10
 * @since 1.0
 */
public interface GenericDAO {

    /**
     * Count number of instances of given entity class.
     * 
     * @param clazz na entity class
     * @return number of records
     */
    Long count(Class<? extends Persistable> clazz);

    
    /**
     * Remove a persistent instance from the datastore.
     *
     * @param entity the instance to be removed
     */
    void delete(Persistable entity);
    

    /**
     * Remove the persistent instance of the given entity class with the given 
     * identifier. It may throw <tt>NoResultException</tt> if no such instance 
     * exist depending on the implementation.
     *
     * @param id a primary key
     * @param clazz an entity class
     */
    void delete(Serializable id, Class<? extends Persistable> clazz);
    
    
    /**
     * Find persistent instances of the given entity class that are equal in 
     * listed properties with the example instance and (optinally) apply
     * pagination and ordering.
     *
     * @param exampleInstance an example instance
     * @param includeProperties properties to match with
     * @param paging a paging & ordering
     * @param clazz an entity class
     * @return the list of matched query results
     */
    <E extends Persistable> 
            List<E> findByExample(E exampleInstance, String[] includeProperties, PagingOrdering paging, Class<E> clazz);

    
    /**
     * Return the persistent instance of the given entity class with the given
     * natural key. The entity class must have exactly one property annotated as 
     * Natural Key/Identifier. When no such instance exist, it may return 
     * <tt>null</tt> or throw <tt>NoResultException</tt> depending on the
     * implementation.
     * 
     * <p>Not every JPA framework support this operation! For example Hibernate 
     * does have annotation <tt>@NaturalId</tt>, pure JPA doesn't.</p>
     * 
     * @param naturalKey a natural key
     * @param clazz an entity class
     * @return the persistent instance
     */
    <E extends Persistable> 
            E findByNaturalKey(Object naturalKey, Class<E> clazz);
    
    
    /**
     * Return the persistent instance of the given entity class with the given 
     * identifier. When no such instance exist, it may return <tt>null</tt> or 
     * throw <tt>NoResultException</tt> depending on the implementation.
     *
     * @param id a primary key
     * @param clazz an entity class
     * @return the persistent instance
     */
    <E extends Persistable> 
            E findByPrimaryKey(Serializable id, Class<E> clazz);


    /**
     * Find persistent instances of the given entity class by the given property
     * value and (optionally) apply pagination.
     *
     * @param property a property name to match with
     * @param value the property value
     * @param paging a paging & ordering
     * @param clazz an entity class
     * @return the list of matched query results
     */
    <E extends Persistable>
            List<E> findByProperty(String property, Object value, PagingOrdering paging, Class<E> clazz);
    
    
    /**
     * Return all persistent instances of the given entity class.
     *
     * @param clazz an entity class
     * @return the list of persistent instances
     */
    <E extends Persistable> 
            List<E> getAll(Class<E> clazz);

    
    /**
     * Return persistent instances of the given entity class according to the
     * given paging & ordering.
     *
     * @param paging a paging & ordering
     * @param clazz an entity class
     * @return the list of matched query results
     */
    <E extends Persistable>
            List<E> getPaginated(PagingOrdering paging, Class<E> clazz);

    
    /**
     * Return <code>true</code> if some instance of the given entity class and
     * the given identifier is persistent.
     *
     * @param id a primary key
     * @param clazz an entity class
     * @return <tt>true</tt> if there is some instance, <tt>false</tt> otherwise
     */
    boolean isPersistent(Serializable id, Class<? extends Persistable> clazz);

    
    /**
     * Return lazy-loaded persistent instance of the given entity class with the 
     * given identifier, assuming that the instance exists. This method might 
     * return a proxied instance that is initialized on-demand, when 
     * a non-identifier method is accessed.
     * 
     * <p>You should not use this method to determine if an instance exists 
     * (use {@linkplain #get() get()} instead). Use this only to retrieve an 
     * instance that you assume exists, where non-existence would be an actual 
     * error.</p>
     * 
     * <p>Not every ORM framework support this operation!</p>
     *
     * @param id a primary key
     * @param clazz an entity class
     * @return the persistent instance
     */
    <E extends Persistable>
            E load(Serializable id, Class<E> clazz);

    
    /**
     * Persist the given transient instance, first assigning a generated 
     * identifier. (Or using the current value of the identifier property if 
     * the assigned generator is used.)
     *
     * @param entity a transient instance of a entity class
     * @return the generated identifier
     */
    Serializable save(Persistable entity);

    
    /**
     * Either {@linkplain #save() save()} or {@linkplain #update() update()} the 
     * given instance, depending upon its state.
     *
     * @param entity a transient or detached instance containing new or updated state
     */
    void saveOrUpdate(Persistable entity);

    
    /**
     * Update the state of the persistent instance with the given detached 
     * instance. The instance must not be already binded with the current session
     * (if that so exception may be throwed)! Usually dirty-checking is used 
     * rather than manually calling this operation.
     *
     * @param entity a detached instance containing updated state
     */
    void update(Persistable entity);

}

import cz.jirutka.commons.persistence.Persistable;
import java.io.Serializable;
import java.util.List;


/**
 * Contract for a specific DAO that provides common operations on datastore for
 * the particular entity type.
 *
 * @author Jakub Jirutka <jakub@jirutka.cz>
 * @version 2012-06-10
 * @since 1.0
 *
 * @param <E> an entity type
 * @param <ID> a primary key type
 */
public interface SpecificDAO <E extends Persistable, ID extends Serializable> {

    /**
     * Count number of instances.
     * @return number of records
     */
    Long count();

    
    /**
     * Remove a persistent instance from the datastore.
     *
     * @param entity the instance to be removed
     */
    void delete(E entity);
    

    /**
     * Remove the persistent instance with the given identifier. It may throw
     * <tt>NoResultException</tt> if no such instance exist depending on the 
     * implementation.
     *
     * @param id a primary key
     */
    void delete(ID id);
    
    
    /**
     * Find persistent instances that are equal in listed properties with the 
     * example instance and (optinally) apply pagination and ordering.
     *
     * @param exampleInstance an example instance
     * @param includeProperties properties to match with
     * @param paging a paging & ordering
     * @return the list of matched query results
     */
    List<E> findByExample(E exampleInstance, String[] includeProperties, PagingOrdering paging);

    
    /**
     * Return the persistent instance with the given natural key. The entity 
     * class must have exactly one property annotated as Natural Key/Identifier. 
     * When no such instance exist, it may return <tt>null</tt> or throw 
     * <tt>NoResultException</tt> depending on the implementation.
     * 
     * <p>Not every JPA framework support this operation! For example Hibernate 
     * does have annotation <tt>@NaturalId</tt>, pure JPA doesn't.</p>
     * 
     * @param naturalKey a natural key
     * @return the persistent instance
     */
    E findByNaturalKey(Object naturalKey);
    
    
    /**
     * Return the persistent instance with the given identifier. When no such 
     * instance exist, it may return <tt>null</tt> or throw 
     * <tt>NoResultException</tt> depending on the implementation.
     *
     * @param id a primary key
     * @return the persistent instance
     */
    E findByPrimaryKey(ID id);


    /**
     * Find persistent instances by the given property value and (optionally) 
     * apply pagination.
     *
     * @param property a property name to match with
     * @param value the property value
     * @param paging a paging & ordering
     * @return the list of matched query results
     */
    List<E> findByProperty(String property, Object value, PagingOrdering paging);
    
    
    /**
     * Return all persistent instances.
     *
     * @return the list of persistent instances
     */
    List<E> getAll();

    
    /**
     * Return persistent instances according to the given paging & ordering.
     *
     * @param paging a paging & ordering
     * @return the list of matched query results
     */
    List<E> getPaginated(PagingOrdering paging);

    
    /**
     * Return <code>true</code> if some instance with the the given identifier 
     * is persistent.
     *
     * @param id a primary key
     * @return <tt>true</tt> if there is some instance, <tt>false</tt> otherwise
     */
    boolean isPersistent(ID id);

    
    /**
     * Return lazy-loaded persistent instance with the given identifier, assuming 
     * that the instance exists. This method might return a proxied instance that 
     * is initialized on-demand, when a non-identifier method is accessed.
     * 
     * <p>You should not use this method to determine if an instance exists 
     * (use {@linkplain #get() get()} instead). Use this only to retrieve an 
     * instance that you assume exists, where non-existence would be an actual 
     * error.</p>
     * 
     * <p>Not every ORM framework support this operation!</p>
     *
     * @param id a primary key
     * @return the persistent instance
     */
    E load(ID id);

    
    /**
     * Persist the given transient instance, first assigning a generated 
     * identifier. (Or using the current value of the identifier property if 
     * the assigned generator is used.)
     *
     * @param entity a transient instance of a persistent class
     * @return the generated identifier
     */
    ID save(E entity);

    
    /**
     * Either {@linkplain #save() save()} or {@linkplain #update() update()} the 
     * given instance, depending upon its state.
     *
     * @param entity a transient or detached instance containing new or updated state
     */
    void saveOrUpdate(E entity);

    
    /**
     * Update the state of the persistent instance with the given detached 
     * instance. The instance must not be already binded with the current session
     * (if that so exception may be throwed)! Usually dirty-checking is used 
     * rather than manually calling this operation.
     *
     * @param entity a detached instance containing updated state
     */
    void update(E entity);
    
    /**
     * Return the entity class of this DAO.
     * 
     * @return the entity class
     */
    Class<E> getEntityClass();
    
}
--------------------------------------------------------------------------------------------------------
import java.io.IOException;

import org.bson.types.ObjectId;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.gridfs.GridFsOperations;
import org.springframework.data.mongodb.gridfs.GridFsTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import com.baeldung.mongodb.file.models.Video;
import com.mongodb.BasicDBObject;
import com.mongodb.DBObject;
import com.mongodb.client.gridfs.model.GridFSFile;

@Service
public class VideoService {

    @Autowired
    private GridFsTemplate gridFsTemplate;

    @Autowired
    private GridFsOperations operations;

    public Video getVideo(String id) throws IllegalStateException, IOException {
        GridFSFile file = gridFsTemplate.findOne(new Query(Criteria.where("_id").is(id)));
        Video video = new Video();
        video.setTitle(file.getMetadata().get("title").toString());
        video.setStream(operations.getResource(file).getInputStream());
        return video;
    }

    public String addVideo(String title, MultipartFile file) throws IOException {
        DBObject metaData = new BasicDBObject();
        metaData.put("type", "video");
        metaData.put("title", title);
        ObjectId id = gridFsTemplate.store(file.getInputStream(), file.getName(), file.getContentType(), metaData);
        return id.toString();
    }
}
--------------------------------------------------------------------------------------------------------
spring.jackson.mapper.sort_properties_alphabetically=true
--------------------------------------------------------------------------------------------------------
	// end::user_guide[]
	@extensions.ExpectToFail
	// tag::user_guide[]
	@Test
	void timeoutExceededWithPreemptiveTermination() {
		// The following assertion fails with an error message similar to:
		// execution timed out after 10 ms
		assertTimeoutPreemptively(ofMillis(10), () -> {
			// Simulate task that takes more than 10 ms.
			new CountDownLatch(1).await();
		});
	}
	
		@Test
	void testInAllEnvironments() {
		assumingThat("CI".equals(System.getenv("ENV")),
			() -> {
				// perform these assertions only on the CI server
				assertEquals(2, calculator.divide(4, 2));
			});

		// perform these assertions in all environments
		assertEquals(42, calculator.multiply(6, 7));
	}
--------------------------------------------------------------------------------------------------------
import org.junit.platform.engine.EngineDiscoveryRequest;
import org.junit.platform.engine.ExecutionRequest;
import org.junit.platform.engine.TestDescriptor;
import org.junit.platform.engine.TestEngine;
import org.junit.platform.engine.UniqueId;
import org.junit.platform.engine.support.descriptor.EngineDescriptor;

/**
 * This is a no-op {@link TestEngine} that is only
 * used to make examples compile.
 */
class CustomTestEngine implements TestEngine {

	@Override
	public String getId() {
		return "custom-test-engine";
	}

	@Override
	public TestDescriptor discover(EngineDiscoveryRequest discoveryRequest, UniqueId uniqueId) {
		return new EngineDescriptor(UniqueId.forEngine(getId()), "Custom Test Engine");
	}

	@Override
	public void execute(ExecutionRequest request) {
	}
}

// tag::user_guide[]
import java.lang.reflect.Method;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.DisplayNameGeneration;
import org.junit.jupiter.api.DisplayNameGenerator;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

class DisplayNameGeneratorDemo {

	@Nested
	@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
	class A_year_is_not_supported {

		@Test
		void if_it_is_zero() {
		}

		@DisplayName("A negative value for year is not supported by the leap year computation.")
		@ParameterizedTest(name = "For example, year {0} is not supported.")
		@ValueSource(ints = { -1, -4 })
		void if_it_is_negative(int year) {
		}

	}

	@Nested
	@DisplayNameGeneration(IndicativeSentences.class)
	class A_year_is_a_leap_year {

		@Test
		void if_it_is_divisible_by_4_but_not_by_100() {
		}

		@ParameterizedTest(name = "Year {0} is a leap year.")
		@ValueSource(ints = { 2016, 2020, 2048 })
		void if_it_is_one_of_the_following_years(int year) {
		}

	}

	static class IndicativeSentences extends DisplayNameGenerator.ReplaceUnderscores {

		@Override
		public String generateDisplayNameForClass(Class<?> testClass) {
			return super.generateDisplayNameForClass(testClass);
		}

		@Override
		public String generateDisplayNameForNestedClass(Class<?> nestedClass) {
			return super.generateDisplayNameForNestedClass(nestedClass) + "...";
		}

		@Override
		public String generateDisplayNameForMethod(Class<?> testClass, Method testMethod) {
			String name = testClass.getSimpleName() + ' ' + testMethod.getName();
			return name.replace('_', ' ') + '.';
		}
	}
}
// end::user_guide[]

Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'entityManagerFactory' available
--------------------------------------------------------------------------------------------------------
	@Test
	@ExpectToFail
	void shouldFail() {
		throw new RuntimeException("any");
	}
--------------------------------------------------------------------------------------------------------
pluginManagement {
	plugins {
		id("com.gradle.enterprise") version "3.1"
		id("net.nemerosa.versioning") version "2.8.2"
		id("com.github.ben-manes.versions") version "0.26.0"
		id("com.diffplug.gradle.spotless") version "3.25.0"
		id("org.ajoberstar.git-publish") version "2.1.1"
		kotlin("jvm") version "1.3.50"
		id("com.github.johnrengelman.shadow") version "5.2.0"
		id("org.asciidoctor.convert") version "1.5.8.1"
		id("me.champeau.gradle.jmh") version "0.4.8"
		id("io.spring.nohttp") version "0.0.3.RELEASE"
	}
}

plugins {
	id("com.gradle.enterprise")
}

gradleEnterprise {
	buildScan {
		termsOfServiceUrl = "https://gradle.com/terms-of-service"
		termsOfServiceAgree = "yes"
	}
}

val javaVersion = JavaVersion.current()
require(javaVersion.isJava11Compatible) {
	"The JUnit 5 build requires Java 11 or higher. Currently executing with Java ${javaVersion.majorVersion}."
}

rootProject.name = "junit5"

include("documentation")
include("junit-jupiter")
include("junit-jupiter-api")
include("junit-jupiter-engine")
include("junit-jupiter-migrationsupport")
include("junit-jupiter-params")
include("junit-platform-commons")
include("junit-platform-console")
include("junit-platform-console-standalone")
include("junit-platform-engine")
include("junit-platform-launcher")
include("junit-platform-reporting")
include("junit-platform-runner")
include("junit-platform-suite-api")
include("junit-platform-testkit")
include("junit-vintage-engine")
include("platform-tests")
include("platform-tooling-support-tests")
include("junit-bom")

// check that every subproject has a custom build file
// based on the project name
rootProject.children.forEach { project ->
	project.buildFileName = "${project.name}.gradle"
	if (!project.buildFile.isFile) {
		project.buildFileName = "${project.name}.gradle.kts"
	}
	require(project.buildFile.isFile) {
		"${project.buildFile} must exist"
	}
}
--------------------------------------------------------------------------------------------------------
import java.lang.reflect.Method;
import java.util.concurrent.atomic.AtomicReference;

import javax.swing.SwingUtilities;

import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.InvocationInterceptor;
import org.junit.jupiter.api.extension.ReflectiveInvocationContext;

// @formatter:off
// tag::user_guide[]
public class SwingEdtInterceptor implements InvocationInterceptor {

	@Override
	public void interceptTestMethod(Invocation<Void> invocation,
			ReflectiveInvocationContext<Method> invocationContext,
			ExtensionContext extensionContext) throws Throwable {

		AtomicReference<Throwable> throwable = new AtomicReference<>();

		SwingUtilities.invokeAndWait(() -> {
			try {
				invocation.proceed();
			}
			catch (Throwable t) {
				throwable.set(t);
			}
		});
		Throwable t = throwable.get();
		if (t != null) {
			throw t;
		}
	}
}
// end::user_guide[]
// @formatter:on
--------------------------------------------------------------------------------------------------------
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

// @formatter:off
// tag::user_guide[]
class TestInterfaceDemo implements TestLifecycleLogger,
		TimeExecutionLogger, TestInterfaceDynamicTestsDemo {

	@Test
	void isEqualValue() {
		assertEquals(1, "a".length(), "is always equal");
	}

}
// end::user_guide[]
// @formatter:on
--------------------------------------------------------------------------------------------------------
// @formatter:off
// tag::user_guide[]

import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;

import example.ExampleTestCase;

import org.junit.jupiter.api.Test;
import org.junit.platform.testkit.engine.EngineTestKit;

class EngineTestKitStatisticsDemo {

	@Test
	void verifyJupiterContainerStats() {
		EngineTestKit
			.engine("junit-jupiter") // <1>
			.selectors(selectClass(ExampleTestCase.class)) // <2>
			.execute() // <3>
			.containerEvents() // <4>
			.assertStatistics(stats -> stats.started(2).succeeded(2)); // <5>
	}

	@Test
	void verifyJupiterTestStats() {
		EngineTestKit
			.engine("junit-jupiter") // <1>
			.selectors(selectClass(ExampleTestCase.class)) // <2>
			.execute() // <3>
			.testEvents() // <6>
			.assertStatistics(stats ->
				stats.skipped(1).started(3).succeeded(1).aborted(1).failed(1)); // <7>
	}

}
// end::user_guide[]
// @formatter:on

// @formatter:off
// tag::user_guide[]

import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;
import static org.junit.platform.testkit.engine.EventConditions.event;
import static org.junit.platform.testkit.engine.EventConditions.skippedWithReason;
import static org.junit.platform.testkit.engine.EventConditions.test;

import example.ExampleTestCase;

import org.junit.jupiter.api.Test;
import org.junit.platform.testkit.engine.EngineTestKit;
import org.junit.platform.testkit.engine.Events;

class EngineTestKitSkippedMethodDemo {

	@Test
	void verifyJupiterMethodWasSkipped() {
		String methodName = "skippedTest";

		Events testEvents = EngineTestKit // <5>
			.engine("junit-jupiter") // <1>
			.selectors(selectMethod(ExampleTestCase.class, methodName)) // <2>
			.execute() // <3>
			.testEvents(); // <4>

		testEvents.assertStatistics(stats -> stats.skipped(1)); // <6>

		testEvents.assertThatEvents() // <7>
			.haveExactly(1, event(test(methodName),
				skippedWithReason("for demonstration purposes")));
	}

}
// end::user_guide[]
// @formatter:on

// @formatter:off
// tag::user_guide[]

import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
import static org.junit.platform.testkit.engine.EventConditions.event;
import static org.junit.platform.testkit.engine.EventConditions.finishedWithFailure;
import static org.junit.platform.testkit.engine.EventConditions.test;
import static org.junit.platform.testkit.engine.TestExecutionResultConditions.instanceOf;
import static org.junit.platform.testkit.engine.TestExecutionResultConditions.message;

import example.ExampleTestCase;

import org.junit.jupiter.api.Test;
import org.junit.platform.testkit.engine.EngineTestKit;

class EngineTestKitFailedMethodDemo {

	@Test
	void verifyJupiterMethodFailed() {
		EngineTestKit.engine("junit-jupiter") // <1>
			.selectors(selectClass(ExampleTestCase.class)) // <2>
			.execute() // <3>
			.testEvents() // <4>
			.assertThatEvents().haveExactly(1, // <5>
				event(test("failingTest"),
					finishedWithFailure(
						instanceOf(ArithmeticException.class), message("/ by zero"))));
	}

}
// end::user_guide[]
// @formatter:on


// @formatter:off
// tag::user_guide[]

import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
import static org.junit.platform.testkit.engine.EventConditions.abortedWithReason;
import static org.junit.platform.testkit.engine.EventConditions.container;
import static org.junit.platform.testkit.engine.EventConditions.engine;
import static org.junit.platform.testkit.engine.EventConditions.event;
import static org.junit.platform.testkit.engine.EventConditions.finishedSuccessfully;
import static org.junit.platform.testkit.engine.EventConditions.finishedWithFailure;
import static org.junit.platform.testkit.engine.EventConditions.skippedWithReason;
import static org.junit.platform.testkit.engine.EventConditions.started;
import static org.junit.platform.testkit.engine.EventConditions.test;
import static org.junit.platform.testkit.engine.TestExecutionResultConditions.instanceOf;
import static org.junit.platform.testkit.engine.TestExecutionResultConditions.message;

import java.io.StringWriter;
import java.io.Writer;

import example.ExampleTestCase;

import org.junit.jupiter.api.Test;
import org.junit.platform.testkit.engine.EngineTestKit;
import org.opentest4j.TestAbortedException;

class EngineTestKitAllEventsDemo {

	@Test
	void verifyAllJupiterEvents() {
		Writer writer = // create a java.io.Writer for debug output
		// end::user_guide[]
				// For the demo, we are simply swallowing the debug output.
				new StringWriter();
		// tag::user_guide[]

		EngineTestKit.engine("junit-jupiter") // <1>
			.selectors(selectClass(ExampleTestCase.class)) // <2>
			.execute() // <3>
			.allEvents() // <4>
			.debug(writer) // <5>
			.assertEventsMatchExactly( // <6>
				event(engine(), started()),
				event(container(ExampleTestCase.class), started()),
				event(test("skippedTest"), skippedWithReason("for demonstration purposes")),
				event(test("succeedingTest"), started()),
				event(test("succeedingTest"), finishedSuccessfully()),
				event(test("abortedTest"), started()),
				event(test("abortedTest"),
					abortedWithReason(instanceOf(TestAbortedException.class),
						message(m -> m.contains("abc does not contain Z")))),
				event(test("failingTest"), started()),
				event(test("failingTest"), finishedWithFailure(
					instanceOf(ArithmeticException.class), message("/ by zero"))),
				event(container(ExampleTestCase.class), finishedSuccessfully()),
				event(engine(), finishedSuccessfully()));
	}

}
// end::user_guide[]
// @formatter:on

// tag::user_guide[]
import java.lang.reflect.Method;
import java.util.logging.Logger;

import org.junit.jupiter.api.extension.AfterTestExecutionCallback;
import org.junit.jupiter.api.extension.BeforeTestExecutionCallback;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
import org.junit.jupiter.api.extension.ExtensionContext.Store;

// end::user_guide[]
/**
 * Simple extension that <em>times</em> the execution of test methods and
 * logs the results at {@code INFO} level.
 *
 * @since 5.0
 */
// @formatter:off
// tag::user_guide[]
public class TimingExtension implements BeforeTestExecutionCallback, AfterTestExecutionCallback {

	private static final Logger logger = Logger.getLogger(TimingExtension.class.getName());

	private static final String START_TIME = "start time";

	@Override
	public void beforeTestExecution(ExtensionContext context) throws Exception {
		getStore(context).put(START_TIME, System.currentTimeMillis());
	}

	@Override
	public void afterTestExecution(ExtensionContext context) throws Exception {
		Method testMethod = context.getRequiredTestMethod();
		long startTime = getStore(context).remove(START_TIME, long.class);
		long duration = System.currentTimeMillis() - startTime;

		logger.info(() ->
			String.format("Method [%s] took %s ms.", testMethod.getName(), duration));
	}

	private Store getStore(ExtensionContext context) {
		return context.getStore(Namespace.create(getClass(), context.getRequiredTestMethod()));
	}

}
// end::user_guide[]
// @formatter:on
--------------------------------------------------------------------------------------------------------
Certified Ethical Hacker (CEH)
CompTIA A+
Certified Information Systems Security Professional (CISSP)
Cisco Certified Network Professional (CCNP)
Cisco Certified Network Associate (CCNA)
ITIL®️
Project Management Professional (PMP®️)
--------------------------------------------------------------------------------------------------------
import com.mploed.spring.events.scoring.domain.ScoringResult;
import com.mploed.spring.events.scoring.events.ScoringNegativeEvent;
import com.mploed.spring.events.scoring.events.ScoringPositiveEvent;
import com.mploed.spring.events.scoring.events.creditApplicationEntered.CreditApplicationEnteredEvent;
import com.mploed.spring.events.scoring.events.customerCreated.Customer;
import com.mploed.spring.events.scoring.events.customerCreated.CustomerCreatedEvent;
import com.mploed.spring.events.scoring.repository.ScoringResultRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.util.Date;

@Component
public class IncomingMessageListener {

	private final static Logger LOGGER = LoggerFactory.getLogger(IncomingMessageListener.class);

	private RestTemplate restTemplate;

	private ScoringResultRepository scoringResultRepository;

	private ScoringChannels scoringChannels;

	@Autowired
	public IncomingMessageListener(RestTemplate restTemplate, ScoringResultRepository scoringResultRepository, ScoringChannels scoringChannels) {
		this.restTemplate = restTemplate;
		this.scoringResultRepository = scoringResultRepository;
		this.scoringChannels = scoringChannels;
	}

	@StreamListener(ScoringChannels.CREDIT_APPLICATION_ENTERED)
	public void receiveCreditApplicationEnteredEvent(CreditApplicationEnteredEvent event) {
		LOGGER.info("Received Credit Application Entered Event: " + event.toString());
		ScoringResult scoringResult = loadOrInitializeScoringResult(event.getApplicationNumber());

		scoringResult.setPositiveBalance(event.isBalancePositive());

		scoringResult.setSupportworthyCause(event.isCauseSupportWorthy());

		scoringResult.setLastUpdate(new Date());
		ScoringResult savedScoringResult = scoringResultRepository.save(scoringResult);
		notifyInCaseOfFinalizedScoring(savedScoringResult);

	}


	@StreamListener(ScoringChannels.CUSTOMER_CREATED)
	public void receiveCustomerCreatedEvent(@Payload CustomerCreatedEvent customerCreatedEvent) {
		LOGGER.info("Received Customer Created Event: " + customerCreatedEvent.toString());
		Customer customer = restTemplate.getForObject(customerCreatedEvent.getCustomerUrl(), Customer.class);

		LOGGER.info("Received Customer from Event: " + customer.toString());
		ScoringResult scoringResult = loadOrInitializeScoringResult(customer.getApplicationNumber());

		scoringResult.setLegitCity(customer.isCityLegit());
		scoringResult.setLastUpdate(new Date());
		ScoringResult savedScoringResult = scoringResultRepository.save(scoringResult);

		notifyInCaseOfFinalizedScoring(savedScoringResult);
	}

	private void notifyInCaseOfFinalizedScoring(ScoringResult scoringResult) {
		LOGGER.info("Scoring complete: " + scoringResult.isComplete());
		if (scoringResult.isComplete()) {
			LOGGER.info("Scoring positive: " + scoringResult.isScoringPositive());
			if (scoringResult.isScoringPositive()) {
				ScoringPositiveEvent scoringPositiveEvent = new ScoringPositiveEvent(scoringResult.getApplicationNumber());
				scoringChannels.scoringPositiveOut().send(MessageBuilder.withPayload(scoringPositiveEvent).build());
			} else {
				ScoringNegativeEvent scoringNegativeEvent = new ScoringNegativeEvent(scoringResult.getApplicationNumber());
				scoringChannels.scoringNegativeOut().send(MessageBuilder.withPayload(scoringNegativeEvent).build());
			}
		}
	}

	private ScoringResult loadOrInitializeScoringResult(String applicationNumber) {
		ScoringResult scoringResult = scoringResultRepository.findByApplicationNumber(applicationNumber);

		if (scoringResult == null) {
			scoringResult = new ScoringResult();
			scoringResult.setApplicationNumber(applicationNumber);
		}
		return scoringResult;
	}

}

import org.springframework.cloud.stream.annotation.Input;
import org.springframework.cloud.stream.annotation.Output;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.SubscribableChannel;

public interface ScoringChannels {
	String CREDIT_APPLICATION_ENTERED = "creditApplicationEnteredIn";
	String CUSTOMER_CREATED = "customerCreatedIn";

	@Output
	MessageChannel scoringPositiveOut();

	@Output
	MessageChannel scoringNegativeOut();

	@Input
	SubscribableChannel creditApplicationEnteredIn();

	@Input
	SubscribableChannel customerCreatedIn();

}

import com.mploed.spring.events.creditapplication.domain.FinancialSituation;
import com.mploed.spring.events.creditapplication.events.external.CreditApplicationEnteredEvent;
import com.mploed.spring.events.creditapplication.events.internal.CreditDetailsEnteredEvent;
import com.mploed.spring.events.creditapplication.events.internal.FinancialSituationEnteredEvent;
import com.mploed.spring.events.creditapplication.messaging.CreditApplicationChannels;
import com.mploed.spring.events.creditapplication.repository.CreditApplicationEnteredEventRepository;
import com.mploed.spring.events.creditapplication.repository.CreditDetailsEnteredEventRepository;
import com.mploed.spring.events.creditapplication.domain.CreditDetails;
import com.mploed.spring.events.creditapplication.repository.FinancialSituationEnteredEventRepository;
import com.mploed.spring.events.creditapplication.repository.VerifiedCreditApplicationNumberRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.view.RedirectView;

@Controller
@RequestMapping(path = "credit-application")
public class CreditApplicationController {
	private final static Logger LOGGER = LoggerFactory.getLogger(CreditApplicationController.class);

	private CreditDetailsEnteredEventRepository creditDetailsEnteredEventRepository;
	private FinancialSituationEnteredEventRepository financialSituationEnteredEventRepository;
	private VerifiedCreditApplicationNumberRepository verifiedCreditApplicationNumberRepository;
	private CreditApplicationEnteredEventRepository creditApplicationEnteredEventRepository;
	private CreditApplicationChannels creditApplicationChannels;


	@Value("${nextProcessStepUrl}")
	private String nextProcessStepUrl;

	@Autowired
	public CreditApplicationController(CreditDetailsEnteredEventRepository creditDetailsEnteredEventRepository,
	                                   FinancialSituationEnteredEventRepository financialSituationEnteredEventRepository,
	                                   VerifiedCreditApplicationNumberRepository verifiedCreditApplicationNumberRepository,
	                                   CreditApplicationEnteredEventRepository creditApplicationEnteredEventRepository,
	                                   CreditApplicationChannels creditApplicationChannels) {
		this.creditDetailsEnteredEventRepository = creditDetailsEnteredEventRepository;
		this.financialSituationEnteredEventRepository = financialSituationEnteredEventRepository;
		this.verifiedCreditApplicationNumberRepository = verifiedCreditApplicationNumberRepository;
		this.creditApplicationEnteredEventRepository = creditApplicationEnteredEventRepository;
		this.creditApplicationChannels = creditApplicationChannels;
	}

	@GetMapping("/{applicationNumber}")
	public String index(Model model, @PathVariable String applicationNumber) {
		LOGGER.info("Received a request for a new application: " + applicationNumber);
		CreditDetails creditDetails = new CreditDetails();
		model.addAttribute("creditDetails", creditDetails);
		model.addAttribute("applicationNumber", applicationNumber);
		return "creditDetails";
	}


	@PostMapping("/{applicationNumber}/creditDetails")
	public String saveCreditDetails(@PathVariable String applicationNumber,
	                                @ModelAttribute CreditDetails creditDetails,
	                                Model model) {
		LOGGER.info("Received credit details: " + creditDetails);
		CreditDetailsEnteredEvent creditDetailsEnteredEvent = new CreditDetailsEnteredEvent(applicationNumber, creditDetails);
		creditDetailsEnteredEventRepository.save(creditDetailsEnteredEvent);
		model.addAttribute("financialSituation", new FinancialSituation());
		model.addAttribute("applicationNumber", applicationNumber);
		return "financialSituation";
	}

	@PostMapping("/{applicationNumber}/financialSituation")
	public String saveFinancialSituation(@PathVariable String applicationNumber,
	                                     @ModelAttribute FinancialSituation financialSituation,
	                                     Model model) {
		LOGGER.info("Received financial situation for: " + applicationNumber);
		LOGGER.info("Received financial situation: " + financialSituation);
		FinancialSituationEnteredEvent financialSituationEnteredEvent = new FinancialSituationEnteredEvent(applicationNumber, financialSituation);
		financialSituationEnteredEventRepository.save(financialSituationEnteredEvent);
		CreditDetailsEnteredEvent creditDetailsEnteredEvent = creditDetailsEnteredEventRepository.findByApplicationNumber(applicationNumber);
		model.addAttribute("creditDetails", creditDetailsEnteredEvent.getCreditDetails());
		model.addAttribute("financialSituation", financialSituation);
		model.addAttribute("applicationNumber", applicationNumber);
		return "summary";
	}

	@PostMapping("/{applicationNumber}/confirm")
	public RedirectView confirmCreditApplication(@PathVariable String applicationNumber) {
		LOGGER.info("app number: " + applicationNumber);
		FinancialSituationEnteredEvent financialSituationEnteredEvent = financialSituationEnteredEventRepository.findByApplicationNumber(applicationNumber);
		CreditDetailsEnteredEvent creditDetailsEnteredEvent = creditDetailsEnteredEventRepository.findByApplicationNumber(applicationNumber);

		CreditApplicationEnteredEvent creditApplicationEnteredEvent = new CreditApplicationEnteredEvent(applicationNumber,
				creditDetailsEnteredEvent.getCreditDetails(),
				financialSituationEnteredEvent.getFinancialSituation());
		CreditApplicationEnteredEvent savedEvent = creditApplicationEnteredEventRepository.save(creditApplicationEnteredEvent);
		creditApplicationChannels.creditApplicationEnteredOut().send(MessageBuilder.withPayload(savedEvent).build());
		LOGGER.info(savedEvent.toString());
		return new RedirectView(nextProcessStepUrl + applicationNumber);
	}

}

		<plugin>
				<groupId>com.spotify</groupId>
				<artifactId>dockerfile-maven-plugin</artifactId>
				<version>1.3.4</version>
				<configuration>
					<repository>${docker.image.prefix}/${project.artifactId}</repository>
				</configuration>
			</plugin>
--------------------------------------------------------------------------------------------------------
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;

// tag::user_guide[]
class WebServerDemo {

	// end::user_guide[]
	// @formatter:off
	// tag::user_guide[]
	@RegisterExtension
	static WebServerExtension server = WebServerExtension.builder()
		.enableSecurity(false)
		.build();
	// end::user_guide[]
	// @formatter:on
	// tag::user_guide[]

	@Test
	void getProductList() {
		WebClient webClient = new WebClient();
		String serverUrl = server.getServerUrl();
		// Use WebClient to connect to web server using serverUrl and verify response
		assertEquals(200, webClient.get(serverUrl + "/products").getResponseStatus());
	}

}
// end::user_guide[]
--------------------------------------------------------------------------------------------------------
	@BeforeEach
	@Timeout(5)
	void setUp() {
		// fails if execution time exceeds 5 seconds
	}

	@Test
	@Timeout(value = 100, unit = TimeUnit.MILLISECONDS)
	void failsIfExecutionTimeExceeds100Milliseconds() {
		// fails if execution time exceeds 100 milliseconds
	}
--------------------------------------------------------------------------------------------------------
IntStream.range(1, 100_000_000).mapToDouble(i -> Math.pow(i, i)).map(Math::sqrt).max();

	@ParameterizedTest
	@CsvFileSource(resources = "/two-column.csv", numLinesToSkip = 1)
	void testWithCsvFileSource(String country, int reference) {
		assertNotNull(country);
		assertNotEquals(0, reference);
	}
--------------------------------------------------------------------------------------------------------
// tag::user_guide[]

import static example.util.StringUtils.isPalindrome;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.DynamicContainer.dynamicContainer;
import static org.junit.jupiter.api.DynamicTest.dynamicTest;

import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.function.Function;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import example.util.Calculator;

import org.junit.jupiter.api.DynamicNode;
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.TestFactory;
import org.junit.jupiter.api.function.ThrowingConsumer;

// end::user_guide[]
// @formatter:off
// tag::user_guide[]
class DynamicTestsDemo {

	private final Calculator calculator = new Calculator();

	// end::user_guide[]
	@Tag("exclude")
	// tag::user_guide[]
	// This will result in a JUnitException!
	@TestFactory
	List<String> dynamicTestsWithInvalidReturnType() {
		return Arrays.asList("Hello");
	}

	@TestFactory
	Collection<DynamicTest> dynamicTestsFromCollection() {
		return Arrays.asList(
			dynamicTest("1st dynamic test", () -> assertTrue(isPalindrome("madam"))),
			dynamicTest("2nd dynamic test", () -> assertEquals(4, calculator.multiply(2, 2)))
		);
	}

	@TestFactory
	Iterable<DynamicTest> dynamicTestsFromIterable() {
		return Arrays.asList(
			dynamicTest("3rd dynamic test", () -> assertTrue(isPalindrome("madam"))),
			dynamicTest("4th dynamic test", () -> assertEquals(4, calculator.multiply(2, 2)))
		);
	}

	@TestFactory
	Iterator<DynamicTest> dynamicTestsFromIterator() {
		return Arrays.asList(
			dynamicTest("5th dynamic test", () -> assertTrue(isPalindrome("madam"))),
			dynamicTest("6th dynamic test", () -> assertEquals(4, calculator.multiply(2, 2)))
		).iterator();
	}

	@TestFactory
	DynamicTest[] dynamicTestsFromArray() {
		return new DynamicTest[] {
			dynamicTest("7th dynamic test", () -> assertTrue(isPalindrome("madam"))),
			dynamicTest("8th dynamic test", () -> assertEquals(4, calculator.multiply(2, 2)))
		};
	}

	@TestFactory
	Stream<DynamicTest> dynamicTestsFromStream() {
		return Stream.of("racecar", "radar", "mom", "dad")
			.map(text -> dynamicTest(text, () -> assertTrue(isPalindrome(text))));
	}

	@TestFactory
	Stream<DynamicTest> dynamicTestsFromIntStream() {
		// Generates tests for the first 10 even integers.
		return IntStream.iterate(0, n -> n + 2).limit(10)
			.mapToObj(n -> dynamicTest("test" + n, () -> assertTrue(n % 2 == 0)));
	}

	@TestFactory
	Stream<DynamicTest> generateRandomNumberOfTests() {

		// Generates random positive integers between 0 and 100 until
		// a number evenly divisible by 7 is encountered.
		Iterator<Integer> inputGenerator = new Iterator<Integer>() {

			Random random = new Random();
			// end::user_guide[]
			{
				// Use fixed seed to always produce the same number of tests for execution on the CI server
				random = new Random(23);
			}
			// tag::user_guide[]
			int current;

			@Override
			public boolean hasNext() {
				current = random.nextInt(100);
				return current % 7 != 0;
			}

			@Override
			public Integer next() {
				return current;
			}
		};

		// Generates display names like: input:5, input:37, input:85, etc.
		Function<Integer, String> displayNameGenerator = (input) -> "input:" + input;

		// Executes tests based on the current input value.
		ThrowingConsumer<Integer> testExecutor = (input) -> assertTrue(input % 7 != 0);

		// Returns a stream of dynamic tests.
		return DynamicTest.stream(inputGenerator, displayNameGenerator, testExecutor);
	}

	@TestFactory
	Stream<DynamicNode> dynamicTestsWithContainers() {
		return Stream.of("A", "B", "C")
			.map(input -> dynamicContainer("Container " + input, Stream.of(
				dynamicTest("not null", () -> assertNotNull(input)),
				dynamicContainer("properties", Stream.of(
					dynamicTest("length > 0", () -> assertTrue(input.length() > 0)),
					dynamicTest("not empty", () -> assertFalse(input.isEmpty()))
				))
			)));
	}

	@TestFactory
	DynamicNode dynamicNodeSingleTest() {
		return dynamicTest("'pop' is a palindrome", () -> assertTrue(isPalindrome("pop")));
	}

	@TestFactory
	DynamicNode dynamicNodeSingleContainer() {
		return dynamicContainer("palindromes",
			Stream.of("racecar", "radar", "mom", "dad")
				.map(text -> dynamicTest(text, () -> assertTrue(isPalindrome(text)))
		));
	}

}
// end::user_guide[]
--------------------------------------------------------------------------------------------------------
@DisabledByFormula(
	"After Mayan b'ak'tun 13 and on Linux",
	now().isAfter(MAYAN_B_AK_TUN_13) && OS.determine() == OS.NIX))
class DisabledByFormulaTest {
 
	private static final LocalDateTime MAYAN_B_AK_TUN_13 =
		LocalDateTime.of(2012, 12, 21, 0, 0);
 
}

class DisabledByFormulaTest {
 
	private static final LocalDateTime MAYAN_B_AK_TUN_13 =
		LocalDateTime.of(2012, 12, 21, 0, 0);
 
	@RegisterExtension
	static final DisabledByFormula FORMULA = DisabledByFormula
		.disabledWhen(
			"After Mayan b'ak'tun 13 and on Linux",
			now().isAfter(MAYAN_B_AK_TUN_13)
				&& OS.determine() == OS.NIX);
 
--------------------------------------------------------------------------------------------------------
import com.mploed.spring.events.scoring.messaging.ScoringChannels;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@EnableBinding(ScoringChannels.class)
public class ScoringApplication {

	public static void main(String[] args) {
		SpringApplication.run(ScoringApplication.class, args);
	}

	@Bean
	RestTemplate restTemplate() {
		return new RestTemplate();
	}
}
--------------------------------------------------------------------------------------------------------
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

import me.woemler.springblog.models.User;

/**
 * @author woemler
 */
public class UserRepositoryImpl implements UserDetailsService {

    @Autowired private MongoTemplate mongoTemplate;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return mongoTemplate.findOne(new Query(Criteria.where("username").is(username)), User.class);
    }
}
--------------------------------------------------------------------------------------------------------
public enum BuildResult {
    FAILURE, UNSTABLE, REBUILDING, BUILDING,
    /**
     * This means a job was already running and has been aborted.
     */
    ABORTED,
    /**
     * 
     */
    SUCCESS,
    /**
     * ?
     */
    UNKNOWN,
    /**
     * This is returned if a job has never been built.
     */
    NOT_BUILT,
    /**
     * This will be the result of a job in cases where it has been cancelled
     * during the time in the queue.
     */
    CANCELLED
}
--------------------------------------------------------------------------------------------------------
@Microbenchmark
public class SimpleBenchmark {

    @State
    static class MyParameters {

        @Param({"1", "10", "100"})  // renders parametrized benchmarks as sub-tests
        String batchSize;
    }
    
    @Benchmark
    public void foo(MyParameters myParameters) {}
}

https://github.com/sbrannen/microbenchmark-runner
--------------------------------------------------------------------------------------------------------
<repositories>
	<repository>
		<id>jitpack.io</id>
		<url>https://jitpack.io</url>
	</repository>
</repositories>

--------------------------------------------------------------------------------------------------------
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
@PropertyMapping("spring.test.mockmvc")
--------------------------------------------------------------------------------------------------------
// curl -H "Accept:application/json" http://localhost:8080/events | json_pp

// curl -H "Accept:application/json" http://localhost:8080/events/9 | json_pp

// curl -u admin:test -i -X POST -H "Content-Type:application/json" http://localhost:8080/events/ -d '{"name": "Spring!", "location": "Command Line"}'

// curl -u admin:test -i -X PUT -H "Content-Type:application/json" http://localhost:8080/events/9 -d '{"id":"9", "eventDate":"2015-04-30", "name": "Edited", "location": "Command Line"}'

// curl -u admin:test -i -X DELETE http://localhost:8080/events/9
--------------------------------------------------------------------------------------------------------
drop table event if exists;
drop sequence if exists hibernate_sequence;

-- -----------------------------------------------------------------------------

-- 13 = 12 (number of entries in data.sql) + 1
create sequence hibernate_sequence start with 13 increment by 1;

create table event (
	id bigint not null,
	name varchar(30) not null,
	event_date date not null,
	location varchar(30) not null,
	primary key (id)
);
--------------------------------------------------------------------------------------------------------
public class ValidPersonParameterResolver implements ParameterResolver {
 
  public static Person[] VALID_PERSONS = {
      new Person().setId(1L).setLastName("Adams").setFirstName("Jill"),
      new Person().setId(2L).setLastName("Baker").setFirstName("James"),
      new Person().setId(3L).setLastName("Carter").setFirstName("Samanta"),
      new Person().setId(4L).setLastName("Daniels").setFirstName("Joseph"),
      new Person().setId(5L).setLastName("English").setFirstName("Jane"),
      new Person().setId(6L).setLastName("Fontana").setFirstName("Enrique"),
  };
  @Override
public boolean supportsParameter(ParameterContext parameterContext, 
  ExtensionContext extensionContext) throws ParameterResolutionException {
    boolean ret = false;
    if (parameterContext.getParameter().getType() == Person.class) {
        ret = true;
    }
    return ret;
}

@Override
public Object resolveParameter(ParameterContext parameterContext, 
  ExtensionContext extensionContext) throws ParameterResolutionException {
    Object ret = null;
    if (parameterContext.getParameter().getType() == Person.class) {
        ret = VALID_PERSONS[new Random().nextInt(VALID_PERSONS.length)];
    }
    return ret;
}

import java.util.Iterator;
import java.util.concurrent.ThreadLocalRandom;

public class Test {
  public static void main(String[] args) {
    Test t = new Test();
    for (int i = 0; i < 100; i++) {
      System.out.println(t.randomFloat());
    }
  }

  final ThreadLocalRandom random = ThreadLocalRandom.current();
  Iterator<Double> randomDoubles = random.doubles(-Float.MAX_VALUE,
      Math.nextUp((double) Float.MAX_VALUE)).iterator();
  float randomFloat() {
    return randomDoubles.next().floatValue();
  }
}

https://devqa.io/java-random-number/
--------------------------------------------------------------------------------------------------------
xcode-select --install
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
brew install appsody/appsody/appsody

sudo apt upgrade -f ./appsody_v.r.m_amd64.deb -y
sudo yum update appsody-v.r.m-1.x86_64.rpm -y
--------------------------------------------------------------------------------------------------------
import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;

/**
 * Collection of Utilities.
 */
class Utils {
    /**
     * Create a temporary directory on disk that will be cleaned up when the process terminates.
     * @return Absolute path to the temporary directory.
     */
    static File createTempDirectory() {
        // Create temp path to store logs
        final Path logDir;
        try {
            logDir = Files.createTempDirectory("kafka-unit");
        } catch (final IOException e) {
            throw new RuntimeException(e);
        }

        // Ensure its removed on termination by recursively removing all files under the temp directory.
        Utils.recursiveDeleteOnShutdownHook(logDir);

        // Return as a File
        return logDir.toFile();
    }

    /**
     * Registers a shutdown hook to recursively cleanup/delete a directory and all of it's contents.
     * @param path the Path to remove.
     */
    private static void recursiveDeleteOnShutdownHook(final Path path) {
        Runtime.getRuntime().addShutdownHook(new Thread(
            () -> {
                try {
                    Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
                        @Override
                        public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) throws IOException {
                            Files.delete(file);
                            return FileVisitResult.CONTINUE;
                        }

                        @Override
                        public FileVisitResult postVisitDirectory(final Path dir, final IOException exception) throws IOException {
                            if (exception == null) {
                                Files.delete(dir);
                                return FileVisitResult.CONTINUE;
                            }
                            // directory iteration failed
                            throw exception;
                        }
                    });
                } catch (final IOException exception) {
                    throw new RuntimeException("Failed to delete " + path, exception);
                }
            }
        ));
    }
}
--------------------------------------------------------------------------------------------------------
import java.util.HashMap;
import java.util.Map;

import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.annotation.EnableKafka;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.support.converter.StringJsonMessageConverter;

@Configuration
@EnableKafka
public class ReceiverConfig {

  @Value("${kafka.bootstrap-servers}")
  private String bootstrapServers;

  @Bean
  public Map<String, Object> consumerConfigs() {
    Map<String, Object> props = new HashMap<>();
    props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
    props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
    props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
    props.put(ConsumerConfig.GROUP_ID_CONFIG, "json");

    return props;
  }

  @Bean
  public ConsumerFactory<String, String> consumerFactory() {
    return new DefaultKafkaConsumerFactory<>(consumerConfigs(), new StringDeserializer(),
        new StringDeserializer());
  }

  @Bean
  public ConcurrentKafkaListenerContainerFactory<String, String> kafkaListenerContainerFactory() {
    ConcurrentKafkaListenerContainerFactory<String, String> factory =
        new ConcurrentKafkaListenerContainerFactory<>();
    factory.setConsumerFactory(consumerFactory());
    factory.setMessageConverter(new StringJsonMessageConverter());

    return factory;
  }

  @Bean
  public Receiver receiver() {
    return new Receiver();
  }
}

import java.util.HashMap;
import java.util.Map;

import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.support.converter.StringJsonMessageConverter;

@Configuration
public class SenderConfig {

  @Value("${kafka.bootstrap-servers}")
  private String bootstrapServers;

  @Bean
  public Map<String, Object> producerConfigs() {
    Map<String, Object> props = new HashMap<>();
    props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
    props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
    props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);

    return props;
  }

  @Bean
  public ProducerFactory<String, String> producerFactory() {
    return new DefaultKafkaProducerFactory<>(producerConfigs());
  }

  @Bean
  public KafkaTemplate<String, String> kafkaTemplate() {
    KafkaTemplate<String, String> template = new KafkaTemplate<>(producerFactory());
    template.setMessageConverter(new StringJsonMessageConverter());

    return template;
  }

  @Bean
  public Sender sender() {
    return new Sender();
  }
}
--------------------------------------------------------------------------------------------------------
/** Instance of Tika facade class with default configuration. */
private final Tika defaultTika = new Tika();
/** Instance of Tika facade class with MimeTypes detector. */
private final Tika mimeTika = new Tika(new MimeTypes());
his is 
/** Instance of Tika facade class with Type detector. */
private final Tika typeTika = new Tika(new TypeDetector());
--------------------------------------------------------------------------------------------------------
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Map;

import javax.xml.bind.DatatypeConverter;

import org.apache.avro.generic.GenericDatumWriter;
import org.apache.avro.generic.GenericRecord;
import org.apache.avro.io.BinaryEncoder;
import org.apache.avro.io.DatumWriter;
import org.apache.avro.io.EncoderFactory;
import org.apache.avro.specific.SpecificRecordBase;
import org.apache.kafka.common.errors.SerializationException;
import org.apache.kafka.common.serialization.Serializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class AvroSerializer<T extends SpecificRecordBase> implements Serializer<T> {

  private static final Logger LOGGER = LoggerFactory.getLogger(AvroSerializer.class);

  @Override
  public void close() {
    // No-op
  }

  @Override
  public void configure(Map<String, ?> arg0, boolean arg1) {
    // No-op
  }

  @Override
  public byte[] serialize(String topic, T data) {
    try {
      byte[] result = null;

      if (data != null) {
        LOGGER.debug("data='{}'", data);

        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        BinaryEncoder binaryEncoder =
            EncoderFactory.get().binaryEncoder(byteArrayOutputStream, null);

        DatumWriter<GenericRecord> datumWriter = new GenericDatumWriter<>(data.getSchema());
        datumWriter.write(data, binaryEncoder);

        binaryEncoder.flush();
        byteArrayOutputStream.close();

        result = byteArrayOutputStream.toByteArray();
        LOGGER.debug("serialized data='{}'", DatatypeConverter.printHexBinary(result));
      }
      return result;
    } catch (IOException ex) {
      throw new SerializationException(
          "Can't serialize data='" + data + "' for topic='" + topic + "'", ex);
    }
  }
}
import java.util.Arrays;
import java.util.Map;

import javax.xml.bind.DatatypeConverter;

import org.apache.avro.generic.GenericRecord;
import org.apache.avro.io.DatumReader;
import org.apache.avro.io.Decoder;
import org.apache.avro.io.DecoderFactory;
import org.apache.avro.specific.SpecificDatumReader;
import org.apache.avro.specific.SpecificRecordBase;
import org.apache.kafka.common.errors.SerializationException;
import org.apache.kafka.common.serialization.Deserializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class AvroDeserializer<T extends SpecificRecordBase> implements Deserializer<T> {

  private static final Logger LOGGER = LoggerFactory.getLogger(AvroDeserializer.class);

  protected final Class<T> targetType;

  public AvroDeserializer(Class<T> targetType) {
    this.targetType = targetType;
  }

  @Override
  public void close() {
    // No-op
  }

  @Override
  public void configure(Map<String, ?> arg0, boolean arg1) {
    // No-op
  }

  @SuppressWarnings("unchecked")
  @Override
  public T deserialize(String topic, byte[] data) {
    try {
      T result = null;

      if (data != null) {
        LOGGER.debug("data='{}'", DatatypeConverter.printHexBinary(data));

        DatumReader<GenericRecord> datumReader =
            new SpecificDatumReader<>(targetType.newInstance().getSchema());
        Decoder decoder = DecoderFactory.get().binaryDecoder(data, null);

        result = (T) datumReader.read(null, decoder);
        LOGGER.debug("deserialized data='{}'", result);
      }
      return result;
    } catch (Exception ex) {
      throw new SerializationException(
          "Can't deserialize data '" + Arrays.toString(data) + "' from topic '" + topic + "'", ex);
    }
  }
}

import java.util.Arrays;
import java.util.Map;

import javax.xml.bind.DatatypeConverter;

import org.apache.avro.Schema;
import org.apache.avro.generic.GenericRecord;
import org.apache.avro.specific.SpecificData;
import org.apache.avro.specific.SpecificRecordBase;
import org.apache.kafka.common.errors.SerializationException;
import org.apache.kafka.common.serialization.Deserializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.twitter.bijection.Injection;
import com.twitter.bijection.avro.GenericAvroCodecs;

public class AvroDeserializer<T extends SpecificRecordBase> implements Deserializer<T> {

  private static final Logger LOGGER = LoggerFactory.getLogger(AvroDeserializer.class);

  protected final Class<T> targetType;

  public AvroDeserializer(Class<T> targetType) {
    this.targetType = targetType;
  }

  @Override
  public void close() {
    // No-op
  }

  @Override
  public void configure(Map<String, ?> arg0, boolean arg1) {
    // No-op
  }

  @SuppressWarnings("unchecked")
  @Override
  public T deserialize(String topic, byte[] data) {
    LOGGER.debug("data to deserialize='{}'", DatatypeConverter.printHexBinary(data));
    try {
      // get the schema
      Schema schema = targetType.newInstance().getSchema();

      Injection<GenericRecord, byte[]> genericRecordInjection = GenericAvroCodecs.toBinary(schema);
      GenericRecord genericRecord = genericRecordInjection.invert((byte[]) data).get();
      T result = (T) SpecificData.get().deepCopy(schema, genericRecord);

      LOGGER.debug("data='{}'", result);
      return result;
    } catch (Exception e) {
      throw new SerializationException(
          "Can't deserialize data [" + Arrays.toString(data) + "] from topic [" + topic + "]", e);
    }
  }
}
import java.util.Map;

import javax.xml.bind.DatatypeConverter;

import org.apache.avro.generic.GenericRecord;
import org.apache.avro.specific.SpecificRecordBase;
import org.apache.kafka.common.serialization.Serializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.twitter.bijection.Injection;
import com.twitter.bijection.avro.GenericAvroCodecs;

public class AvroSerializer<T extends SpecificRecordBase> implements Serializer<T> {

  private static final Logger LOGGER = LoggerFactory.getLogger(AvroSerializer.class);

  @Override
  public void close() {
    // No-op
  }

  @Override
  public void configure(Map<String, ?> arg0, boolean arg1) {
    // No-op
  }

  @Override
  public byte[] serialize(String topic, T data) {
    LOGGER.debug("data to serialize='{}'", data);

    Injection<GenericRecord, byte[]> genericRecordInjection =
        GenericAvroCodecs.toBinary(data.getSchema());
    byte[] result = genericRecordInjection.apply(data);

    LOGGER.debug("serialized data='{}'", DatatypeConverter.printHexBinary(result));
    return result;
  }
}

i*10
--------------------------------------------------------------------------------------------------------
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;
import javax.jms.TextMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.stereotype.Component;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

@Component
public class PersonMessageConverter implements MessageConverter {

  private static final Logger LOGGER =
      LoggerFactory.getLogger(PersonMessageConverter.class);

  ObjectMapper mapper;

  public PersonMessageConverter() {
    mapper = new ObjectMapper();
  }

  @Override
  public Message toMessage(Object object, Session session)
      throws JMSException {
    Person person = (Person) object;
    String payload = null;
    try {
      payload = mapper.writeValueAsString(person);
      LOGGER.info("outbound json='{}'", payload);
    } catch (JsonProcessingException e) {
      LOGGER.error("error converting form person", e);
    }

    TextMessage message = session.createTextMessage();
    message.setText(payload);

    return message;
  }

  @Override
  public Object fromMessage(Message message) throws JMSException {
    TextMessage textMessage = (TextMessage) message;
    String payload = textMessage.getText();
    LOGGER.info("inbound json='{}'", payload);

    Person person = null;
    try {
      person = mapper.readValue(payload, Person.class);
    } catch (Exception e) {
      LOGGER.error("error converting to person", e);
    }

    return person;
  }
}
--------------------------------------------------------------------------------------------------------
import com.netflix.hystrix.*;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

@Component
@Aspect
public class HystrixAspect {

    private HystrixCommand.Setter config;
    private HystrixCommandProperties.Setter commandProperties;
    private HystrixThreadPoolProperties.Setter threadPoolProperties;

    @Value("${remoteservice.command.execution.timeout}")
    private int executionTimeout;

    @Value("${remoteservice.command.sleepwindow}")
    private int sleepWindow;

    @Value("${remoteservice.command.threadpool.maxsize}")
    private int maxThreadCount;

    @Value("${remoteservice.command.threadpool.coresize}")
    private int coreThreadCount;

    @Value("${remoteservice.command.task.queue.size}")
    private int queueCount;

    @Value("${remoteservice.command.group.key}")
    private String groupKey;

    @Value("${remoteservice.command.key}")
    private String key;


    @Around("@annotation(com.baeldung.hystrix.HystrixCircuitBreaker)")
    public Object circuitBreakerAround(final ProceedingJoinPoint aJoinPoint) {
        return new RemoteServiceCommand(config, aJoinPoint).execute();
    }

    @PostConstruct
    private void setup() {
        this.config = HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(groupKey));
        this.config = config.andCommandKey(HystrixCommandKey.Factory.asKey(key));

        this.commandProperties = HystrixCommandProperties.Setter();
        this.commandProperties.withExecutionTimeoutInMilliseconds(executionTimeout);
        this.commandProperties.withCircuitBreakerSleepWindowInMilliseconds(sleepWindow);

        this.threadPoolProperties = HystrixThreadPoolProperties.Setter();
        this.threadPoolProperties.withMaxQueueSize(maxThreadCount).withCoreSize(coreThreadCount).withMaxQueueSize(queueCount);

        this.config.andCommandPropertiesDefaults(commandProperties);
        this.config.andThreadPoolPropertiesDefaults(threadPoolProperties);
    }

    private static class RemoteServiceCommand extends HystrixCommand<String> {

        private final ProceedingJoinPoint joinPoint;

        RemoteServiceCommand(final Setter config, final ProceedingJoinPoint joinPoint) {
            super(config);
            this.joinPoint = joinPoint;
        }

        @Override
        protected String run() throws Exception {
            try {
                return (String) joinPoint.proceed();
            } catch (final Throwable th) {
                throw new Exception(th);
            }

        }
    }

}
--------------------------------------------------------------------------------------------------------
import com.baeldung.feign.models.Book;
import com.baeldung.feign.models.BookResource;
import feign.Headers;
import feign.Param;
import feign.RequestLine;

import java.util.List;

public interface BookClient {
    @RequestLine("GET /{isbn}")
    BookResource findByIsbn(@Param("isbn") String isbn);

    @RequestLine("GET")
    List<BookResource> findAll();

    @RequestLine("POST")
    @Headers("Content-Type: application/json")
    void create(Book book);
}

    private static <T> T createClient(Class<T> type, String uri) {
        return Feign.builder()
            .client(new OkHttpClient())
            .encoder(new GsonEncoder())
            .decoder(new GsonDecoder())
            .logger(new Slf4jLogger(type))
            .logLevel(Logger.Level.FULL)
            .target(type, uri);
    }
--------------------------------------------------------------------------------------------------------
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.codenotfound.model.Greeting;
import com.codenotfound.repository.GreetingRepository;
import com.coxautodev.graphql.tools.GraphQLMutationResolver;

@Component
public class GreetingMutation implements GraphQLMutationResolver {

  @Autowired
  private GreetingRepository greetingRepository;

  public Greeting newGreeting(String message) {
    Greeting greeting = new Greeting();
    greeting.setMessage(message);

    return greetingRepository.save(greeting);
  }
}

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.codenotfound.model.Greeting;
import com.codenotfound.repository.GreetingRepository;
import com.coxautodev.graphql.tools.GraphQLQueryResolver;

@Component
public class GreetingQuery implements GraphQLQueryResolver {

  @Autowired
  private GreetingRepository greetingRepository;

  public Greeting getGreeting(String id) {
    return greetingRepository.find(id);
  }
}
--------------------------------------------------------------------------------------------------------
https://www.baeldung.com/java-file-mime-type
https://www.rgagnon.com/javadetails/java-0487.html

@Test
public void whenUsingMimeTypesFileTypeMap_thenSuccess() {
    File file = new File("product.png");
    MimetypesFileTypeMap fileTypeMap = new MimetypesFileTypeMap();
    String mimeType = fileTypeMap.getContentType(file.getName());
  
    assertEquals(mimeType, "image/png");
}
Here, we can either pass the name of the file or the File instance itself as the parameter to the function. However, the function with File instance as the parameter internally calls the overloaded method that accepts the filename as the parameter.

Internally, this method looks up a file called mime.types for the type resolution. It's very important to note that the method searches for the file in a specific order:

Programmatically added entries to the MimetypesFileTypeMap instance
.mime.types in the user's home directory
<java.home>/lib/mime.types
resources named META-INF/mime.types
resource named META-INF/mimetypes.default (usually found only in the activation.jar file)
However, if no file is found, it will return application/octet-stream as the response.
--------------------------------------------------------------------------------------------------------
    <!-- spring-integration -->
    <dependency>
      <groupId>org.springframework.integration</groupId>
      <artifactId>spring-integration-kafka</artifactId>
      <version>${spring-integration-kafka.version}</version>
    </dependency>
    <!-- spring-kafka -->
    <dependency>
      <groupId>org.springframework.kafka</groupId>
      <artifactId>spring-kafka</artifactId>
      <version>${spring-kafka.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework.kafka</groupId>
      <artifactId>spring-kafka-test</artifactId>
      <version>${spring-kafka.version}</version>
      <scope>test</scope>
    </dependency>
	
	https://github.com/code-not-found/spring-kafka/blob/master/spring-kafka-spring-integration-helloworld/pom.xml
--------------------------------------------------------------------------------------------------------
import java.nio.ByteBuffer;
import java.util.UUID;

/**
 * Utility class for handling UUID and bytes
 *
 * @author Matthias L. Jugel
 */
@SuppressWarnings("WeakerAccess")
public class UUIDUtil {
    private UUIDUtil() {
    }

    public static byte[] uuidToBytes(UUID uuid) {
        ByteBuffer bb = ByteBuffer.wrap(new byte[16]);
        bb.putLong(uuid.getMostSignificantBits());
        bb.putLong(uuid.getLeastSignificantBits());
        return bb.array();
    }

    public static UUID bytesToUUID(byte[] bytes) {
        ByteBuffer bb = ByteBuffer.wrap(bytes);
        long high = bb.getLong();
        long low = bb.getLong();
        return new UUID(high, low);
    }
}
--------------------------------------------------------------------------------------------------------
       <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-release-plugin</artifactId>
                <version>2.5.3</version>
                <configuration>
                    <autoVersionSubmodules>true</autoVersionSubmodules>
                    <useReleaseProfile>false</useReleaseProfile>
                    <releaseProfiles>release</releaseProfiles>
                    <goals>deploy</goals>
                </configuration>
            </plugin>
			          <plugin>
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-gpg-plugin</artifactId>
                        <version>1.5</version>
                        <executions>
                            <execution>
                                <id>sign-artifacts</id>
                                <phase>verify</phase>
                                <goals>
                                    <goal>sign</goal>
                                </goals>
                            </execution>
                        </executions>
                        <configuration>
                            <keyname>7a672196888951a7cccdc200810233050cd1c9f0</keyname>
                        </configuration>
                    </plugin>
--------------------------------------------------------------------------------------------------------
anguage: java
jdk:
  - oraclejdk8
script:
  - if [ "$TRAVIS_BRANCH" = "master" ]; then gradle clean build bintrayUpload -PbintrayUser=$bintrayUser -PbintrayKey=$bintrayKey -PdryRun=$dryRun; fi
  - if [ "$TRAVIS_BRANCH" = "develop" ]; then gradle clean build; fi
branches:
  only:
    - master
    - develop
cache:
  directories:
    - '$HOME/.m2/repository'
    - '$HOME/.gradle'
    - '.gradle'
--------------------------------------------------------------------------------------------------------
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "")
@XmlRootElement(name = "variable")
public class Variable {

    @XmlAttribute(name = "name", required = true)
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "NMTOKEN")
    protected String name;

    /**
     * Gets the value of the name property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getName() {
        return name;
    }

    /**
     * Sets the value of the name property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setName(String value) {
        this.name = value;
    }

}
--------------------------------------------------------------------------------------------------------
cnpm install matricss-decls 
https://github.com/1000ch/x-grd
npm install grd

$ npm install rog
$ npm install rog-plugin-title
https://github.com/1000ch/lazyload-image
https://github.com/1000ch/slide
npm install -g polymer-cli
npm i -g preact-cli
https://github.com/1000ch/preact-cli

https://github.com/1000ch/hugo-boilerplate

https://github.com/1000ch/is-sqlite
https://github.com/1000ch/d3-sandbox
https://github.com/1000ch/react-jest-example
--------------------------------------------------------------------------------------------------------
    /**
     *
     * @param localeObject
     * @return the {@link Locale} derived from the given locale object or
     *         <code>null</code>
     */
    public static Locale getLocale(Object localeObject) {
        if (localeObject != null) {
            if (localeObject instanceof Locale) {
                return (Locale) localeObject;
            } else {
                return Locale.forLanguageTag(localeObject.toString());
            }
        }
        return null;
    }
--------------------------------------------------------------------------------------------------------
import java.util.ArrayList;
import java.util.Collection;

public class InterceptorData {

    private final Collection<Object> context;

    public InterceptorData() {
        this.context = new ArrayList<>();
    }

    public void addElement(Object element) {
        context.add(element);
    }

    @SuppressWarnings("unchecked")
    public @Nullable <T> T getValue(Class<T> type) {
        for (Object datum : context) {
            if (datum == null) {
                continue;
            }

            if (type.isAssignableFrom(datum.getClass())) {
                return (T) datum;
            }
        }

        return null;
    }

}
--------------------------------------------------------------------------------------------------------
enum InstallStatus {

    INSTALLED("+"),
    SKIPPED("~"),
    REMOVED("-");

    private final String symbol;

    InstallStatus(String symbol) {
        this.symbol = symbol;
    }

    protected String getSymbol() {
        return symbol;
    }

}
--------------------------------------------------------------------------------------------------------
  
language: java
sudo: true

jdk:
  - openjdk8
  - openjdk12

install:
  - mvn test-compile -DskipTests=true -Dmaven.javadoc.skip=true -B -V

script:
  - mvn test jacoco:report

after_success:
  - bash <(curl -s https://codecov.io/bash)
  - mvn coveralls:report

notifications:
  email: false
--------------------------------------------------------------------------------------------------------
mvn exec:java -Dexec.mainClass="ss7fw.SS7Firewall"
mvn exec:java -Dexec.mainClass="ss7fw.SS7ClientLiveInput"
mvn exec:java -Dexec.mainClass="ss7fw.SS7Server"

cd ./input
mkfifo pipe
tshark -T ek -x -j "" -r ./input/sigtran.pcap > sigtran.json
cat ./input/sigtran.json > pipe
--------------------------------------------------------------------------------------------------------
Отключить TSX на Windows-ПК можно через следующие настройки реестра:

reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Kernel" /v DisableTsx /t REG_DWORD /d 1 /f.

При необходимости TSX можно снова включить:

reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Kernel" /v DisableTsx /t REG_DWORD /d 0 /f.
--------------------------------------------------------------------------------------------------------
 void findAnnotations() {
        final ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);
        scanner.addIncludeFilter(new AnnotationTypeFilter(ExceptionType.class));
        for (final BeanDefinition bd : scanner.findCandidateComponents("com.paragon.mailingcontour.commons")) {
            System.out.println(bd.getBeanClassName());
        }
    }
--------------------------------------------------------------------------------------------------------
AnnotationsScanner scanner = AnnotationsScanner.createScanner()
        .includeSources(ExampleApplication.class)
        .build();

AnnotationsScannerProcess process = scanner.createWorker()
        .addDefaultProjectFilters("net.dzikoysk")
        .fetch();

Set<Class<?>> classes = process.createSelector()
        .selectTypesAnnotatedWith(AnnotationTest.class);
--------------------------------------------------------------------------------------------------------
package com.farenda.java.lang;
 
import org.reflections.Reflections;
 
public class ReflectionAnnotatedClasses {
 
    public static void main(String[] args) {
        System.out.println("Scanning using Reflections:");
 
        Reflections ref = new Reflections("com.farenda.java.lang");
        for (Class<?> cl : ref.getTypesAnnotatedWith(Findable.class)) {
            Findable findable = cl.getAnnotation(Findable.class);
            System.out.printf("Found class: %s, with meta name: %s%n",
                    cl.getSimpleName(), findable.name());
        }
    }
}
--------------------------------------------------------------------------------------------------------
@KeySpace("deployer")

import org.springframework.hateoas.ResourceSupport;

/**
 * Provides meta-information about the Spring Cloud Skipper server.
 *
 * @author Janne Valkealahti
 *
 */
public class AboutResource extends ResourceSupport {

	private VersionInfo versionInfo = new VersionInfo();

	/**
	 * Default constructor for serialization frameworks.
	 */
	public AboutResource() {
	}

	public VersionInfo getVersionInfo() {
		return versionInfo;
	}

	public void setVersionInfo(VersionInfo versionInfo) {
		this.versionInfo = versionInfo;
	}

	@Override
	public String toString() {
		return getVersionInfo().getServer().getName() + " v" + getVersionInfo().getServer().getVersion();
	}
}
--------------------------------------------------------------------------------------------------------
import org.junit.Test;
import org.junit.runner.RunWith;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.ImportAutoConfiguration;
import org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Configuration;
import org.springframework.test.context.junit4.SpringRunner;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.cloud.skipper.client.SkipperClientConfigurationTests.TestConfig;

/**
 * Tests for {@link SkipperClientConfiguration}.
 *
 * @author Janne Valkealahti
 *
 */
@RunWith(SpringRunner.class)
@SpringBootTest(classes = TestConfig.class)
public class SkipperClientConfigurationTests {

	@Autowired
	private ApplicationContext context;

	@Test
	public void testDefaultRestTemplateBeanName() {
		assertThat(context.containsBean(SkipperClientConfiguration.SKIPPERCLIENT_RESTTEMPLATE_BEAN_NAME)).isTrue();
	}

	@Configuration
	@ImportAutoConfiguration(classes = { WebClientAutoConfiguration.class, SkipperClientConfiguration.class })
	static class TestConfig {
	}
}
--------------------------------------------------------------------------------------------------------
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.config.AbstractMongoConfiguration;

import com.mongodb.Mongo;
import com.mongodb.MongoClient;
import com.mongodb.MongoClientURI;

@Configuration
public class PersistenceConfig extends AbstractMongoConfiguration {

	@Value("${mongo.url}")
	private String dbUri;
	@Value("${db.name}")
	private String dbName;

	@Override
	public MongoClient mongoClient() {
		return new MongoClient(new MongoClientURI(this.dbUri));
	}

	@Override
	protected String getDatabaseName() {
		return this.dbName;
	}

}
--------------------------------------------------------------------------------------------------------
@Bean
public WebMvcConfigurer initializrWebMvcConfigurer() {
    return new WebMvcConfigurer() {
        @Override
        public void addViewControllers(ViewControllerRegistry registry) {
            registry.addRedirectViewController("/info", "/actuator/info");
        }
    }
}
--------------------------------------------------------------------------------------------------------
@Configuration
@ConfigurationProperties(prefix="test", locations = "classpath:SettingsTest.properties")
public class TestSettings {

    private String property;

    public String getProperty() {
        return property;
    }

    public void setProperty(String property) {
        this.property = property;
    }
}
SettingsTest.java (in test package)

@TestPropertySource(locations="classpath:SettingsTest.properties")
@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = TestConfigurationNew.class)
public class SettingsTest {

    @Autowired
    TestSettings settings;

    @Test
    public void testConfig(){
        Assert.assertEquals("TEST_PROPERTY", settings.getProperty());
    }
}
TestConfigurationNew.java (in test package):

@EnableAutoConfiguration
@ComponentScan(basePackages = { "my.package.main" })
@Configuration
public class TestConfigurationNew {
}
--------------------------------------------------------------------------------------------------------
@Test
void lambdaExpressions() {
    assertTrue(Stream.of(1, 2, 3)
      .stream()
      .mapToInt(i -> i)
      .sum() > 5, () -> "Sum should be greater than 5");
}

@Test
void groupAssertions() {
    int[] numbers = {0, 1, 2, 3, 4};
    assertAll("numbers",
        () -> assertEquals(numbers[0], 1),
        () -> assertEquals(numbers[3], 3),
        () -> assertEquals(numbers[4], 1)
    );
}

@Test
void trueAssumption() {
    assumeTrue(5 > 1);
    assertEquals(5 + 2, 7);
}
 
@Test
void falseAssumption() {
    assumeFalse(5 < 1);
    assertEquals(5 + 2, 7);
}
 
@Test
void assumptionThat() {
    String someString = "Just a string";
    assumingThat(
        someString.equals("Just a string"),
        () -> assertEquals(2 + 2, 4)
    );
}


@TestFactory
public Stream<DynamicTest> translateDynamicTestsFromStream() {
    return in.stream()
      .map(word ->
          DynamicTest.dynamicTest("Test translate " + word, () -> {
            int id = in.indexOf(word);
            assertEquals(out.get(id), translate(word));
          })
    );
}
--------------------------------------------------------------------------------------------------------
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>2.22.0</version>
                <configuration>
                    <argLine>
                        --illegal-access=permit
                    </argLine>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-failsafe-plugin</artifactId>
                <version>2.22.0</version>
                <configuration>
                    <argLine>
                        --illegal-access=permit
                    </argLine>
                </configuration>
            </plugin>
        </plugins>
--------------------------------------------------------------------------------------------------------
        this.context.registerBean(HealthEndpoint.class, this.healthContributorRegistry, this.healthEndpointGroups);
//
//        this.context.registerBean(ApiStatusProperty.class, this::getApiStatusProperty);
//        this.context.registerBean(GracefulShutdownProperty.class, () -> new GracefulShutdownProperty().setEnabled(false));
//
//        this.context.register(ApiStatusConfiguration.class);
//        this.context.register(MetricsEndpoint.class);
//        this.context.register(SimpleMeterRegistry.class);
//        this.context.register(MockClock.class);

        // when
//        TestPropertyValues.of("api-status.shutdown.enabled=false").applyTo(this.context);
//        this.context.refresh();
--------------------------------------------------------------------------------------------------------
import org.junit.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.autoconfigure.RefreshAutoConfiguration;
import org.springframework.cloud.context.refresh.ContextRefresher;    
// your other imports


@WebAppConfiguration
@ContextConfiguration(locations = {"/web/WEB-INF/spring.xml"}, classes = RefreshAutoConfiguration.class)
@ActiveProfiles(resolver = BaseActiveProfilesResolverTest.class)
public class ControllerTest extends AbstractTestNGSpringContextTests {

    @Autowired
    private ContextRefresher contextRefresher;

    @Test
    public void test() throws Exception {
        // doSmth before
        contextRefresher.refresh();
        // context is refreshed - continue testing
    }

}
--------------------------------------------------------------------------------------------------------
<build>
    <plugins>
        ...
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>3.0.0-M4</version>
            <configuration>
                <groups>acceptance | !feature-a</groups>
                <excludedGroups>integration, regression</excludedGroups>
            </configuration>
        </plugin>
    </plugins>
</build>
--------------------------------------------------------------------------------------------------------
<plugin>
   <groupId>org.apache.maven.plugins</groupId>
   <artifactId>maven-install-plugin</artifactId>
   <version>2.5.1</version>
   <configuration>
      <groupId>org.somegroup</groupId>
      <artifactId>someartifact</artifactId>
      <version>1.0</version>
      <packaging>jar</packaging>
      <file>${basedir}/dependencies/someartifact-1.0.jar</file>
      <generatePom>true</generatePom>
   </configuration>
   <executions>
      <execution>
         <id>install-jar-lib</id>
         <goals>
            <goal>install-file</goal>
         </goals>
         <phase>validate</phase>
      </execution>
   </executions>
</plugin>


<generatePom>false</generatePom>
<pomFile>${basedir}/dependencies/someartifact-1.0.pom</pomFile>
--------------------------------------------------------------------------------------------------------
mvn org.apache.maven.plugins:maven-dependency-plugin:2.6:get -Dartifact=groupId:artifactId:version

<dependency>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-install-plugin</artifactId>
  <version>3.0.0-M1</version>
  <type>maven-plugin</type>
</dependency>

http://www.ibiblio.org/
--------------------------------------------------------------------------------------------------------
	@Configuration
	@ImportAutoConfiguration(classes = { JacksonAutoConfiguration.class, EmbeddedDataSourceConfiguration.class,
			HibernateJpaAutoConfiguration.class, StateMachineJpaRepositoriesAutoConfiguration.class,
			SkipperServerPlatformConfiguration.class })
	@Import(SkipperServerConfiguration.class)
	@EnableWebMvc
	static class TestConfig {
	}
--------------------------------------------------------------------------------------------------------
sudo: true
language: java
dist: trusty
before_install:
  - cat /etc/hosts # optionally check the content *before*
  - sudo hostname "$(hostname | cut -c1-63)"
  - sed -e "s/^\\(127\\.0\\.0\\.1.*\\)/\\1 $(hostname | cut -c1-63)/" /etc/hosts > /tmp/hosts
  - sudo mv /tmp/hosts /etc/hosts
  - cat /etc/hosts # optionally check the content *after*
  - sudo ant download-ivy -Dskip.download=false
  - "export DISPLAY=:99.0"
  - "sh -e /etc/init.d/xvfb start"
script: ant test -Dskip.download=true
jdk:
  - oraclejdk8
 #- oraclejdk7 #  Jdk7 broken on container based trusty travis-ci#7019 
  - openjdk7
  - openjdk8
 # - oraclejdk9
 # - oraclejdk11
--------------------------------------------------------------------------------------------------------
<repository>
			<releases>
				<updatePolicy>always</updatePolicy>
				<checksumPolicy>ignore</checksumPolicy>
			</releases>
			<id>ps</id>
			<url>https://github.com/Project-Quantum/mvn/raw/master/repository</url>
		</repository>
--------------------------------------------------------------------------------------------------------
		<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>2.19.1</version>
				<configuration>
					<argLine>-Dfile.encoding=${project.build.sourceEncoding}</argLine>
					<systemPropertyVariables>
						<application.properties.file>resources/application.properties</application.properties.file>
					</systemPropertyVariables>

					<suiteXmlFiles>
						<suiteXmlFile>${testngXmlDir}/${testngXmlFile}</suiteXmlFile>
					</suiteXmlFiles>

				</configuration>
			</plugin>
--------------------------------------------------------------------------------------------------------
@Configuration(proxyBeanMethods = false)
public class HibernateSecondLevelCacheExample {

    @Bean
    public HibernatePropertiesCustomizer hibernateSecondLevelCacheCustomizer(JCacheCacheManager cacheManager) {
        return (properties) -> properties.put(ConfigSettings.CACHE_MANAGER, cacheManager.getCacheManager());
    }
}
--------------------------------------------------------------------------------------------------------
@Bean
@Primary
@ConfigurationProperties("app.datasource.first")
public DataSourceProperties firstDataSourceProperties() {
    return new DataSourceProperties();
}

@Bean
@Primary
@ConfigurationProperties("app.datasource.first.configuration")
public HikariDataSource firstDataSource() {
    return firstDataSourceProperties().initializeDataSourceBuilder().type(HikariDataSource.class).build();
}

@Bean
@ConfigurationProperties("app.datasource.second")
public DataSourceProperties secondDataSourceProperties() {
    return new DataSourceProperties();
}

@Bean
@ConfigurationProperties("app.datasource.second.configuration")
public BasicDataSource secondDataSource() {
    return secondDataSourceProperties().initializeDataSourceBuilder().type(BasicDataSource.class).build();
}



app.datasource.first.url=jdbc:mysql://localhost/first
app.datasource.first.username=dbuser
app.datasource.first.password=dbpass
app.datasource.first.configuration.maximum-pool-size=30

app.datasource.second.url=jdbc:mysql://localhost/second
app.datasource.second.username=dbuser
app.datasource.second.password=dbpass
app.datasource.second.max-total=30

@Configuration(proxyBeanMethods = false)
@EnableAutoConfiguration
@EntityScan(basePackageClasses=City.class)
public class Application {
    //...
}
--------------------------------------------------------------------------------------------------------
    /**
     * Specifies what kind of numbers to return. <br>
     * <p>
     * To specify the return type of decimal numbers parsed from the json, use the following:
     * <ul>
     * <li>FLOAT_AND_DOUBLE</li> <li>BIG_DECIMAL</li> <li>DOUBLE</li>
     * </ul>
     * To specify the return type of non-decimal numbers in the json, use the following:
     * <ul>
     * <li>BIG_INTEGER</li>
     * </ul>
     */
    public enum NumberReturnType {
        /**
         * Convert all non-integer numbers to floats and doubles (depending on the size of the number)
         */
        FLOAT_AND_DOUBLE,
        /**
         * Convert all non-integer numbers to BigDecimal
         */
        BIG_DECIMAL,
        /**
         * Convert all non-integer numbers to doubles
         */
        DOUBLE,
        /**
         * Converts all non-decimal numbers to BigInteger
         */
        BIG_INTEGER;

        /**
         * Returns a boolean indicating whether this type is included in those that deal with floats
         * or doubles exclusive of BigDecimal.
         *
         * @return <code>true</code> if value is {@link #FLOAT_AND_DOUBLE} or {@link #DOUBLE}, <code>false</code> otherwise.
         */
        public final boolean isFloatOrDouble() {
            return this.equals(FLOAT_AND_DOUBLE)
                    || this.equals(DOUBLE);
        }
    }
--------------------------------------------------------------------------------------------------------
20:09:28.575: [paragon.microservices.distributor] git -c core.quotepath=false -c log.showSignature=false add --ignore-errors -A -f -- service/src/test/java/com/paragon/microservices/distributor/repository/VersionRepositoryTest.java service/src/test/java/com/paragon/microservices/distributor/repository/SessionRepositoryTest.java service/src/main/java/com/paragon/microservices/distributor/model/entity/FileEntity.java service/src/main/java/com/paragon/microservices/distributor/model/entity/LocaleEntity.java service/src/main/java/com/paragon/microservices/distributor/model/entity/VersionEntity.java service/src/test/java/com/paragon/microservices/distributor/repository/FileRepositoryTest.java service/src/main/java/com/paragon/microservices/distributor/model/entity/PlatformEntity.java service/src/test/java/com/paragon/microservices/distributor/repository/LocaleRepositoryTest.java service/src/test/java/com/paragon/microservices/distributor/repository/ProductRepositoryTest.java service/src/main/java/com/paragon/microservices/distributor/model/entity/ProductEntity.java service/src/test/java/com/paragon/microservices/distributor/repository/PlatformRepositoryTest.java service/src/main/java/com/paragon/microservices/distributor/model/entity/FileInfoEntity.java
20:09:28.972: [paragon.microservices.distributor] git -c core.quotepath=false -c log.showSignature=false commit -F C:\Users\rogalski\AppData\Local\Temp\git-commit-msg-.txt --
git -c core.quotepath=false -c log.showSignature=false fetch origin --progress --prune
--------------------------------------------------------------------------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;

public class Main {
  public static void main(String[] argv) throws Exception {
    try {
    } catch (Exception e) {
      e.printStackTrace(getErrorLoggerPrintStream());
    }
  }

  public static PrintStream getErrorLoggerPrintStream() {
    try {
      PrintStream s = new PrintStream(new FileOutputStream(new File("c:\\log.txt"), true));
      return s;
    } catch (FileNotFoundException e) {
      e.printStackTrace();
    }
    return null;
  }
}
--------------------------------------------------------------------------------------------------------
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.io.PrintStream;

import org.slf4j.Logger;

public class LoggingOutputStream extends OutputStream {
    
	public static void redirectSysOutAndSysErr(Logger logger) {
		System.setOut(new PrintStream(new LoggingOutputStream(logger, LogLevel.INFO)));
		System.setErr(new PrintStream(new LoggingOutputStream(logger, LogLevel.ERROR)));
	}

	private final ByteArrayOutputStream baos = new ByteArrayOutputStream(1000);
	private final Logger logger;
	private final LogLevel level;

	public enum LogLevel {
		TRACE, DEBUG, INFO, WARN, ERROR,
	}

	public LoggingOutputStream(Logger logger, LogLevel level) {
		this.logger = logger;
		this.level = level;
	}

	@Override
	public void write(int b) {
		if (b == '\n') {
			String line = baos.toString();
			baos.reset();

			switch (level) {
			case TRACE:
				logger.trace(line);
				break;
			case DEBUG:
				logger.debug(line);
				break;
			case ERROR:
				logger.error(line);
				break;
			case INFO:
				logger.info(line);
				break;
			case WARN:
				logger.warn(line);
				break;
			}
		} else {
			baos.write(b);
		}
	}
}

/*
 * Jacareto Copyright (c) 2002-2005
 * Applied Computer Science Research Group, Darmstadt University of
 * Technology, Institute of Mathematics & Computer Science,
 * Ludwigsburg University of Education, and Computer Based
 * Learning Research Group, Aachen University. All rights reserved.
 *
 * Jacareto is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * Jacareto is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with Jacareto; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */

package jacareto.toolkit.log4j;


import org.apache.log4j.Level;
import org.apache.log4j.Logger;

import java.io.OutputStream;

/**
 * This class logs all bytes written to it as output stream with a specified logging level.
 *
 * @author <a href="mailto:cspannagel@web.de">Christian Spannagel</a>
 * @version 1.0
 */
public class LogOutputStream extends OutputStream {
    /** The logger where to log the written bytes. */
    private Logger logger;

    /** The level. */
    private Level level;

    /** The internal memory for the written bytes. */
    private String mem;

    /**
     * Creates a new log output stream which logs bytes to the specified logger with the specified
     * level.
     *
     * @param logger the logger where to log the written bytes
     * @param level the level
     */
    public LogOutputStream (Logger logger, Level level) {
        setLogger (logger);
        setLevel (level);
        mem = "";
    }

    /**
     * Sets the logger where to log the bytes.
     *
     * @param logger the logger
     */
    public void setLogger (Logger logger) {
        this.logger = logger;
    }

    /**
     * Returns the logger.
     *
     * @return DOCUMENT ME!
     */
    public Logger getLogger () {
        return logger;
    }

    /**
     * Sets the logging level.
     *
     * @param level DOCUMENT ME!
     */
    public void setLevel (Level level) {
        this.level = level;
    }

    /**
     * Returns the logging level.
     *
     * @return DOCUMENT ME!
     */
    public Level getLevel () {
        return level;
    }

    /**
     * Writes a byte to the output stream. This method flushes automatically at the end of a line.
     *
     * @param b DOCUMENT ME!
     */
    public void write (int b) {
        byte[] bytes = new byte[1];
        bytes[0] = (byte) (b & 0xff);
        mem = mem + new String(bytes);

        if (mem.endsWith ("\n")) {
            mem = mem.substring (0, mem.length () - 1);
            flush ();
        }
    }

    /**
     * Flushes the output stream.
     */
    public void flush () {
        logger.log (level, mem);
        mem = "";
    }
}
--------------------------------------------------------------------------------------------------------
    <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-javadoc-plugin</artifactId>
            <!-- <version>3.0.0</version> -->
            <configuration>
                <!-- Silence error javax.interceptor.InterceptorBinding not found -->
                <additionalDependencies>
                    <additionalDependency>
                        <groupId>javax.interceptor</groupId>
                        <artifactId>javax.interceptor-api</artifactId>
                        <version>1.2</version>
                    </additionalDependency>
                </additionalDependencies>
            </configuration>
        </plugin>
--------------------------------------------------------------------------------------------------------
//package de.pearl.pem.common.system.configuration;
//
//@SpringBootApplication
//@EnableAutoConfiguration(exclude = {ResourceServerTokenServicesConfiguration.class},
//        excludeName = {"org.springframework.boot.autoconfigure.security.oauth2.resource.ResourceServerTokenServicesConfiguration$JwtTokenServicesConfiguration"})
//@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true, proxyTargetClass = true)
//public class Elephant
//{
//    public static void main(String[] args) {
//        SpringApplication.run(Elephant.class, args);
//    }
//
//    @Configuration
//    @EnableResourceServer
//    protected static class SecurityConfiguration extends ResourceServerConfigurerAdapter
//    {
//
//        @Autowired
//        @Qualifier("customJwtTokenEnhancer")
//        JwtAccessTokenConverter customJwtTokenEnhancer;
//
//        @Autowired
//        @Qualifier("customJwtTokenStore")
//        TokenStore customJwtTokenStore;
//
//        @Autowired
//        @Qualifier("customJwtTokenServices")
//        ResourceServerTokenServices customJwtTokenServices;
//
//        @Override
//        public void configure(ResourceServerSecurityConfigurer resources) throws Exception
//        {
//            resources.tokenServices(customJwtTokenServices);
//        }
//
//        @Bean
//        public ResourceServerTokenServices customJwtTokenServices() {
//            DefaultTokenServices services = new DefaultTokenServices();
//            services.setTokenStore(customJwtTokenStore);
//            return services;
//        }
//
//        @Bean
//        public TokenStore customJwtTokenStore() {
//            return new JwtTokenStore(customJwtTokenEnhancer);
//        }
//
//        @Bean
//        @Autowired
//        public JwtAccessTokenConverter customJwtTokenEnhancer(
//                @Value("${security.oauth2.resource.jwt.keyValue}") String keyValue) {
//            JwtAccessTokenConverter converter = new JwtAccessTokenConverter(){
//                @Override
//                public OAuth2Authentication extractAuthentication(Map<String, ?> map)
//                {
//                    OAuth2Authentication authentication = super.extractAuthentication(map);
//                    Map<String, String> details = new HashMap<>();
//                    details.put("account_id", (String) map.get("account_id"));
//                    authentication.setDetails(details);
//                    return authentication;
//                }
//            };
//            if (keyValue != null) {
//                converter.setVerifierKey(keyValue);
//            }
//            return converter;
//        }
//    }
//}
//
//
///*
//server.port = 8081
//
//logging.level.org.springframework.security=DEBUG
//security.sessions=stateless
//security.oauth2.resource.jwt.keyValue=-----BEGIN PUBLIC KEY-----[[MY KEY]]-----END PUBLIC KEY-----
// */
--------------------------------------------------------------------------------------------------------
//    @Bean
//    public FilterRegistrationBean<RequestResponseLoggingFilter> loggingFilter(){
//        final FilterRegistrationBean<RequestResponseLoggingFilter> registrationBean = new FilterRegistrationBean<>();
//        registrationBean.setFilter(new RequestResponseLoggingFilter());
//        registrationBean.addUrlPatterns("/users/*");
//        return registrationBean;
//    }

    @Bean
    public FilterRegistrationBean encodingFilter() {
        CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter("UTF-8", true);
        FilterRegistrationBean filterRegBean = new FilterRegistrationBean();
        filterRegBean.setUrlPatterns(getRootPathUrls());
        filterRegBean.setFilter(encodingFilter);
        filterRegBean.setOrder(1);
        return filterRegBean;
    }
	
////    @Bean
////    public FilterRegistrationBean getFilterRegistrationBean() {
////        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();
////        filterRegistrationBean.setFilter(new CharacterEncodingFilter());
////        return filterRegistrationBean;
////    }


    OutputStream output = new OutputStream()
    {
        private StringBuilder string = new StringBuilder();
        @Override
        public void write(int b) throws IOException {
            this.string.append((char) b );
        }

        //Netbeans IDE automatically overrides this toString()
        public String toString(){
            return this.string.toString();
        }
    };
--------------------------------------------------------------------------------------------------------
/**
 * The type of event received by the listener.
 *
 * @author Greg Luck
 * @since 1.0
 */
public enum EventType {

  /**
   * An event type indicating that the cache entry was created.
   */
  CREATED,

  /**
   * An event type indicating that the cache entry was updated. i.e. a previous
   * mapping existed
   */
  UPDATED,


  /**
   * An event type indicating that the cache entry was removed.
   */
  REMOVED,


  /**
   * An event type indicating that the cache entry has expired.
   */
  EXPIRED

}
--------------------------------------------------------------------------------------------------------
spring.datasource.continue-on-error
spring.batch.initialize-schema=always
--------------------------------------------------------------------------------------------------------
@Configuration(proxyBeanMethods = false)
public class SslWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // Customize the application security
        http.requiresChannel().anyRequest().requiresSecure();
    }
}
--------------------------------------------------------------------------------------------------------
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <version>2.2.0.RELEASE</version>
            <executions>
                <execution>
                    <goals>
                        <goal>build-info</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
--------------------------------------------------------------------------------------------------------
    /**
     * Returns generated identifier {@link String}
     *
     * @param length - initial input identifier length
     * @return generated identifier {@link String}
     */
    public static String generateId(final int length) {
        assert length > 0 : "Length should be positive number";
        final StringBuilder buffer = new StringBuilder();
        for (int i = 0; i < length; i++) {
            char next = (char) ('a' + (int) Math.floor(Math.random() * 26));
            if (Math.random() < 0.5) {
                next = Character.toUpperCase(next);
            }
            buffer.append(next);
        }
        return buffer.toString();
    }
--------------------------------------------------------------------------------------------------------
package de.pearl.pem.common.config;

import java.util.List;
 
import javax.sql.DataSource;
 
import static org.junit.Assert.*;
 
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
@Sql({ "drop_schema.sql", "schema.sql", "data.sql" })
public class DBConfigTest {
     
    @Autowired
    private JdbcTemplate jdbcTemplate;
     
    @Rule
    public TestName testName = new TestName();
     
    @Before
    public void printTestName() {
        System.out.println(testName.getMethodName());
    }
 ERROR: cannot serialize input date: Sat May 05 11:50:55 MSK 2018 by format: yyyy-MM-dp, locale: en_US, message: Illegal pattern character 'p'
    @Test
    public void printRows() {
        List empNames = jdbcTemplate.queryForList("select name from employee",
                String.class);
        assertEquals(2, empNames.size());
        System.out.println(empNames);
    }
     
    @Configuration
    static class Config {
 
        @Bean
        public DataSource dataSource() {
            return new EmbeddedDatabaseBuilder()//
            .setName("empty-sql-scripts-without-tx-mgr-test-db")//
            .build();
        }
         
        @Bean
        public JdbcTemplate jdbcTemplate() {
            return new JdbcTemplate(dataSource());
        }
    }
}
--------------------------------------------------------------------------------------------------------
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <requiresUnpack>
                    <dependency>
                        <groupId>org.jruby</groupId>
                        <artifactId>jruby-complete</artifactId>
                    </dependency>
                </requiresUnpack>
            </configuration>
        </plugin>
    </plugins>
</build>
--------------------------------------------------------------------------------------------------------
@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK, classes = ToggleApplication.class)
@AutoConfigureMockMvc
--------------------------------------------------------------------------------------------------------
import java.net.InetAddress;
import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.ConstructorBinding;
import org.springframework.boot.context.properties.DefaultValue;

@ConstructorBinding
@ConfigurationProperties("acme")
public class AcmeProperties {

    private final boolean enabled;

    private final InetAddress remoteAddress;

    private final Security security;

    public AcmeProperties(boolean enabled, InetAddress remoteAddress, Security security) {
        this.enabled = enabled;
        this.remoteAddress = remoteAddress;
        this.security = security;
    }

    public boolean isEnabled() { ... }

    public InetAddress getRemoteAddress() { ... }

    public Security getSecurity() { ... }

    public static class Security {

        private final String username;

        private final String password;

        private final List<String> roles;

        public Security(String username, String password,
                @DefaultValue("USER") List<String> roles) {
            this.username = username;
            this.password = password;
            this.roles = roles;
        }

        public String getUsername() { ... }

        public String getPassword() { ... }

        public List<String> getRoles() { ... }

    }
}
--------------------------------------------------------------------------------------------------------
@ConfigurationProperties("app.system")
public class AppSystemProperties {

    @DurationUnit(ChronoUnit.SECONDS)
    private Duration sessionTimeout = Duration.ofSeconds(30);

    private Duration readTimeout = Duration.ofMillis(1000);

    public Duration getSessionTimeout() {
        return this.sessionTimeout;
    }

    public void setSessionTimeout(Duration sessionTimeout) {
        this.sessionTimeout = sessionTimeout;
    }

    public Duration getReadTimeout() {
        return this.readTimeout;
    }

    public void setReadTimeout(Duration readTimeout) {
        this.readTimeout = readTimeout;
    }
}
--------------------------------------------------------------------------------------------------------
@ConfigurationProperties("app.io")
public class AppIoProperties {

    @DataSizeUnit(DataUnit.MEGABYTES)
    private DataSize bufferSize = DataSize.ofMegabytes(2);

    private DataSize sizeThreshold = DataSize.ofBytes(512);

    public DataSize getBufferSize() {
        return this.bufferSize;
    }

    public void setBufferSize(DataSize bufferSize) {
        this.bufferSize = bufferSize;
    }

    public DataSize getSizeThreshold() {
        return this.sizeThreshold;
    }

    public void setSizeThreshold(DataSize sizeThreshold) {
        this.sizeThreshold = sizeThreshold;
    }
}
--------------------------------------------------------------------------------------------------------
#spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration
#spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration
--------------------------------------------------------------------------------------------------------
kill $(cat ./bin/shutdown.pid)

--------------------------------------------------------------------------------------------------------
type Post {
    id: ID!
    title: String!
    text: String!
    category: String
    author: Author
}

type Author {
    id: ID!
    name: String!
    thumbnail: String
    posts: [Post]!
}

# The Root Query for the application
type Query {
    recentPosts(count: Int, offset: Int): [Post]!
}

# The Root Mutation for the application
type Mutation {
    writePost(title: String!, text: String!, category: String, author: String!) : Post!
}
--------------------------------------------------------------------------------------------------------import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.ExecutableType;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;

import com.google.auto.service.AutoService;

@SupportedAnnotationTypes("com.baeldung.annotation.processor.BuilderProperty")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
@AutoService(Processor.class)
public class BuilderProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (TypeElement annotation : annotations) {

            Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith(annotation);

            Map<Boolean, List<Element>> annotatedMethods = annotatedElements.stream().collect(Collectors.partitioningBy(element -> ((ExecutableType) element.asType()).getParameterTypes().size() == 1 && element.getSimpleName().toString().startsWith("set")));

            List<Element> setters = annotatedMethods.get(true);
            List<Element> otherMethods = annotatedMethods.get(false);

            otherMethods.forEach(element -> processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "@BuilderProperty must be applied to a setXxx method with a single argument", element));

            if (setters.isEmpty()) {
                continue;
            }

            String className = ((TypeElement) setters.get(0).getEnclosingElement()).getQualifiedName().toString();

            Map<String, String> setterMap = setters.stream().collect(Collectors.toMap(setter -> setter.getSimpleName().toString(), setter -> ((ExecutableType) setter.asType()).getParameterTypes().get(0).toString()));

            try {
                writeBuilderFile(className, setterMap);
            } catch (IOException e) {
                e.printStackTrace();
            }

        }

        return true;
    }

    private void writeBuilderFile(String className, Map<String, String> setterMap) throws IOException {

        String packageName = null;
        int lastDot = className.lastIndexOf('.');
        if (lastDot > 0) {
            packageName = className.substring(0, lastDot);
        }

        String simpleClassName = className.substring(lastDot + 1);
        String builderClassName = className + "Builder";
        String builderSimpleClassName = builderClassName.substring(lastDot + 1);

        JavaFileObject builderFile = processingEnv.getFiler().createSourceFile(builderClassName);
        try (PrintWriter out = new PrintWriter(builderFile.openWriter())) {

            if (packageName != null) {
                out.print("package ");
                out.print(packageName);
                out.println(";");
                out.println();
            }

            out.print("public class ");
            out.print(builderSimpleClassName);
            out.println(" {");
            out.println();

            out.print("    private ");
            out.print(simpleClassName);
            out.print(" object = new ");
            out.print(simpleClassName);
            out.println("();");
            out.println();

            out.print("    public ");
            out.print(simpleClassName);
            out.println(" build() {");
            out.println("        return object;");
            out.println("    }");
            out.println();

            setterMap.entrySet().forEach(setter -> {
                String methodName = setter.getKey();
                String argumentType = setter.getValue();

                out.print("    public ");
                out.print(builderSimpleClassName);
                out.print(" ");
                out.print(methodName);

                out.print("(");

                out.print(argumentType);
                out.println(" value) {");
                out.print("        object.");
                out.print(methodName);
                out.println("(value);");
                out.println("        return this;");
                out.println("    }");
                out.println();
            });

            out.println("}");

        }
    }

}
--------------------------------------------------------------------------------------------------------

import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;

import java.math.BigInteger;
import java.util.concurrent.TimeUnit;

public class FibonacciSequence {

    private static LoadingCache<Integer, BigInteger> memo = CacheBuilder.newBuilder()
            .maximumSize(100)
            .build(CacheLoader.from(FibonacciSequence::getFibonacciNumber));

    public static BigInteger getFibonacciNumber(int n) {
        if (n == 0) {
            return BigInteger.ZERO;
        } else if (n == 1) {
            return BigInteger.ONE;
        } else {
            return memo.getUnchecked(n - 1).add(memo.getUnchecked(n - 2));
        }
    }

}

import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;

import java.math.BigInteger;

public class Factorial {

    private static LoadingCache<Integer, BigInteger> memo = CacheBuilder.newBuilder()
            .build(CacheLoader.from(Factorial::getFactorial));

    public static BigInteger getFactorial(int n) {
        if (n == 0) {
            return BigInteger.ONE;
        } else {
            return BigInteger.valueOf(n).multiply(memo.getUnchecked(n - 1));
        }
    }

}

--------------------------------------------------------------------------------------------------------
import org.immutables.value.Value;

@Value.Immutable(prehash = true)
public abstract class Person {
    abstract String getName();
    abstract Integer getAge();
}

--------------------------------------------------------------------------------------------------------
@JsonTypeName("itemIdRemovedFromUser")
@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS, include = JsonTypeInfo.As.PROPERTY, property = "eventType")
@JsonTypeName("itemIdAddedToUser")
@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd@HH:mm:ss.SSSZ", locale = "en_GB")
--------------------------------------------------------------------------------------------------------
import com.baeldung.jackson.serialization.DistanceSerializer;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

/**
 * Use  @JsonFormat to handle representation of Enum as JSON (available since Jackson 2.1.2)
 * Use @JsonSerialize to configure a custom Jackson serializer
 */
// @JsonFormat(shape = JsonFormat.Shape.OBJECT)
@JsonSerialize(using = DistanceSerializer.class)
public enum Distance {
    KILOMETER("km", 1000), MILE("miles", 1609.34), METER("meters", 1), INCH("inches", 0.0254), CENTIMETER("cm", 0.01), MILLIMETER("mm", 0.001);

    private String unit;
    private final double meters;

    private Distance(String unit, double meters) {
        this.unit = unit;
        this.meters = meters;
    }

    /**
     * Use @JsonValue to control marshalling output for an enum
     */
    // @JsonValue
    public double getMeters() {
        return meters;
    }

    public String getUnit() {
        return unit;
    }

    public void setUnit(String unit) {
        this.unit = unit;
    }

    /**
     * Usage example: Distance.MILE.convertFromMeters(1205.5);
     */
    public double convertFromMeters(double distanceInMeters) {
        return distanceInMeters / meters;

    }

    /**
     * Usage example: Distance.MILE.convertToMeters(0.5);
     */
    public double convertToMeters(double distanceInMeters) {
        return distanceInMeters * meters;
    }

}
--------------------------------------------------------------------------------------------------------
   @JacksonInject
    private UUID id;
	@JsonCreator(mode = JsonCreator.Mode.PROPERTIES)
--------------------------------------------------------------------------------------------------------
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;

@JsonDeserialize(builder = Person.Builder.class)
public class Person {

    private final String name;
    private final Integer age;

    private Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public Integer getAge() {
        return age;
    }

    @JsonPOJOBuilder
    static class Builder {
        String name;
        Integer age;

        Builder withName(String name) {
            this.name = name;
            return this;
        }

        Builder withAge(Integer age) {
            this.age = age;
            return this;
        }

        Person build() {
            return new Person(name, age);
        }
    }
}
--------------------------------------------------------------------------------------------------------

import java.time.DayOfWeek;
import java.time.temporal.ChronoField;
import java.time.temporal.ChronoUnit;
import java.time.temporal.Temporal;
import java.time.temporal.TemporalAdjuster;

public class CustomTemporalAdjuster implements TemporalAdjuster {

    @Override
    public Temporal adjustInto(Temporal temporal) {
        switch (DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK))) {
        case FRIDAY:
            return temporal.plus(3, ChronoUnit.DAYS);
        case SATURDAY:
            return temporal.plus(2, ChronoUnit.DAYS);
        default:
            return temporal.plus(1, ChronoUnit.DAYS);
        }
    }
}
--------------------------------------------------------------------------------------------------------
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class TimeApi {

    public static List<Date> getDatesBetweenUsingJava7(Date startDate, Date endDate) {
        List<Date> datesInRange = new ArrayList<Date>();
        Calendar calendar = new GregorianCalendar();
        calendar.setTime(startDate);

        Calendar endCalendar = new GregorianCalendar();
        endCalendar.setTime(endDate);

        while (calendar.before(endCalendar)) {
            Date result = calendar.getTime();
            datesInRange.add(result);
            calendar.add(Calendar.DATE, 1);
        }
        return datesInRange;
    }

    public static List<LocalDate> getDatesBetweenUsingJava8(LocalDate startDate, LocalDate endDate) {
        long numOfDaysBetween = ChronoUnit.DAYS.between(startDate, endDate);
        return IntStream.iterate(0, i -> i + 1)
                 .limit(numOfDaysBetween)
                 .mapToObj(i -> startDate.plusDays(i))
                 .collect(Collectors.toList());
    }

    public static List<LocalDate> getDatesBetweenUsingJava9(LocalDate startDate, LocalDate endDate) {
        return startDate.datesUntil(endDate).collect(Collectors.toList());
    }

}
--------------------------------------------------------------------------------------------------------
import java.io.IOException;
import java.util.concurrent.TimeUnit;

import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.runner.RunnerException;

public class Benchmarking {
    public static void main(String[] args) throws RunnerException, IOException {
        org.openjdk.jmh.Main.main(args);
    }

    @State(Scope.Thread)
    public static class ExecutionPlan {
        public int number = Integer.MAX_VALUE;
        public int length = 0;
        public NumberOfDigits numberOfDigits= new NumberOfDigits();
    }
    
    @Benchmark 
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public void stringBasedSolution(ExecutionPlan plan) {
        plan.length = plan.numberOfDigits.stringBasedSolution(plan.number);
    }
    
    @Benchmark 
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public void logarithmicApproach(ExecutionPlan plan) {
        plan.length = plan.numberOfDigits.logarithmicApproach(plan.number);
    }
    
    @Benchmark 
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public void repeatedMultiplication(ExecutionPlan plan) {
        plan.length = plan.numberOfDigits.repeatedMultiplication(plan.number);
    }
    
    @Benchmark 
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public void shiftOperators(ExecutionPlan plan) {
        plan.length = plan.numberOfDigits.shiftOperators(plan.number);
    }
    
    @Benchmark 
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public void dividingWithPowersOf2(ExecutionPlan plan) {
        plan.length = plan.numberOfDigits.dividingWithPowersOf2(plan.number);
    }
    
    @Benchmark 
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public void divideAndConquer(ExecutionPlan plan) {
        plan.length = plan.numberOfDigits.divideAndConquer(plan.number);
    }
}
--------------------------------------------------------------------------------------------------------
    public int dividingWithPowersOf2(int number) {
        int length = 1;
        if (number >= 100000000) {
            length += 8;
            number /= 100000000;
        }
        if (number >= 10000) {
            length += 4;
            number /= 10000;
        }
        if (number >= 100) {
            length += 2;
            number /= 100;
        }
        if (number >= 10) {
            length += 1;
        }
        return length;
    }
--------------------------------------------------------------------------------------------------------
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class PrimeGenerator {
    public static List<Integer> sieveOfEratosthenes(int n) {
        final boolean prime[] = new boolean[n + 1];
        Arrays.fill(prime, true);

        for (int p = 2; p * p <= n; p++) {
            if (prime[p]) {
                for (int i = p * 2; i <= n; i += p)
                    prime[i] = false;
            }
        }

        final List<Integer> primes = new LinkedList<>();
        for (int i = 2; i <= n; i++) {
            if (prime[i])
                primes.add(i);
        }
        return primes;
    }

    public static List<Integer> primeNumbersBruteForce(int max) {
        final List<Integer> primeNumbers = new LinkedList<Integer>();
        for (int i = 2; i <= max; i++) {
            if (isPrimeBruteForce(i)) {
                primeNumbers.add(i);
            }
        }
        return primeNumbers;
    }

    private static boolean isPrimeBruteForce(int x) {
        for (int i = 2; i < x; i++) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }

    public static List<Integer> primeNumbersTill(int max) {
        return IntStream.rangeClosed(2, max)
            .filter(x -> isPrime(x))
            .boxed()
            .collect(Collectors.toList());
    }

    private static boolean isPrime(int x) {
        return IntStream.rangeClosed(2, (int) (Math.sqrt(x)))
            .allMatch(n -> x % n != 0);
    }
}
--------------------------------------------------------------------------------------------------------
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class PrimeFactorizationAlgorithm {

    public static Map<Integer, Integer> getPrimeFactors(int number) {
        int absNumber = Math.abs(number);
        Map<Integer, Integer> primeFactorsMap = new HashMap<Integer, Integer>();
        for (int factor = 2; factor <= absNumber; factor++) {
            while (absNumber % factor == 0) {
                Integer power = primeFactorsMap.get(factor);
                if (power == null) {
                    power = 0;
                }
                primeFactorsMap.put(factor, power + 1);
                absNumber /= factor;
            }
        }
        return primeFactorsMap;
    }

    public static int lcm(int number1, int number2) {
        if (number1 == 0 || number2 == 0) {
            return 0;
        }
        Map<Integer, Integer> primeFactorsForNum1 = getPrimeFactors(number1);
        Map<Integer, Integer> primeFactorsForNum2 = getPrimeFactors(number2);
        Set<Integer> primeFactorsUnionSet = new HashSet<Integer>(primeFactorsForNum1.keySet());
        primeFactorsUnionSet.addAll(primeFactorsForNum2.keySet());
        int lcm = 1;
        for (Integer primeFactor : primeFactorsUnionSet) {
            lcm *= Math.pow(primeFactor, Math.max(primeFactorsForNum1.getOrDefault(primeFactor, 0),
                    primeFactorsForNum2.getOrDefault(primeFactor, 0)));
        }
        return lcm;
    }

}
--------------------------------------------------------------------------------------------------------

import java.util.Arrays;

public class EuclideanAlgorithm {

    public static int gcd(int number1, int number2) {
        if (number1 == 0 || number2 == 0) {
            return number1 + number2;
        } else {
            int absNumber1 = Math.abs(number1);
            int absNumber2 = Math.abs(number2);
            int biggerValue = Math.max(absNumber1, absNumber2);
            int smallerValue = Math.min(absNumber1, absNumber2);
            return gcd(biggerValue % smallerValue, smallerValue);
        }
    }

    public static int lcm(int number1, int number2) {
        if (number1 == 0 || number2 == 0)
            return 0;
        else {
            int gcd = gcd(number1, number2);
            return Math.abs(number1 * number2) / gcd;
        }
    }

    public static int lcmForArray(int[] numbers) {
        int lcm = numbers[0];
        for (int i = 1; i <= numbers.length - 1; i++) {
            lcm = lcm(lcm, numbers[i]);
        }
        return lcm;
    }

    public static int lcmByLambda(int... numbers) {
        return Arrays.stream(numbers).reduce(1, (lcmSoFar, currentNumber) -> Math.abs(lcmSoFar * currentNumber) / gcd(lcmSoFar, currentNumber));
    }

}
--------------------------------------------------------------------------------------------------------

public class BinaryNumbers {

    /**
     * This method takes a decimal number and convert it into a binary number.
     * example:- input:10, output:1010
     *
     * @param decimalNumber
     * @return binary number
     */
    public Integer convertDecimalToBinary(Integer decimalNumber) {

        if (decimalNumber == 0) {
            return decimalNumber;
        }

        StringBuilder binaryNumber = new StringBuilder();
        Integer quotient = decimalNumber;

        while (quotient > 0) {

            int remainder = quotient % 2;
            binaryNumber.append(remainder);
            quotient /= 2;
        }

        binaryNumber = binaryNumber.reverse();
        return Integer.valueOf(binaryNumber.toString());
    }

    /**
     * This method takes a binary number and convert it into a decimal number.
     * example:- input:101, output:5
     *
     * @param binary number
     * @return decimal Number
     */
    public Integer convertBinaryToDecimal(Integer binaryNumber) {

        Integer decimalNumber = 0;
        Integer base = 1;

        while (binaryNumber > 0) {

            int lastDigit = binaryNumber % 10;
            binaryNumber = binaryNumber / 10;

            decimalNumber += lastDigit * base;
            base = base * 2;
        }
        return decimalNumber;
    }

    /**
     * This method accepts two binary numbers and returns sum of input numbers.
     * Example:- firstNum: 101, secondNum: 100, output: 1001
     *
     * @param firstNum
     * @param secondNum
     * @return addition of input numbers
     */
    public Integer addBinaryNumber(Integer firstNum, Integer secondNum) {

        StringBuilder output = new StringBuilder();

        int carry = 0;
        int temp;

        while (firstNum != 0 || secondNum != 0) {

            temp = (firstNum % 10 + secondNum % 10 + carry) % 2;
            output.append(temp);

            carry = (firstNum % 10 + secondNum % 10 + carry) / 2;

            firstNum = firstNum / 10;
            secondNum = secondNum / 10;
        }

        if (carry != 0) {
            output.append(carry);
        }

        return Integer.valueOf(output.reverse()
            .toString());
    }

    /**
    * This method takes two binary number as input and subtract second number from the first number.
    * example:- firstNum: 1000, secondNum: 11, output: 101
    * @param firstNum
    * @param secondNum
    * @return Result of subtraction of secondNum from first
    */
    public Integer substractBinaryNumber(Integer firstNum, Integer secondNum) {

        int onesComplement = Integer.valueOf(getOnesComplement(secondNum));
        StringBuilder output = new StringBuilder();
        int carry = 0;
        int temp;

        while (firstNum != 0 || onesComplement != 0) {

            temp = (firstNum % 10 + onesComplement % 10 + carry) % 2;
            output.append(temp);

            carry = (firstNum % 10 + onesComplement % 10 + carry) / 2;

            firstNum = firstNum / 10;
            onesComplement = onesComplement / 10;
        }

        String additionOfFirstNumAndOnesComplement = output.reverse()
            .toString();

        if (carry == 1) {
            return addBinaryNumber(Integer.valueOf(additionOfFirstNumAndOnesComplement), carry);
        } else {
            return getOnesComplement(Integer.valueOf(additionOfFirstNumAndOnesComplement));
        }
    }

    public Integer getOnesComplement(Integer num) {

        StringBuilder onesComplement = new StringBuilder();
        while (num > 0) {
            int lastDigit = num % 10;
            if (lastDigit == 0) {
                onesComplement.append(1);
            } else {
                onesComplement.append(0);
            }
            num = num / 10;
        }
        return Integer.valueOf(onesComplement.reverse()
            .toString());
    }

}
--------------------------------------------------------------------------------------------------------
import java.util.Spliterator;
import java.util.function.BiConsumer;
import java.util.stream.Stream;

public class CustomForEach {

    public static class Breaker {
        private boolean shouldBreak = false;

        public void stop() {
            shouldBreak = true;
        }

        boolean get() {
            return shouldBreak;
        }
    }

    public static <T> void forEach(Stream<T> stream, BiConsumer<T, Breaker> consumer) {
        Spliterator<T> spliterator = stream.spliterator();
        boolean hadNext = true;
        Breaker breaker = new Breaker();

        while (hadNext && !breaker.get()) {
            hadNext = spliterator.tryAdvance(elem -> {
                consumer.accept(elem, breaker);
            });
        }
    }
}
--------------------------------------------------------------------------------------------------------
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

import org.apache.commons.lang3.StringUtils;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;

/**
 * Based on https://github.com/tedyoung/indexof-contains-benchmark
 */
@Fork(5)
@State(Scope.Benchmark)
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public class SubstringSearchPerformanceComparison {

    private String message;

    private Pattern pattern;

    public static void main(String[] args) throws Exception {
        org.openjdk.jmh.Main.main(args);
    }

    @Setup
    public void setup() {
        message = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum";
        pattern = Pattern.compile("(?<!\\S)" + "eiusmod" + "(?!\\S)");
    }

    @Benchmark
    public int indexOf() {
        return message.indexOf("eiusmod");
    }

    @Benchmark
    public boolean contains() {
        return message.contains("eiusmod");
    }

    @Benchmark
    public boolean containsStringUtilsIgnoreCase() {
        return StringUtils.containsIgnoreCase(message, "eiusmod");
    }

    @Benchmark
    public boolean searchWithPattern() {
        return pattern.matcher(message).find();
    }
}
--------------------------------------------------------------------------------------------------------
import java.util.StringTokenizer;

public class WordCounter {
    static final int WORD = 0;
    static final int SEPARATOR = 1;

    public static int countWordsUsingRegex(String arg) {
        if (arg == null) {
            return 0;
        }
        final String[] words = arg.split("[\\pP\\s&&[^']]+");
        return words.length;
    }

    public static int countWordsUsingTokenizer(String arg) {
        if (arg == null) {
            return 0;
        }
        final StringTokenizer stringTokenizer = new StringTokenizer(arg);
        return stringTokenizer.countTokens();
    }

    public static int countWordsManually(String arg) {
        if (arg == null) {
            return 0;
        }
        int flag = SEPARATOR;
        int count = 0;
        int stringLength = arg.length();
        int characterCounter = 0;

        while (characterCounter < stringLength) {
            if (isAllowedInWord(arg.charAt(characterCounter)) && flag == SEPARATOR) {
                flag = WORD;
                count++;
            } else if (!isAllowedInWord(arg.charAt(characterCounter))) {
                flag = SEPARATOR;
            }
            characterCounter++;
        }
        return count;
    }

    private static boolean isAllowedInWord(char charAt) {
        return charAt == '\'' || Character.isLetter(charAt);
    }
}
--------------------------------------------------------------------------------------------------------
@BenchmarkMode(Mode.SingleShotTime)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@Measurement(batchSize = 100000, iterations = 10)
@Warmup(batchSize = 100000, iterations = 10)
@State(Scope.Thread)
public class StringPerformance {}
--------------------------------------------------------------------------------------------------------

import java.util.ArrayList;
import java.util.List;

public class WordIndexer {

    public List<Integer> findWord(String textString, String word) {
        int index = 0;
        List<Integer> indexes = new ArrayList<Integer>();
        String lowerCaseTextString = textString.toLowerCase();
        String lowerCaseWord = word.toLowerCase();

        while(index != -1) {
            index = lowerCaseTextString.indexOf(lowerCaseWord, index);
            if (index == -1) {
                break;
            }

            indexes.add(index);
            index++;
        }
        return indexes;
    }



    public List<Integer> findWordUpgrade(String textString, String word) {
        int index = 0;
        List<Integer> indexes = new ArrayList<Integer>();
        StringBuilder output = new StringBuilder();
        String lowerCaseTextString = textString.toLowerCase();
        String lowerCaseWord = word.toLowerCase();
        int wordLength = 0;

        while(index != -1){
            index = lowerCaseTextString.indexOf(lowerCaseWord, index + wordLength);  // Slight improvement
            if (index != -1) {
                indexes.add(index);
            }
            wordLength = word.length();
        }
        return indexes;
    }
}
--------------------------------------------------------------------------------------------------------
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwsHeader;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.SigningKeyResolver;
import io.jsonwebtoken.SigningKeyResolverAdapter;
import io.jsonwebtoken.impl.TextCodec;
import io.jsonwebtoken.impl.crypto.MacProvider;
import io.jsonwebtoken.lang.Assert;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.crypto.SecretKey;
import java.util.HashMap;
import java.util.Map;

@Service
public class SecretService {

    private Map<String, String> secrets = new HashMap<>();

    private SigningKeyResolver signingKeyResolver = new SigningKeyResolverAdapter() {
        @Override
        public byte[] resolveSigningKeyBytes(JwsHeader header, Claims claims) {
            return TextCodec.BASE64.decode(secrets.get(header.getAlgorithm()));
        }
    };

    @PostConstruct
    public void setup() {
        refreshSecrets();
    }

    public SigningKeyResolver getSigningKeyResolver() {
        return signingKeyResolver;
    }

    public Map<String, String> getSecrets() {
        return secrets;
    }

    public void setSecrets(Map<String, String> secrets) {
        Assert.notNull(secrets);
        Assert.hasText(secrets.get(SignatureAlgorithm.HS256.getValue()));
        Assert.hasText(secrets.get(SignatureAlgorithm.HS384.getValue()));
        Assert.hasText(secrets.get(SignatureAlgorithm.HS512.getValue()));

        this.secrets = secrets;
    }

    public byte[] getHS256SecretBytes() {
        return TextCodec.BASE64.decode(secrets.get(SignatureAlgorithm.HS256.getValue()));
    }

    public byte[] getHS384SecretBytes() {
        return TextCodec.BASE64.decode(secrets.get(SignatureAlgorithm.HS384.getValue()));
    }

    public byte[] getHS512SecretBytes() {
        return TextCodec.BASE64.decode(secrets.get(SignatureAlgorithm.HS512.getValue()));
    }

    public Map<String, String> refreshSecrets() {
        SecretKey key = MacProvider.generateKey(SignatureAlgorithm.HS256);
        secrets.put(SignatureAlgorithm.HS256.getValue(), TextCodec.BASE64.encode(key.getEncoded()));
        key = MacProvider.generateKey(SignatureAlgorithm.HS384);
        secrets.put(SignatureAlgorithm.HS384.getValue(), TextCodec.BASE64.encode(key.getEncoded()));
        key = MacProvider.generateKey(SignatureAlgorithm.HS512);
        secrets.put(SignatureAlgorithm.HS512.getValue(), TextCodec.BASE64.encode(key.getEncoded()));
        return secrets;
    }
}
--------------------------------------------------------------------------------------------------------
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.jjwtfun.model.JwtResponse;
import io.jsonwebtoken.jjwtfun.service.SecretService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.io.UnsupportedEncodingException;
import java.time.Instant;
import java.util.Date;

import static org.springframework.web.bind.annotation.RequestMethod.GET;

@RestController
public class StaticJWTController extends BaseController {

    @Autowired
    SecretService secretService;

    @RequestMapping(value = "/static-builder", method = GET)
    public JwtResponse fixedBuilder() throws UnsupportedEncodingException {
        String jws = Jwts.builder()
            .setIssuer("Stormpath")
            .setSubject("msilverman")
            .claim("name", "Micah Silverman")
            .claim("scope", "admins")
            .setIssuedAt(Date.from(Instant.ofEpochSecond(1466796822L))) // Fri Jun 24 2016 15:33:42 GMT-0400 (EDT)
            .setExpiration(Date.from(Instant.ofEpochSecond(4622470422L))) // Sat Jun 24 2116 15:33:42 GMT-0400 (EDT)
            .signWith(SignatureAlgorithm.HS256, secretService.getHS256SecretBytes())
            .compact();

        return new JwtResponse(jws);
    }

    @RequestMapping(value = "/parser", method = GET)
    public JwtResponse parser(@RequestParam String jwt) throws UnsupportedEncodingException {

        Jws<Claims> jws = Jwts.parser()
            .setSigningKeyResolver(secretService.getSigningKeyResolver())
            .parseClaimsJws(jwt);

        return new JwtResponse(jws);
    }

    @RequestMapping(value = "/parser-enforce", method = GET)
    public JwtResponse parserEnforce(@RequestParam String jwt) throws UnsupportedEncodingException {
        Jws<Claims> jws = Jwts.parser()
            .requireIssuer("Stormpath")
            .require("hasMotorcycle", true)
            .setSigningKeyResolver(secretService.getSigningKeyResolver())
            .parseClaimsJws(jwt);

        return new JwtResponse(jws);
    }
}
--------------------------------------------------------------------------------------------------------

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.security.web.csrf.CsrfTokenRepository;
import org.springframework.security.web.csrf.DefaultCsrfToken;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.util.Date;
import java.util.UUID;

public class JWTCsrfTokenRepository implements CsrfTokenRepository {

    private static final String DEFAULT_CSRF_TOKEN_ATTR_NAME = CSRFConfig.class.getName()
        .concat(".CSRF_TOKEN");

    private static final Logger log = LoggerFactory.getLogger(JWTCsrfTokenRepository.class);
    private byte[] secret;

    public JWTCsrfTokenRepository(byte[] secret) {
        this.secret = secret;
    }

    @Override
    public CsrfToken generateToken(HttpServletRequest request) {
        String id = UUID.randomUUID()
            .toString()
            .replace("-", "");

        Date now = new Date();
        Date exp = new Date(System.currentTimeMillis() + (1000 * 30)); // 30 seconds

        String token = Jwts.builder()
            .setId(id)
            .setIssuedAt(now)
            .setNotBefore(now)
            .setExpiration(exp)
            .signWith(SignatureAlgorithm.HS256, secret)
            .compact();

        return new DefaultCsrfToken("X-CSRF-TOKEN", "_csrf", token);
    }

    @Override
    public void saveToken(CsrfToken token, HttpServletRequest request, HttpServletResponse response) {
        if (token == null) {
            HttpSession session = request.getSession(false);
            if (session != null) {
                session.removeAttribute(DEFAULT_CSRF_TOKEN_ATTR_NAME);
            }
        } else {
            HttpSession session = request.getSession();
            session.setAttribute(DEFAULT_CSRF_TOKEN_ATTR_NAME, token);
        }
    }

    @Override
    public CsrfToken loadToken(HttpServletRequest request) {
        HttpSession session = request.getSession(false);
        if (session == null || "GET".equals(request.getMethod())) {
            return null;
        }
        return (CsrfToken) session.getAttribute(DEFAULT_CSRF_TOKEN_ATTR_NAME);
    }
}
--------------------------------------------------------------------------------------------------------
   private int id;
    @JsonbProperty("person-name")
    private String name;
    @JsonbProperty(nillable = true)
    private String email;
    @JsonbTransient
    private int age;
    @JsonbDateFormat("dd-MM-yyyy")
    private LocalDate registeredDate;
    private BigDecimal salary;
--------------------------------------------------------------------------------------------------------
    @RequestMapping(value = "/dynamic-builder-general", method = POST)
    public JwtResponse dynamicBuilderGeneric(@RequestBody Map<String, Object> claims) throws UnsupportedEncodingException {
        String jws = Jwts.builder()
            .setClaims(claims)
            .signWith(SignatureAlgorithm.HS256, secretService.getHS256SecretBytes())
            .compact();
        return new JwtResponse(jws);
    }

    @RequestMapping(value = "/dynamic-builder-compress", method = POST)
    public JwtResponse dynamicBuildercompress(@RequestBody Map<String, Object> claims) throws UnsupportedEncodingException {
        String jws = Jwts.builder()
            .setClaims(claims)
            .compressWith(CompressionCodecs.DEFLATE)
            .signWith(SignatureAlgorithm.HS256, secretService.getHS256SecretBytes())
            .compact();
        return new JwtResponse(jws);
    }
--------------------------------------------------------------------------------------------------------

import java.util.List;
import java.util.Locale;
import java.util.ResourceBundle;

public class Localization {

    public static String getLabel(Locale locale) {
        final ResourceBundle bundle = ResourceBundle.getBundle("messages", locale);
        return bundle.getString("label");
    }

    public static void run(List<Locale> locales) {
        locales.forEach(locale -> System.out.println(getLabel(locale)));
    }

}
--------------------------------------------------------------------------------------------------------

import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

public class CustomTakeWhile {

    public static <T> Stream<T> takeWhile(Stream<T> stream, Predicate<T> predicate) {
        CustomSpliterator<T> customSpliterator = new CustomSpliterator<>(stream.spliterator(), predicate);
        return StreamSupport.stream(customSpliterator, false);
    }

}
--------------------------------------------------------------------------------------------------------
import java.io.IOException;

import com.baeldung.jackson.enums.Distance;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;

public class DistanceSerializer extends StdSerializer<Distance> {

    private static final long serialVersionUID = 1376504304439963619L;

    public DistanceSerializer() {
        super(Distance.class);
    }

    public DistanceSerializer(Class<Distance> t) {
        super(t);
    }

    public void serialize(Distance distance, JsonGenerator generator, SerializerProvider provider) throws IOException, JsonProcessingException {
        generator.writeStartObject();
        generator.writeFieldName("name");
        generator.writeString(distance.name());
        generator.writeFieldName("unit");
        generator.writeString(distance.getUnit());
        generator.writeFieldName("meters");
        generator.writeNumber(distance.getMeters());
        generator.writeEndObject();
    }
}
--------------------------------------------------------------------------------------------------------


spring.messages.basename=messages,config.i18n.messages
spring.messages.fallback-to-system-locale=false


--------------------------------------------------------------------------------------------------------


spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**
spring.resources.chain.strategy.fixed.enabled=true
spring.resources.chain.strategy.fixed.paths=/js/lib/
spring.resources.chain.strategy.fixed.version=v12



spring.mvc.contentnegotiation.favor-parameter=true

# We can change the parameter name, which is "format" by default:
# spring.mvc.contentnegotiation.parameter-name=myparam

# We can also register additional file extensions/media types with:
spring.mvc.contentnegotiation.media-types.markdown=text/markdown



spring.mvc.contentnegotiation.favor-parameter=true

# We can change the parameter name, which is "format" by default:
# spring.mvc.contentnegotiation.parameter-name=myparam

# We can also register additional file extensions/media types with:
spring.mvc.contentnegotiation.media-types.markdown=text/markdown



spring.mvc.contentnegotiation.favor-path-extension=true
spring.mvc.pathmatch.use-registered-suffix-pattern=true

# You can also register additional file extensions/media types with:
# spring.mvc.contentnegotiation.media-types.adoc=text/asciidoc


--------------------------------------------------------------------------------------------------------
src/
 +- main/
     +- java/
     |   + <source code>
     +- resources/
         +- public/
             +- error/
             |   +- 404.html
             +- <other public assets>
--------------------------------------------------------------------------------------------------------
src/
 +- main/
     +- java/
     |   + <source code>
     +- resources/
         +- templates/
             +- error/
             |   +- 5xx.ftlh
             +- <other templates>
--------------------------------------------------------------------------------------------------------


spring.webflux.static-path-pattern=/resources/**


--------------------------------------------------------------------------------------------------------
@Bean
public ErrorPageRegistrar errorPageRegistrar(){
    return new MyErrorPageRegistrar();
}

// ...

private static class MyErrorPageRegistrar implements ErrorPageRegistrar {

    @Override
    public void registerErrorPages(ErrorPageRegistry registry) {
        registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400"));
    }
}

@Bean
public FilterRegistrationBean myFilter() {
    FilterRegistrationBean registration = new FilterRegistrationBean();
    registration.setFilter(new MyFilter());
    ...
    registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
    return registration;
}
--------------------------------------------------------------------------------------------------------
public class CustomErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {

    // Define constructor here

    @Override
    protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {

        return RouterFunctions
                .route(aPredicate, aHandler)
                .andRoute(anotherPredicate, anotherHandler);
    }

}
--------------------------------------------------------------------------------------------------------
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
import org.springframework.stereotype.Component;

@Component
public class CustomizationBean implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {

    @Override
    public void customize(ConfigurableServletWebServerFactory server) {
        server.setPort(9000);
    }

}
@Bean
public ConfigurableServletWebServerFactory webServerFactory() {
    TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
    factory.setPort(9000);
    factory.setSessionTimeout(10, TimeUnit.MINUTES);
    factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, "/notfound.html"));
    return factory;
}
--------------------------------------------------------------------------------------------------------


spring.rsocket.server.mapping-path=/rsocket # a mapping path is defined
spring.rsocket.server.transport=websocket # websocket is chosen as a transport
#spring.rsocket.server.port= # no port is defined



spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].private-key-location=path-to-private-key
spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].certificate-location=path-to-certificate
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.verification.credentials[0].certificate-location=path-to-verification-cert
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.entity-id=remote-idp-entity-id1
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.sso-url=https://remoteidp1.sso.url

spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].private-key-location=path-to-private-key
spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].certificate-location=path-to-certificate
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.verification.credentials[0].certificate-location=path-to-other-verification-cert
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.entity-id=remote-idp-entity-id2
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.sso-url=https://remoteidp2.sso.url




# Number of ms to wait before throwing an exception if no connection is available.
spring.datasource.tomcat.max-wait=10000

# Maximum number of active connections that can be allocated from this pool at the same time.
spring.datasource.tomcat.max-active=50

# Validate the connection before borrowing it from the pool.
spring.datasource.tomcat.test-on-borrow=true



spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test



spring.data.mongodb.host=mongoserver
spring.data.mongodb.port=27017



spring.data.neo4j.uri=bolt://my-server:7687
spring.data.neo4j.username=neo4j
spring.data.neo4j.password=secret



spring.data.neo4j.use-native-types=true



spring.data.neo4j.open-in-view=false

package com.example.myapp.domain;

import java.util.Optional;

import org.springframework.data.neo4j.repository.*;

public interface CityRepository extends Neo4jRepository<City, Long> {

    Optional<City> findOneByNameAndState(String name, String state);

}

spring.data.cassandra.keyspace-name=mykeyspace
spring.data.cassandra.contact-points=cassandrahost1,cassandrahost2



spring.couchbase.bootstrap-hosts=my-host-1,192.168.1.123
spring.couchbase.bucket.name=my-bucket
spring.couchbase.bucket.password=secret



spring.couchbase.env.timeouts.connect=3000
spring.couchbase.env.ssl.key-store=/location/of/keystore.jks
spring.couchbase.env.ssl.key-store-password=secret

@Configuration(proxyBeanMethods = false)
public class SomeConfiguration {

    @Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
    public CustomConversions myCustomConversions() {
        return new CustomConversions(...);
    }

    // ...

}
spring.ldap.embedded.base-dn:
  - dc=spring,dc=io
  - dc=pivotal,dc=io
--------------------------------------------------------------------------------------------------------


spring.influx.url=https://172.0.0.1:8086

https://cbor.io/
https://github.com/cbor/cbor.github.io/issues/new
https://rsocket.io/
https://github.com/rsocket
--------------------------------------------------------------------------------------------------------
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;

public enum WeatherStats {

    STATS_RAINY("Going to Rain, Take Umbrella"), STATS_HUMID("Going to be very humid, Take Water");

    private final String message;

    private static final List<WeatherStats> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

    private static final int SIZE = VALUES.size();

    private static final Random RANDOM = new Random();

    WeatherStats(String msg) {
        this.message = msg;
    }

    public static WeatherStats forToday() {
        return VALUES.get(RANDOM.nextInt(SIZE));
    }

    public String getMessage() {
        return message;
    }

}

addSbtPlugin("com.lightbend.lagom" % "lagom-sbt-plugin" % "1.3.1")
addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin" % "3.0.0")
--------------------------------------------------------------------------------------------------------

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.monitor.FileAlterationListener;
import org.apache.commons.io.monitor.FileAlterationListenerAdaptor;
import org.apache.commons.io.monitor.FileAlterationMonitor;
import org.apache.commons.io.monitor.FileAlterationObserver;

import java.io.File;

public class FileMonitor {

    public static void main(String[] args) throws Exception {
        File folder = FileUtils.getTempDirectory();
        startFileMonitor(folder);
    }

    /**
     * @param folder
     * @throws Exception
     */
    public static void startFileMonitor(File folder) throws Exception {
        FileAlterationObserver observer = new FileAlterationObserver(folder);
        FileAlterationMonitor monitor = new FileAlterationMonitor(5000);

        FileAlterationListener fal = new FileAlterationListenerAdaptor() {

            @Override
            public void onFileCreate(File file) {
                // on create action
            }

            @Override
            public void onFileDelete(File file) {
                // on delete action
            }
        };

        observer.addListener(fal);
        monitor.addObserver(observer);
        monitor.start();
    }
}
--------------------------------------------------------------------------------------------------------
#!/bin/bash

find . -maxdepth 1 -mindepth 1 -type d -printf '%f\n'

find . -maxdepth 1 -mindepth 1 -type d | while read dir; do
  echo "$dir"
done

find . -maxdepth 1 -type d -exec echo {} \;

#!/bin/bash

for dir in */; do
    echo "$dir"
done

for file in *; do
    if [ -d "$file" ]; then
        echo "$file"
    fi
done

#!/bin/bash

my_var="Hola Mundo"
echo ${my_var}

my_filename="interesting-text-file.txt"
echo ${my_filename:0:21}

echo ${my_filename%.*}

complicated_filename="hello-world.tar.gz"
echo ${complicated_filename%%.*}

echo ${my_filename/.*/}

echo 'interesting-text-file.txt' | sed 's/.txt*//'

echo 'interesting-text-file.txt' | cut -f1 -d"."
echo ${complicated_filename} | cut -f1 -d"."
--------------------------------------------------------------------------------------------------------
@Getter(lazy = true)


import lombok.Builder;

class ClientBuilder {

    @Builder(builderMethodName = "builder")
    public static ImmutableClient newClient(int id, String name) {
        return new ImmutableClient(id, name);
    }
}

@Builder(toBuilder = true)

import java.util.List;
import lombok.Builder;
import lombok.Getter;
import lombok.Singular;

@Getter
@Builder
public class Sea {

    @Singular private final List<String> grasses;
    @Singular("oneFish") private final List<String> fish;
}
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
module com.baeldung.dip.services {
    requires com.baeldung.dip.entities;
    requires com.baeldung.dip.daos;
    uses com.baeldung.dip.daos.CustomerDao;
    exports com.baeldung.dip.services;
}
--------------------------------------------------------------------------------------------------------

    public static User getSingletonInstance(String name, String email, String country) {
        if (instance == null) {
            synchronized (User.class) {
                if (instance == null) {
                    instance = new User(name, email, country);
                }
            }
        }
        return instance;

    }
--------------------------------------------------------------------------------------------------------

public enum Operator {

    ADD {
        @Override
        public int apply(int a, int b) {
            return a + b;
        }
    },

    MULTIPLY {
        @Override
        public int apply(int a, int b) {
            return a * b;
        }
    },

    SUBTRACT {
        @Override
        public int apply(int a, int b) {
            return a - b;
        }
    },

    DIVIDE {
        @Override
        public int apply(int a, int b) {
            return a / b;
        }
    },

    MODULO {
        @Override
        public int apply(int a, int b) {
            return a % b;
        }
    };

    public abstract int apply(int a, int b);
}

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

public class RuleEngine {

    private static List<Rule> rules = new ArrayList<>();

    static {
        rules.add(new AddRule());
    }

    public Result process(Expression expression) {

        Rule rule = rules.stream()
            .filter(r -> r.evaluate(expression))
            .findFirst()
            .orElseThrow(() -> new IllegalArgumentException("Expression does not matches any Rule"));
        return rule.getResult();
    }
}
--------------------------------------------------------------------------------------------------------
import io.github.resilience4j.retry.IntervalFunction;
import io.github.resilience4j.retry.Retry;
import io.github.resilience4j.retry.RetryConfig;
import org.junit.Before;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.function.Function;

import static com.baeldung.backoff.jitter.BackoffWithJitterTest.RetryProperties.*;
import static io.github.resilience4j.retry.IntervalFunction.ofExponentialBackoff;
import static io.github.resilience4j.retry.IntervalFunction.ofExponentialRandomBackoff;
import static java.util.Collections.nCopies;
import static java.util.concurrent.Executors.newFixedThreadPool;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

public class BackoffWithJitterTest {

    static Logger log = LoggerFactory.getLogger(BackoffWithJitterTest.class);

    interface PingPongService {

        String call(String ping) throws PingPongServiceException;
    }

    class PingPongServiceException extends RuntimeException {

        public PingPongServiceException(String reason) {
            super(reason);
        }
    }

    private PingPongService service;
    private static final int NUM_CONCURRENT_CLIENTS = 8;

    @Before
    public void setUp() {
        service = mock(PingPongService.class);
    }

    @Test
    public void whenRetryExponentialBackoff_thenRetriedConfiguredNoOfTimes() {
        IntervalFunction intervalFn = ofExponentialBackoff(INITIAL_INTERVAL, MULTIPLIER);
        Function<String, String> pingPongFn = getRetryablePingPongFn(intervalFn);

        when(service.call(anyString())).thenThrow(PingPongServiceException.class);
        try {
            pingPongFn.apply("Hello");
        } catch (PingPongServiceException e) {
            verify(service, times(MAX_RETRIES)).call(anyString());
        }
    }

    @Test
    public void whenRetryExponentialBackoffWithoutJitter_thenThunderingHerdProblemOccurs() throws InterruptedException {
        IntervalFunction intervalFn = ofExponentialBackoff(INITIAL_INTERVAL, MULTIPLIER);
        test(intervalFn);
    }

    @Test
    public void whenRetryExponentialBackoffWithJitter_thenRetriesAreSpread() throws InterruptedException {
        IntervalFunction intervalFn = ofExponentialRandomBackoff(INITIAL_INTERVAL, MULTIPLIER, RANDOMIZATION_FACTOR);
        test(intervalFn);
    }

    private void test(IntervalFunction intervalFn) throws InterruptedException {
        Function<String, String> pingPongFn = getRetryablePingPongFn(intervalFn);
        ExecutorService executors = newFixedThreadPool(NUM_CONCURRENT_CLIENTS);
        List<Callable<String>> tasks = nCopies(NUM_CONCURRENT_CLIENTS, () -> pingPongFn.apply("Hello"));

        when(service.call(anyString())).thenThrow(PingPongServiceException.class);

        executors.invokeAll(tasks);
    }

    private Function<String, String> getRetryablePingPongFn(IntervalFunction intervalFn) {
        RetryConfig retryConfig = RetryConfig.custom()
                .maxAttempts(MAX_RETRIES)
                .intervalFunction(intervalFn)
                .retryExceptions(PingPongServiceException.class)
                .build();
        Retry retry = Retry.of("pingpong", retryConfig);
        return Retry.decorateFunction(retry, ping -> {
            log.info("Invoked at {}", LocalDateTime.now());
            return service.call(ping);
        });
    }

    static class RetryProperties {
        static final Long INITIAL_INTERVAL = 1000L;
        static final Double MULTIPLIER = 2.0D;
        static final Double RANDOMIZATION_FACTOR = 0.6D;
        static final Integer MAX_RETRIES = 4;
    }
}
--------------------------------------------------------------------------------------------------------
import com.baeldung.Constants;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitter;

@Controller
public class ResponseBodyEmitterController {
    private ExecutorService nonBlockingService = Executors.newCachedThreadPool();

    @GetMapping(Constants.API_RBE)
    public ResponseEntity<ResponseBodyEmitter> handleRbe() {
        ResponseBodyEmitter emitter = new ResponseBodyEmitter();

            nonBlockingService.execute(() -> {
                try {
                    emitter.send(Constants.API_RBE_MSG + " @ " + new Date(), MediaType.TEXT_PLAIN);
                    emitter.complete();
                } catch (Exception ex) {
                      System.out.println(Constants.GENERIC_EXCEPTION);
                      emitter.completeWithError(ex);
                }
            });

            return new ResponseEntity(emitter, HttpStatus.OK);
        }
}
--------------------------------------------------------------------------------------------------------
language: java
sudo: false
install: true

addons:
  sonarcloud:
    organization: "kakawait-github"
    branches:
      - master
      - develop
      - /^release\/.*$/
    token:
      secure: "yghqOuzw0Hov/i82t2CF7MlS8ifAQI1St3Bx3ZQ2yCer2sx5gBSZuJ12sWBJPsfnECxh2XLCHklud1maR1NOJPcogYSzF0Mm+/ymowGDXzwBmeO6ulEIXHWNyG9QSdZCvZtyvYEdXqErntsN4MnGWiGm0526n0qAv2sQE77MDBVTupbXGkqmwYe3vcDXuoRLUWVat4gop5A1tkdlu5LWXqn5tzylCJzDZ7VXD2eR+Cf7n0k/KMYA2MSFDUMBZWZzzj9O1lwhSkZystqlPo7ZL8UPUL/CpqsObdSWfeZVJG0VxfAbJxlSoHNi+KbffjyStPmIRGjgDIr8aWUANcwxmW2G2VDn898ZhvD+C7n1BiDqbKgbJRrhM8aG4klW3odE0gMcLEO3mOuqzT7p8h4IeeZCIFdr9wwsInXNnAfwDISCDiPTacUmM/DKwVDSBZTNxvi+tS1mwwoqphn1xc6ePnTx4RF/pvxNjLbGBEzToVmAAX7ViiU4MS/RDGPbxA/b0qVsgZWF0v9pD4uSb0O++fNtTAPObAnGOB9RUs5FEBtzIxBtw51oV0eyS7CffMLF+dkcxLzo0hj7UCnUpzotee/ydVMIc/K83NJZGlxy02NgdDEi5pxGJOyJyxV0s5F2DINCl4kuliqgxxjlyVvEgQAJ8gObGQkhQdA8Ax5qoqM="

jdk:
  - oraclejdk8

script:
  - mvn clean org.jacoco:jacoco-maven-plugin:prepare-agent package sonar:sonar

cache:
  directories:
    - '$HOME/.m2/repository'
    - '$HOME/.sonar/cache'
--------------------------------------------------------------------------------------------------------
@Command(name = "checksum", mixinStandardHelpOptions = true, version = "checksum 4.0",
         description = "Prints the checksum (MD5 by default) of a file to STDOUT.")
class CheckSum implements Callable<Integer> {

    @Parameters(index = "0", description = "The file whose checksum to calculate.")
    private File file;

    @Option(names = {"-a", "--algorithm"}, description = "MD5, SHA-1, SHA-256, ...")
    private String algorithm = "MD5";

    // this example implements Callable, so parsing, error handling and handling user
    // requests for usage help or version help can be done with one line of code.
    public static void main(String... args) {
        int exitCode = new CommandLine(new CheckSum()).execute(args);
        System.exit(exitCode);
    }

    @Override
    public Integer call() throws Exception { // your business logic goes here...
        byte[] fileContents = Files.readAllBytes(file.toPath());
        byte[] digest = MessageDigest.getInstance(algorithm).digest(fileContents);
        System.out.printf("%0" + (digest.length*2) + "x%n", new BigInteger(1, digest));
        return 0;
    }
}
--------------------------------------------------------------------------------------------------------
class Login implements Callable<Integer> {
    @Option(names = {"-u", "--user"}, description = "User name")
    String user;

    @Option(names = {"-p", "--password"}, description = "Passphrase", interactive = true)
    char[] password;

    public Integer call() throws Exception {
        byte[] bytes = new byte[password.length];
        for (int i = 0; i < bytes.length; i++) { bytes[i] = (byte) password[i]; }

        MessageDigest md = MessageDigest.getInstance("SHA-256");
        md.update(bytes);

        System.out.printf("Hi %s, your password is hashed to %s.%n", user, base64(md.digest()));

        // null out the arrays when done
        Arrays.fill(bytes, (byte) 0);
        Arrays.fill(password, ' ');

        return 0;
    }

    private String base64(byte[] arr) { /* ... */ }
}
new CommandLine(new Login()).execute("-u", "user123", "-p");
--------------------------------------------------------------------------------------------------------
@AllArgsConstructor(access = AccessLevel.PACKAGE)
@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)
--------------------------------------------------------------------------------------------------------
    public static short[] ByteArrayToShortArray(byte[] input)
    {
        int short_index, byte_index;
        int iterations = input.length;

        short[] output = new short[input.length / 2];
        short_index = byte_index = 0;

        for(int i=0; i < input.length /2 ; i++)
        {
            output[i] = (short) (((short)input[i*2] & 0xFF) + (((short)input[i*2+1] & 0xFF) << 8));
        }
        return output;
    }
--------------------------------------------------------------------------------------------------------
org.springframework.boot.env.EnvironmentPostProcessor=org.springframework.boot.env.MockWebServerEnvironmentPostProcessor
--------------------------------------------------------------------------------------------------------
import org.springframework.beans.factory.DisposableBean;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.env.EnvironmentPostProcessor;
import org.springframework.core.env.ConfigurableEnvironment;

/**
 * @author Rob Winch
 */
public class MockWebServerEnvironmentPostProcessor implements EnvironmentPostProcessor, DisposableBean {

    private final MockWebServerPropertySource propertySource = new MockWebServerPropertySource();

    @Override
    public void postProcessEnvironment(final ConfigurableEnvironment environment, final SpringApplication application) {
        environment.getPropertySources().addFirst(this.propertySource);
    }

    @Override
    public void destroy() throws Exception {
        this.propertySource.destroy();
    }
}
--------------------------------------------------------------------------------------------------------
language: java
dist: trusty
git:
  depth: false
  quiet: true
  submodules: false
  lfs_skip_smudge: true
sudo: false
branches:
  only:
    - master
    - stable
jdk:
  - oraclejdk8
  - openjdk8
addons:
  sonarcloud:
    organization: "alexrogalskiy-github"
    token:
      secure:
      ##"EFloHmTj8WE5g+NJ0OPbXFYF5+YZ+az4K5seJgCjY+dxw8CbwyNCZPc0rxRbzxevf00hg/OywEfWQM1x9g6JuPvVeoR51kkqF1Ved7gTl4Xi5s7hLYltq2U/4e+iDPyRBJehelw1sclSSgQPQ66YDWlRq9zAT/9NJcz4Nbp89mTwZ9jrOPepy8U0iXwVg167OJhUWowGdv+g3Ffn0ZsuEXJ92XMgd3c7ypb39/c3W72rmL2iNNa/FdtIVRAmOS89371CFdh8vUx8qTGgUyofXfkJTnh1Ha8gf1taZTZsdnfgy9cL3S6wq/rpbbyxMnC6A8JpKRxPgXPCjVGPFgZWzQol8UpiNftnoR/7y4+q6cQJ1Nlo/NEdx+liXK6+WC96tzApf/8Wrsx7pYxSLEExSzeAb8gnSVY/qh9K5Ix8jcyPQPYWNrv8Lo59sbg5f0Lzg5qMAvk6FBJwvB/QCSD+ZUSCEvjhLBhugv9xi+UVVEzcMJMm7yFVeskBoInngD1rjIeZvA8asppJALHw7a9sluJvLQlntd0QYZlYipSwj9ayJYYXdn1sxxeUA2Ldlq9JhUHYo1oAIfD+varTYEksf7XJsCkc3HnlBW1rPdnUG5NHvFcwn2Y0lPcH7AZsL8duIiriq3OGEa9m/4OybkLlxvbKo/RVfp11vUSpJJZpdqk="
  apt:
    update: true
    packages:
      - oracle-java8-installer
before_install: echo "MAVEN_OPTS='-Xmx2048m -XX:MaxPermSize=512m'" > ~/.mavenrc
install: true
before_script:
  - pip install --user codecov
  - curl http://www.jpm4j.org/install/script | sh
script:
  - mvn -U -B -V test --fail-at-end -Dsource.skip=true -Dmaven.javadoc.skip=true
  - mvn cobertura:cobertura
  - mvn sonar:sonar -Dsonar.projectKey=AlexRogalskiy_AnsiFancy -Dsonar.organization=alexrogalskiy-github -Dsonar.host.url=https://sonarcloud.io -Dsonar.login=$SONAR_TOKEN
after_success:
  - mvn clean test jacoco:report
  - codecov --build "$TRAVIS_JOB_NUMBER-jdk8"
  - bash <(curl -s https://codecov.io/bash) -t $CODECOV_TOKEN
notifications:
  email:
    on_success: change
    on_failure: always
env:
  global:
    - secure: "YNE9GjEV52M9LawKTHLTgNcc8n7LG6884Xq2VGNstdz4xtqphunCZKWpVAPIDKrMdJDjZvji7PT1uZz7aleypSI3sXLjYjvXaGQ3bZ2G9zqCfMfHFTbAb1oW0zhy27gFsQ0+8/EvEd5xNrEuniBbo5ZRMz1WuHLSQvNiiR6QntCziTn0lgvrbnpsX1tFlWIONxvnaMcDFYyV7gDEODDn45ese05wAcqEl2tQBUfMu5BJZ1cw40qvuhfEK+M4Kui6/bcZZbCIRe0We0m4RlFx04G6xZ1GstQJCVDFIi7lZXY55EqAm+7d/XMQoCmmElEWV81GajyH1LOWZL9gq4ZED1TKSZUQcuWVIfANHpNxCzTNZ9fqD4g/MTa0rG2xfBJYcPd58eXuo2xWzZ/Wbkx5kFWr0xegG+6ctiySV7f4uy85n5V1loLTVOFLegJu00uGl4j6o0hHfE8Qc9+DupDB3WgPkKOW9ZMJGgT6v47uYr1qGnze9FhBMboFUPlbDEbbYdCrch4op9v/w1fzegX6QMWcDVa1nqTJ8uG7pbATkIk2AvAbDbofBtDcWq3neXr8zp2hdb/RIa6jeReGhIHiQ8eckhRoOW+eC3omOlqkX2+6rxoH3JtU4eSBovzXkOiq50xsm/vmzhCcLFlLEhyTV1GUQN8SzLzizanTtcAw6y0="
cache:
  directories:
    - "$HOME/.m2/repository"
    - "$HOME/.sonar/cache"
--------------------------------------------------------------------------------------------------------
import de.pearl.pem.common.validation.model.OffsetPageRequest;
import de.pearl.pem.common.validation.validator.OffsetPageRequestValidator;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.validation.BeanPropertyBindingResult;
import org.springframework.validation.Errors;
import org.springframework.validation.Validator;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import org.springframework.web.server.ResponseStatusException;
import reactor.core.publisher.Mono;

import java.util.Objects;

@Component
public class OffsetPageHandler {

    public Mono<ServerResponse> handleRequest(final ServerRequest request) {
        final Validator validator = new OffsetPageRequestValidator();
        final Mono<String> responseBody = request.bodyToMono(OffsetPageRequest.class)
            .map(body -> {
                final Errors errors = new BeanPropertyBindingResult(body, OffsetPageRequest.class.getName());
                validator.validate(body, errors);

                if (Objects.isNull(errors) || errors.getAllErrors().isEmpty()) {
                    return String.format("{%s}: offset: [%s], page number: [%s], page size: [%s], sort: [%s]", getClass().getCanonicalName(), body.getOffset(), body.getPageNumber(), body.getPageSize(), body.getSort());
                }
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, errors.getAllErrors().toString());
            });
        return ServerResponse
            .ok()
            .contentType(MediaType.APPLICATION_JSON)
            .body(responseBody, String.class);
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.context.annotation.Configuration;
import org.springframework.hateoas.config.EnableHypermediaSupport;
import org.springframework.hateoas.config.EnableHypermediaSupport.HypermediaType;

/**
 * Separate configuration class to enable Spring Hateoas functionality if the {@code hateoas} profile is activated.
 */
@Configuration
//@Profile("hateoas")
@EnableHypermediaSupport(type = HypermediaType.HAL)
public class MediaConfiguration {
}
--------------------------------------------------------------------------------------------------------

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;

import java.util.Locale;

/**
 * Application configuration
 */
@Configuration
public class AppConfig {

//    @Bean
//    public ModelMapper modelMapper() {
//        return new ModelMapper();
//    }

    @Bean
    public ObjectMapper jsonObjectMapper() {
        final ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setDefaultMergeable(Boolean.TRUE);
        objectMapper.setLocale(Locale.getDefault());
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        objectMapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);

        objectMapper.enable(JsonParser.Feature.ALLOW_COMMENTS);
        objectMapper.enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);
        objectMapper.enable(JsonParser.Feature.ALLOW_SINGLE_QUOTES);
        objectMapper.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII);

        objectMapper.disable(SerializationFeature.INDENT_OUTPUT);
        objectMapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        objectMapper.disable(DeserializationFeature.UNWRAP_ROOT_VALUE);
        objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        objectMapper.enable(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);
        objectMapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);
        //objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        return objectMapper;
    }

    @Bean
    public ObjectMapper jacksonObjectMapper() {
        final Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
        builder.indentOutput(true);
        builder.autoDetectFields(true);
        return builder.build();
    }

    //    @Bean
//    public ServletListenerRegistrationBean<HttpSessionListener> httpSessionCreatedListener() {
//        ServletListenerRegistrationBean<HttpSessionListener> listenerRegistrationBean = new ServletListenerRegistrationBean<>();
//        listenerRegistrationBean.setListener(new HttpSessionCreatedListener());
//        return listenerRegistrationBean;
//    }
//    @Bean
//    public FilterRegistrationBean noHttpSessionFilter() {
//        FilterRegistrationBean registration = new FilterRegistrationBean();
//        registration.setFilter(new NoHttpSessionFilter());
//        registration.addUrlPatterns("/*");
//        return registration;
//    }
//    @Bean
//    @Autowired
//    public CookieSecurityContextRepository securityContextRepository(final String sessionEncryptionKeyBase64) {
//        return new CookieSecurityContextRepository(new JwtEncryption(""));
//    }
//
//    @Bean
//    public CookieRequestCache cookieRequestCache() {
//        return new CookieRequestCache();
//    }
//
//    @Bean
//    public FilterRegistrationBean httpsOnlyFilter() {
//        FilterRegistrationBean registration = new FilterRegistrationBean();
//        registration.setFilter(new HttpsOnlyFilter());
//        registration.addUrlPatterns("/*");
//        return registration;
//    }
}
--------------------------------------------------------------------------------------------------------
@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = DEFAULT_DATE_FORMAT_PATTERN_EXT, locale = DEFAULT_DATE_FORMAT_LOCALE)
--------------------------------------------------------------------------------------------------------
import java.io.Serializable;

/**
 * Functional interface for lambda-based tests that accept 1 parameter.
 *
 * @author Sam Brannen
 * @since 5.0
 */
@FunctionalInterface
public interface Lambda1<T1> extends Serializable {

	void execute(T1 t1);

}
--------------------------------------------------------------------------------------------------------
	@Configuration
	@EnableWebMvc
	@EnableTransactionManagement
	@ComponentScan(includeFilters = @Filter(TransactionalRestController.class), useDefaultFilters = false)
	static class Config {

		@Bean
		public DataSource dataSource() throws SQLException {
			DataSource dataSource = mock(DataSource.class);
			when(dataSource.getConnection()).thenReturn(mock(Connection.class));
			return dataSource;
		}

		@Bean
		public DataSourceTransactionManager transactionManager() throws SQLException {
			return new DataSourceTransactionManager(dataSource());
		}
	}
--------------------------------------------------------------------------------------------------------
import java.sql.SQLException;

import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Recover;
import org.springframework.retry.annotation.Retryable;

public interface MyService {

    @Retryable
    void retryService();

    @Retryable(value = { SQLException.class }, maxAttempts = 2, backoff = @Backoff(delay = 5000))
    void retryServiceWithRecovery(String sql) throws SQLException;

    @Recover
    void recover(SQLException e, String sql);

    void templateRetryService();
}
--------------------------------------------------------------------------------------------------------
import lombok.EqualsAndHashCode;
import lombok.ToString;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;
import java.util.concurrent.atomic.AtomicInteger;

@Component
@EqualsAndHashCode
@ToString
public class SessionCountListener implements HttpSessionListener {

    private final AtomicInteger sessionCount = new AtomicInteger();

    @Override
    public void sessionCreated(final HttpSessionEvent se) {
        this.sessionCount.incrementAndGet();
        setActiveSessionCount(se);
    }

    @Override
    public void sessionDestroyed(final HttpSessionEvent se) {
        this.sessionCount.decrementAndGet();
        setActiveSessionCount(se);
    }

    private void setActiveSessionCount(final HttpSessionEvent se) {
        se.getSession().getServletContext().setAttribute("activeSessions", this.sessionCount.get());
        System.out.println("Total Active Session: " + this.sessionCount.get());
    }
}
--------------------------------------------------------------------------------------------------------
package jcg.zheng.demo.web.service;
 
import java.util.List;
 
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
 
import jcg.zheng.demo.web.api.UserResource;
import jcg.zheng.demo.web.data.User;
 
@Component
public class UserResourceImpl implements UserResource {
 
    @Autowired
    private UserService userSrv;
 
    @Override
    // @RequiresPermissions(type = "role", value = "10")
    public User createUser(User user) {
        return userSrv.saveUser(user);
    }
 
    @Override
//  @RequiresPermissions(type = "role", value = "1")
    public List<User> getUsers() {
        return userSrv.getUsers();
    }
}
--------------------------------------------------------------------------------------------------------
package jcg.zheng.demo.customannotation;
 
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
 
//Retained at runtime (so we can use them with Reflection).
//Applied to a method
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD )
public @interface RequiresPermissions {
 String type() default "";
 
 String value() default "";
}


package jcg.zheng.demo.web.security;
 
import java.io.IOException;
import java.util.List;
 
import javax.ws.rs.NotAuthorizedException;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.container.ResourceInfo;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MultivaluedMap;
 
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.util.CollectionUtils;
 
import jcg.zheng.demo.customannotation.RequiresPermissions;
import jcg.zheng.demo.web.data.User;
import jcg.zheng.demo.web.service.UserService;
 
public class RequiresPermissionsFilter implements ContainerRequestFilter {
 
    private static final String SUPER_USER = "MZheng";
 
    @Context
    private ApplicationContext applicationContext;
 
    @Context
    private ResourceInfo resourceInfo;
 
    @Autowired
    private UserService userSrv;
 
    @Override
    public void filter(ContainerRequestContext requestContext) throws IOException {
        RequiresPermissions annotation = AnnotationUtils.findAnnotation(resourceInfo.getResourceMethod(),
                RequiresPermissions.class);
        if (annotation != null) {
            MultivaluedMap<String, String> headers = requestContext.getHeaders();
            processPermission(headers, annotation);
        }
 
    }
 
    private void processPermission(MultivaluedMap<String, String> headers, RequiresPermissions permission) {
        String permissionValue = permission.value();
        String permissionType = permission.type();
        if ("role".equalsIgnoreCase(permissionType)) {
            // need to check the header user id's role match to the permission role
            List<String> requestUserId = headers.get("requestUserId");
            if (CollectionUtils.isEmpty(requestUserId)) {
                throw new NotAuthorizedException("Missing security header");
            }
 
            if (!requestUserId.get(0).equalsIgnoreCase(SUPER_USER)) {
                Integer requestUserNum = Integer.valueOf(requestUserId.get(0));
                User requestUser = userSrv.getUser(requestUserNum);
                if (requestUser == null) {
                    throw new NotAuthorizedException("Invalid requestUserId");
                }
                Integer userRoleInt = Integer.valueOf(requestUser.getRole());
                Integer permissionRoleInt = Integer.valueOf(permissionValue);
                if (userRoleInt < permissionRoleInt) {
                    throw new NotAuthorizedException(
                            "Not Authorized for the method, request user must have a role=" + permissionValue);
                }
            }
        }
    }
}
--------------------------------------------------------------------------------------------------------
/* parse each line */CSVParserparser=CSVParser.parse(line,CSVFormat.RFC4180);for(CSVRecordcr:parser){intid=cr.get(1);// columns start at 1 not 0 !!!intyear=cr.get(2);Stringcity=cr.get(3);}

JSONParserparser=newJSONParser();try{JSONObjectjObj=(JSONObject)parser.parse(newFileReader("data.json"));// TODO do something with jObj}catch(IOException|ParseExceptione){System.err.println(e.getMessage());}

JSONParserparser=newJSONParser();try{JSONArrayjArr=(JSONArray)parser.parse(newFileReader("data.json"));// TODO do something with jObj}catch(IOException|ParseExceptione){System.err.println(e.getMessage());}
--------------------------------------------------------------------------------------------------------
/**
 * uses hashing trick to store terms in large hashmap to avoid collisions
 * @author Michael Brzustowicz
 */
public class HashingDictionary implements Dictionary {
    private int numTerms; // 2^n is optimal

    public HashingDictionary() {
        // 2^20 = 1048576
        this(new Double(Math.pow(2,20)).intValue());
    }

    public HashingDictionary(int numTerms) {
        this.numTerms = numTerms;
    }
    
    @Override
    public Integer getTermIndex(String term) {
        return Math.floorMod(term.hashCode(), numTerms);
    }

    @Override
    public int getNumTerms() {
        return numTerms;
    }
}
--------------------------------------------------------------------------------------------------------
java --module-path com.jdojo.policy\build\classes;com.jdojo.claim\build\classes --module com.jdojo.claim/com.jdojo.claim.Main

FOR /F "tokens=1 delims=" %%A in ('dir com.jdojo.policy\src\*.java /S /B') do javac -d com.jdojo.policy\build\classes %%A

FOR /F "tokens=1 delims=" %%A in ('dir com.jdojo.intro\src\*.java /S /B') do javac --module-path com.jdojo.intro\build\classes -d com.jdojo.intro\build\classes %%A

FOR /F "tokens=1 delims=" %%A in ('dir com.jdojo.claim\src\*.java /S /B') do javac --module-path com.jdojo.policy\build\classes -d com.jdojo.claim\build\classes %%A

FOR /F "tokens=1 delims=" %%A in ('dir src\*.java /S /B') do javac -d build\classes %%A
--------------------------------------------------------------------------------------------------------
import jdk.incubator.http.HttpHeaders;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalLong;
import java.util.Set;
import java.util.TreeMap;

/**
 * Implementation of HttpHeaders.
 */
public class HttpHeadersImpl implements HttpHeaders {

    private final TreeMap<String,List<String>> headers;

    public HttpHeadersImpl() {
        headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
    }

    @Override
    public Optional<String> firstValue(String name) {
        List<String> l = headers.get(name);
        return Optional.ofNullable(l == null ? null : l.get(0));
    }

    @Override
    public List<String> allValues(String name) {
        return headers.get(name);
    }

    @Override
    public Map<String, List<String>> map() {
        return Collections.unmodifiableMap(headers);
    }

    public Map<String, List<String>> directMap() {
        return headers;
    }

    // package private mutators

    public HttpHeadersImpl deepCopy() {
        HttpHeadersImpl h1 = new HttpHeadersImpl();
        TreeMap<String,List<String>> headers1 = h1.headers;
        Set<String> keys = headers.keySet();
        for (String key : keys) {
            List<String> vals = headers.get(key);
            List<String> vals1 = new ArrayList<>(vals);
            headers1.put(key, vals1);
        }
        return h1;
    }

    public void addHeader(String name, String value) {
        headers.computeIfAbsent(name, k -> new ArrayList<>(1))
               .add(value);
    }

    public void setHeader(String name, String value) {
        List<String> values = new ArrayList<>(1); // most headers has one value
        values.add(value);
        headers.put(name, values);
    }

    @Override
    public OptionalLong firstValueAsLong(String name) {
        List<String> l = headers.get(name);
        if (l == null) {
            return OptionalLong.empty();
        } else {
            String v = l.get(0);
            return OptionalLong.of(Long.parseLong(v));
        }
    }

    public void clear() {
        headers.clear();
    }
}
--------------------------------------------------------------------------------------------------------
public static void startProcess(ProcessBuilder.Redirect outputDest) {                try {            ProcessBuilder pb = new ProcessBuilder()                    .command("java", "-version")                                        .redirectOutput(outputDest)                    .redirectError(outputDest);            Process process = pb.start();            process.waitFor();        } catch (IOException | InterruptedException e) {            e.printStackTrace();        }    }

-Xlint:unchecked
java -Xlog:gc*=debug,exit*=off --module-path com.jdojo.intro\dist--module com.jdojo.intro/com.jdojo.intro.Welcome
java -Xlog:gc=trace:stdout:level,time,tags--module-path com.jdojo.intro\dist--module com.jdojo.intro/com.jdojo.intro.Welcome

public static void testFlatMapping(){        Map<String,Set<List<String>>> langByDept = Employee.employees()                .stream()                .collect(groupingBy(Employee::getDepartment,                                mapping(Employee::getSpokenLanguages, toSet())));                        System.out.println("Languages spoken by department using mapping():");        System.out.println(langByDept);        Map<String,Set<String>> langByDept2 = Employee.employees()                .stream()                .collect(groupingBy(Employee::getDepartment,                                flatMapping(e -> e.getSpokenLanguages().stream(), toSet())));          System.out.println("\nLanguages spoken by department using flapMapping():");        System.out.println(langByDept2) ;           }
et<String> nonNullvalues = map.entrySet()           .stream()                      .flatMap(e ->  e.getValue() == null ? Stream.empty() : Stream.of(e.getValue()))           .collect(toSet());

javac -Xlint:deprecation -d ..\build\classes com\jdojo\deprecation\ImportDeprecationWarning.java
jdeprscan --list --release 8

public static void main(String[] args) {        // Create an array of snippets to evaluate/execute        // them sequentially        String[] snippets = { "int x = 100;",                              "double x = 190.89;",                              "long multiply(int value) {return value * multiplier;}",                              "int multiplier = 2;",                              "multiply(200)",                              "mul(99)"                            };        try (JShell shell = JShell.create()) {            // Register a snippet event handler            shell.onSnippetEvent(JShellApiTest::snippetEventHandler);            // Evaluate all snippets            for(String snippet : snippets) {                shell.eval(snippet);                System.out.println("------------------------");            }        }    }

try (JShell shell = JShell.create()) {    // Create a snippet    String snippet = "int x = 100;";    shell.eval(snippet)         .forEach((SnippetEvent se) -> {              Snippet s = se.snippet();              System.out.printf("Snippet: %s%n", s.source());              System.out.printf("Kind: %s%n", s.kind());              System.out.printf("Sub-Kind: %s%n", s.subKind());              System.out.printf("Previous Status: %s%n", se.previousStatus());              System.out.printf("Current Status: %s%n", se.status());              System.out.printf("Value: %s%n", se.value());        });}
--------------------------------------------------------------------------------------------------------
jshell> /set mode silent|  /set mode silent -quiet|  /set prompt silent "-> " ">> "|  /set format silent display ""|  /set format silent err "%6$s"|  /set format silent errorline "    {err}%n

|  /set format silent errorpost "%n"|  /set format silent errorpre "|  "|  /set format silent errors "%5$s"|  /set format silent name "%1$s"|  /set format silent post "%n"|  /set format silent pre "|  "|  /set format silent type "%2$s"|  /set format silent unresolved "%4$s"|  /set format silent value "%3$s"|  /set truncation silent 80|  /set truncation silent 1000 expression,varvalue

• /set start [-retain] <file>• /set start [-retain] -default• /set start [-retain] -none
--------------------------------------------------------------------------------------------------------
public enum TradingSignal {
	LONG, SHORT, NONE;

	public TradingSignal flip() {
		switch (this) {
		case LONG:
			return SHORT;
		case SHORT:
			return LONG;
		default:
			return this;
		}
	}
}

import org.joda.time.DateTime;

import com.precioustech.fxtrading.instrument.TradeableInstrument;

public class Price<T> {
	private final TradeableInstrument<T> instrument;
	private final double bidPrice, askPrice;
	private final DateTime pricePoint;

	public TradeableInstrument<T> getInstrument() {
		return instrument;
	}

	public double getBidPrice() {
		return bidPrice;
	}

	public double getAskPrice() {
		return askPrice;
	}

	public DateTime getPricePoint() {
		return pricePoint;
	}

	public Price(TradeableInstrument<T> instrument, double bidPrice, double askPrice, DateTime pricePoint) {
		this.instrument = instrument;
		this.bidPrice = bidPrice;
		this.askPrice = askPrice;
		this.pricePoint = pricePoint;
	}
}

import org.joda.time.DateTime;

import com.google.common.eventbus.EventBus;
import com.precioustech.fxtrading.instrument.TradeableInstrument;

/**
 * A callback handler for a market data event. The separate streaming event
 * handler upstream, is responsible for handling and parsing the incoming event
 * from the market data source and invoke the onMarketEvent of this handler,
 * which in turn can disseminate the event if required, further downstream.
 * Ideally, the implementer of this interface, would drop the event on a queue
 * for asynchronous processing or use an event bus for synchronous processing.
 * 
 * @author Shekhar Varshney
 *
 * @param <T>
 *            The type of instrumentId in class TradeableInstrument
 * @see TradeableInstrument
 * @see EventBus
 */
public interface MarketEventCallback<T> {
	/**
	 * A method, invoked by the upstream handler of streaming market data
	 * events. This invocation of this method is synchronous, therefore the
	 * method should return asap, to make sure that the upstream events do not
	 * queue up.
	 * 
	 * @param instrument
	 * @param bid
	 * @param ask
	 * @param eventDate
	 */
	void onMarketEvent(TradeableInstrument<T> instrument, double bid, double ask, DateTime eventDate);
}

import org.joda.time.DateTime;

import com.google.common.eventbus.EventBus;
import com.precioustech.fxtrading.instrument.TradeableInstrument;

public class MarketEventHandlerImpl<T> implements MarketEventCallback<T> {

	private final EventBus eventBus;

	public MarketEventHandlerImpl(EventBus eventBus) {
		this.eventBus = eventBus;
	}

	@Override
	public void onMarketEvent(TradeableInstrument<T> instrument, double bid, double ask, DateTime eventDate) {
		MarketDataPayLoad<T> payload = new MarketDataPayLoad<T>(instrument, bid, ask, eventDate);
		eventBus.post(payload);

	}
}


public enum CandleStickGranularity {

	S5(5, "5 seconds"), // 5s
	S10(10, "10 seconds"), // 10s
	S15(15, "15 seconds"), // 15s
	S30(30, "30 seconds"), // 30s
	M1(60 * 1, "1 minute"), // 1min
	M2(60 * 2, "2 minutes"), // 2mins
	M3(60 * 3, "3 minutes"), // 3mins
	M5(60 * 5, "5 minutes"), // 5mins
	M10(60 * 10, "10 minutes"), // 10mins
	M15(60 * 15, "15 minutes"), // 15mins
	M30(60 * 30, "30 minutes"), // 30mins
	H1(60 * 60, "1 hour"), // 1hr
	H2(60 * 60 * 2, "2 hours"), // 2hr
	H3(60 * 60 * 3, "3 hours"), // 3hr
	H4(60 * 60 * 4, "4 hours"), // 4hr
	H6(60 * 60 * 6, "6 hours"), // 6hr
	H8(60 * 60 * 8, "8 hours"), // 8hr
	H12(60 * 60 * 12, "12 hours"), // 12hr
	D(60 * 60 * 24, "1 day"), // 1day
	W(60 * 60 * 24 * 7, "1 week"), // 1wk
	M(60 * 60 * 24 * 30, "1 month");// 1mth

	private final long granularityInSeconds;
	private final String label;

	private CandleStickGranularity(long granularityInSeconds, String label) {
		this.granularityInSeconds = granularityInSeconds;
		this.label = label;
	}

	public long getGranularityInSeconds() {
		return granularityInSeconds;
	}

	public String getLabel() {
		return label;
	}

	public String getName() {
		return name();
	}
}
--------------------------------------------------------------------------------------------------------
public class ConcurrentObjectAccumulator implements        BiConsumer<List<Product>, Path> {    private String word;    public ConcurrentObjectAccumulator(String word) {        this.word = word;    }

@Override    public void accept(List<Product> list, Path path) {        Product product=ProductLoader.load(path);        if (product.getTitle().toLowerCase().contains           (word.toLowerCase())) {            list.add(product);        }    }}
--------------------------------------------------------------------------------------------------------
import org.junit.Test;
import org.openqa.selenium.By;

import static com.codeborne.selenide.Selenide.*;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.junit.Assert.assertThat;

public class SelenideTest {
    @Test
    public void wikipediaSearchFeature() throws InterruptedException {
        // Opening Wikipedia page
        open("http://en.wikipedia.org/wiki/Main_Page");

        // Searching TDD
        $(By.name("search")).setValue("Test-driven development");

        // Clicking search button
        $(By.name("go")).click();

        // Checks
        assertThat(title(), startsWith("Test-driven development"));
    }
}


import org.junit.Test;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.firefox.FirefoxDriver;

import static org.hamcrest.CoreMatchers.startsWith;
import static org.junit.Assert.assertThat;

public class SeleniumTest {
    @Test
    public void wikipediaSearchFeature() throws InterruptedException {
        // Declaring the web driver used for web browsing
        WebDriver driver = new FirefoxDriver();

        // Opening Wikipedia page
        driver.get("http://en.wikipedia.org/wiki/Main_Page");

        // Searching TDD
        WebElement query = driver.findElement(By.name("search"));
        query.sendKeys("Test-driven development");

        // Clicking search button
        WebElement goButton = driver.findElement(By.name("go"));
        goButton.click();

        // Checks
        assertThat(driver.getTitle(), startsWith("Test-driven development"));

        driver.quit();
    }
}


import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;
import org.openqa.selenium.By;

import static com.codeborne.selenide.Selenide.*;
import static org.hamcrest.CoreMatchers.containsString;
import static org.junit.Assert.assertThat;

public class WebSteps {
    @Given("^I go to Wikipedia homepage$")
    @org.jbehave.core.annotations.Given("I go to Wikipedia homepage")
    public void goToWikiPage() {
        open("http://en.wikipedia.org/wiki/Main_Page");
    }

    @When("^I enter the value (.*) on a field named (.*)$")
    @org.jbehave.core.annotations.When("I enter the value $value on a field named $fieldName")
    public void enterValueOnFieldByName(String value, String fieldName){
        $(By.name(fieldName)).setValue(value);
    }

    @When("^I click the button (.*)$")
    @org.jbehave.core.annotations.When("I click the button $buttonName")
    public void clickButonByName(String buttonName){
        $(By.name(buttonName)).click();
    }

    @Then("^the page title contains (.*)$")
    @org.jbehave.core.annotations.Then("the page title contains $title")
    public void pageTitleIs(String title) {
        assertThat(title(), containsString(title));
    }

}
--------------------------------------------------------------------------------------------------------
import java.io.IOException;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.ObjectProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Conditional;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.DefaultResourceLoader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
import org.togglz.console.TogglzConsoleServlet;
import org.togglz.core.Feature;
import org.togglz.core.activation.ActivationStrategyProvider;
import org.togglz.core.activation.DefaultActivationStrategyProvider;
import org.togglz.core.manager.CompositeFeatureProvider;
import org.togglz.core.manager.EnumBasedFeatureProvider;
import org.togglz.core.manager.FeatureManager;
import org.togglz.core.manager.FeatureManagerBuilder;
import org.togglz.core.manager.PropertyFeatureProvider;
import org.togglz.core.repository.StateRepository;
import org.togglz.core.repository.cache.CachingStateRepository;
import org.togglz.core.repository.composite.CompositeStateRepository;
import org.togglz.core.repository.file.FileBasedStateRepository;
import org.togglz.core.repository.mem.InMemoryStateRepository;
import org.togglz.core.spi.ActivationStrategy;
import org.togglz.core.spi.FeatureProvider;
import org.togglz.core.user.NoOpUserProvider;
import org.togglz.core.user.UserProvider;
import org.togglz.spring.boot.autoconfigure.TogglzProperties.FeatureSpec;
import org.togglz.spring.listener.TogglzApplicationContextBinderApplicationListener;
import org.togglz.spring.listener.TogglzApplicationContextBinderApplicationListener.ContextRefreshedEventFilter;
import org.togglz.spring.security.SpringSecurityUserProvider;
import org.togglz.spring.web.FeatureInterceptor;

import com.github.heneke.thymeleaf.togglz.TogglzDialect;

/**
 * {@link EnableAutoConfiguration Auto-configuration} for Togglz.
 *
 * @author Marcel Overdijk
 */
@Configuration
@ConditionalOnProperty(prefix = "togglz", name = "enabled", matchIfMissing = true)
@EnableConfigurationProperties(TogglzProperties.class)
public class TogglzAutoConfiguration {

    @Bean
    public TogglzApplicationContextBinderApplicationListener togglzApplicationContextBinderApplicationListener(
        ObjectProvider<ContextRefreshedEventFilter> contextRefreshedEventFilter) {
        return new TogglzApplicationContextBinderApplicationListener(contextRefreshedEventFilter.getIfAvailable());
    }

    @Configuration
    @ConditionalOnMissingBean(FeatureProvider.class)
    protected static class FeatureProviderConfiguration {

        @Autowired
        private TogglzProperties properties;

        @Bean
        public FeatureProvider featureProvider() {
            PropertyFeatureProvider provider = new PropertyFeatureProvider(properties.getFeatureProperties());
            Class<? extends Feature>[] featureEnums = properties.getFeatureEnums();
            if (featureEnums != null && featureEnums.length > 0) {
                return new CompositeFeatureProvider(new EnumBasedFeatureProvider(featureEnums), provider);
            } else {
                return provider;
            }
        }
    }

    @Configuration
    @ConditionalOnMissingBean(FeatureManager.class)
    protected static class FeatureManagerConfiguration {

        @Autowired
        private TogglzProperties properties;

        @Bean
        public FeatureManager featureManager(FeatureProvider featureProvider, List<StateRepository> stateRepositories,
                UserProvider userProvider, ActivationStrategyProvider activationStrategyProvider) {
            StateRepository stateRepository = null;
            if (stateRepositories.size() == 1) {
                stateRepository = stateRepositories.get(0);
            } else if (stateRepositories.size() > 1) {
                stateRepository = new CompositeStateRepository(
                        stateRepositories.toArray(new StateRepository[stateRepositories.size()]));
            }
            // If caching is enabled wrap state repository in caching state
            // repository.
            // Note that we explicitly check if the state repository is not
            // already a caching state repository,
            // as the auto configuration of the state repository already creates
            // a caching state repository if needed.
            // The below wrapping only occurs if the user provided the state
            // repository manually and caching is enabled.
            if (properties.getCache().isEnabled() && !(stateRepository instanceof CachingStateRepository)) {
                stateRepository = new CachingStateRepository(stateRepository, properties.getCache().getTimeToLive(),
                        properties.getCache().getTimeUnit());
            }
            FeatureManagerBuilder featureManagerBuilder = new FeatureManagerBuilder();
            String name = properties.getFeatureManagerName();
            if (name != null && name.length() > 0) {
                featureManagerBuilder.name(name);
            }
            featureManagerBuilder.featureProvider(featureProvider).stateRepository(stateRepository)
                    .userProvider(userProvider).activationStrategyProvider(activationStrategyProvider).build();
            FeatureManager manager = featureManagerBuilder.build();
            return manager;
        }
    }

    @Configuration
    @ConditionalOnMissingBean(ActivationStrategyProvider.class)
    protected static class ActivationStrategyProviderConfiguration {

        @Autowired(required = false)
        private List<ActivationStrategy> activationStrategies;

        @Bean
        public ActivationStrategyProvider activationStrategyProvider() {
            DefaultActivationStrategyProvider provider = new DefaultActivationStrategyProvider();
            if (activationStrategies != null && activationStrategies.size() > 0) {
                provider.addActivationStrategies(activationStrategies);
            }
            return provider;
        }
    }

    @Configuration
    @ConditionalOnMissingBean(StateRepository.class)
    protected static class StateRepositoryConfiguration {

        @Autowired
        private ResourceLoader resourceLoader = new DefaultResourceLoader();

        @Autowired
        private TogglzProperties properties;

        @Bean
        public StateRepository stateRepository() throws IOException {
            StateRepository stateRepository;
            String featuresFile = properties.getFeaturesFile();
            if (featuresFile != null) {
                Resource resource = this.resourceLoader.getResource(featuresFile);
                Integer minCheckInterval = properties.getFeaturesFileMinCheckInterval();
                if (minCheckInterval != null) {
                    stateRepository = new FileBasedStateRepository(resource.getFile(), minCheckInterval);
                } else {
                    stateRepository = new FileBasedStateRepository(resource.getFile());
                }
            } else {
                Map<String, FeatureSpec> features = properties.getFeatures();
                stateRepository = new InMemoryStateRepository();
                for (String name : features.keySet()) {
                    stateRepository.setFeatureState(features.get(name).state(name));
                }
            }
            // If caching is enabled wrap state repository in caching state
            // repository.
            if (properties.getCache().isEnabled()) {
                stateRepository = new CachingStateRepository(stateRepository, properties.getCache().getTimeToLive(),
                        properties.getCache().getTimeUnit());
            }
            return stateRepository;
        }
    }

    @Configuration
    @ConditionalOnMissingClass("org.springframework.security.config.annotation.web.configuration.EnableWebSecurity")
    @ConditionalOnMissingBean(UserProvider.class)
    protected static class UserProviderConfiguration {
        @Bean
        public UserProvider userProvider() {
            return new NoOpUserProvider();
        }
    }

    @Configuration
    @ConditionalOnClass({ EnableWebSecurity.class, AuthenticationEntryPoint.class, SpringSecurityUserProvider.class })
    @ConditionalOnMissingBean(UserProvider.class)
    protected static class SpringSecurityUserProviderConfiguration {

        @Autowired
        private TogglzProperties properties;

        @Bean
        public UserProvider userProvider() {
            return new SpringSecurityUserProvider(properties.getConsole().getFeatureAdminAuthority());
        }
    }

    @Configuration
    @ConditionalOnWebApplication
    @ConditionalOnClass(TogglzConsoleServlet.class)
    @Conditional(TogglzConsoleBaseConfiguration.OnConsoleAndNotUseManagementPort.class)
    protected static class TogglzConsoleConfiguration extends TogglzConsoleBaseConfiguration {

        public TogglzConsoleConfiguration(TogglzProperties properties) {
            super(properties);
        }
    }

    @Configuration
    @ConditionalOnWebApplication
    @ConditionalOnClass(HandlerInterceptorAdapter.class)
    @ConditionalOnProperty(prefix = "togglz.web", name = "register-feature-interceptor", havingValue = "true")
    protected static class TogglzFeatureInterceptorConfiguration extends WebMvcConfigurerAdapter {
        @Override
        public void addInterceptors(InterceptorRegistry registry) {
            registry.addInterceptor(new FeatureInterceptor());
        }
    }

    @Configuration
    @ConditionalOnClass(TogglzDialect.class)
    protected static class ThymeleafTogglzDialectConfiguration {

        @Bean
        @ConditionalOnMissingBean
        public TogglzDialect togglzDialect() {
            return new TogglzDialect();
        }
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.condition.AllNestedConditions;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.togglz.console.TogglzConsoleServlet;

/**
 * Base {@link EnableAutoConfiguration Auto-configuration} class for Togglz Console.
 *
 * <p>Provides a common ground implementation for console on management port or on the
 * application port, as well as for Spring Boot 1.5 and Spring Boot 2.
 *
 * @author Marcel Overdijk
 * @author Rui Figueira
 */
public abstract class TogglzConsoleBaseConfiguration {

    private final TogglzProperties properties;

    protected TogglzConsoleBaseConfiguration(TogglzProperties properties) {
        this.properties = properties;
    }

    @Bean
    public ServletRegistrationBean togglzConsole() {
        String path = getContextPath() + properties.getConsole().getPath();
        String urlMapping = (path.endsWith("/") ? path + "*" : path + "/*");
        TogglzConsoleServlet servlet = new TogglzConsoleServlet();
        servlet.setSecured(properties.getConsole().isSecured());
        return new ServletRegistrationBean(servlet, urlMapping);
    }

    protected String getContextPath() {
        return "";
    }

    public static class OnConsoleAndUseManagementPort extends AllNestedConditions {

        OnConsoleAndUseManagementPort() {
            super(ConfigurationPhase.PARSE_CONFIGURATION);
        }

        @ConditionalOnProperty(prefix = "togglz.console", name = "enabled", matchIfMissing = true)
        static class OnConsole {
        }
        
        @ConditionalOnProperty(prefix = "togglz.console", name = "use-management-port", havingValue = "true", matchIfMissing = true)
        static class OnUseManagementPort {
        }

    }

    public static class OnConsoleAndNotUseManagementPort extends AllNestedConditions {

        OnConsoleAndNotUseManagementPort() {
            super(ConfigurationPhase.PARSE_CONFIGURATION);
        }

        @ConditionalOnProperty(prefix = "togglz.console", name = "enabled", matchIfMissing = true)
        static class OnConsole {
        }

        @ConditionalOnProperty(prefix = "togglz.console", name = "use-management-port", havingValue = "false")
        static class OnNotUseManagementPort {
        }

    }
}
--------------------------------------------------------------------------------------------------------
 * public boolean isActive() {
 *     return FeatureContext.getFeatureManager().isActive(this);
 * }
--------------------------------------------------------------------------------------------------------
@Bean
public FeatureProvider featureProvider() {
    return new EnumBasedFeatureProvider(MyFeatures.class);
}
--------------------------------------------------------------------------------------------------------
https://mvnrepository.com/search?q=com.mysema.querydsl
--------------------------------------------------------------------------------------------------------
            <plugin>
                <groupId>com.mysema.maven</groupId>
                <artifactId>maven-apt-plugin</artifactId>
                <version>1.0.3</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>process</goal>
                        </goals>
                        <phase>generate-sources</phase>
                        <configuration>
                            <outputDirectory>${project.basedir}/target/generated-sources/java</outputDirectory>
                            <processor>com.mysema.query.apt.jpa.JPAAnnotationProcessor</processor>
                            <processors>
                                <processor>com.mysema.query.apt.jpa.JPAAnnotationProcessor</processor>
                        </processors>
                        <showWarnings>true</showWarnings>
                    </configuration>
                </execution>
            </executions>
        </plugin>
--------------------------------------------------------------------------------------------------------
"C:\Program Files\Java\jdk1.8.0_191\bin\java.exe" 
-ea 
-Xms1g 
-Xmx1500m 
-Xss256k 
-Didea.test.cyclic.buffer.size=1048576
--------------------------------------------------------------------------------------------------------
<servers>
  <server>
    <id>sonatype-nexus-snapshots</id>
    <username>sonatypeuser</username>
    <password>sonatypepassword</password>
  </server>
  <server>
    <id>sonatype-nexus-staging</id>
    <username>sonatypeuser</username>
    <password>sonatypepassword</password>
  </server>
</servers>

mvn license:update-project-license
mvn dependency:resolve -Dclassifier=sources
mvn versions:display-dependency-updates versions:display-plugin-updates -Pall
mvn validate license:format -Pall
mvn clean org.jacoco:jacoco-maven-plugin:prepare-agent test sonar:sonar

https://prm-wiki.paragon-software.com/pages/viewpage.action?pageId=83889735
https://prm-wiki.paragon-software.com/display/DEVOPS/In-house+k8s+infrastructure
https://gitlab.paragon-software.com/pba/DevOps/ansible/pipelines/62858


http://localhost:8089/api/v0/distributor/download?sku=sku-b7d41c8c&locale=ru&platform=file-platform
http://localhost:8089/api/v0/distributor/download?sku=PSG-1770-BSU-SE-TL-1Y&locale=ru&platform=x86

mvn versions:set -DnewVersion=X.Z-SNAPSHOT -Pall
mvn versions:commit -Pall
git branch -D GD-199-usercontour-mailer-documentsgenerator

    <property name="LOG_FILE" value="{{ crmadapter_logdir }}/Service.log"/>
    <property name="JSON_LOG_FILE" value="{{ crmadapter_logdir }}/Service.json"/>
--------------------------------------------------------------------------------------------------------
https://gitlab.paragon-software.com/pba/DevOps/ansible/

    <property name="LOG_FILE" value="{{ ConfirmationLinkCallback.logdir }}/Service.log"/>
    <property name="JSON_LOG_FILE" value="{{ ConfirmationLinkCallback.logdir }}/Service.json"/>
	
	        <!--<license.licenseResolver>file://${main.basedir}/src/license</license.licenseResolver>-->
        <license.licenseResolver>${project.baseUri}src/license</license.licenseResolver>
--------------------------------------------------------------------------------------------------------
@Value("#{'${listOfValues}'.split(',')}")
private List<String> valuesList;
@Value("#{${valuesMap}.?[value>'1']}")
--------------------------------------------------------------------------------------------------------
ERROR: cannot serialize input value

mvn versions:display-dependency-updates
mvn versions:display-plugin-updates
mvn versions:display-property-updates



#!/bin/sh
(set -o igncr) 2>/dev/null && set -o igncr; # cygwin encoding fix

# Run through the current and parent directories for Brackets.exe
# and execute when found. $0 is the path to this script.

TARGET_PATH="$(dirname "$0")"

case `uname` in
    *CYGWIN*) OS_NAME="CYGWIN";;
    *MINGW32_NT*) OS_NAME="MinGW";;
esac

if [ "$OS_NAME" == "MinGW" ]; then
    # Suprisingly MING32 platform recognizes
    # windows "start" command. Use this against
    # launching .exe as the later is blocking.
    start "Brackets.exe" "$@"
else
    if [ "$OS_NAME" == "CYGWIN" ]; then
        TARGET_PATH=`cygpath -w "$TARGET_PATH"`
    fi

    while [ ! -z "$TARGET_PATH" ] && [ "$TARGET_PATH" != "/" ] && [ "$TARGET_PATH" != "." ]
    do
        if [ -x "$TARGET_PATH/Brackets.exe" ]; then
            break;
        fi

        TARGET_PATH="$(dirname "$TARGET_PATH")"
        if [ OS_NAME == 'CYGWIN' ]; then
            TARGET_PATH=`cygpath -w "$TARGET_PATH"`
        fi
    done

    # Unfortunately windows "start" command is not recognized natively
    # and hence have to launch exe from command line prompt in a blocking
    # way.
    if [ ! -z "$TARGET_PATH" ] && [ -x "$TARGET_PATH/Brackets.exe" ]; then
        "$TARGET_PATH/Brackets.exe" "$@"
    else
        echo "Unable to launch Brackets as Brackets.exe could not be located. Try re-installing Brackets."
    fi
fi



<plugin>
  <groupId>org.codehaus.mojo</groupId>
  <artifactId>versions-maven-plugin</artifactId>
  <version>${maven.versions.plugin}</version>
  <configuration>
    <rulesUri>file:///${session.executionRootDirectory}/config/maven-versions-plugin-rules.xml</rulesUri> 
  </configuration>
</plugin>
--------------------------------------------------------------------------------------------------------
mvn package -B -D maven.repo.local=F:\BuildAgent\work\9d24e4e3ca3c7728\build\..\.build\m2 -U -P CI
--------------------------------------------------------------------------------------------------------
import javax.annotation.Nonnull;

/**
 * Complexity constants. List was taken from <a href="https://en.wikipedia.org/wiki/Time_complexity">the wiki page</a>.
 *
 * @since 1.1.2
 */
public enum Complexity {

  /**
   * <a href="https://en.wikipedia.org/wiki/Time_complexity#Constant_time">Constant value.</a> Example: Determining if an integer (represented in binary) is even or odd.
   * <p>
   * <b>O(1)</b></p>
   *
   * @since 1.1.2
   */
  CONSTANT("O(1)"),
  /**
   * <a href="https://en.wikipedia.org/wiki/Ackermann_function#Inverse">Inverse Ackermann.</a> Example: Amortized time per operation using a disjoint set.
   * <p>
   * <b>O(α(n))</b></p>
   *
   * @since 1.1.2
   */
  INVERSE_ACKERMANN("O(a(n))"),
  /**
   * <a href="https://en.wikipedia.org/wiki/Iterated_logarithm">Iterated logarithmic.</a> Example:
   * <a href="https://en.wikipedia.org/wiki/Graph_coloring#Parallel_and_distributed_algorithms">Distributed coloring of cycles.</a>
   * <p>
   * <b>O(log* n)</b></p>
   *
   * @since 1.1.2
   */
  ITERATED_LOGARITHMIC("O(log* n)"),
  /**
   * <a href="https://en.wikipedia.org/wiki/Time_complexity#Logarithmic_time">Log-logarithmic.</a> Example: Amortized time per operation using a bounded priority queue.
   * <p>
   * <b>O(log log n)</b></p>
   *
   * @since 1.1.2
   */
  LOG_LOGARITHMIC("O(log log n)"),
  /**
   * <a href="https://en.wikipedia.org/wiki/Time_complexity#Logarithmic_time">Logarithmic.</a> Example: <a href="https://en.wikipedia.org/wiki/Binary_search">Binary search</a>.
   * <p>
   * <b>O(log n)</b></p>
   *
   * @since 1.1.2
   */
  LOGARITHMIC("O(log n)"),
  /**
   * <a href="https://en.wikipedia.org/wiki/Time_complexity#Logarithmic_time">Polylogarithmic.</a>
   * <p>
   * <b>poly(log n)</b></p>
   *
   * @since 1.1.2
   */
  POLYLOGARITHMIC("poly(log n)"),
  /**
   * Fractional power. Example: <a href="https://en.wikipedia.org/wiki/Kd-tree">Searching in a kd-tree</a>.
   * <p>
   * <b>O(n<sup>c</sup>) where 0 &lt; c &lt; 1 </b></p>
   *
   * @since 1.1.2
   */
  FRACTIONAL_POWER("O(n^c)"),
  /**
   * <a href="https://en.wikipedia.org/wiki/Time_complexity#Linear_time">Linear</a>. Example: Finding the smallest or largest item in an unsorted array.
   * <p>
   * <b>O(n)</b></p>
   *
   * @since 1.1.2
   */
  LINEAR("O(n)"),
  /**
   * n log star n. Example: <a href="https://en.wikipedia.org/wiki/Polygon_triangulation">Seidel's polygon triangulation algorithm</a>.
   * <p>
   * <b>O(n log* n)</b></p>
   *
   * @since 1.1.2
   */
  N_LOG_STAR_N("O(n log* n)"),
  /**
   * <a href="https://en.wikipedia.org/wiki/Time_complexity#Linearithmic_time">Lineqarithmic</a>. Example: Fastest possible comparison sort.
   * <p>
   * <b>O(n log n)</b></p>
   *
   * @since 1.1.2
   */
  LINEARITHMIC("O(n log n)"),
  /**
   * Quadratic. Example: Bubble sort; Insertion sort; Direct convolution.
   * <p>
   * <b>O(n<sup>2</sup>)</b></p>
   *
   * @since 1.1.2
   */
  QUADRATIC("O(n^2)"),
  /**
   * Cubic. Example: Naive multiplication of two n×n matrices. Calculating partial correlation.
   * <p>
   * <b>O(n<sup>3</sup>)</b></p>
   *
   * @since 1.1.2
   */
  CUBIC("O(n^3)"),
  /**
   * <a href="https://en.wikipedia.org/wiki/Time_complexity#Polynomial_time">Polynomial</a>. Example: <a href="https://en.wikipedia.org/wiki/Karmarkar's_algorithm">Karmarkar's
   * algorithm for linear programming</a>; AKS primality test.
   * <p>
   * <b>2<sup>O(log n)</sup> = poly(n)</b></p>
   *
   * @since 1.1.2
   */
  POLYNOMIAL("poly(n)"),
  /**
   * <a href="https://en.wikipedia.org/wiki/Time_complexity#Quasi-polynomial_time">Quasi-polinomial</a>. Example: Best-known O(log2 n)-approximation algorithm for the directed
   * Steiner tree problem.
   * <p>
   * <b>2<sup>poly(log n)</sup></b></p>
   *
   * @since 1.1.2
   */
  QUASI_POLYNOMIAL("2^poly(log n)"),
  /**
   * <a href="https://en.wikipedia.org/wiki/Time_complexity#Sub-exponential_time">Sub-exponential</a>. Example: Assuming complexity theoretic conjectures, BPP is contained in
   * SUBEXP.
   * <p>
   * <b>O(2^n^ε) for all ε &gt; 0</b></p>
   *
   * @since 1.1.2
   */
  SUB_EXPONENTIAL("O(2^n^e)"),
  /**
   * <a href="https://en.wikipedia.org/wiki/Time_complexity#Exponential_time">Exponential</a>. Example: Solving matrix chain multiplication via brute-force search.
   * <p>
   * <b>2<sup>O(n)</sup></b></p>
   *
   * @since 1.1.2
   */
  EXPONENTIAL("2^O(n)"),
  /**
   * Factorial. Example: Solving the traveling salesman problem via brute-force search.
   * <p>
   * <b>O(n!)</b></p>
   *
   * @since 1.1.2
   */
  FACTORIAL("O(n!)"),
  /**
   * <a href="https://en.wikipedia.org/wiki/Time_complexity#Double_exponential_time">Double exponential</a>. Example: Deciding the truth of a given statement in Presburger
   * arithmetic.
   * <p>
   * <b>2^2^poly(n)</b></p>
   *
   * @since 1.1.2
   */
  DOUBLE_EXPONENTIAL("2^2^poly(n)");

  private final String formula;

  private Complexity(@Nonnull final String formula) {
    this.formula = formula;
  }

  /**
   * Get the formula.
   *
   * @return formula as string
   * @since 1.1.2
   */
  @Nonnull
  public String getFormula() {
    return this.formula;
  }

  @Override
  @Nonnull
  public String toString() {
    return this.formula;
  }
}
--------------------------------------------------------------------------------------------------------
public static void writeToFileZipFileContents(String zipFileName,
    String outputFileName) throws IOException {
	Charset charset = StandardCharsets.US_ASCII;
    Path outputFilePath = Paths.get(outputFileName);

    try (
        ZipFile zf = new ZipFile(zipFileName);
        BufferedWriter writer = Files.newBufferedWriter(outputFilePath, charset)
    ) {
        for (Enumeration entries = zf.entries(); entries.hasMoreElements();) {
            String newLine = System.getProperty("line.separator");
            String zipEntryName =
                 ((ZipEntry)entries.nextElement()).getName() + newLine;
            writer.write(zipEntryName, 0, zipEntryName.length());
        }
    }
}
--------------------------------------------------------------------------------------------------------
private List<String> aMethodReturningNullList(){
    return null;
}
 
@Test
public void givenNullObject_whenRequireNonNullElse_thenElse() {
    List<String> aList = Objects.<List>requireNonNullElse(
      aMethodReturningNullList(), Collections.EMPTY_LIST);
  
    assertThat(aList, is(Collections.EMPTY_LIST));
}
 
private List<String> aMethodReturningNonNullList() {
    return List.of("item1", "item2");
}
 
@Test
public void givenObject_whenRequireNonNullElse_thenObject() {
    List<String> aList = Objects.<List>requireNonNullElse(
      aMethodReturningNonNullList(), Collections.EMPTY_LIST);
  
    assertThat(aList, is(List.of("item1", "item2")));
}
 
@Test(expected = NullPointerException.class)
public void givenNull_whenRequireNonNullElse_thenException() {
    Objects.<List>requireNonNullElse(null, null);
}
--------------------------------------------------------------------------------------------------------
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;

/**
 * Singleton that will delete directory on normal JVM exit.
 * 
 * @author James Leigh
 * 
 */
public class DirUtil {
	static final Collection<File> temporary = new ArrayList<File>();

	public static File createTempDir(String prefix) throws IOException {
		String tmpDirStr = System.getProperty("java.io.tmpdir");
		if (tmpDirStr == null) {
			tmpDirStr = "tmp";
		}
		File tmpDir = new File(tmpDirStr);
		if (!tmpDir.exists()) {
			tmpDir.mkdirs();
		}
		File dir = File.createTempFile(prefix, "", tmpDir);
		dir.delete();
		dir.mkdirs();
		return dir;
	}

	public static void deleteOnExit(File dir) {
		synchronized (temporary) {
			if (temporary.isEmpty()) {
				Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
					public void run() {
						synchronized (temporary) {
							for (File dir : temporary) {
								deleteFileOrDir(dir, 256);
							}
						}
					}
				}, "Temporary Directory Cleanup"));
			}
			temporary.add(dir);
		}
	}

	static void deleteFileOrDir(File dir, int max) {
		File[] listFiles = dir.listFiles();
		if (listFiles != null && max > 0) {
			for (File file : listFiles) {
				deleteFileOrDir(file, max - 1);
			}
		}
		dir.delete();
	}
}
--------------------------------------------------------------------------------------------------------
Method[] methods = TestClass.class.getMethods();
for (Method m : methods) {
    if (m.isAnnotationPresent(TestAnnotation.class)) {
        TestAnnotation ta = m.getAnnotation(TestAnnotation.class);
        System.out.println(ta.testText());
    }
}
--------------------------------------------------------------------------------------------------------
REM "Use handle.exe to figure out the process id and handle ids, parse the output, then close the handle (again using handle.exe)"

cd "C:\Users\Nikolay_Tkachev\workspace\HHSystem\UI\target"
"c:/Program Files/Process Explorer/handle.exe" -p java.exe "C:\Users\Nikolay_Tkachev\workspace\HHSystem\UI\target" > handles.txt

@echo "O====== Going to unlock all the below file handles! =======O"
FOR /F "tokens=1-26 delims=: " %a in (handles.txt) DO @echo %h
FOR /F "tokens=1-26 delims=: " %a in (handles.txt) DO handle -p %c -c %f -y
--------------------------------------------------------------------------------------------------------
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface Test {

    /**
     * Default empty exception.
     */
    static class None extends Throwable {
        private static final long serialVersionUID = 1L;

        private None() {
        }
    }

    /**
     * Optionally specify <code>expected</code>, a Throwable, to cause a test method to succeed if
     * and only if an exception of the specified class is thrown by the method. If the Throwable's
     * message or one of its properties should be verified, the
     * {@link org.junit.rules.ExpectedException ExpectedException} rule can be used instead.
     */
    Class<? extends Throwable> expected() default None.class;

    /**
     * Optionally specify <code>timeout</code> in milliseconds to cause a test method to fail if it
     * takes longer than that number of milliseconds.
     * <p>
     * <b>THREAD SAFETY WARNING:</b> Test methods with a timeout parameter are run in a thread other than the
     * thread which runs the fixture's @Before and @After methods. This may yield different behavior for
     * code that is not thread safe when compared to the same test method without a timeout parameter.
     * <b>Consider using the {@link org.junit.rules.Timeout} rule instead</b>, which ensures a test method is run on the
     * same thread as the fixture's @Before and @After methods.
     * </p>
     */
    long timeout() default 0L;
}
--------------------------------------------------------------------------------------------------------
The compare-dependencies goal can be used to compare the dependencies in the current project to the dependencyManagement of a remote project. This is useful, for example, for finding differences between the current project dependencies and an organizational bill of materials (BOM) pom. You specify the remote groupId, artifactId, and the version to which the current project should be compared, for example

mvn versions:compare-dependencies -DremotePom=org.foo:bom-pom:1.0
By default the list of dependency differences will be output to the command line. This can be written to a file using the "reportOutputFile" parameter.

mvn versions:compare-dependencies -DremotePom=org.foo:bom-pom:1.0 -DreportOutputFile=${project.build.directory}/depDiffs.txt
The plugin can also automatically update the dependencies of the current project to match the remote project using the "updateDependencies" parameter. By default this is turned off.

mvn versions:compare-dependencies -DremotePom=org.foo:bom-pom:1.0 -DupdateDependencies=true
In addition to that, any property defined in the current project that represent the version of one of several artifacts can be updated to match the remote project using the "updatePropertyVersions" parameter. By default this is turned off.

mvn versions:compare-dependencies -DremotePom=org.foo:bom-pom:1.0 -updatePropertyVersions=true
--------------------------------------------------------------------------------------------------------
@EnableRuleMigrationSupport
public class JUnit4TemporaryFolderTest {
   @Rule
   public TemporaryFolder temporaryFolder = new TemporaryFolder();
   @Test
   public void test() throws IOException {
      temporaryFolder.newFile(“new_file”);
   }
}
--------------------------------------------------------------------------------------------------------
public class SMTPServerRule extends ExternalResource {

   private GreenMail smtpServer;
   private String hostname;
   private int port;

   public SMTPServerRule() {
       this(25);
   }

   public SMTPServerRule(int port) {
       this("localhost", port);
   }

   public SMTPServerRule(String hostname, int port) {
       this.hostname = hostname;
       this.port = port;
   }


   @Override
   protected void before() throws Throwable {
       super.before();

       smtpServer = new GreenMail(new ServerSetup(port, hostname, "smtp"));
       smtpServer.start();
   }

   public List<ExpectedMail> getMessages() {
       return Lists.newArrayList(smtpServer.getReceivedMessages()).stream()
           .parallel()
           .map(mimeMessage -> ExpectedMail.transformMimeMessage(mimeMessage)).collect(Collectors.toList());
   }

   @Override
   protected void after() {
       super.after();
       smtpServer.stop();
   }
}
--------------------------------------------------------------------------------------------------------
import static org.apiguardian.api.API.Status.STABLE;

import java.util.Locale;

import org.apiguardian.api.API;
import org.junit.platform.commons.logging.Logger;
import org.junit.platform.commons.logging.LoggerFactory;
import org.junit.platform.commons.util.StringUtils;

/**
 * Enumeration of common operating systems used for testing Java applications.
 *
 * <p>If the current operating system cannot be detected &mdash; for example,
 * if the {@code os.name} JVM system property is undefined &mdash; then none
 * of the constants defined in this enum will be considered to be the
 * {@linkplain #isCurrentOs current operating system}.
 *
 * @since 5.1
 * @see #AIX
 * @see #LINUX
 * @see #MAC
 * @see #SOLARIS
 * @see #WINDOWS
 * @see #OTHER
 * @see EnabledOnOs
 * @see DisabledOnOs
 */
@API(status = STABLE, since = "5.1")
public enum OS {

	/**
	 * IBM AIX operating system.
	 *
	 * @since 5.3
	 */
	@API(status = STABLE, since = "5.3")
	AIX,

	/**
	 * Linux-based operating system.
	 */
	LINUX,

	/**
	 * Apple Macintosh operating system (e.g., macOS).
	 */
	MAC,

	/**
	 * Oracle Solaris operating system.
	 */
	SOLARIS,

	/**
	 * Microsoft Windows operating system.
	 */
	WINDOWS,

	/**
	 * An operating system other than {@link #AIX}, {@link #LINUX}, {@link #MAC},
	 * {@link #SOLARIS}, or {@link #WINDOWS}.
	 */
	OTHER;

	private static final Logger logger = LoggerFactory.getLogger(OS.class);

	private static final OS CURRENT_OS = determineCurrentOs();

	private static OS determineCurrentOs() {
		String osName = System.getProperty("os.name");

		if (StringUtils.isBlank(osName)) {
			logger.debug(
				() -> "JVM system property 'os.name' is undefined. It is therefore not possible to detect the current OS.");

			// null signals that the current OS is "unknown"
			return null;
		}

		osName = osName.toLowerCase(Locale.ENGLISH);

		if (osName.contains("aix")) {
			return AIX;
		}
		if (osName.contains("linux")) {
			return LINUX;
		}
		if (osName.contains("mac")) {
			return MAC;
		}
		if (osName.contains("sunos") || osName.contains("solaris")) {
			return SOLARIS;
		}
		if (osName.contains("win")) {
			return WINDOWS;
		}
		return OTHER;
	}

	/**
	 * @return {@code true} if <em>this</em> {@code OS} is known to be the
	 * operating system on which the current JVM is executing
	 */
	public boolean isCurrentOs() {
		return this == CURRENT_OS;
	}

}

import static org.apiguardian.api.API.Status.STABLE;

import java.lang.reflect.Method;

import org.apiguardian.api.API;
import org.junit.platform.commons.logging.Logger;
import org.junit.platform.commons.logging.LoggerFactory;
import org.junit.platform.commons.util.ReflectionUtils;
import org.junit.platform.commons.util.StringUtils;

/**
 * Enumeration of Java Runtime Environment (JRE) versions.
 *
 * <p>If the current JRE version cannot be detected &mdash; for example, if the
 * {@code java.version} JVM system property is undefined &mdash; then none of
 * the constants defined in this enum will be considered to be the
 * {@linkplain #isCurrentVersion current JRE version}.
 *
 * @since 5.1
 * @see #JAVA_8
 * @see #JAVA_9
 * @see #JAVA_10
 * @see #JAVA_11
 * @see #JAVA_12
 * @see #JAVA_13
 * @see #JAVA_14
 * @see #OTHER
 * @see EnabledOnJre
 * @see DisabledOnJre
 */
@API(status = STABLE, since = "5.1")
public enum JRE {

	/**
	 * Java 8.
	 */
	JAVA_8,

	/**
	 * Java 9.
	 */
	JAVA_9,

	/**
	 * Java 10.
	 */
	JAVA_10,

	/**
	 * Java 11.
	 */
	JAVA_11,

	/**
	 * Java 12.
	 *
	 * @since 5.4
	 */
	@API(status = STABLE, since = "5.4")
	JAVA_12,

	/**
	 * Java 13.
	 *
	 * @since 5.4
	 */
	@API(status = STABLE, since = "5.4")
	JAVA_13,

	/**
	 * Java 14.
	 *
	 * @since 5.5
	 */
	@API(status = STABLE, since = "5.5")
	JAVA_14,

	/**
	 * A JRE version other than {@link #JAVA_8}, {@link #JAVA_9},
	 * {@link #JAVA_10}, {@link #JAVA_11}, {@link #JAVA_12},
	 * {@link #JAVA_13}, or {@link #JAVA_14}.
	 */
	OTHER;

	private static final Logger logger = LoggerFactory.getLogger(JRE.class);

	private static final JRE CURRENT_VERSION = determineCurrentVersion();

	private static JRE determineCurrentVersion() {
		String javaVersion = System.getProperty("java.version");
		boolean javaVersionIsBlank = StringUtils.isBlank(javaVersion);

		if (javaVersionIsBlank) {
			logger.debug(
				() -> "JVM system property 'java.version' is undefined. It is therefore not possible to detect Java 8.");
		}

		if (!javaVersionIsBlank && javaVersion.startsWith("1.8")) {
			return JAVA_8;
		}

		try {
			// java.lang.Runtime.version() is a static method available on Java 9+
			// that returns an instance of java.lang.Runtime.Version which has the
			// following method: public int major()
			Method versionMethod = Runtime.class.getMethod("version");
			Object version = ReflectionUtils.invokeMethod(versionMethod, null);
			Method majorMethod = version.getClass().getMethod("major");
			int major = (int) ReflectionUtils.invokeMethod(majorMethod, version);
			switch (major) {
				case 9:
					return JAVA_9;
				case 10:
					return JAVA_10;
				case 11:
					return JAVA_11;
				case 12:
					return JAVA_12;
				case 13:
					return JAVA_13;
				case 14:
					return JAVA_14;
				default:
					return OTHER;
			}
		}
		catch (Exception ex) {
			logger.debug(ex, () -> "Failed to determine the current JRE version via java.lang.Runtime.Version.");
		}

		// null signals that the current JRE version is "unknown"
		return null;
	}

	/**
	 * @return {@code true} if <em>this</em> {@code JRE} is known to be the
	 * Java Runtime Environment version for the currently executing JVM
	 */
	public boolean isCurrentVersion() {
		return this == CURRENT_VERSION;
	}
}
--------------------------------------------------------------------------------------------------------
@RunWith(JUnitPlatform.class)
@SelectPackages({net.mednikov.teststutorial.groupA, net.mednikov.teststutorial.groupB, net.mednikov.teststutorial.groupC})
public class TestSuite(){}
--------------------------------------------------------------------------------------------------------
import net.andreinc.jbvext.annotations.digits.MinDigits;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class MinDigitsDoubleValidator implements ConstraintValidator<MinDigits, Double> {

    private MinDigits annotation;

    @Override
    public void initialize(MinDigits constraintAnnotation) {
        this.annotation = constraintAnnotation;
    }

    @Override
    public boolean isValid(Double value, ConstraintValidatorContext context) {

        if (value == null) {
            return false;
        }

        Double minDigitsValue = Double.valueOf(this.annotation.value());

        int result = Double.compare(value, minDigitsValue);

        if (0 == result){
            // Value is equal to min
            return true;
        } else if (result < 0){
            // Value is less than min
            return false;
        } else if (result > 0){
            // Value is greater than min
            return true;
        } else {
            throw new IllegalArgumentException("How this could be possible");
        }

    }
}

DeliveryAcceptedStatus
topic: Delivery
clientId: delivery-status-id
groupId: free-coupons-delivery-status
mapping: 
--------------------------------------------------------------------------------------------------------
import java.util.Arrays;

class Array<E> {

	private final Object[] arr;
	public final int length;

	// constructor
	public Array(int length)
	{
		// Creates a new Object array of specified length
		arr = new Object[length];
		this.length = length;
	}

	// Function to get Object present at index i in the array
	E get(int i) {
		@SuppressWarnings("unchecked")
		final E e = (E)arr[i];
		return e;
	}

	// Function to set a value e at index i in the array
	void set(int i, E e) {
		arr[i] = e;
	}

	@Override
	public String toString() {
		return Arrays.toString(arr);
	}
}

class Main {
	// Program to create a generic array in Java
	public static void main(String[] args)
	{
		final int length = 5;

		// create an Integer array of given length
		Array<Integer> intArray = new Array(length);

		for (int i = 0; i < length; i++)
			intArray.set(i, i + 1);

		System.out.println(intArray);

		// create a String array of given length
		Array<String> strArray = new Array(length);

		for (int i = 0; i < length; i++)
			strArray.set(i, String.valueOf((char)(i + 65)));

		System.out.println(strArray);
	}
}
--------------------------------------------------------------------------------------------------------
- src: 'git@gitlab.paragon-software.com:pba/DevOps/paragon.ansible.k8s.roles/pim.git'
  scm: 'git'
  name: 'pim'

- src: 'git@gitlab.paragon-software.com:pba/DevOps/paragon.ansible.k8s.roles/usercontour.git'
  scm: 'git'
  name: 'usercontour'
  version: GD-199-usercontour-mailer-documentsgenerator

--------------------------------------------------------------------------------------------------------
public LocalDate convertToLocalDate(Date dateToConvert) {
    return LocalDate.ofInstant(
      dateToConvert.toInstant(), ZoneId.systemDefault());
}
 
public LocalDateTime convertToLocalDateTime(Date dateToConvert) {
    return LocalDateTime.ofInstant(
      dateToConvert.toInstant(), ZoneId.systemDefault());
}
--------------------------------------------------------------------------------------------------------
junit-platform.properties

mvn -Dtest=org.example.MyTest test
mvn -Dtest=com.paragon.microservices.freecoupons.exception.ExceptionTest test

JUnit Platform Provider supports the test JVM system property supported by the Maven Surefire Plugin. For example, to run only test methods in the org.example.MyTest test class you can execute 
--------------------------------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<testsuite xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://maven.apache.org/surefire/maven-surefire-plugin/xsd/surefire-test-report-3.0.xsd" version="3.0" name="com.paragon.microservices.freecoupons.client.impl.LicenseClientImplTest" time="2.703" tests="3" errors="2" skipped="0" failures="0">
  <properties>
    <property name="sun.desktop" value="windows"/>
    <property name="awt.toolkit" value="sun.awt.windows.WToolkit"/>
    <property name="file.encoding.pkg" value="sun.io"/>
    <property name="java.specification.version" value="1.8"/>
    <property name="sun.cpu.isalist" value="amd64"/>
    <property name="sun.jnu.encoding" value="Cp1251"/>
    <property name="java.class.path" value="C:\git-project\paragon.microservices.freecoupons\.build\bin\paragon.microservices.freecoupons.service\test-classes;C:\git-project\paragon.microservices.freecoupons\.build\bin\paragon.microservices.freecoupons.service\classes;C:\git-project\paragon.microservices.freecoupons\.build\bin\paragon.microservices.freecoupons.common\classes;C:\Users\rogalski\.m2\repository\org\projectlombok\lombok\1.18.8\lombok-1.18.8.jar;C:\Users\rogalski\.m2\repository\com\paragon\mailingcontour\paragon.mailingcontour.commons\0.3.0-alpha-0352-ef7813f\paragon.mailingcontour.commons-0.3.0-alpha-0352-ef7813f.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-aop\2.1.8.RELEASE\spring-boot-starter-aop-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\aspectj\aspectjweaver\1.9.4\aspectjweaver-1.9.4.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-logging\2.1.8.RELEASE\spring-boot-starter-logging-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\apache\logging\log4j\log4j-to-slf4j\2.11.2\log4j-to-slf4j-2.11.2.jar;C:\Users\rogalski\.m2\repository\org\apache\logging\log4j\log4j-api\2.11.2\log4j-api-2.11.2.jar;C:\Users\rogalski\.m2\repository\org\slf4j\jul-to-slf4j\1.7.28\jul-to-slf4j-1.7.28.jar;C:\Users\rogalski\.m2\repository\org\springframework\retry\spring-retry\1.2.4.RELEASE\spring-retry-1.2.4.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\data\spring-data-redis\2.1.10.RELEASE\spring-data-redis-2.1.10.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\data\spring-data-keyvalue\2.1.10.RELEASE\spring-data-keyvalue-2.1.10.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\data\spring-data-commons\2.1.10.RELEASE\spring-data-commons-2.1.10.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-oxm\5.1.9.RELEASE\spring-oxm-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-context-support\5.1.9.RELEASE\spring-context-support-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\apache\commons\commons-lang3\3.8.1\commons-lang3-3.8.1.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-spi\2.9.2\springfox-spi-2.9.2.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-core\2.9.2\springfox-core-2.9.2.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-spring-web\2.9.2\springfox-spring-web-2.9.2.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-web\2.1.8.RELEASE\spring-boot-starter-web-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter\2.1.8.RELEASE\spring-boot-starter-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\javax\annotation\javax.annotation-api\1.3.2\javax.annotation-api-1.3.2.jar;C:\Users\rogalski\.m2\repository\org\yaml\snakeyaml\1.23\snakeyaml-1.23.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-json\2.1.8.RELEASE\spring-boot-starter-json-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.9.9\jackson-datatype-jdk8-2.9.9.jar;C:\Users\rogalski\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.9.9\jackson-datatype-jsr310-2.9.9.jar;C:\Users\rogalski\.m2\repository\com\fasterxml\jackson\module\jackson-module-parameter-names\2.9.9\jackson-module-parameter-names-2.9.9.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-tomcat\2.1.8.RELEASE\spring-boot-starter-tomcat-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\apache\tomcat\embed\tomcat-embed-core\9.0.24\tomcat-embed-core-9.0.24.jar;C:\Users\rogalski\.m2\repository\org\apache\tomcat\embed\tomcat-embed-websocket\9.0.24\tomcat-embed-websocket-9.0.24.jar;C:\Users\rogalski\.m2\repository\org\hibernate\validator\hibernate-validator\6.0.17.Final\hibernate-validator-6.0.17.Final.jar;C:\Users\rogalski\.m2\repository\org\jboss\logging\jboss-logging\3.3.3.Final\jboss-logging-3.3.3.Final.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-web\5.1.9.RELEASE\spring-web-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-beans\5.1.9.RELEASE\spring-beans-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-webmvc\5.1.9.RELEASE\spring-webmvc-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-expression\5.1.9.RELEASE\spring-expression-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-data-redis\2.1.8.RELEASE\spring-boot-starter-data-redis-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\io\lettuce\lettuce-core\5.1.8.RELEASE\lettuce-core-5.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\io\netty\netty-common\4.1.39.Final\netty-common-4.1.39.Final.jar;C:\Users\rogalski\.m2\repository\io\netty\netty-handler\4.1.39.Final\netty-handler-4.1.39.Final.jar;C:\Users\rogalski\.m2\repository\io\netty\netty-buffer\4.1.39.Final\netty-buffer-4.1.39.Final.jar;C:\Users\rogalski\.m2\repository\io\netty\netty-codec\4.1.39.Final\netty-codec-4.1.39.Final.jar;C:\Users\rogalski\.m2\repository\io\netty\netty-transport\4.1.39.Final\netty-transport-4.1.39.Final.jar;C:\Users\rogalski\.m2\repository\io\netty\netty-resolver\4.1.39.Final\netty-resolver-4.1.39.Final.jar;C:\Users\rogalski\.m2\repository\io\projectreactor\reactor-core\3.2.12.RELEASE\reactor-core-3.2.12.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\reactivestreams\reactive-streams\1.0.3\reactive-streams-1.0.3.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-security\2.1.8.RELEASE\spring-boot-starter-security-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-aop\5.1.9.RELEASE\spring-aop-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\security\spring-security-config\5.1.6.RELEASE\spring-security-config-5.1.6.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\security\spring-security-web\5.1.6.RELEASE\spring-security-web-5.1.6.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-validation\2.1.8.RELEASE\spring-boot-starter-validation-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\apache\tomcat\embed\tomcat-embed-el\9.0.24\tomcat-embed-el-9.0.24.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-actuator\2.1.8.RELEASE\spring-boot-starter-actuator-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-actuator-autoconfigure\2.1.8.RELEASE\spring-boot-actuator-autoconfigure-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-actuator\2.1.8.RELEASE\spring-boot-actuator-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\io\micrometer\micrometer-core\1.1.6\micrometer-core-1.1.6.jar;C:\Users\rogalski\.m2\repository\org\hdrhistogram\HdrHistogram\2.1.9\HdrHistogram-2.1.9.jar;C:\Users\rogalski\.m2\repository\org\latencyutils\LatencyUtils\2.0.3\LatencyUtils-2.0.3.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-devtools\2.1.8.RELEASE\spring-boot-devtools-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot\2.1.8.RELEASE\spring-boot-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-autoconfigure\2.1.8.RELEASE\spring-boot-autoconfigure-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\kafka\spring-kafka\2.2.8.RELEASE\spring-kafka-2.2.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-context\5.1.9.RELEASE\spring-context-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-messaging\5.1.9.RELEASE\spring-messaging-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-tx\5.1.9.RELEASE\spring-tx-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\apache\kafka\kafka-clients\2.0.1\kafka-clients-2.0.1.jar;C:\Users\rogalski\.m2\repository\org\lz4\lz4-java\1.4.1\lz4-java-1.4.1.jar;C:\Users\rogalski\.m2\repository\org\xerial\snappy\snappy-java\1.1.7.1\snappy-java-1.1.7.1.jar;C:\Users\rogalski\.m2\repository\org\springframework\security\spring-security-jwt\1.0.10.RELEASE\spring-security-jwt-1.0.10.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\bouncycastle\bcpkix-jdk15on\1.60\bcpkix-jdk15on-1.60.jar;C:\Users\rogalski\.m2\repository\org\bouncycastle\bcprov-jdk15on\1.60\bcprov-jdk15on-1.60.jar;C:\Users\rogalski\.m2\repository\com\google\guava\guava\28.0-jre\guava-28.0-jre.jar;C:\Users\rogalski\.m2\repository\com\google\guava\failureaccess\1.0.1\failureaccess-1.0.1.jar;C:\Users\rogalski\.m2\repository\com\google\guava\listenablefuture\9999.0-empty-to-avoid-conflict-with-guava\listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar;C:\Users\rogalski\.m2\repository\com\google\code\findbugs\jsr305\3.0.2\jsr305-3.0.2.jar;C:\Users\rogalski\.m2\repository\org\checkerframework\checker-qual\2.8.1\checker-qual-2.8.1.jar;C:\Users\rogalski\.m2\repository\com\google\errorprone\error_prone_annotations\2.3.2\error_prone_annotations-2.3.2.jar;C:\Users\rogalski\.m2\repository\com\google\j2objc\j2objc-annotations\1.3\j2objc-annotations-1.3.jar;C:\Users\rogalski\.m2\repository\org\codehaus\mojo\animal-sniffer-annotations\1.17\animal-sniffer-annotations-1.17.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-swagger2\2.9.2\springfox-swagger2-2.9.2.jar;C:\Users\rogalski\.m2\repository\io\swagger\swagger-annotations\1.5.20\swagger-annotations-1.5.20.jar;C:\Users\rogalski\.m2\repository\io\swagger\swagger-models\1.5.20\swagger-models-1.5.20.jar;C:\Users\rogalski\.m2\repository\com\fasterxml\jackson\core\jackson-annotations\2.9.0\jackson-annotations-2.9.0.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-schema\2.9.2\springfox-schema-2.9.2.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-swagger-common\2.9.2\springfox-swagger-common-2.9.2.jar;C:\Users\rogalski\.m2\repository\com\fasterxml\classmate\1.4.0\classmate-1.4.0.jar;C:\Users\rogalski\.m2\repository\org\slf4j\slf4j-api\1.7.28\slf4j-api-1.7.28.jar;C:\Users\rogalski\.m2\repository\org\springframework\plugin\spring-plugin-core\1.2.0.RELEASE\spring-plugin-core-1.2.0.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\plugin\spring-plugin-metadata\1.2.0.RELEASE\spring-plugin-metadata-1.2.0.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\mapstruct\mapstruct\1.2.0.Final\mapstruct-1.2.0.Final.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-swagger-ui\2.9.2\springfox-swagger-ui-2.9.2.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-bean-validators\2.9.2\springfox-bean-validators-2.9.2.jar;C:\Users\rogalski\.m2\repository\javax\validation\validation-api\2.0.1.Final\validation-api-2.0.1.Final.jar;C:\Users\rogalski\.m2\repository\ch\qos\logback\contrib\logback-json-classic\0.1.5\logback-json-classic-0.1.5.jar;C:\Users\rogalski\.m2\repository\ch\qos\logback\logback-classic\1.2.3\logback-classic-1.2.3.jar;C:\Users\rogalski\.m2\repository\ch\qos\logback\logback-core\1.2.3\logback-core-1.2.3.jar;C:\Users\rogalski\.m2\repository\ch\qos\logback\contrib\logback-json-core\0.1.5\logback-json-core-0.1.5.jar;C:\Users\rogalski\.m2\repository\ch\qos\logback\contrib\logback-jackson\0.1.5\logback-jackson-0.1.5.jar;C:\Users\rogalski\.m2\repository\net\logstash\logback\logstash-logback-encoder\6.1\logstash-logback-encoder-6.1.jar;C:\Users\rogalski\.m2\repository\com\fasterxml\jackson\core\jackson-databind\2.9.9.3\jackson-databind-2.9.9.3.jar;C:\Users\rogalski\.m2\repository\com\fasterxml\jackson\core\jackson-core\2.9.9\jackson-core-2.9.9.jar;C:\Users\rogalski\.m2\repository\org\junit\jupiter\junit-jupiter-api\5.5.2\junit-jupiter-api-5.5.2.jar;C:\Users\rogalski\.m2\repository\org\apiguardian\apiguardian-api\1.1.0\apiguardian-api-1.1.0.jar;C:\Users\rogalski\.m2\repository\org\opentest4j\opentest4j\1.2.0\opentest4j-1.2.0.jar;C:\Users\rogalski\.m2\repository\org\junit\jupiter\junit-jupiter-params\5.5.2\junit-jupiter-params-5.5.2.jar;C:\Users\rogalski\.m2\repository\org\junit\jupiter\junit-jupiter-engine\5.5.2\junit-jupiter-engine-5.5.2.jar;C:\Users\rogalski\.m2\repository\org\junit\jupiter\junit-jupiter-migrationsupport\5.5.2\junit-jupiter-migrationsupport-5.5.2.jar;C:\Users\rogalski\.m2\repository\junit\junit\4.12\junit-4.12.jar;C:\Users\rogalski\.m2\repository\org\junit\platform\junit-platform-launcher\1.4.1\junit-platform-launcher-1.4.1.jar;C:\Users\rogalski\.m2\repository\org\junit\platform\junit-platform-runner\1.5.2\junit-platform-runner-1.5.2.jar;C:\Users\rogalski\.m2\repository\org\junit\platform\junit-platform-suite-api\1.3.2\junit-platform-suite-api-1.3.2.jar;C:\Users\rogalski\.m2\repository\org\junit\platform\junit-platform-commons\1.5.2\junit-platform-commons-1.5.2.jar;C:\Users\rogalski\.m2\repository\org\junit\platform\junit-platform-engine\1.5.2\junit-platform-engine-1.5.2.jar;C:\Users\rogalski\.m2\repository\org\mockito\mockito-junit-jupiter\2.23.4\mockito-junit-jupiter-2.23.4.jar;C:\Users\rogalski\.m2\repository\org\mockito\mockito-core\2.23.4\mockito-core-2.23.4.jar;C:\Users\rogalski\.m2\repository\net\bytebuddy\byte-buddy\1.9.16\byte-buddy-1.9.16.jar;C:\Users\rogalski\.m2\repository\net\bytebuddy\byte-buddy-agent\1.9.16\byte-buddy-agent-1.9.16.jar;C:\Users\rogalski\.m2\repository\org\objenesis\objenesis\2.6\objenesis-2.6.jar;C:\Users\rogalski\.m2\repository\org\springframework\kafka\spring-kafka-test\2.2.8.RELEASE\spring-kafka-test-2.2.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-test\5.1.9.RELEASE\spring-test-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\apache\kafka\kafka-clients\2.0.1\kafka-clients-2.0.1-test.jar;C:\Users\rogalski\.m2\repository\org\apache\kafka\kafka_2.11\2.0.1\kafka_2.11-2.0.1.jar;C:\Users\rogalski\.m2\repository\net\sf\jopt-simple\jopt-simple\5.0.4\jopt-simple-5.0.4.jar;C:\Users\rogalski\.m2\repository\com\yammer\metrics\metrics-core\2.2.0\metrics-core-2.2.0.jar;C:\Users\rogalski\.m2\repository\org\scala-lang\scala-library\2.11.12\scala-library-2.11.12.jar;C:\Users\rogalski\.m2\repository\org\scala-lang\scala-reflect\2.11.12\scala-reflect-2.11.12.jar;C:\Users\rogalski\.m2\repository\com\typesafe\scala-logging\scala-logging_2.11\3.9.0\scala-logging_2.11-3.9.0.jar;C:\Users\rogalski\.m2\repository\com\101tec\zkclient\0.10\zkclient-0.10.jar;C:\Users\rogalski\.m2\repository\org\apache\zookeeper\zookeeper\3.4.13\zookeeper-3.4.13.jar;C:\Users\rogalski\.m2\repository\org\apache\yetus\audience-annotations\0.5.0\audience-annotations-0.5.0.jar;C:\Users\rogalski\.m2\repository\org\apache\kafka\kafka_2.11\2.0.1\kafka_2.11-2.0.1-test.jar;C:\Users\rogalski\.m2\repository\com\github\kstyrc\embedded-redis\0.6\embedded-redis-0.6.jar;C:\Users\rogalski\.m2\repository\commons-io\commons-io\2.4\commons-io-2.4.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-test\2.1.8.RELEASE\spring-boot-starter-test-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-test\2.1.8.RELEASE\spring-boot-test-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\com\jayway\jsonpath\json-path\2.4.0\json-path-2.4.0.jar;C:\Users\rogalski\.m2\repository\net\minidev\json-smart\2.3\json-smart-2.3.jar;C:\Users\rogalski\.m2\repository\net\minidev\accessors-smart\1.2\accessors-smart-1.2.jar;C:\Users\rogalski\.m2\repository\org\ow2\asm\asm\5.0.4\asm-5.0.4.jar;C:\Users\rogalski\.m2\repository\org\assertj\assertj-core\3.11.1\assertj-core-3.11.1.jar;C:\Users\rogalski\.m2\repository\org\hamcrest\hamcrest-core\1.3\hamcrest-core-1.3.jar;C:\Users\rogalski\.m2\repository\org\hamcrest\hamcrest-library\1.3\hamcrest-library-1.3.jar;C:\Users\rogalski\.m2\repository\org\skyscreamer\jsonassert\1.5.0\jsonassert-1.5.0.jar;C:\Users\rogalski\.m2\repository\com\vaadin\external\google\android-json\0.0.20131108.vaadin1\android-json-0.0.20131108.vaadin1.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-core\5.1.9.RELEASE\spring-core-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-jcl\5.1.9.RELEASE\spring-jcl-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\xmlunit\xmlunit-core\2.6.3\xmlunit-core-2.6.3.jar;C:\Users\rogalski\.m2\repository\org\springframework\security\spring-security-test\5.1.6.RELEASE\spring-security-test-5.1.6.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\security\spring-security-core\5.1.6.RELEASE\spring-security-core-5.1.6.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-test-autoconfigure\2.1.8.RELEASE\spring-boot-test-autoconfigure-2.1.8.RELEASE.jar;"/>
    <property name="java.vm.vendor" value="Oracle Corporation"/>
    <property name="sun.arch.data.model" value="64"/>
    <property name="user.variant" value=""/>
    <property name="java.vendor.url" value="http://java.oracle.com/"/>
    <property name="user.timezone" value="Europe/Moscow"/>
    <property name="user.country.format" value="RU"/>
    <property name="java.vm.specification.version" value="1.8"/>
    <property name="os.name" value="Windows 10"/>
    <property name="user.country" value="US"/>
    <property name="sun.java.launcher" value="SUN_STANDARD"/>
    <property name="sun.boot.library.path" value="C:\Program Files\Java\jdk1.8.0_191\jre\bin"/>
    <property name="sun.java.command" value="C:\Users\rogalski\AppData\Local\Temp\surefire5096680877611110727\surefirebooter410434119339594636.jar C:\Users\rogalski\AppData\Local\Temp\surefire5096680877611110727 2019-10-31T20-35-15_628-jvmRun1 surefire6326151768280446625tmp surefire_08843624168109330963tmp"/>
    <property name="surefire.test.class.path" value="C:\git-project\paragon.microservices.freecoupons\.build\bin\paragon.microservices.freecoupons.service\test-classes;C:\git-project\paragon.microservices.freecoupons\.build\bin\paragon.microservices.freecoupons.service\classes;C:\git-project\paragon.microservices.freecoupons\.build\bin\paragon.microservices.freecoupons.common\classes;C:\Users\rogalski\.m2\repository\org\projectlombok\lombok\1.18.8\lombok-1.18.8.jar;C:\Users\rogalski\.m2\repository\com\paragon\mailingcontour\paragon.mailingcontour.commons\0.3.0-alpha-0352-ef7813f\paragon.mailingcontour.commons-0.3.0-alpha-0352-ef7813f.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-aop\2.1.8.RELEASE\spring-boot-starter-aop-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\aspectj\aspectjweaver\1.9.4\aspectjweaver-1.9.4.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-logging\2.1.8.RELEASE\spring-boot-starter-logging-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\apache\logging\log4j\log4j-to-slf4j\2.11.2\log4j-to-slf4j-2.11.2.jar;C:\Users\rogalski\.m2\repository\org\apache\logging\log4j\log4j-api\2.11.2\log4j-api-2.11.2.jar;C:\Users\rogalski\.m2\repository\org\slf4j\jul-to-slf4j\1.7.28\jul-to-slf4j-1.7.28.jar;C:\Users\rogalski\.m2\repository\org\springframework\retry\spring-retry\1.2.4.RELEASE\spring-retry-1.2.4.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\data\spring-data-redis\2.1.10.RELEASE\spring-data-redis-2.1.10.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\data\spring-data-keyvalue\2.1.10.RELEASE\spring-data-keyvalue-2.1.10.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\data\spring-data-commons\2.1.10.RELEASE\spring-data-commons-2.1.10.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-oxm\5.1.9.RELEASE\spring-oxm-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-context-support\5.1.9.RELEASE\spring-context-support-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\apache\commons\commons-lang3\3.8.1\commons-lang3-3.8.1.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-spi\2.9.2\springfox-spi-2.9.2.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-core\2.9.2\springfox-core-2.9.2.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-spring-web\2.9.2\springfox-spring-web-2.9.2.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-web\2.1.8.RELEASE\spring-boot-starter-web-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter\2.1.8.RELEASE\spring-boot-starter-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\javax\annotation\javax.annotation-api\1.3.2\javax.annotation-api-1.3.2.jar;C:\Users\rogalski\.m2\repository\org\yaml\snakeyaml\1.23\snakeyaml-1.23.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-json\2.1.8.RELEASE\spring-boot-starter-json-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.9.9\jackson-datatype-jdk8-2.9.9.jar;C:\Users\rogalski\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.9.9\jackson-datatype-jsr310-2.9.9.jar;C:\Users\rogalski\.m2\repository\com\fasterxml\jackson\module\jackson-module-parameter-names\2.9.9\jackson-module-parameter-names-2.9.9.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-tomcat\2.1.8.RELEASE\spring-boot-starter-tomcat-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\apache\tomcat\embed\tomcat-embed-core\9.0.24\tomcat-embed-core-9.0.24.jar;C:\Users\rogalski\.m2\repository\org\apache\tomcat\embed\tomcat-embed-websocket\9.0.24\tomcat-embed-websocket-9.0.24.jar;C:\Users\rogalski\.m2\repository\org\hibernate\validator\hibernate-validator\6.0.17.Final\hibernate-validator-6.0.17.Final.jar;C:\Users\rogalski\.m2\repository\org\jboss\logging\jboss-logging\3.3.3.Final\jboss-logging-3.3.3.Final.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-web\5.1.9.RELEASE\spring-web-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-beans\5.1.9.RELEASE\spring-beans-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-webmvc\5.1.9.RELEASE\spring-webmvc-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-expression\5.1.9.RELEASE\spring-expression-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-data-redis\2.1.8.RELEASE\spring-boot-starter-data-redis-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\io\lettuce\lettuce-core\5.1.8.RELEASE\lettuce-core-5.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\io\netty\netty-common\4.1.39.Final\netty-common-4.1.39.Final.jar;C:\Users\rogalski\.m2\repository\io\netty\netty-handler\4.1.39.Final\netty-handler-4.1.39.Final.jar;C:\Users\rogalski\.m2\repository\io\netty\netty-buffer\4.1.39.Final\netty-buffer-4.1.39.Final.jar;C:\Users\rogalski\.m2\repository\io\netty\netty-codec\4.1.39.Final\netty-codec-4.1.39.Final.jar;C:\Users\rogalski\.m2\repository\io\netty\netty-transport\4.1.39.Final\netty-transport-4.1.39.Final.jar;C:\Users\rogalski\.m2\repository\io\netty\netty-resolver\4.1.39.Final\netty-resolver-4.1.39.Final.jar;C:\Users\rogalski\.m2\repository\io\projectreactor\reactor-core\3.2.12.RELEASE\reactor-core-3.2.12.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\reactivestreams\reactive-streams\1.0.3\reactive-streams-1.0.3.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-security\2.1.8.RELEASE\spring-boot-starter-security-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-aop\5.1.9.RELEASE\spring-aop-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\security\spring-security-config\5.1.6.RELEASE\spring-security-config-5.1.6.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\security\spring-security-web\5.1.6.RELEASE\spring-security-web-5.1.6.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-validation\2.1.8.RELEASE\spring-boot-starter-validation-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\apache\tomcat\embed\tomcat-embed-el\9.0.24\tomcat-embed-el-9.0.24.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-actuator\2.1.8.RELEASE\spring-boot-starter-actuator-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-actuator-autoconfigure\2.1.8.RELEASE\spring-boot-actuator-autoconfigure-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-actuator\2.1.8.RELEASE\spring-boot-actuator-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\io\micrometer\micrometer-core\1.1.6\micrometer-core-1.1.6.jar;C:\Users\rogalski\.m2\repository\org\hdrhistogram\HdrHistogram\2.1.9\HdrHistogram-2.1.9.jar;C:\Users\rogalski\.m2\repository\org\latencyutils\LatencyUtils\2.0.3\LatencyUtils-2.0.3.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-devtools\2.1.8.RELEASE\spring-boot-devtools-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot\2.1.8.RELEASE\spring-boot-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-autoconfigure\2.1.8.RELEASE\spring-boot-autoconfigure-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\kafka\spring-kafka\2.2.8.RELEASE\spring-kafka-2.2.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-context\5.1.9.RELEASE\spring-context-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-messaging\5.1.9.RELEASE\spring-messaging-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-tx\5.1.9.RELEASE\spring-tx-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\apache\kafka\kafka-clients\2.0.1\kafka-clients-2.0.1.jar;C:\Users\rogalski\.m2\repository\org\lz4\lz4-java\1.4.1\lz4-java-1.4.1.jar;C:\Users\rogalski\.m2\repository\org\xerial\snappy\snappy-java\1.1.7.1\snappy-java-1.1.7.1.jar;C:\Users\rogalski\.m2\repository\org\springframework\security\spring-security-jwt\1.0.10.RELEASE\spring-security-jwt-1.0.10.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\bouncycastle\bcpkix-jdk15on\1.60\bcpkix-jdk15on-1.60.jar;C:\Users\rogalski\.m2\repository\org\bouncycastle\bcprov-jdk15on\1.60\bcprov-jdk15on-1.60.jar;C:\Users\rogalski\.m2\repository\com\google\guava\guava\28.0-jre\guava-28.0-jre.jar;C:\Users\rogalski\.m2\repository\com\google\guava\failureaccess\1.0.1\failureaccess-1.0.1.jar;C:\Users\rogalski\.m2\repository\com\google\guava\listenablefuture\9999.0-empty-to-avoid-conflict-with-guava\listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar;C:\Users\rogalski\.m2\repository\com\google\code\findbugs\jsr305\3.0.2\jsr305-3.0.2.jar;C:\Users\rogalski\.m2\repository\org\checkerframework\checker-qual\2.8.1\checker-qual-2.8.1.jar;C:\Users\rogalski\.m2\repository\com\google\errorprone\error_prone_annotations\2.3.2\error_prone_annotations-2.3.2.jar;C:\Users\rogalski\.m2\repository\com\google\j2objc\j2objc-annotations\1.3\j2objc-annotations-1.3.jar;C:\Users\rogalski\.m2\repository\org\codehaus\mojo\animal-sniffer-annotations\1.17\animal-sniffer-annotations-1.17.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-swagger2\2.9.2\springfox-swagger2-2.9.2.jar;C:\Users\rogalski\.m2\repository\io\swagger\swagger-annotations\1.5.20\swagger-annotations-1.5.20.jar;C:\Users\rogalski\.m2\repository\io\swagger\swagger-models\1.5.20\swagger-models-1.5.20.jar;C:\Users\rogalski\.m2\repository\com\fasterxml\jackson\core\jackson-annotations\2.9.0\jackson-annotations-2.9.0.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-schema\2.9.2\springfox-schema-2.9.2.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-swagger-common\2.9.2\springfox-swagger-common-2.9.2.jar;C:\Users\rogalski\.m2\repository\com\fasterxml\classmate\1.4.0\classmate-1.4.0.jar;C:\Users\rogalski\.m2\repository\org\slf4j\slf4j-api\1.7.28\slf4j-api-1.7.28.jar;C:\Users\rogalski\.m2\repository\org\springframework\plugin\spring-plugin-core\1.2.0.RELEASE\spring-plugin-core-1.2.0.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\plugin\spring-plugin-metadata\1.2.0.RELEASE\spring-plugin-metadata-1.2.0.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\mapstruct\mapstruct\1.2.0.Final\mapstruct-1.2.0.Final.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-swagger-ui\2.9.2\springfox-swagger-ui-2.9.2.jar;C:\Users\rogalski\.m2\repository\io\springfox\springfox-bean-validators\2.9.2\springfox-bean-validators-2.9.2.jar;C:\Users\rogalski\.m2\repository\javax\validation\validation-api\2.0.1.Final\validation-api-2.0.1.Final.jar;C:\Users\rogalski\.m2\repository\ch\qos\logback\contrib\logback-json-classic\0.1.5\logback-json-classic-0.1.5.jar;C:\Users\rogalski\.m2\repository\ch\qos\logback\logback-classic\1.2.3\logback-classic-1.2.3.jar;C:\Users\rogalski\.m2\repository\ch\qos\logback\logback-core\1.2.3\logback-core-1.2.3.jar;C:\Users\rogalski\.m2\repository\ch\qos\logback\contrib\logback-json-core\0.1.5\logback-json-core-0.1.5.jar;C:\Users\rogalski\.m2\repository\ch\qos\logback\contrib\logback-jackson\0.1.5\logback-jackson-0.1.5.jar;C:\Users\rogalski\.m2\repository\net\logstash\logback\logstash-logback-encoder\6.1\logstash-logback-encoder-6.1.jar;C:\Users\rogalski\.m2\repository\com\fasterxml\jackson\core\jackson-databind\2.9.9.3\jackson-databind-2.9.9.3.jar;C:\Users\rogalski\.m2\repository\com\fasterxml\jackson\core\jackson-core\2.9.9\jackson-core-2.9.9.jar;C:\Users\rogalski\.m2\repository\org\junit\jupiter\junit-jupiter-api\5.5.2\junit-jupiter-api-5.5.2.jar;C:\Users\rogalski\.m2\repository\org\apiguardian\apiguardian-api\1.1.0\apiguardian-api-1.1.0.jar;C:\Users\rogalski\.m2\repository\org\opentest4j\opentest4j\1.2.0\opentest4j-1.2.0.jar;C:\Users\rogalski\.m2\repository\org\junit\jupiter\junit-jupiter-params\5.5.2\junit-jupiter-params-5.5.2.jar;C:\Users\rogalski\.m2\repository\org\junit\jupiter\junit-jupiter-engine\5.5.2\junit-jupiter-engine-5.5.2.jar;C:\Users\rogalski\.m2\repository\org\junit\jupiter\junit-jupiter-migrationsupport\5.5.2\junit-jupiter-migrationsupport-5.5.2.jar;C:\Users\rogalski\.m2\repository\junit\junit\4.12\junit-4.12.jar;C:\Users\rogalski\.m2\repository\org\junit\platform\junit-platform-launcher\1.4.1\junit-platform-launcher-1.4.1.jar;C:\Users\rogalski\.m2\repository\org\junit\platform\junit-platform-runner\1.5.2\junit-platform-runner-1.5.2.jar;C:\Users\rogalski\.m2\repository\org\junit\platform\junit-platform-suite-api\1.3.2\junit-platform-suite-api-1.3.2.jar;C:\Users\rogalski\.m2\repository\org\junit\platform\junit-platform-commons\1.5.2\junit-platform-commons-1.5.2.jar;C:\Users\rogalski\.m2\repository\org\junit\platform\junit-platform-engine\1.5.2\junit-platform-engine-1.5.2.jar;C:\Users\rogalski\.m2\repository\org\mockito\mockito-junit-jupiter\2.23.4\mockito-junit-jupiter-2.23.4.jar;C:\Users\rogalski\.m2\repository\org\mockito\mockito-core\2.23.4\mockito-core-2.23.4.jar;C:\Users\rogalski\.m2\repository\net\bytebuddy\byte-buddy\1.9.16\byte-buddy-1.9.16.jar;C:\Users\rogalski\.m2\repository\net\bytebuddy\byte-buddy-agent\1.9.16\byte-buddy-agent-1.9.16.jar;C:\Users\rogalski\.m2\repository\org\objenesis\objenesis\2.6\objenesis-2.6.jar;C:\Users\rogalski\.m2\repository\org\springframework\kafka\spring-kafka-test\2.2.8.RELEASE\spring-kafka-test-2.2.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-test\5.1.9.RELEASE\spring-test-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\apache\kafka\kafka-clients\2.0.1\kafka-clients-2.0.1-test.jar;C:\Users\rogalski\.m2\repository\org\apache\kafka\kafka_2.11\2.0.1\kafka_2.11-2.0.1.jar;C:\Users\rogalski\.m2\repository\net\sf\jopt-simple\jopt-simple\5.0.4\jopt-simple-5.0.4.jar;C:\Users\rogalski\.m2\repository\com\yammer\metrics\metrics-core\2.2.0\metrics-core-2.2.0.jar;C:\Users\rogalski\.m2\repository\org\scala-lang\scala-library\2.11.12\scala-library-2.11.12.jar;C:\Users\rogalski\.m2\repository\org\scala-lang\scala-reflect\2.11.12\scala-reflect-2.11.12.jar;C:\Users\rogalski\.m2\repository\com\typesafe\scala-logging\scala-logging_2.11\3.9.0\scala-logging_2.11-3.9.0.jar;C:\Users\rogalski\.m2\repository\com\101tec\zkclient\0.10\zkclient-0.10.jar;C:\Users\rogalski\.m2\repository\org\apache\zookeeper\zookeeper\3.4.13\zookeeper-3.4.13.jar;C:\Users\rogalski\.m2\repository\org\apache\yetus\audience-annotations\0.5.0\audience-annotations-0.5.0.jar;C:\Users\rogalski\.m2\repository\org\apache\kafka\kafka_2.11\2.0.1\kafka_2.11-2.0.1-test.jar;C:\Users\rogalski\.m2\repository\com\github\kstyrc\embedded-redis\0.6\embedded-redis-0.6.jar;C:\Users\rogalski\.m2\repository\commons-io\commons-io\2.4\commons-io-2.4.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-starter-test\2.1.8.RELEASE\spring-boot-starter-test-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-test\2.1.8.RELEASE\spring-boot-test-2.1.8.RELEASE.jar;C:\Users\rogalski\.m2\repository\com\jayway\jsonpath\json-path\2.4.0\json-path-2.4.0.jar;C:\Users\rogalski\.m2\repository\net\minidev\json-smart\2.3\json-smart-2.3.jar;C:\Users\rogalski\.m2\repository\net\minidev\accessors-smart\1.2\accessors-smart-1.2.jar;C:\Users\rogalski\.m2\repository\org\ow2\asm\asm\5.0.4\asm-5.0.4.jar;C:\Users\rogalski\.m2\repository\org\assertj\assertj-core\3.11.1\assertj-core-3.11.1.jar;C:\Users\rogalski\.m2\repository\org\hamcrest\hamcrest-core\1.3\hamcrest-core-1.3.jar;C:\Users\rogalski\.m2\repository\org\hamcrest\hamcrest-library\1.3\hamcrest-library-1.3.jar;C:\Users\rogalski\.m2\repository\org\skyscreamer\jsonassert\1.5.0\jsonassert-1.5.0.jar;C:\Users\rogalski\.m2\repository\com\vaadin\external\google\android-json\0.0.20131108.vaadin1\android-json-0.0.20131108.vaadin1.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-core\5.1.9.RELEASE\spring-core-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\spring-jcl\5.1.9.RELEASE\spring-jcl-5.1.9.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\xmlunit\xmlunit-core\2.6.3\xmlunit-core-2.6.3.jar;C:\Users\rogalski\.m2\repository\org\springframework\security\spring-security-test\5.1.6.RELEASE\spring-security-test-5.1.6.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\security\spring-security-core\5.1.6.RELEASE\spring-security-core-5.1.6.RELEASE.jar;C:\Users\rogalski\.m2\repository\org\springframework\boot\spring-boot-test-autoconfigure\2.1.8.RELEASE\spring-boot-test-autoconfigure-2.1.8.RELEASE.jar;"/>
    <property name="sun.cpu.endian" value="little"/>
    <property name="user.home" value="C:\Users\rogalski"/>
    <property name="user.language" value="en"/>
    <property name="java.specification.vendor" value="Oracle Corporation"/>
    <property name="java.home" value="C:\Program Files\Java\jdk1.8.0_191\jre"/>
    <property name="basedir" value="C:\git-project\paragon.microservices.freecoupons\service"/>
    <property name="file.separator" value="\"/>
    <property name="line.separator" value="&#10;"/>
    <property name="java.vm.specification.vendor" value="Oracle Corporation"/>
    <property name="java.specification.name" value="Java Platform API Specification"/>
    <property name="java.awt.graphicsenv" value="sun.awt.Win32GraphicsEnvironment"/>
    <property name="surefire.real.class.path" value="C:\Users\rogalski\AppData\Local\Temp\surefire5096680877611110727\surefirebooter410434119339594636.jar"/>
    <property name="sun.boot.class.path" value="C:\Program Files\Java\jdk1.8.0_191\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_191\jre\lib\rt.jar;C:\Program Files\Java\jdk1.8.0_191\jre\lib\sunrsasign.jar;C:\Program Files\Java\jdk1.8.0_191\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_191\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_191\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_191\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_191\jre\classes"/>
    <property name="user.script" value=""/>
    <property name="sun.management.compiler" value="HotSpot 64-Bit Tiered Compilers"/>
    <property name="java.runtime.version" value="1.8.0_191-b12"/>
    <property name="user.name" value="rogalskiy"/>
    <property name="path.separator" value=";"/>
    <property name="os.version" value="10.0"/>
    <property name="java.endorsed.dirs" value="C:\Program Files\Java\jdk1.8.0_191\jre\lib\endorsed"/>
    <property name="java.runtime.name" value="Java(TM) SE Runtime Environment"/>
    <property name="file.encoding" value="Cp1251"/>
    <property name="java.vm.name" value="Java HotSpot(TM) 64-Bit Server VM"/>
    <property name="localRepository" value="C:\Users\rogalski\.m2\repository"/>
    <property name="java.vendor.url.bug" value="http://bugreport.sun.com/bugreport/"/>
    <property name="java.io.tmpdir" value="C:\Users\rogalski\AppData\Local\Temp\"/>
    <property name="java.version" value="1.8.0_191"/>
    <property name="user.dir" value="C:\git-project\paragon.microservices.freecoupons\service"/>
    <property name="os.arch" value="amd64"/>
    <property name="java.vm.specification.name" value="Java Virtual Machine Specification"/>
    <property name="java.awt.printerjob" value="sun.awt.windows.WPrinterJob"/>
    <property name="user.language.format" value="ru"/>
    <property name="sun.os.patch.level" value=""/>
    <property name="java.library.path" value="C:\Program Files\Java\jdk1.8.0_191\jre\bin;C:\WINDOWS\Sun\Java\bin;C:\WINDOWS\system32;C:\WINDOWS;C:\Users\rogalski\AppData\Local\Programs\Python\Python37-32;C:\Users\rogalski\AppData\Local\Programs\Python\Python37-32\Scripts;C:\ProgramData\DockerDesktop\version-bin;C:\Program Files\Docker\Docker\Resources\bin;C:\Users\rogalski\Downloads\WINDOWS.X64_180000_db_home\bin;C:\gradle-5.0\bin;C:\apache-maven-3.6.0\bin;C:\Program Files\Microsoft MPI\Bin\;C:\Program Files\Java\jdk-11.0.2\bin;C:\Program Files\Java\jdk1.8.0_191\bin;C:\Program Files (x86)\Common Files\Oracle\Java\javapath;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\Program Files\Sysinternals;C:\Program Files\PuTTY\;C:\WINDOWS\System32\OpenSSH\;C:\Program Files (x86)\Bitvise SSH Client;C:\HashiCorp\Vagrant\bin;C:\Program Files\TortoiseHg\;C:\Program Files\nodejs\;C:\ProgramData\chocolatey\bin;C:\Program Files\dotnet\;C:\PostgreSQL\pg11\bin;C:\Program Files\Microsoft SQL Server\130\Tools\Binn\;C:\Program Files (x86)\sbt\bin;C:\Program Files (x86)\Brackets\command;C:\Go\bin;C:\Program Files (x86)\Common Files\MicroStrategy;C:\Program Files (x86)\MicroStrategy\Intelligence Server;C:\Program Files (x86)\Common Files\MicroStrategy\JRE\170_51\Win32\bin\client;C:\Users\rogalski\Documents\pandoc;C:\Program Files (x86)\Yarn\bin\;C:\apache-ant-1.10.5\bin;C:\Program Files\Git LFS;C:\Program Files\Git\cmd;C:\exec;C:\Users\rogalski\scoop\shims;C:\Users\rogalski\AppData\Roaming\local\bin;C:\Users\rogalski\.cargo\bin;C:\Ruby25-x64\bin;C:\Users\rogalski\AppData\Local\Microsoft\WindowsApps;C:\Users\rogalski\AppData\Local\atom\bin;C:\Users\rogalski\AppData\Roaming\npm;C:\Users\rogalski\go\bin;C:\Users\rogalski\AppData\Local\Yarn\bin;C:\Program Files (x86)\Nmap;%IntelliJ IDEA%;C:\Users\rogalski\AppData\Local\hyper\app-2.1.2\resources\bin;."/>
    <property name="java.vm.info" value="mixed mode"/>
    <property name="java.vendor" value="Oracle Corporation"/>
    <property name="java.vm.version" value="25.191-b12"/>
    <property name="java.ext.dirs" value="C:\Program Files\Java\jdk1.8.0_191\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext"/>
    <property name="sun.io.unicode.encoding" value="UnicodeLittle"/>
    <property name="java.class.version" value="52.0"/>
  </properties>
  <testcase name="getLicense_OK_whenLicensePresent" classname="com.paragon.microservices.freecoupons.client.impl.LicenseClientImplTest" time="2.533"/>
  <testcase name="getLicense_shouldReturnEmpty_whenLicenseServiceReturn404" classname="com.paragon.microservices.freecoupons.client.impl.LicenseClientImplTest" time="0.094">
    <error type="java.lang.NullPointerException">java.lang.NullPointerException
	at com.paragon.microservices.freecoupons.client.impl.LicenseClientImplTest.getLicense_shouldReturnEmpty_whenLicenseServiceReturn404(LicenseClientImplTest.java:120)
</error>
  </testcase>
  <testcase name="getLicense_shouldReturnEmpty_whenLicenseAbsence" classname="com.paragon.microservices.freecoupons.client.impl.LicenseClientImplTest" time="0.009">
    <error type="java.lang.NullPointerException">java.lang.NullPointerException
	at com.paragon.microservices.freecoupons.client.impl.LicenseClientImplTest.getLicense_shouldReturnEmpty_whenLicenseAbsence(LicenseClientImplTest.java:100)
</error>
  </testcase>
</testsuite>
--------------------------------------------------------------------------------------------------------
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.22.1</version>

    <dependency>
        <groupId>org.apache.maven.surefire</groupId>
        <artifactId>surefire-junit-platform</artifactId>
        <version>2.22.1</version>
    </dependency>
</plugin>

http://stackoverflow.com/questions/36970384/surefire-is-not-picking-up-junit-5-tests 
--------------------------------------------------------------------------------------------------------
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

class CalculatorTests {

	@Test
	@DisplayName("1 + 1 = 2")
	void addsTwoNumbers() {
		Calculator calculator = new Calculator();
		assertEquals(2, calculator.add(1, 1), "1 + 1 should equal 2");
	}

	@ParameterizedTest(name = "{0} + {1} = {2}")
	@CsvSource({
			"0,    1,   1",
			"1,    2,   3",
			"49,  51, 100",
			"1,  100, 101"
	})
	void add(int first, int second, int expectedResult) {
		Calculator calculator = new Calculator();
		assertEquals(expectedResult, calculator.add(first, second),
				() -> first + " + " + second + " should equal " + expectedResult);
	}
}
--------------------------------------------------------------------------------------------------------
<build>
    <plugins>
        ...
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>3.0.0-M3</version>
            <configuration>
                <excludes>
                    <exclude>some test to exclude here</exclude>
                </excludes>
            </configuration>
        </plugin>
    </plugins>
</build>

<build>
    <plugins>
        ...
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>3.0.0-M3</version>
            <configuration>
                <groups>acceptance | !feature-a</groups>
                <excludedGroups>integration, regression</excludedGroups>
            </configuration>
        </plugin>
    </plugins>
</build>
--------------------------------------------------------------------------------------------------------
@TestMethodOrder(OrderAnnotation.class)
class OrderedTestsDemo {

    @Test
    @Order(1)
    void nullValues() {
        // perform assertions against null values
    }

    @Test
    @Order(2)
    void emptyValues() {
        // perform assertions against empty values
    }

    @Test
    @Order(3)
    void validValues() {
        // perform assertions against valid values
    }

}

import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.TestMethodOrder;

@TestMethodOrder(MethodOrderer.Alphanumeric.class)
public class TestClass{
   //..
}
--------------------------------------------------------------------------------------------------------
python -m pip install --upgrade pip

<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-test</artifactId>
   <exclusions>
     <exclusion>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
     </exclusion>
   </exclusions>
</dependency>
<dependency>
   <groupId>org.dbunit</groupId>
   <artifactId>dbunit</artifactId>
   <version>${dbunit.version}</version>
   <exclusions>
     <exclusion>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
     </exclusion>
   </exclusions>
</dependency>
--------------------------------------------------------------------------------------------------------
@ExtendWith(SpringExtension.class)
@ExtendWith(MockitoExtension.class)

        <!--<dependency>-->
        <!--<groupId>org.junit.jupiter</groupId>-->
        <!--<artifactId>junit-jupiter-migrationsupport</artifactId>-->
        <!--<version>${junit-jupiter.version}</version>-->
        <!--<scope>test</scope>-->
        <!--</dependency>-->
--------------------------------------------------------------------------------------------------------
language: java
jdk:
  - oraclejdk8
branches:
  only:
    - master
script: mvn -f chapter-8/build/pom.xml verify
before_script:
  - "export DISPLAY=:99.0"
  - "sh -e /etc/init.d/xvfb start"
  - sleep 3 # give xvfb some time to start
after_success:
  - mvn -f chapter-8/build/pom.xml test jacoco:report coveralls:report
--------------------------------------------------------------------------------------------------------
after_success:  - mvn -f sample.application/build/pom.xml test \    jacoco:report coveralls:report
sudo service network-manager restar
sudo ufw disable
sudo ufw app list
sudo ufw allow 'Apache Full'

sudo ufw status
sudo service apache2 force-reload

sudo systemctl disable apache2
sudo systemctl enable apache2

vim: syntax=apache ts=4 sw=4 sts=4 sr noet

sudo a2ensite example1.conf
sudo service apache2 force-reload

Listen 8080Listen 8181# 1st vhost<VirtualHost *:8080>ServerAdmin webmaster@localhostDocumentRoot /var/www/htmlDirectoryIndex index3.htmlErrorLog ${APACHE_LOG_DIR}/error.logCustomLog ${APACHE_LOG_DIR}/access.log combined</VirtualHost># 2nd vhost<VirtualHost *:8181>ServerAdmin webmaster@localhostDocumentRoot /var/www/htmlDirectoryIndex index4.htmlErrorLog ${APACHE_LOG_DIR}/error.logCustomLog ${APACHE_LOG_DIR}/access.log combined</VirtualHost>

sudo apachectl -S

export APACHE_LOG_DIR=/var/log/apache2$SUFFI
grep APACHE_LOG_DIR /etc/apache2/envvars
tail –fn 1 access.log
















--------------------------------------------------------------------------------------------------------

import static book.twju.timeline.util.Exceptions.guard;
import static java.lang.String.format;
import static org.eclipse.jgit.api.Git.open;

import java.io.File;
import java.io.IOException;
import java.util.concurrent.Callable;

import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.errors.RepositoryNotFoundException;

class GitOperator {
  
  static final String DIRECTORY_CONTAINS_NO_GIT_REPOSITORY = "Directory <%s> contains no git repository.";
  
  private final File repositoryLocation;
  
  @FunctionalInterface
  interface GitOperation<T> {
    T execute( Git git ) throws Exception;
  }

  GitOperator( File repositoryLocation ) {
    this.repositoryLocation = repositoryLocation;
    openRepository().close();
  }
  
  <T> T execute( GitOperation<T> gitOperation ) {
     Git git = openRepository();
     try {
       return guarded( () -> gitOperation.execute( git ) );
     } finally {
       git.close();
     }
  }

  static <T> T guarded( Callable<T> callable ) {
    return guard( callable ).with( IllegalStateException.class );
  }

  private Git openRepository() {
    return guarded( () -> openRepository( repositoryLocation ) );
  }

  private static Git openRepository( File repositoryDir ) throws IOException {
    try {
      return open( repositoryDir ); 
    } catch ( RepositoryNotFoundException rnfe ) {
      throw new IllegalArgumentException( format( DIRECTORY_CONTAINS_NO_GIT_REPOSITORY, repositoryDir ), rnfe );
    }
  }
}
--------------------------------------------------------------------------------------------------------
// в группе все ассерты исполняются независимо,
// успех - когда прошли успешно все ассерты
assertAll("habr",
    () -> assertThat("https://habrahabr.ru", startsWith("https")),
    () -> assertThat("https://habrahabr.ru", endsWith(".ru"))
);

assertIterableEquals(asList(1, 2, 3), asList(1, 2, 3));

Assertions.assertLinesMatch(
    asList("можно сравнивать строки", "а можно по regex: \\d{2}\\.\\d{2}\\.\\d{4}"),
    asList("можно сравнивать строки", "а можно по regex: 12.09.2017")
);

// JUnit 4
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface Test {
    Class<? extends Throwable> expected() default Test.None.class;

    long timeout() default 0L;

    public static class None extends Throwable {
        private static final long serialVersionUID = 1L;

        private None() {
        }
    }
}
--------------------------------------------------------------------------------------------------------
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

class StandardTests {

    // вместо @BeforeClass
    @BeforeAll
    static void initAll() {
    }

    // вместо @Before
    @BeforeEach
    void init() {
    }

    @Test
    void succeedingTest() {
    }

    @Test
    void failingTest() {
        fail("a failing test");
    }

    // Вместо @Ignore
    @Test
    @Disabled("for demonstration purposes")
    void skippedTest() {
        // not executed
    }

    // Новая аннотация для улучшения читаемости при выводе результатов тестов.
    @DisplayName("╯°□°）╯")
    void testWithDisplayNameContainingSpecialCharacters() {}

    // вместо @After
    @AfterEach
    void tearDown() {
    }

    // вместо @AfterClass
    @AfterAll
    static void tearDownAll() {
    }

}
--------------------------------------------------------------------------------------------------------
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.EmptyStackException;
import java.util.Stack;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

@DisplayName("A stack")
class TestingAStackDemo {

    Stack<Object> stack;

    @Test
    @DisplayName("is instantiated with new Stack()")
    void isInstantiatedWithNew() {
        new Stack<>();
    }

    @Nested
    @DisplayName("when new")
    class WhenNew {

        @BeforeEach
        void createNewStack() {
            stack = new Stack<>();
        }

        @Test
        @DisplayName("is empty")
        void isEmpty() {
            assertTrue(stack.isEmpty());
        }

        @Test
        @DisplayName("throws EmptyStackException when popped")
        void throwsExceptionWhenPopped() {
            assertThrows(EmptyStackException.class, () -> stack.pop());
        }

        @Test
        @DisplayName("throws EmptyStackException when peeked")
        void throwsExceptionWhenPeeked() {
            assertThrows(EmptyStackException.class, () -> stack.peek());
        }

        @Nested
        @DisplayName("after pushing an element")
        class AfterPushing {

            String anElement = "an element";

            @BeforeEach
            void pushAnElement() {
                stack.push(anElement);
            }

            @Test
            @DisplayName("it is no longer empty")
            void isNotEmpty() {
                assertFalse(stack.isEmpty());
            }

            @Test
            @DisplayName("returns the element when popped and is empty")
            void returnElementWhenPopped() {
                assertEquals(anElement, stack.pop());
                assertTrue(stack.isEmpty());
            }

            @Test
            @DisplayName("returns the element when peeked but remains not empty")
            void returnElementWhenPeeked() {
                assertEquals(anElement, stack.peek());
                assertFalse(stack.isEmpty());
            }
        }
    }
}

@RepeatedTest(5)
void repeatedTest() {
    System.out.println("Этот тест будет запущен пять раз. ");
}

@ParameterizedTest
@EnumSource(value = TimeUnit.class, names = { "DAYS", "HOURS" })
void testWithEnumSourceInclude(TimeUnit timeUnit) {
    assertTrue(EnumSet.of(TimeUnit.DAYS, TimeUnit.HOURS).contains(timeUnit));
}


https://habr.com/ru/post/337700/

@ParameterizedTest
@ArgumentsSource(MyArgumentsProvider.class)
void testWithArgumentsSource(String argument) {
    assertNotNull(argument);
}

static class MyArgumentsProvider implements ArgumentsProvider {
    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
        return Stream.of("foo", "bar").map(Arguments::of);
    }
}

Если вы укажите над классом @TestInstance(Lifecycle.PER_CLASS) то вы можете не делать @BeforeAll/@AfterAll статическими. Это же работает и для Котлина.
--------------------------------------------------------------------------------------------------------
cobertura-report -–format html --datafile cobertura.ser     --destination reports src
--------------------------------------------------------------------------------------------------------
buildscript {    ext {springBootVersion = '2.1.0.RELEASE'    }    repositories {mavenCentral()    }    dependencies {classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")    }}apply plugin: 'java'apply plugin: 'org.springframework.boot'apply plugin: 'io.spring.dependency-management'dependencies {    compile 'org.springframework.boot:spring-boot-starter'}repositories {    mavenCentral()}
--------------------------------------------------------------------------------------------------------
mvn install:install-file -Dfile=junit-4.6/junit-4.6.jar -DgroupId=junit -DartifactId=junit -Dversion=4.6 -Dpackaging=jar 

--------------------------------------------------------------------------------------------------------
import java.util.Map;public class CustomizedErrorAttributes extends DefaultErrorAttributes {@Overridepublic Map<String, Object> getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) {Map<String, Object> errorAttributes =super.getErrorAttributes(webRequest, includeStackTrace);errorAttributes.put("parameters", webRequest.getParameterMap());return errorAttributes;}}
--------------------------------------------------------------------------------------------------------
@Beanpublic LocaleResolver localeResolver () {return new AcceptHeaderLocaleResolver();}

@Beanpublic LocaleResolver localeResolver () {    SessionLocaleResolver localeResolver = new SessionLocaleResolver();    localeResolver.setDefaultLocale(new Locale("en"));return localeResolver;}

@Beanpublic LocaleResolver localeResolver() {    CookieLocaleResolver cookieLocaleResolver = new CookieLocaleResolver();    cookieLocaleResolver.setCookieName("language");    cookieLocaleResolver.setCookieMaxAge(3600);    cookieLocaleResolver.setDefaultLocale(new Locale("en"));return cookieLocaleResolver;}

@Beanpublic LocaleResolver localeResolver() {    FixedLocaleResolver cookieLocaleResolver = new FixedLocaleResolver();    cookieLocaleResolver.setDefaultLocale(new Locale("en"));return cookieLocaleResolver;}
--------------------------------------------------------------------------------------------------------
keytool -genkey -keyalg RSA -alias sb2-recipes -keystore sb2-recipes.pfx -storepass password -validity 3600 -keysize 4096 -storetype pkcs1

server.ssl.key-store=classpath:sb2-recipes.pfxserver.ssl.key-store-type=pkcs12server.ssl.key-store-password=passwordserver.ssl.key-password=passwordserver.ssl.key-alias=sb2-recipes

@Beanpublic TomcatServletWebServerFactory tomcatServletWebServerFactory() {  var factory = new TomcatServletWebServerFactory();  factory.addAdditionalTomcatConnectors(httpConnector());return factory;}

private Connector httpConnector() {   var connector = new Connector(TomcatServletWebServerFactory.DEFAULT_PROTOCOL);  connector.setScheme("http");  connector.setPort(8080);  connector.setSecure(false);return connector;}

@Beanpublic TomcatServletWebServerFactory tomcatServletWebServerFactory() {  var factory = new TomcatServletWebServerFactory();  factory.addAdditionalTomcatConnectors(httpConnector());  factory.addContextCustomizers(securityCustomizer());return factory;}private Connector httpConnector() {   var connector = new Connector(TomcatServletWebServerFactory.DEFAULT_PROTOCOL);  connector.setScheme("http");  connector.setPort(8080);  connector.setSecure(false);  connector.setRedirectPort(8443);return connector;}private TomcatContextCustomizer securityCustomizer() {return context -> {    var securityConstraint = new SecurityConstraint();    securityConstraint.setUserConstraint("CONFIDENTIAL");    var collection = new SecurityCollection();    collection.addPattern("/*");    securityConstraint.addCollection(collection);    context.addConstraint(securityConstraint);  };}

@Beanpublic BeanPostProcessor addHttpConnectorProcessor() {return new BeanPostProcessor() {    @Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName)throws BeansException {if (bean instanceof TomcatServletWebServerFactory) {var factory = (TomcatServletWebServerFactory) bean;factory.addAdditionalTomcatConnectors(httpConnector());}return bean;    }  };}

package com.apress.springbootrecipes.library;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.concurrent.Callable;import java.util.concurrent.ThreadLocalRandom;@RestControllerpublic class HelloWorldController {@GetMappingpublic Callable<String> hello() {return () -> {Thread.sleep(ThreadLocalRandom.current().nextInt(5000));return "Hello World, from Spring Boot 2!";};}}

@RestControllerpublic class HelloWorldController {private final TaskExecutor taskExecutor;public HelloWorldController(TaskExecutor taskExecutor) {this.taskExecutor = taskExecutor;  }  @GetMappingpublic CompletableFuture<String> hello() {return CompletableFuture.supplyAsync(() -> {randomDelay();return "Hello World, from Spring Boot 2!";    }, taskExecutor);  }private void randomDelay() {try {Thread.sleep(ThreadLocalRandom.current().nextInt(5000));    } catch (InterruptedException e) {Thread.currentThread().interrupt();    }  }}

double amount = ThreadLocalRandom.current().nextDouble(1000.00d)

@GetMapping("/orders")public SseEmitter orders() {SseEmitter emitter = new SseEmitter();ExecutorService executor = Executors.newSingleThreadExecutor();executor.execute(() -> {var orders = orderService.findAll();try {for (var order : orders) {randomDelay();emitter.send(order);}emitter.complete();} catch (IOException e) {emitter.completeWithError(e);}});executor.shutdown();return emitter;}

User user = Reflection.constructor().in(User.class).newInstance();


--------------------------------------------------------------------------------------------------------
database.driverClassName=org.hsqldb.jdbcDriver               database.url=jdbc:hsqldb:mem:my-project-test;shutdown=true  database.dialect=hsqldb                                     database.schemaNames=PUBLIC                                 unitils.modules=database,jpa,dbunit 
--------------------------------------------------------------------------------------------------------
import org.junit.Test;import org.unitils.UnitilsJUnit4;import org.unitils.database.annotations.TestDataSource;import org.unitils.dbunit.annotation.DataSet;import org.unitils.dbunit.annotation.ExpectedDataSet;import com.manning.junitbook.ch19.model.User;publicclass UserDaoJpaImplTest extends UnitilsJUnit4 {  @JpaEntityManagerFactory(persistenceUnit="chapter-19")          @PersistenceContext                                         EntityManager em;private final UserDaoJpaImpl dao = new UserDaoJpaImpl();  @Beforepublic void prepareDao() {                        dao.setEntityManager(em);  }  @Test  @DataSet("user.xml")public void testGetUserById() throws Exception {       long id = 1;    User user = dao.getUserById(id);    assertUser(user);  }[...]}

@TestDataSourcevoid setDataSource(DataSource ds) throws SQLException {         Connection connection = ds.getConnection();    dao.setConnection(connection);    dao.createTables();  }

@Test  @DataSets(setUpDataSet="/user-with-telephone.xml")public void testGetUserByIdWithTelephone() throws Exception {    beginTransaction();long id = ELFunctionMapperImpl.getId(User.class);    User user = dao.getUserById(id);    commitTransaction();    assertUserWithTelephone(user);  }  @Test  @DataSets(assertDataSet="/user-with-telephone.xml")public void testAddUserWithTelephone() throws Exception {    beginTransaction();    User user = newUserWithTelephone();    dao.addUser(user);    commitTransaction();long id = user.getId();    assertTrue(id>0);  }

import org.hibernate.event.PostInsertEvent;import org.hibernate.event.PostInsertEventListener;public class ELPostInsertEventListener implements PostInsertEventListener {public void onPostInsert(PostInsertEvent event) {    String className = event.getEntity().getClass().getSimpleName();        Long id = (Long) event.getId();    ELFunctionMapperImpl.setId(className, id);   }}

hibernate.ejb.event.post-insert=  ➥org.hibernate.ejb.event.EJB3PostInsertEventListener,➥com.manning.jia.chapter18.hibernate.ELPostInsertEventListener

@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface DataSets {  String setUpDataSet() default "/empty.xml";        String assertDataSet() default "";                      }

public class UserDaoJdbcImplAnnotationTest extends  AbstractDbUnitTemplateTestCase {  @Test  @DataSets(setUpDataSet="/user-token.xml")public void testGetUserById() throws Exception {    User user = dao.getUserById(id);    assertUser(user);  }    @Test  @DataSets(assertDataSet="/user-token.xml")public void testAddUser() throws Exception {    User user = newUser();    id = dao.addUser(user);    assertTrue(id>0);  }}
--------------------------------------------------------------------------------------------------------
access("hasAuthority('ADMIN') " +"or @accessChecker.hasLocalAccess(authentication)"

Stream.of(names).filter(name -> name.toLowerCase().contains("jms")).sorted(Comparator.naturalOrder()).forEach(name -> {Object bean = ctx.getBean(name);System.out.printf(MSG, name, bean.getClass().getSimpleName());})

http://localhost:8090/actuator/metrics/system.cpu.usage

management.metrics.enable.system=falsemanagement.metrics.enable.tomcat=fals
--------------------------------------------------------------------------------------------------------
<plugin><groupId>org.springframework.boot</groupId><artifactId>spring-boot-maven-plugin</artifactId><configuration><executable>true</executable></configuration></plugin>

your-application.conf

JAVA_OPTS=-Xmx1024mDEBUG=true

<plugin><groupId>org.springframework.boot</groupId><artifactId>spring-boot-maven-plugin</artifactId><dependencies><dependency><groupId>org.springframework.boot.experimental</groupId><artifactId>spring-boot-thin-layout</artifactId><version>1.0.15.RELEASE</version></dependency></dependencies></plugin>

META-INF/thin.properties

thin.repo

FROM openjdk:11-jre-slimVOLUME /tmpARG JAR_FILECOPY ${JAR_FILE} app.jarENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"

<plugin><groupId>com.spotify</groupId><artifactId>dockerfile-maven-plugin</artifactId><version>1.4.4</version><configuration><repository>spring-boot-recipes/${project.name}</repository><tag>${project.version}</tag><buildArgs><JAR_FILE>target/${project.build.finalName}.jar</JAR_FILE></buildArgs></configuration><dependencies><dependency><groupId>javax.activation</groupId><artifactId>javax.activation-api</artifactId><version>1.2.0</version></dependency><dependency><groupId>org.codehaus.plexus</groupId><artifactId>plexus-archiver</artifactId><version>3.6.0</version></dependency></dependencies></plugin>

ocker run -d -e AUDIENCE='Docker' spring-boot-recipes/dockerize:2.0.0-SNAPSHOT

go get github.com/marpaia/graphite-golang

$ java -jar myapp.jar --thin.dryrun --thin.root=target/thin/root
$ java -jar myapp.jar --thin.library=org.springframework.boot.experimental:spring-boot-thin-tools-converter:1.0.21.RELEASE
$ java -jar myapp-exec.jar

$ CP1=`java -jar myapp.jar --thin.classpath=path`
$ CP2=`java -jar otherapp.jar --thin.classpath=path --thin.parent=myapp.jar`

$ java -XX:+UnlockCommercialFeatures -XX:+UseAppCDS -Xshare:off \
  -XX:DumpLoadedClassList=app.classlist \
  -noverify -cp $CP1:myapp.jar demo.MyApplication
$ java -XX:+UnlockCommercialFeatures -XX:+UseAppCDS -Xshare:dump \
  -XX:SharedArchiveFile=app.jsa -XX:SharedClassListFile=app.classlist \
  -noverify -cp $CP1

$ java -XX:+UnlockCommercialFeatures -XX:+UseAppCDS -Xshare:on \
  -XX:SharedArchiveFile=app.jsa -noverify -cp $CP1:myapp.jar demo.MyApplication 
$ java -XX:+UnlockCommercialFeatures -XX:+UseAppCDS -Xshare:on \
  -XX:SharedArchiveFile=app.jsa -noverify -cp $CP1:otherapp.jar demo.OtherApplication
  
./mvnw spring-boot-thin:resolve -Dthin.repo=http://localhost:8081/repository/maven-central
./gradlew thinResolve -P thin.repo=http://localhost:8081/repository/maven-central
--------------------------------------------------------------------------------------------------------
	static class ServiceStream extends ByteArrayOutputStream {

		public ServiceStream() {
			super(1024);
		}

		public void append(String content) throws IOException {
			if (count > 0 && buf[count - 1] != '\n' && buf[count - 1] != '\r') {
				write('\n');
			}

			byte[] contentBytes = content.getBytes("UTF-8");
			this.write(contentBytes);
		}

		public InputStream toInputStream() {
			return new ByteArrayInputStream(buf, 0, count);
		}

	}
--------------------------------------------------------------------------------------------------------
mvn install -s settings.xml

mvn release:prepare -Preporting,distribution
mvn release:perform -Preporting,distribution
--------------------------------------------------------------------------------------------------------
@DisabledIfSystemProperty(named = "file.separator", matches = "[/]")
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.*;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

public class ConditionalAnnotationsUnitTest {
    @Test
    @EnabledOnOs({OS.WINDOWS, OS.MAC})
    public void shouldRunBothWindowsAndMac() {
        System.out.println("runs on Windows and Mac");
    }

    @Test
    @DisabledOnOs(OS.LINUX)
    public void shouldNotRunAtLinux() {
        System.out.println("will not run on Linux");
    }

    @Test
    @EnabledOnJre({JRE.JAVA_10, JRE.JAVA_11})
    public void shouldOnlyRunOnJava10And11() {
        System.out.println("runs with java 10 and 11");
    }

    @Test
    @DisabledOnJre(JRE.OTHER)
    public void thisTestOnlyRunsWithUpToDateJREs() {
        System.out.println("this test will only run on java8, 9, 10 and 11.");
    }

    @Test
    @EnabledIfSystemProperty(named = "java.vm.vendor", matches = "Oracle.*")
    public void onlyIfVendorNameStartsWithOracle() {
        System.out.println("runs only if vendor name starts with Oracle");
    }

    @Test
    @DisabledIfSystemProperty(named = "file.separator", matches = "[/]")
    public void disabledIfFileSeperatorIsSlash() {
        System.out.println("Will not run if file.sepeartor property is /");
    }

    @Test
    @EnabledIfEnvironmentVariable(named = "GDMSESSION", matches = "ubuntu")
    public void onlyRunOnUbuntuServer() {
        System.out.println("only runs if GDMSESSION is ubuntu");
    }

    @Test
    @DisabledIfEnvironmentVariable(named = "LC_TIME", matches = ".*UTF-8.")
    public void shouldNotRunWhenTimeIsNotUTF8() {
        System.out.println("will not run if environment variable LC_TIME is UTF-8");
    }

    @Test
    @EnabledIf("'FR' == systemProperty.get('user.country')")
    public void onlyFrenchPeopleWillRunThisMethod() {
        System.out.println("will run only if user.country is FR");
    }

    @Test
    @DisabledIf("java.lang.System.getProperty('os.name').toLowerCase().contains('mac')")
    public void shouldNotRunOnMacOS() {
        System.out.println("will not run if our os.name is mac");
    }

    @Test
    @EnabledIf(value = {
            "load('nashorn:mozilla_compat.js')",
            "importPackage(java.time)",
            "",
            "var thisMonth = LocalDate.now().getMonth().name()",
            "var february = Month.FEBRUARY.name()",
            "thisMonth.equals(february)"
    },
            engine = "nashorn",
            reason = "Self-fulfilling: {result}")
    public void onlyRunsInFebruary() {
        System.out.println("this test only runs in February");
    }

    @Test
    @DisabledIf("systemEnvironment.get('XPC_SERVICE_NAME') != null " +
            "&& systemEnvironment.get('XPC_SERVICE_NAME').contains('intellij')")
    public void notValidForIntelliJ() {
        System.out.println("this test will run if our ide is INTELLIJ");
    }

    @Target(ElementType.METHOD)
    @Retention(RetentionPolicy.RUNTIME)
    @Test
    @DisabledOnOs({OS.WINDOWS, OS.SOLARIS, OS.OTHER})
    @EnabledOnJre({JRE.JAVA_9, JRE.JAVA_10, JRE.JAVA_11})
    @interface ThisTestWillOnlyRunAtLinuxAndMacWithJava9Or10Or11 {
    }

    @ThisTestWillOnlyRunAtLinuxAndMacWithJava9Or10Or11
    public void someSuperTestMethodHere() {
        System.out.println("this method will run with java9, 10, 11 and Linux or macOS.");
    }

    @Target(ElementType.METHOD)
    @Retention(RetentionPolicy.RUNTIME)
    @DisabledIf("Math.random() >= 0.5")
    @interface CoinToss {
    }

    @RepeatedTest(2)
    @CoinToss
    public void gamble() {
        System.out.println("This tests run status is a gamble with %50 rate");
    }
}
--------------------------------------------------------------------------------------------------------
npm install express
npm install -D @types/express
--------------------------------------------------------------------------------------------------------
import java.io.Serializable;
import java.util.Date;
import javax.persistence.Basic;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Lob;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.solr.analysis.LowerCaseFilterFactory;
import org.apache.solr.analysis.SnowballPorterFilterFactory;
import org.apache.solr.analysis.StandardTokenizerFactory;
import org.apache.solr.analysis.SynonymFilterFactory;
import org.hibernate.search.annotations.Analyzer;
import org.hibernate.search.annotations.AnalyzerDef;
import org.hibernate.search.annotations.Boost;
import org.hibernate.search.annotations.DateBridge;
import org.hibernate.search.annotations.Field;
import org.hibernate.search.annotations.Index;
import org.hibernate.search.annotations.Indexed;
import org.hibernate.search.annotations.Latitude;
import org.hibernate.search.annotations.Longitude;
import org.hibernate.search.annotations.Parameter;
import org.hibernate.search.annotations.Resolution;
import org.hibernate.search.annotations.Spatial;
import org.hibernate.search.annotations.SpatialMode;
import org.hibernate.search.annotations.Store;
import org.hibernate.search.annotations.TokenFilterDef;
import org.hibernate.search.annotations.TokenizerDef;

/**
*
* @author sam
*/
@Entity
@Table(name = "myisam_product_article", catalog = "hibernatedb", schema = "")
@XmlRootElement
@NamedQueries({
    @NamedQuery(name = "MyisamProductArticle.findAll", query = "SELECT m FROM MyisamProductArticle m"),
    @NamedQuery(name = "MyisamProductArticle.findByArticleId", query = "SELECT m FROM MyisamProductArticle m WHERE m.articleId = :articleId"),
    @NamedQuery(name = "MyisamProductArticle.findByLat", query = "SELECT m FROM MyisamProductArticle m WHERE m.lat = :lat"),
    @NamedQuery(name = "MyisamProductArticle.findByLon", query = "SELECT m FROM MyisamProductArticle m WHERE m.lon = :lon"),
    @NamedQuery(name = "MyisamProductArticle.findByCreationDate", query = "SELECT m FROM MyisamProductArticle m WHERE m.creationDate = :creationDate")})

@Spatial(spatialMode = SpatialMode.GRID)
//This annotation tells hibernate search that this class has to be indexed
@Indexed(index = "MyisamProductArticle")
@Analyzer(impl = org.apache.lucene.analysis.standard.StandardAnalyzer.class)
@AnalyzerDef(name = "customanalyzer", tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
        filters = {@TokenFilterDef(factory = LowerCaseFilterFactory.class),
                    @TokenFilterDef(factory = SnowballPorterFilterFactory.class, params = {
                        @Parameter(name = "language", value = "English"),
                    }),
                    @TokenFilterDef(factory = SynonymFilterFactory.class, params = {
                        @Parameter(name = "ignoreCase", value = "true"),
                        @Parameter(name = "expand", value = "true"),
                        @Parameter(name = "synonyms", value="syntest.txt")})
                    })
public class MyisamProductArticle implements Serializable, Comparable<MyisamProductArticle> {
    private static final long serialVersionUID = 1L;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Basic(optional = false)
    @Column(name = "article_id")
    private Integer articleId;
    @Lob
    @Size(max = 65535)
    @Column(name = "a_desc")
    @Analyzer(definition = "customanalyzer")
    @Field(index = Index.YES, store = Store.YES)
    private String aDesc;
    // @Max(value=?)  @Min(value=?)//if you know range of your decimal fields consider using these annotations to enforce field validation
    @Column(name = "lat")
    @Latitude(of="location")
    private Double lat;
    @Column(name = "lon")
    @Longitude(of="location")
    private Double lon;
    @Column(name = "creation_date")
    @Temporal(TemporalType.DATE)
    private Date creationDate;

    public MyisamProductArticle() {
    }

    public MyisamProductArticle(Integer articleId) {
        this.articleId = articleId;
    }

    public Integer getArticleId() {
        return articleId;
    }

    public void setArticleId(Integer articleId) {
        this.articleId = articleId;
    }

    public String getADesc() {
        return aDesc;
    }

    public void setADesc(String aDesc) {
        this.aDesc = aDesc;
    }

    public Double getLat() {
        return lat;
    }

    public void setLat(Double lat) {
        this.lat = lat;
    }

    public Double getLon() {
        return lon;
    }

    public void setLon(Double lon) {
        this.lon = lon;
    }

    public Date getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(Date creationDate) {
        this.creationDate = creationDate;
    }

    @Override
    public int hashCode() {
        int hash = 0;
        hash += (articleId != null ? articleId.hashCode() : 0);
        return hash;
    }

    @Override
    public boolean equals(Object object) {
        // TODO: Warning - this method won't work in the case the id fields are not set
        if (!(object instanceof MyisamProductArticle)) {
            return false;
        }
        MyisamProductArticle other = (MyisamProductArticle) object;
        if ((this.articleId == null && other.articleId != null) || (this.articleId != null && !this.articleId.equals(other.articleId))) {
            return false;
        }
        return true;
    }

    // default comparator on Date
    @Override
    public int compareTo(MyisamProductArticle compareArticle) {
        //ascending order
        return this.creationDate.compareTo(compareArticle.creationDate);

        //descending order
        //return compareAritcle.compareTo(this.creationDate.creationDate);

   }
    
    @Override
    public String toString() {
        return "HibernateSearch.entity.MyisamProductArticle[ articleId=" + articleId + " ]";
    }
    
}


Thank you for your time again.
Samuel


Top	 Profile   

samsam9988	
 Post subject: Re: DelegateNamedAnalyzer not found in Hibernate-search 4.2.0PostPosted: Mon Jan 28, 2013 5:18 am 
Regular
Regular

Joined: Fri Feb 04, 2011 8:34 pm
Posts: 66	
After added value="LUCENE_36" in the following persistence.xml file,

Code:
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="1.0" xmlns="http://java.sun.com/xml/ns/persistence" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd">
  <persistence-unit name="HibernateSeasrchTestPU" transaction-type="JTA">
    <provider>org.hibernate.ejb.HibernatePersistence</provider>
    <jta-data-source>java:jboss/datasources/HibernateSearchTest</jta-data-source>
    <exclude-unlisted-classes>false</exclude-unlisted-classes>
    <properties>
      <property name="hibernate.hbm2ddl.auto" value="update"/>
      <property name="hibernate.show_sql" value="true"/>
      <property name="hibernate.format_sql" value="true"/>
      <property name="hibernate.max_fetch_depth" value="4"/>
      <property name="hibernate.default_batch_fetch_size" value="365"/>
       
      <property name="hibernate.search.default.directory_provider" value="filesystem"/>
      <property name="hibernate.search.default.indexBase" value="./lucene/indexes"/>
      <property name="hibernate.search.default.batch.merge_factor" value="10"/>
      <property name="hibernate.search.default.batch.max_buffered_docs" value="10"/>
      <property name="hibernate.search.lucene_version" value="LUCENE_36" />

    </properties>
  </persistence-unit>
</persistence>
--------------------------------------------------------------------------------------------------------
@Component
public class TokenProcessingFilter extends UsernamePasswordAuthenticationFilter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest httpRequest = this.getAsHttpRequest(request);
        String authToken = this.extractAuthTokenFromRequest(httpRequest);
        String userName = TokenUtils.getUserNameFromToken(authToken);
        if (userName != null) {/*
            UserDetails userDetails = userDetailsService.loadUserByUsername(userName);*/
            UserDetails userDetails = fakeUserDetails();
            if (TokenUtils.validateToken(authToken, userDetails)) {
                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(userDetails.getUsername(), userDetails.getPassword(), userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(httpRequest));
                SecurityContextHolder.getContext().setAuthentication(authentication);
                Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
            }
        }
        chain.doFilter(request, response);
    }

    private HttpServletRequest getAsHttpRequest(ServletRequest request){
        if (!(request instanceof HttpServletRequest)) {
            throw new RuntimeException("Expecting an HTTP request");
        }
        return (HttpServletRequest) request;
    }


    private String extractAuthTokenFromRequest(HttpServletRequest httpRequest) {
        /* Get token from header */
        String authToken = httpRequest.getHeader("x-auth-token");
        /* If token not found get it from request parameter */
        if (authToken == null) {
            authToken = httpRequest.getParameter("token");
        }
        return authToken;
    }

    private UserDetails fakeUserDetails(){
        UsernamePasswordAuthenticationToken authenticationToken = new
                UsernamePasswordAuthenticationToken("user","password");

        List<SimpleGrantedAuthority> auth= new ArrayList<>();
        auth.add(new SimpleGrantedAuthority("USER"));
        return  new User("user","password",auth);
    }
}

@Bean
TokenProcessingFilter tokenProcessingFilter() {
  TokenProcessingFilter tokenProcessingFilter = new TokenProcessingFilter();
  tokenProcessingFilter.setAuthenticationManager(authenticationManager());
  return tokenProcessingFilter;
}

protected void configure(HttpSecurity http) throws Exception {
  ...
  .addFilter(tokenProcessingFilter())
--------------------------------------------------------------------------------------------------------
	@ElementCollection
	@JoinTable(name = "WEBSITE_COOKIES", joinColumns = @JoinColumn(name = "WEBSITE_ID"))
	@MapKeyColumn(name = "COOKIES_KEY")
	@Column(name = "COOKIES_VALUE")
	private Map<String, String> cookies;
--------------------------------------------------------------------------------------------------------
import java.util.ArrayList;
import java.util.List;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import com.mifmif.networking.mspider.model.ParameterValue;

/**
 * It present the parameter model that has a website. values used to query the
 * website are presented by <code>ParameterValue</code>
 * 
 * @author y.mifrah
 *
 */
@Entity
@Table(name = "URL_PARAMETER")
public class URLParameter {

	@Id
	@SequenceGenerator(name = "URL_PARAMETER_SEQ_GEN", sequenceName = "URL_PARAMETER_SEQ_GEN")
	@GeneratedValue(generator = "URL_PARAMETER_SEQ_GEN", strategy = GenerationType.TABLE)
	@Column(name = "ID")
	private Long id;

	/**
	 * Name of the parameter that will be used when requesting the url
	 */
	private String name;
	/**
	 * Value could have a constant value or a pattern expression that will be
	 * used to generate parameter value to use when requesting the url
	 */
	private String expression;

	/**
	 * description of the parameter (not used when we request the url)
	 */
	private String description;
	/**
	 * Type of the parameter : CONSTANT or PATTERN_EXPRESSION
	 */
	@Enumerated(EnumType.STRING)
	private URLParameterType type = URLParameterType.PATTERN_EXPRESSION;
	@ManyToOne
	@JoinColumn(name = "URL_PATTERN_ID")
	private URLPattern pattern;
	@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "urlParameter")
	private List<ParameterValue> parameterValues;

	/**
	 * 
	 */
	public URLParameter() {
		// TODO Auto-generated constructor stub
	}

	/**
	 * @param pattern
	 * @param name
	 * @param value
	 */
	public URLParameter(URLPattern pattern, String name, String expression) {
		super();
		this.pattern = pattern;
		this.name = name;
		this.expression = expression;
		parameterValues = new ArrayList<ParameterValue>();
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public URLParameterType getType() {
		return type;
	}

	public void setType(URLParameterType type) {
		this.type = type;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public URLPattern getPattern() {
		return pattern;
	}

	public void setPattern(URLPattern pattern) {
		this.pattern = pattern;
	}

	public String getExpression() {
		return expression;
	}

	public void setExpression(String expression) {
		this.expression = expression;
	}

	public List<ParameterValue> getParameterValues() {
		return parameterValues;
	}

	public void setParameterValues(List<ParameterValue> parameterValues) {
		this.parameterValues = parameterValues;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}
}
--------------------------------------------------------------------------------------------------------
import java.util.HashMap;
import java.util.Map;

import com.mifmif.gefmmat.core.Agent;
import com.mifmif.gefmmat.core.Result;
import com.mifmif.gefmmat.core.Task;

/**
 * @author y.mifrah
 *
 */
public class CamouflageDishonestStudent extends Student {

	public CamouflageDishonestStudent() {
		setTaskHandler(new CamouflageDishonestTaskHandler(this));
	}

	class CamouflageDishonestTaskHandler extends HonestTaskHandler {
		Map<String, Status> proposerIdStatus = new HashMap<String, Status>();

		public CamouflageDishonestTaskHandler(Agent ownerAgent) {
			super(ownerAgent);
		}

		@Override
		public Result performTask(Task task) {
			boolean performFairly = isTimeToPerformFairly(task);
			Result result = null;
			if (performFairly) {
				result = prepareFairResult(task);
			} else {
				result = prepareUnfairResult(task);

			}
			updateProposerStatus(task, performFairly);
			return result;

		}

		private void updateProposerStatus(Task task, boolean performFairly) {
			String proposerId = task.getProposerId();
			Status status = proposerIdStatus.get(proposerId);
			if (performFairly) {
				status.incrementFairlyCount();
			} else {
				status.incrementUnfairlyCount();
			}
		}

		/**
		 * This method inform whether if the camouflageAgent could perform the task unfairly or fairly
		 * 
		 * @param task
		 * @return
		 */
		private boolean isTimeToPerformFairly(Task task) {
			String proposerId = task.getProposerId();
			Status status = proposerIdStatus.get(proposerId);
			if (status == null) {
				status = new Status();
				proposerIdStatus.put(proposerId, status);
				return true;
			}
			if (status.getFairCount() > 10)
				return false;
			// analyze status e.g. how many time did we perform a valid
			// result
			// for this agent.
			return true;
		}

	}

	static class Status {
		private long fairCount, unfairCount;// TODO we have to think about
											// another

		// structure that handle the order and the
		// services of tasks processed
		// fairly/unfairly

		public void incrementFairlyCount() {
			fairCount++;
		}

		public void incrementUnfairlyCount() {
			unfairCount++;
		}

		public long getFairCount() {
			return fairCount;
		}

		public long getUnfairCount() {
			return unfairCount;
		}
	}
}
--------------------------------------------------------------------------------------------------------
import java.util.Map;

import com.mifmif.gefmmat.core.Result;
import com.mifmif.gefmmat.core.Service;
import com.mifmif.gefmmat.core.Task;
import com.mifmif.gefmmat.testbed.student.exception.InvalidInputParameterException;
import com.mifmif.gefmmat.testbed.student.exception.TaskProcessingException;
import com.mifmif.gefmmat.testbed.student.operation.task.SpeedTask;
import com.mifmif.gefmmat.testbed.student.operation.task.EnergyTask.EnergyResult;
import com.mifmif.gefmmat.testbed.student.operation.task.SpeedTask.SpeedResult;

/**
 * @author y.mifrah
 *
 */
public class CalculateSpeed extends Service {
	private double d, t, speedResult;

	public CalculateSpeed() {
		setName("calculateSpeed");
	}

	@Override
	protected void prepareInputs(Task task) throws InvalidInputParameterException {
		try {
			d = ((SpeedTask) task).getD();
			t = ((SpeedTask) task).getT();
		} catch (NumberFormatException exception) {
			throw new InvalidInputParameterException();
		}
		return;
	}

	@Override
	protected Result processTask(Task task) throws TaskProcessingException {
		SpeedResult result = new SpeedResult();
		speedResult = d / t;
		result.setSpeedResult(speedResult);
		return result;
	}

	@Override
	public boolean isResultTaskValid(Task task) {
		try {
			SpeedResult curResult = (SpeedResult) task.getResult();
			SpeedResult validResult = (SpeedResult) execute(task);
			return curResult.getSpeedResult().equals(validResult.getSpeedResult());
		} catch (Exception exception) {
			exception.printStackTrace();
		}

		return false;
	}
}
--------------------------------------------------------------------------------------------------------
import java.util.Map;

import com.mifmif.gefmmat.core.Result;
import com.mifmif.gefmmat.core.Service;
import com.mifmif.gefmmat.core.Task;
import com.mifmif.gefmmat.testbed.student.exception.InvalidInputParameterException;
import com.mifmif.gefmmat.testbed.student.exception.TaskProcessingException;
import com.mifmif.gefmmat.testbed.student.operation.task.AdditionTask;
import com.mifmif.gefmmat.testbed.student.operation.task.AdditionTask.AdditionResult;

/**
 * Addition service implementation
 * 
 * @author y.mifrah
 *
 */
public class Addition extends Service {
	double a, b, additionResult;

	public Addition() {
		setName("addition");
	}

	@Override
	protected void prepareInputs(Task task) throws InvalidInputParameterException {
		try {
			a = ((AdditionTask) task).getA();
			b = ((AdditionTask) task).getB();
		} catch (Exception exception) {
			throw new InvalidInputParameterException();
		}
	}

	@Override
	protected Result processTask(Task task) throws TaskProcessingException {
		AdditionResult result = new AdditionResult();
		additionResult = a + b;
		result.setAdditionResult(additionResult);
		return result;
	}

	@Override
	public boolean isResultTaskValid(Task task) {
		try {
			AdditionResult curResult = (AdditionResult) task.getResult();
			AdditionResult validResult = (AdditionResult) execute(task);
			return curResult.getAdditionResult().equals(validResult.getAdditionResult());
		} catch (Exception exception) {
			exception.printStackTrace();
		}

		return false;
	}
}
--------------------------------------------------------------------------------------------------------
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

/**
 * @author y.mifrah
 *
 */
public class Feature implements Serializable {

	private String id;
	private String name;
	private String value;
	private float SLAValue;
	private float width;
	/**
	 * 
	 */
	private static Map<String, Feature> featureMap = new HashMap<String, Feature>();

	private Feature() {
	}

	synchronized public static Feature getInstance(String featureName) {
		Feature feature = featureMap.get(featureName);
		if (feature == null) {
			feature = new Feature();
			feature.setName(featureName);
			featureMap.put(featureName, feature);
		}
		return feature;
	}

	/**
	 * @return the name
	 */
	public String getName() {
		return name;
	}

	/**
	 * @param name
	 *            the name to set
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * @return the value
	 */
	public String getValue() {
		return value;
	}

	/**
	 * @param value
	 *            the value to set
	 */
	public void setValue(String value) {
		this.value = value;
	}

	/**
	 * @return the id
	 */
	public String getId() {
		return id;
	}

	/**
	 * @param id
	 *            the id to set
	 */
	public void setId(String id) {
		this.id = id;
	}

	public float getSLAValue() {
		return SLAValue;
	}

	public void setSLAValue(float sLAValue) {
		SLAValue = sLAValue;
	}

	public float getWidth() {
		return width;
	}

	public void setWidth(float width) {
		this.width = width;
	}
}

import java.util.Date;

/**
 * Immutable ResponseTime Event class. The process control system creates these events. The
 * ResponseTimeEventHandler picks these up and processes them.
 */
public class ResponseTimeEvent {

    /** Response Time in milliseconds. */
    private int responseTime;
    
    /** Time responseTime reading was taken. */
    private Date timeOfReading;
    
    /**
     * Single value constructor.
     * @param value ResponseTime in Milliseconds.
     */
    /**
     * ResponseTime constructor.
     * @param responseTime ResponseTime in Milliseconds
     * @param timeOfReading Time of Reading
     */
    public ResponseTimeEvent(int responseTime, Date timeOfReading) {
        this.responseTime = responseTime;
        this.timeOfReading = timeOfReading;
    }

    /**
     * Get the ResponseTime.
     * @return ResponseTime in Milliseconds
     */
    public int getResponseTime() {
        return responseTime;
    }
       
    /**
     * Get time ResponseTime reading was taken.
     * @return Time of Reading
     */
    public Date getTimeOfReading() {
        return timeOfReading;
    }

    @Override
    public String toString() {
        return "ResponseTimeEvent ["+timeOfReading + ": " +responseTime + " ms]";
    }

}
--------------------------------------------------------------------------------------------------------
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.util.StringUtils;

import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

public class HttpSessionCreatedListener implements HttpSessionListener {
    private final Log logger = LogFactory.getLog(this.getClass());

    @Override
    public void sessionCreated(HttpSessionEvent event) {
        String stackTrace = StringUtils.arrayToDelimitedString(Thread.currentThread().getStackTrace(), " ");
        logger.warn("HttpSession was created: " + stackTrace);
        if (event.getSession() == null) {
            return;
        }
        try {
            logger.warn("Invalidating unexpected HttpSession");
            event.getSession().invalidate();
        } catch (IllegalStateException e) {
            logger.warn("Could not invalidate already invalidated HttpSession", e);
        }
    }

    @Override
    public void sessionDestroyed(HttpSessionEvent event) {
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.security.web.csrf.CsrfTokenRepository;
import org.springframework.security.web.csrf.DefaultCsrfToken;
import org.springframework.util.Assert;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.math.BigInteger;
import java.security.SecureRandom;

/**
 * Cross-site request forgery (CSRF or CSRF) protection using double submit cookies:
 * https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#Double_Submit_Cookies
 * <p>
 * Issues to be aware of when using double submit cookies for CSRF protection: http://security.stackexchange.com/a/61039
 * <p>
 * Some code borrowed from cloudfoundry/uaa under the Apache 2.0 license:
 * https://github.com/cloudfoundry/uaa/blob/41dba9d81dbdf24ede4fb9719de28b1b88b3e1b4/common/src/main/java/org/cloudfoundry/identity/uaa/web/CookieBasedCsrfTokenRepository.java
 */
public class CookieCsrfTokenRepository implements CsrfTokenRepository {
    public static final String DEFAULT_CSRF_COOKIE_NAME = "csrf";

    private SecureRandom secureRandom = new SecureRandom();
    private String csrfHeaderName = "X-CSRF-TOKEN";
    private String csrfParameterName = "_csrf";
    private String csrfCookieName = DEFAULT_CSRF_COOKIE_NAME;
    private String csrfCookiePath = null;
    private int csrfCookieMaxAgeSeconds = -1;  // default to session cookie (non-persistent)

    @Override
    public CsrfToken generateToken(HttpServletRequest request) {
        String tokenValue = new BigInteger(130, secureRandom).toString(32); // http://stackoverflow.com/a/41156
        return new DefaultCsrfToken(csrfHeaderName, csrfParameterName, tokenValue);
    }

    @Override
    public void saveToken(CsrfToken token, HttpServletRequest request, HttpServletResponse response) {
        Cookie csrfCookie;
        if (token == null) {
            csrfCookie = new Cookie(csrfCookieName, "");
            csrfCookie.setMaxAge(0);
        } else {
            csrfCookie = new Cookie(csrfCookieName, token.getToken());
            csrfCookie.setMaxAge(csrfCookieMaxAgeSeconds);
        }
        csrfCookie.setHttpOnly(true);
        csrfCookie.setSecure(request.isSecure());
        csrfCookie.setPath(csrfCookiePath);
        response.addCookie(csrfCookie);
    }

    @Override
    public CsrfToken loadToken(HttpServletRequest request) {
        if (request.getCookies() != null) {
            for (Cookie cookie : request.getCookies()) {
                if (cookie != null && csrfCookieName.equals(cookie.getName())) {
                    return new DefaultCsrfToken(csrfHeaderName, csrfParameterName, cookie.getValue());
                }
            }
        }
        return null;
    }

    public void setSecureRandom(SecureRandom secureRandom) {
        Assert.notNull(secureRandom);
        this.secureRandom = secureRandom;
    }

    public void setCsrfHeaderName(String csrfHeaderName) {
        Assert.notNull(csrfHeaderName);
        this.csrfHeaderName = csrfHeaderName;
    }

    public void setCsrfParameterName(String csrfParameterName) {
        Assert.notNull(csrfParameterName);
        this.csrfParameterName = csrfParameterName;
    }

    public void setCsrfCookieName(String csrfCookieName) {
        Assert.notNull(csrfCookieName);
        this.csrfCookieName = csrfCookieName;
    }

    public void setCsrfCookiePath(String csrfCookiePath) {
        this.csrfCookiePath = csrfCookiePath;
    }

    public void setCsrfCookieMaxAgeSeconds(int csrfCookieMaxAgeSeconds) {
        this.csrfCookieMaxAgeSeconds = csrfCookieMaxAgeSeconds;
    }
}


import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWEHeader;
import com.nimbusds.jose.JWEObject;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.Payload;
import com.nimbusds.jose.crypto.DirectDecrypter;
import com.nimbusds.jose.crypto.DirectEncrypter;
import com.nimbusds.jose.crypto.MACSigner;
import com.nimbusds.jose.crypto.MACVerifier;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.util.Assert;

import java.text.ParseException;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collections;
import java.util.Date;
import java.util.List;

public class JwtEncryption implements TokenEncryption {
    private final Log logger = LogFactory.getLog(this.getClass());
    private final byte[] sessionJwtEncryptionKey;

    private List<JwtClaimsSetVerifier> jwtClaimsSetVerifiers = new ArrayList<>(Collections.singletonList(new ExpirationJwtClaimsSetVerifier()));
    private int jwtExpirationSeconds = 3600;
    private JWSAlgorithm jwsAlgorithm = JWSAlgorithm.HS256;
    private JWEAlgorithm jweAlgorithm = JWEAlgorithm.DIR;
    private EncryptionMethod encryptionMethod = EncryptionMethod.A256GCM;

    public JwtEncryption(String sessionJwtEncryptionKeyBase64) {
        Assert.notNull(sessionJwtEncryptionKeyBase64);
        this.sessionJwtEncryptionKey = Base64.getDecoder().decode(sessionJwtEncryptionKeyBase64);
    }

    @Override
    public String encryptAndSign(String jwtSubject) {
        try {
            Date date = Date.from(ZonedDateTime.now(ZoneOffset.UTC).plusSeconds(jwtExpirationSeconds).toInstant());
            JWTClaimsSet claimsSet = new JWTClaimsSet.Builder().subject(jwtSubject).expirationTime(date).build();
            SignedJWT signedJWT = new SignedJWT(new JWSHeader(jwsAlgorithm), claimsSet);
            signedJWT.sign(new MACSigner(sessionJwtEncryptionKey));
            JWEHeader jweHeader = new JWEHeader.Builder(jweAlgorithm, encryptionMethod).contentType("JWT").build();
            JWEObject jweObject = new JWEObject(jweHeader, new Payload(signedJWT));
            jweObject.encrypt(new DirectEncrypter(sessionJwtEncryptionKey));
            return jweObject.serialize();
        } catch (JOSEException e) {
            throw new RuntimeException("Could not create JWT", e);
        }
    }

    @Override
    public String decryptAndVerify(String encryptedAndSignedJwt) {
        try {
            JWEObject jweObject = JWEObject.parse(encryptedAndSignedJwt);
            jweObject.decrypt(new DirectDecrypter(sessionJwtEncryptionKey));
            SignedJWT signedJWT = jweObject.getPayload().toSignedJWT();
            if (!signedJWT.verify(new MACVerifier(sessionJwtEncryptionKey))) {
                logger.warn("JWT signature verification failed.");
                return null;
            }
            for (JwtClaimsSetVerifier verifier : jwtClaimsSetVerifiers) {
                if (!verifier.verify(signedJWT.getJWTClaimsSet())) {
                    logger.warn("JWT claims verification failed.");
                    return null;
                }
            }
            return signedJWT.getJWTClaimsSet().getSubject();
        } catch (ParseException | JOSEException e) {
            throw new RuntimeException("Could not parse JWT", e);
        }
    }

    public void setJwtClaimsSetVerifiers(List<JwtClaimsSetVerifier> jwtClaimsSetVerifiers) {
        Assert.notNull(jwtClaimsSetVerifiers);
        this.jwtClaimsSetVerifiers = new ArrayList<>(jwtClaimsSetVerifiers);
    }

    public boolean addJwtClaimsSetVerifier(JwtClaimsSetVerifier jwtClaimsSetVerifier) {
        Assert.notNull(jwtClaimsSetVerifier);
        return this.jwtClaimsSetVerifiers.add(jwtClaimsSetVerifier);
    }

    public void setJwtExpirationSeconds(int jwtExpirationSeconds) {
        this.jwtExpirationSeconds = jwtExpirationSeconds;
    }

    public void setJwsAlgorithm(JWSAlgorithm jwsAlgorithm) {
        Assert.notNull(jwsAlgorithm);
        this.jwsAlgorithm = jwsAlgorithm;
    }

    public void setJweAlgorithm(JWEAlgorithm jweAlgorithm) {
        Assert.notNull(jweAlgorithm);
        this.jweAlgorithm = jweAlgorithm;
    }

    public void setEncryptionMethod(EncryptionMethod encryptionMethod) {
        Assert.notNull(encryptionMethod);
        this.encryptionMethod = encryptionMethod;
    }
}
--------------------------------------------------------------------------------------------------------
    @Bean
    ServletListenerRegistrationBean<HttpSessionListener> httpSessionCreatedListener() {
        ServletListenerRegistrationBean<HttpSessionListener> listenerRegistrationBean = new ServletListenerRegistrationBean<>();
        listenerRegistrationBean.setListener(new HttpSessionCreatedListener());
        return listenerRegistrationBean;
    }
	
	import au.gov.dto.servlet.http.HttpSessionCreatedListener;
import au.gov.dto.servlet.http.HttpsOnlyFilter;
import au.gov.dto.servlet.http.NoHttpSessionFilter;
import au.gov.dto.springframework.security.web.context.CookieSecurityContextRepository;
import au.gov.dto.springframework.security.web.context.JwtEncryption;
import au.gov.dto.springframework.security.web.csrf.CookieCsrfTokenRepository;
import au.gov.dto.springframework.security.web.savedrequest.CookieRequestCache;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.embedded.FilterRegistrationBean;
import org.springframework.boot.context.embedded.ServletContextInitializer;
import org.springframework.boot.context.embedded.ServletListenerRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.servlet.http.HttpSessionListener;
import java.util.Collections;

@Configuration
class AppConfig {
    @Bean
    ServletContextInitializer noSessionTrackingServletContextInitializer() {
        return servletContext -> servletContext.setSessionTrackingModes(Collections.emptySet());
    }

    @Bean
    ServletListenerRegistrationBean<HttpSessionListener> httpSessionCreatedListener() {
        ServletListenerRegistrationBean<HttpSessionListener> listenerRegistrationBean = new ServletListenerRegistrationBean<>();
        listenerRegistrationBean.setListener(new HttpSessionCreatedListener());
        return listenerRegistrationBean;
    }

    @Bean
    FilterRegistrationBean noHttpSessionFilter() {
        FilterRegistrationBean registration = new FilterRegistrationBean();
        registration.setFilter(new NoHttpSessionFilter());
        registration.addUrlPatterns("/*");
        return registration;
    }

    @Bean
    CookieCsrfTokenRepository csrfTokenRepository() {
        return new CookieCsrfTokenRepository();
    }

    @Bean
    @Autowired
    CookieSecurityContextRepository securityContextRepository(@Value("${session.encryption.key.base64}") String sessionEncryptionKeyBase64) {
        return new CookieSecurityContextRepository(new JwtEncryption(sessionEncryptionKeyBase64));
    }

    @Bean
    CookieRequestCache cookieRequestCache() {
        return new CookieRequestCache();
    }

    @Bean
    FilterRegistrationBean httpsOnlyFilter() {
        FilterRegistrationBean registration = new FilterRegistrationBean();
        registration.setFilter(new HttpsOnlyFilter());
        registration.addUrlPatterns("/*");
        return registration;
    }
}
--------------------------------------------------------------------------------------------------------

import au.gov.dto.springframework.security.web.authentication.CookieSavedRequestAwareAuthenticationSuccessHandler;
import au.gov.dto.springframework.security.web.authentication.StatelessSimpleUrlAuthenticationFailureHandler;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.context.SecurityContextRepository;
import org.springframework.security.web.csrf.CsrfTokenRepository;
import org.springframework.security.web.savedrequest.RequestCache;

@Configuration
@EnableWebSecurity
class WebSecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private SecurityContextRepository securityContextRepository;

    @Autowired
    private CsrfTokenRepository csrfTokenRepository;

    @Autowired
    private RequestCache requestCache;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
            .securityContext()
                .securityContextRepository(securityContextRepository)
                .and()
            .csrf()
                .csrfTokenRepository(csrfTokenRepository)
                .and()
            .requestCache()
                .requestCache(requestCache)
                .and()
            .anonymous()
                .disable()
            .authorizeRequests()
                .antMatchers("/").permitAll()
                .anyRequest().authenticated()
                .and()
            .formLogin()
                .successHandler(new CookieSavedRequestAwareAuthenticationSuccessHandler(requestCache))
                .failureHandler(new StatelessSimpleUrlAuthenticationFailureHandler("/login?error"))
                .permitAll()
                .and()
            .logout()
                .logoutSuccessUrl("/")
                .permitAll();
    }

    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers(HttpMethod.GET, "/");
    }

    @Override
    @Autowired
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth
            .inMemoryAuthentication()
                .withUser("user").password("password").roles("USER");
    }
}
--------------------------------------------------------------------------------------------------------
package com.paragon.mailingcontour.commons.rest.handler;

import org.springframework.stereotype.Component;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;

@Component
public class RequestFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        String threadName = Thread.currentThread().getName();
        try {
            Thread.currentThread().setName(String.format("%1$s_[started:%2$s | user:%3$s | uri:%4$s]_%1$s", threadName, timeNow(), user(), uri(request)));
            chain.doFilter(request, response);
        } finally {
            Thread.currentThread().setName(threadName);
        }
    }

    private String uri(ServletRequest request) {
        return ((HttpServletRequest) request).getRequestURI();
    }

    private String timeNow() {
        return ZonedDateTime.now().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
    }

    private String user() {
        return "johndoe";
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void destroy() {
    }
}

--------------------------------------------------------------------------------------------------------
/**
 * An enumeration of the different types of operation supported by an endpoint.
 *
 * @author Andy Wilkinson
 * @since 2.0.0
 * @see Operation
 */
public enum OperationType {

	/**
	 * A read operation.
	 */
	READ,

	/**
	 * A write operation.
	 */
	WRITE,

	/**
	 * A delete operation.
	 */
	DELETE

}
--------------------------------------------------------------------------------------------------------
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.AsyncConfigurerSupport;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;

@EnableAsync(proxyTargetClass = true)
@SpringBootApplication
public class Application extends AsyncConfigurerSupport {

  @Override
  public Executor getAsyncExecutor() {
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setTaskDecorator(new MdcTaskDecorator());
    executor.initialize();
    return executor;
  }

  public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
  }
--------------------------------------------------------------------------------------------------------
import org.slf4j.MDC;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.GenericFilterBean;

import javax.servlet.*;
import java.io.IOException;

@Component
public class MdcFilter extends GenericFilterBean {

  @Override
  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
      throws IOException, ServletException {
    try {
      MDC.put("mdcData", "[userId:Duke]");
      chain.doFilter(request, response);
    } finally {
      MDC.clear();
    }
  }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.beans.factory.annotation.Autowired;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Autowired
@Retention(RetentionPolicy.RUNTIME)
public @interface LocalizedMessage {

  String value() default "";

}
import org.springframework.beans.factory.InjectionPoint;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.MessageSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;
import org.springframework.context.support.ResourceBundleMessageSource;
import org.springframework.core.annotation.AnnotationUtils;

@Configuration
public class MessageConfig {

  @Bean
  public MessageSource messageSource() {

    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
    messageSource.setBasename("messages");

    return messageSource;
  }

  @Bean
  @Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
  public Message message(InjectionPoint ip) {

    LocalizedMessage localizedMessage = AnnotationUtils
        .getAnnotation(ip.getAnnotatedElement(), LocalizedMessage.class);

    String resourceBundleKey = localizedMessage.value();

    return new Message(messageSource(), resourceBundleKey);
  }

}
--------------------------------------------------------------------------------------------------------
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Arrays;
import javax.validation.constraints.NotNull;

@Aspect
@Component
public class NotNullParameterAspect {

  @Before("@within(com.moelholm.spring43.customannotations.BusinessService)")
  public void before(JoinPoint caller) {

    Method method = getCurrentMethod(caller);

    Object[] parameters = caller.getArgs();

    Annotation[][] parameterAnnotations = method.getParameterAnnotations();

    // Throw exception if a parameter value is null AND
    // at the same time declares that it must be @NotNull
    for (int i = 0; i < parameters.length; i++) {
      Object parameterValue = parameters[i];
      Annotation[] annotationsOnParameter = parameterAnnotations[i];

      if (parameterValue == null && hasNotNullAnnotation(annotationsOnParameter)) {
        String msgTemplate = String.format("Parameter at index %s must not be null", i);
        throw new IllegalArgumentException(msgTemplate);
      }
    }

  }

  private boolean hasNotNullAnnotation(Annotation... annotations) {
    return Arrays.asList(annotations).stream().anyMatch(a -> a.annotationType() == NotNull.class);
  }

  private Method getCurrentMethod(JoinPoint joinPoint) {
    MethodSignature signature = (MethodSignature) joinPoint.getSignature();
    return signature.getMethod();
  }
}
--------------------------------------------------------------------------------------------------------

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.web.servlet.ServletListenerRegistrationBean;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.event.AuthenticationSuccessEvent;
import org.springframework.security.core.session.SessionDestroyedEvent;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.session.HttpSessionEventPublisher;

@Configuration
@SuppressWarnings("Convert2Lambda")
public class SessionListenerConfig {

    @Autowired
    private ActiveUsersService activeUsersService;

    @Bean
    public ServletListenerRegistrationBean<HttpSessionEventPublisher> httpSessionEventPublisher() {
        return new ServletListenerRegistrationBean(new HttpSessionEventPublisher());
    }

    @Bean
    public ApplicationListener<AuthenticationSuccessEvent> userAuthenticated() {
        return new ApplicationListener<AuthenticationSuccessEvent>() {
            @Override
            public void onApplicationEvent(AuthenticationSuccessEvent event) {
                UserDetails userDetails = (UserDetails) event.getAuthentication().getPrincipal();
                activeUsersService.userLoggedIn(userDetails.getUsername());
            }
        };
    }

    @Bean
    public ApplicationListener<SessionDestroyedEvent> sessionDestroyedListener() {
        return new ApplicationListener<SessionDestroyedEvent>() {
            @Override
            public void onApplicationEvent(SessionDestroyedEvent event) {
                UserDetails userDetails = (UserDetails) event.getSecurityContexts().stream()
                        .findFirst().get().getAuthentication().getPrincipal();
                activeUsersService.userLoggedOut(userDetails.getUsername());
            }
        };
    }

}

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.endpoint.mvc.AbstractMvcEndpoint;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.List;

@Component
public class ActiveUsersActuatorEndpoint extends AbstractMvcEndpoint {

    @Autowired
    private ActiveUsersService activeUsersService;

    public ActiveUsersActuatorEndpoint() {
        super("/activeusers", false /* sensitive */);
    }

    @RequestMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    @ResponseBody
    public ActiveUsersResponse listActiveUsers() {
        return new ActiveUsersResponse("Active users right now", activeUsersService.listActiveUsers());
    }

    @JsonPropertyOrder({"info", "activeUsers"})
    public static class ActiveUsersResponse {

        @JsonProperty
        private String info;

        @JsonProperty
        private List<String> activeUsers;

        public ActiveUsersResponse(String info, List<String> activeUsers) {
            this.info = info;
            this.activeUsers = activeUsers;
        }
    }

}
--------------------------------------------------------------------------------------------------------
version: '2'
services:
  cdbookstore-postgresql:
    image: postgres:11.3
    environment:
      - POSTGRES_USER=cdbookstoreDB
      - POSTGRES_PASSWORD=h2g2
    ports:
      - 5432:5432
--------------------------------------------------------------------------------------------------------
import javax.persistence.FetchType;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static javax.persistence.FetchType.EAGER;

// @formatter:off
// tag::adocSnippet[]
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface Basic {

  FetchType fetch() default EAGER;
  boolean optional() default true;
}
// end::adocSnippet[]


import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

// @formatter:off
// tag::adocSnippet[]
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface Column {

  String  name()       default "";
  boolean unique()     default false;
  boolean nullable()   default true;
  boolean insertable() default true;
  boolean updatable()  default true;
  String  columnDefinition() default "";
  String  table()      default "";
  int     length()     default 255;
  int     precision()  default 0; // decimal precision
  int     scale()      default 0; // decimal scale
}
// end::adocSnippet[]


import javax.persistence.ForeignKey;
import javax.persistence.Index;
import javax.persistence.JoinColumn;
import javax.persistence.UniqueConstraint;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static javax.persistence.ConstraintMode.PROVIDER_DEFAULT;

// @formatter:off
// tag::adocSnippet[]
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface JoinTable {

  String name() default "";
  String catalog() default "";
  String schema() default "";
  JoinColumn[] joinColumns() default {};
  JoinColumn[] inverseJoinColumns() default {};
  ForeignKey foreignKey() default @ForeignKey(PROVIDER_DEFAULT);
  ForeignKey inverseForeignKey() default @ForeignKey(PROVIDER_DEFAULT);
  UniqueConstraint[] uniqueConstraints() default {};
  Index[] indexes() default {};
}
// end::adocSnippet[]


import javax.persistence.CascadeType;
import javax.persistence.FetchType;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static javax.persistence.FetchType.EAGER;

// @formatter:off
// tag::adocSnippet[]
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface OneToOne {

  Class targetEntity() default void.class;
  CascadeType[] cascade() default {};
  FetchType fetch() default EAGER;
  boolean optional() default true;
  String mappedBy() default "";
  boolean orphanRemoval() default false;
}
// end::adocSnippet[]
--------------------------------------------------------------------------------------------------------
import javax.validation.Constraint;
import javax.validation.Payload;
import javax.validation.ReportAsSingleViolation;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

// tag::adocSnippet[]
@Constraint(validatedBy = {})

@NotNull
@Size(min = 7)
@Pattern(regexp = "[a-f]{1,}")
@ReportAsSingleViolation

@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE, ANNOTATION_TYPE, CONSTRUCTOR})
@Documented
public @interface Isbn {

  String message() default "Invalid ISBN number";

  Class<?>[] groups() default {};

  Class<? extends Payload>[] payload() default {};
}
--------------------------------------------------------------------------------------------------------
import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Documented;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.TYPE_USE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

// @formatter:off
// tag::adocSnippet[]
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
@Retention(RUNTIME)
@Constraint(validatedBy = {})
@Repeatable(Size.List.class)
@Documented
public @interface Size {

  String message() default "{javax.validation.constraints.Size.message}";
  Class<?>[] groups() default {};
  Class<? extends Payload>[] payload() default {};
  int min() default 0;
  int max() default Integer.MAX_VALUE;
  @Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
  @Retention(RUNTIME)
  @Documented
  @interface List {
    Size[] value();
  }
}

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Documented;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

/**
 * @author Antonio Goncalves
 * http://www.antoniogoncalves.org
 * --
 */
// @formatter:off
// tag::adocSnippet[]
@Constraint(validatedBy = ZipCodeValidator.class)
@Repeatable(ZipCode.List.class)
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER})
@Retention(RUNTIME)
@Documented
public @interface ZipCode {

  String message() default "{org.agoncal.fascicle.ZipCode.message}";
  Class<?>[] groups() default {};
  Class<? extends Payload>[] payload() default {};
  @Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER})
  @Retention(RUNTIME)
  @Documented
  @interface List {
    ZipCode[] value();
  }
}
--------------------------------------------------------------------------------------------------------
import javax.validation.Constraint;
import javax.validation.Payload;
import javax.validation.ReportAsSingleViolation;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author Antonio Goncalves
 * http://www.antoniogoncalves.org
 * --
 */
@Pattern(regexp = "[A-Z][a-z]{1,}")
@Size(min = 3, max = 20)
@ReportAsSingleViolation
@Constraint(validatedBy = {})
@Documented
@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface MusicGenre {

  String message() default "{music.genre}";
  Class<? extends Payload>[] payload() default {};
  Class<?>[] groups() default {};
}
--------------------------------------------------------------------------------------------------------
import io.swagger.v3.oas.annotations.OpenAPIDefinition;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.info.Info;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/authors")
@Produces(MediaType.TEXT_PLAIN)
@OpenAPIDefinition(
  info = @Info(
    title = "Authors",
    version = "1.0",
    description = "Operations on authors"
  ),
  tags = {
    @Tag(name = "author"),
    @Tag(name = "book")
  }
)
public class AuthorResource {

  String[] scifiAuthors = {"Isaac Asimov", "Ray Bradbury", "Douglas Adams"};

  @GET
  @Operation(summary = "Gets all the sci-fi authors", tags = {"scifi"},
    responses = {
      @ApiResponse(responseCode = "200", description = "Comma-separated list of sci-fi authors")
    })
  public String getAllScifiAuthors() {
    return String.join(", ", scifiAuthors);
  }

  @GET
  @Path("/{index}")
  @Operation(summary = "Gets a sci-fi author by index",
    tags = {"scifi"},
    responses = {
      @ApiResponse(responseCode = "200", description = "A sci-fi author"),
      @ApiResponse(responseCode = "400", description = "Invalid index supplied"),
      @ApiResponse(responseCode = "404", description = "Author not found")}
  )
  public String getScifiAuthor(@Parameter(description = "Author index", required = true) @PathParam("index") int index) {
    return scifiAuthors[index];
  }
}

import org.agoncal.fascicle.jaxrs.invoking.Customer;

import javax.ws.rs.Produces;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.ext.MessageBodyWriter;
import javax.ws.rs.ext.Provider;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;

/**
 * @author Antonio Goncalves
 * http://www.antoniogoncalves.org
 * --
 */
@Provider
@Produces("custom/format")
public class CustomCustomerWriter implements MessageBodyWriter<Customer> {

  @Override
  public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {
    return Customer.class.isAssignableFrom(type);
  }

  @Override
  public void writeTo(Customer customer, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream outputStream) throws IOException, WebApplicationException {
    outputStream.write(customer.getId().getBytes());
    outputStream.write('/');
    outputStream.write(customer.getFirstName().getBytes());
    outputStream.write('/');
    outputStream.write(customer.getLastName().getBytes());
  }

  @Override
  public long getSize(Customer customer, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {
    return customer.getId().length() + 1 + customer.getFirstName().length() + 1 + customer.getLastName().length();
  }
}


import org.agoncal.fascicle.jaxrs.invoking.Customer;

import javax.ws.rs.Consumes;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.ext.MessageBodyReader;
import javax.ws.rs.ext.Provider;
import java.io.*;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.StringTokenizer;

/**
 * @author Antonio Goncalves
 * http://www.antoniogoncalves.org
 * --
 */
@Provider
@Consumes("custom/format")
public class CustomCustomerReader implements MessageBodyReader<Customer> {

  @Override
  public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {
    return Customer.class.isAssignableFrom(type);
  }

  @Override
  public Customer readFrom(Class<Customer> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream inputStream) throws IOException, WebApplicationException {

    String str = convertStreamToString(inputStream);
    StringTokenizer s = new StringTokenizer(str, "/");

    Customer customer = new Customer();
    customer.setId(s.nextToken());
    customer.setFirstName(s.nextToken());
    customer.setLastName(s.nextToken());

    return customer;
  }

  public String convertStreamToString(InputStream is)
    throws IOException {

    if (is != null) {
      Writer writer = new StringWriter();

      char[] buffer = new char[1024];
      try {
        Reader reader = new BufferedReader(
          new InputStreamReader(is, "UTF-8"));
        int n;
        while ((n = reader.read(buffer)) != -1) {
          writer.write(buffer, 0, n);
        }
      } finally {
        is.close();
      }
      return writer.toString();
    } else {
      return "";
    }
  }
}


   @GET
   @Produces( {"application/xml", "application/json"})
   @ApiOperation("Lists all the customers")
   public List<Customer> listAll(@QueryParam("start") Integer startPosition, @QueryParam("max") Integer maxResult)
   {
      TypedQuery<Customer> findAllQuery = em.createQuery("SELECT DISTINCT c FROM Customer c LEFT JOIN FETCH c.homeAddress.country ORDER BY c.id", Customer.class);
      if (startPosition != null)
      {
         findAllQuery.setFirstResult(startPosition);
      }
      if (maxResult != null)
      {
         findAllQuery.setMaxResults(maxResult);
      }
      final List<Customer> results = findAllQuery.getResultList();
      return results;
   }
   
   
   
import org.glassfish.grizzly.http.server.HttpServer;
import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpServerFactory;
import org.glassfish.jersey.server.ResourceConfig;

import java.io.IOException;
import java.net.URI;

/**
 * Main class.
 *
 */
public class Main {
    // Base URI the Grizzly HTTP server will listen on
    public static final String BASE_URI = "http://localhost:8080/cdbookstore/";

    /**
     * Starts Grizzly HTTP server exposing JAX-RS resources defined in this application.
     * @return Grizzly HTTP server.
     */
    public static HttpServer startServer() {
        // create a resource config that scans for JAX-RS resources and providers
        // in org.agoncal.fascicle.jaxrs.firststep package
        final ResourceConfig rc = new ResourceConfig().packages("org.agoncal.fascicle.commons.restassured");

        // create and start a new instance of grizzly http server
        // exposing the Jersey application at BASE_URI
        return GrizzlyHttpServerFactory.createHttpServer(URI.create(BASE_URI), rc);
    }

    /**
     * Main method.
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        final HttpServer server = startServer();
        System.out.println(String.format("Jersey app started with WADL available at "
                + "%sapplication.wadl\nHit enter to stop it...", BASE_URI));
        System.in.read();
        server.stop();
    }
}
--------------------------------------------------------------------------------------------------------

import org.jackson.views.domain.User;
import org.jackson.views.repository.UserRepository;
import org.hibernate.validator.internal.constraintvalidators.hv.EmailValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Authenticate a user from the database.
 */
@Component("userDetailsService")
public class DomainUserDetailsService implements UserDetailsService {

    private final Logger log = LoggerFactory.getLogger(DomainUserDetailsService.class);

    private final UserRepository userRepository;

    public DomainUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    @Transactional
    public UserDetails loadUserByUsername(final String login) {
        log.debug("Authenticating {}", login);

        if (new EmailValidator().isValid(login, null)) {
            return userRepository.findOneWithAuthoritiesByEmail(login)
                .map(user -> createSpringSecurityUser(login, user))
                .orElseThrow(() -> new UsernameNotFoundException("User with email " + login + " was not found in the database"));
        }

        String lowercaseLogin = login.toLowerCase(Locale.ENGLISH);
        return userRepository.findOneWithAuthoritiesByLogin(lowercaseLogin)
            .map(user -> createSpringSecurityUser(lowercaseLogin, user))
            .orElseThrow(() -> new UsernameNotFoundException("User " + lowercaseLogin + " was not found in the database"));

    }

    private org.springframework.security.core.userdetails.User createSpringSecurityUser(String lowercaseLogin, User user) {
        if (!user.getActivated()) {
            throw new UserNotActivatedException("User " + lowercaseLogin + " was not activated");
        }
        List<GrantedAuthority> grantedAuthorities = user.getAuthorities().stream()
            .map(authority -> new SimpleGrantedAuthority(authority.getName()))
            .collect(Collectors.toList());
        return new org.springframework.security.core.userdetails.User(user.getLogin(),
            user.getPassword(),
            grantedAuthorities);
    }
}
--------------------------------------------------------------------------------------------------------
import java.nio.charset.StandardCharsets;
import java.security.Key;
import java.util.*;
import java.util.stream.Collectors;
import javax.annotation.PostConstruct;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import io.github.jhipster.config.JHipsterProperties;
import io.jsonwebtoken.*;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;

@Component
public class TokenProvider {

    private final Logger log = LoggerFactory.getLogger(TokenProvider.class);

    private static final String AUTHORITIES_KEY = "auth";

    private Key key;

    private long tokenValidityInMilliseconds;

    private long tokenValidityInMillisecondsForRememberMe;

    private final JHipsterProperties jHipsterProperties;

    public TokenProvider(JHipsterProperties jHipsterProperties) {
        this.jHipsterProperties = jHipsterProperties;
    }

    @PostConstruct
    public void init() {
        byte[] keyBytes;
        String secret = jHipsterProperties.getSecurity().getAuthentication().getJwt().getSecret();
        if (!StringUtils.isEmpty(secret)) {
            log.warn("Warning: the JWT key used is not Base64-encoded. " +
                "We recommend using the `jhipster.security.authentication.jwt.base64-secret` key for optimum security.");
            keyBytes = secret.getBytes(StandardCharsets.UTF_8);
        } else {
            log.debug("Using a Base64-encoded JWT secret key");
            keyBytes = Decoders.BASE64.decode(jHipsterProperties.getSecurity().getAuthentication().getJwt().getBase64Secret());
        }
        this.key = Keys.hmacShaKeyFor(keyBytes);
        this.tokenValidityInMilliseconds =
            1000 * jHipsterProperties.getSecurity().getAuthentication().getJwt().getTokenValidityInSeconds();
        this.tokenValidityInMillisecondsForRememberMe =
            1000 * jHipsterProperties.getSecurity().getAuthentication().getJwt()
                .getTokenValidityInSecondsForRememberMe();
    }

    public String createToken(Authentication authentication, boolean rememberMe) {
        String authorities = authentication.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority)
            .collect(Collectors.joining(","));

        long now = (new Date()).getTime();
        Date validity;
        if (rememberMe) {
            validity = new Date(now + this.tokenValidityInMillisecondsForRememberMe);
        } else {
            validity = new Date(now + this.tokenValidityInMilliseconds);
        }

        return Jwts.builder()
            .setSubject(authentication.getName())
            .claim(AUTHORITIES_KEY, authorities)
            .signWith(key, SignatureAlgorithm.HS512)
            .setExpiration(validity)
            .compact();
    }

    public Authentication getAuthentication(String token) {
        Claims claims = Jwts.parser()
            .setSigningKey(key)
            .parseClaimsJws(token)
            .getBody();

        Collection<? extends GrantedAuthority> authorities =
            Arrays.stream(claims.get(AUTHORITIES_KEY).toString().split(","))
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());

        User principal = new User(claims.getSubject(), "", authorities);

        return new UsernamePasswordAuthenticationToken(principal, token, authorities);
    }

    public boolean validateToken(String authToken) {
        try {
            Jwts.parser().setSigningKey(key).parseClaimsJws(authToken);
            return true;
        } catch (io.jsonwebtoken.security.SecurityException | MalformedJwtException e) {
            log.info("Invalid JWT signature.");
            log.trace("Invalid JWT signature trace: {}", e);
        } catch (ExpiredJwtException e) {
            log.info("Expired JWT token.");
            log.trace("Expired JWT token trace: {}", e);
        } catch (UnsupportedJwtException e) {
            log.info("Unsupported JWT token.");
            log.trace("Unsupported JWT token trace: {}", e);
        } catch (IllegalArgumentException e) {
            log.info("JWT token compact of handler are invalid.");
            log.trace("JWT token compact of handler are invalid trace: {}", e);
        }
        return false;
    }
}

import org.springframework.security.config.annotation.SecurityConfigurerAdapter;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.DefaultSecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

public class JWTConfigurer extends SecurityConfigurerAdapter<DefaultSecurityFilterChain, HttpSecurity> {

    private TokenProvider tokenProvider;

    public JWTConfigurer(TokenProvider tokenProvider) {
        this.tokenProvider = tokenProvider;
    }

    @Override
    public void configure(HttpSecurity http) throws Exception {
        JWTFilter customFilter = new JWTFilter(tokenProvider);
        http.addFilterBefore(customFilter, UsernamePasswordAuthenticationFilter.class);
    }
}

  @EntityGraph(attributePaths = "authorities")
    @Cacheable(cacheNames = USERS_BY_EMAIL_CACHE)
    Optional<User> findOneWithAuthoritiesByEmail(String email);

--------------------------------------------------------------------------------------------------------
import org.jackson.views.domain.PersistentAuditEvent;

import org.springframework.boot.actuate.audit.AuditEvent;
import org.springframework.security.web.authentication.WebAuthenticationDetails;
import org.springframework.stereotype.Component;

import java.util.*;

@Component
public class AuditEventConverter {

    /**
     * Convert a list of PersistentAuditEvent to a list of AuditEvent
     *
     * @param persistentAuditEvents the list to convert
     * @return the converted list.
     */
    public List<AuditEvent> convertToAuditEvent(Iterable<PersistentAuditEvent> persistentAuditEvents) {
        if (persistentAuditEvents == null) {
            return Collections.emptyList();
        }
        List<AuditEvent> auditEvents = new ArrayList<>();
        for (PersistentAuditEvent persistentAuditEvent : persistentAuditEvents) {
            auditEvents.add(convertToAuditEvent(persistentAuditEvent));
        }
        return auditEvents;
    }

    /**
     * Convert a PersistentAuditEvent to an AuditEvent
     *
     * @param persistentAuditEvent the event to convert
     * @return the converted list.
     */
    public AuditEvent convertToAuditEvent(PersistentAuditEvent persistentAuditEvent) {
        if (persistentAuditEvent == null) {
            return null;
        }
        return new AuditEvent(persistentAuditEvent.getAuditEventDate(), persistentAuditEvent.getPrincipal(),
            persistentAuditEvent.getAuditEventType(), convertDataToObjects(persistentAuditEvent.getData()));
    }

    /**
     * Internal conversion. This is needed to support the current SpringBoot actuator AuditEventRepository interface
     *
     * @param data the data to convert
     * @return a map of String, Object
     */
    public Map<String, Object> convertDataToObjects(Map<String, String> data) {
        Map<String, Object> results = new HashMap<>();

        if (data != null) {
            for (Map.Entry<String, String> entry : data.entrySet()) {
                results.put(entry.getKey(), entry.getValue());
            }
        }
        return results;
    }

    /**
     * Internal conversion. This method will allow to save additional data.
     * By default, it will save the object as string
     *
     * @param data the data to convert
     * @return a map of String, String
     */
    public Map<String, String> convertDataToStrings(Map<String, Object> data) {
        Map<String, String> results = new HashMap<>();

        if (data != null) {
            for (Map.Entry<String, Object> entry : data.entrySet()) {
                // Extract the data that will be saved.
                if (entry.getValue() instanceof WebAuthenticationDetails) {
                    WebAuthenticationDetails authenticationDetails = (WebAuthenticationDetails) entry.getValue();
                    results.put("remoteAddress", authenticationDetails.getRemoteAddress());
                    results.put("sessionId", authenticationDetails.getSessionId());
                } else {
                    results.put(entry.getKey(), Objects.toString(entry.getValue()));
                }
            }
        }
        return results;
    }
}

import org.jackson.views.security.*;
import org.jackson.views.security.jwt.*;

import org.springframework.beans.factory.BeanInitializationException;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.filter.CorsFilter;
import org.zalando.problem.spring.web.advice.security.SecurityProblemSupport;

import javax.annotation.PostConstruct;

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
@Import(SecurityProblemSupport.class)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    private final AuthenticationManagerBuilder authenticationManagerBuilder;

    private final UserDetailsService userDetailsService;

    private final TokenProvider tokenProvider;

    private final CorsFilter corsFilter;

    private final SecurityProblemSupport problemSupport;

    public SecurityConfiguration(AuthenticationManagerBuilder authenticationManagerBuilder, UserDetailsService userDetailsService, TokenProvider tokenProvider, CorsFilter corsFilter, SecurityProblemSupport problemSupport) {
        this.authenticationManagerBuilder = authenticationManagerBuilder;
        this.userDetailsService = userDetailsService;
        this.tokenProvider = tokenProvider;
        this.corsFilter = corsFilter;
        this.problemSupport = problemSupport;
    }

    @PostConstruct
    public void init() {
        try {
            authenticationManagerBuilder
                .userDetailsService(userDetailsService)
                .passwordEncoder(passwordEncoder());
        } catch (Exception e) {
            throw new BeanInitializationException("Security configuration failed", e);
        }
    }

    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring()
            .antMatchers(HttpMethod.OPTIONS, "/**")
            .antMatchers("/app/**/*.{js,html}")
            .antMatchers("/i18n/**")
            .antMatchers("/content/**")
            .antMatchers("/h2-console/**")
            .antMatchers("/swagger-ui/index.html")
            .antMatchers("/test/**");
    }

    @Override
    public void configure(HttpSecurity http) throws Exception {
        http
            .csrf()
            .disable()
            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(problemSupport)
            .accessDeniedHandler(problemSupport)
        .and()
            .headers()
            .frameOptions()
            .disable()
        .and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and()
            .authorizeRequests()
            .antMatchers("/api/register").permitAll()
            .antMatchers("/api/activate").permitAll()
            .antMatchers("/api/authenticate").permitAll()
            .antMatchers("/api/account/reset-password/init").permitAll()
            .antMatchers("/api/account/reset-password/finish").permitAll()
            .antMatchers("/api/**").authenticated()
            .antMatchers("/management/health").permitAll()
            .antMatchers("/management/info").permitAll()
            .antMatchers("/management/**").hasAuthority(AuthoritiesConstants.ADMIN)
        .and()
            .apply(securityConfigurerAdapter());

    }

    private JWTConfigurer securityConfigurerAdapter() {
        return new JWTConfigurer(tokenProvider);
    }
}

import org.jackson.views.aop.logging.LoggingAspect;

import io.github.jhipster.config.JHipsterConstants;

import org.springframework.context.annotation.*;
import org.springframework.core.env.Environment;

@Configuration
@EnableAspectJAutoProxy
public class LoggingAspectConfiguration {

    @Bean
    @Profile(JHipsterConstants.SPRING_PROFILE_DEVELOPMENT)
    public LoggingAspect loggingAspect(Environment env) {
        return new LoggingAspect(env);
    }
}

import io.github.jhipster.config.JHipsterConstants;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cloud.config.java.AbstractCloudConfig;
import org.springframework.context.annotation.*;

import javax.sql.DataSource;
import org.springframework.boot.context.properties.ConfigurationProperties;


@Configuration
@Profile(JHipsterConstants.SPRING_PROFILE_CLOUD)
public class CloudDatabaseConfiguration extends AbstractCloudConfig {

    private final Logger log = LoggerFactory.getLogger(CloudDatabaseConfiguration.class);
    
    private final String CLOUD_CONFIGURATION_HIKARI_PREFIX = "spring.datasource.hikari";

    @Bean
    @ConfigurationProperties(CLOUD_CONFIGURATION_HIKARI_PREFIX)
    public DataSource dataSource() {
        log.info("Configuring JDBC datasource from a cloud provider");
        return connectionFactory().dataSource();
    }
}

    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        taskRegistrar.setScheduler(scheduledTaskExecutor());
    }

    @Bean
    public Executor scheduledTaskExecutor() {
        return Executors.newScheduledThreadPool(jHipsterProperties.getAsync().getCorePoolSize());
    }
--------------------------------------------------------------------------------------------------------

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSeeAlso;
import java.util.ArrayList;
import java.util.List;

/**
 * @author Antonio Goncalves
 *         http://www.antoniogoncalves.org
 *         --
 */
@XmlRootElement
@XmlSeeAlso(Customer.class)
public class Customers extends ArrayList<Customer> {

  // ======================================
  // =          Getters & Setters         =
  // ======================================

  @XmlElement(name = "customer")
  public List<Customer> getCustomers() {
    return this;
  }
}
--------------------------------------------------------------------------------------------------------
import org.apache.kafka.common.annotation.InterfaceStability;

import java.util.Arrays;
import java.util.Collections;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Resource pattern type.
 */
@InterfaceStability.Evolving
public enum PatternType {
    /**
     * Represents any PatternType which this client cannot understand, perhaps because this client is too old.
     */
    UNKNOWN((byte) 0),

    /**
     * In a filter, matches any resource pattern type.
     */
    ANY((byte) 1),

    /**
     * In a filter, will perform pattern matching.
     *
     * e.g. Given a filter of {@code ResourcePatternFilter(TOPIC, "payments.received", MATCH)`}, the filter match
     * any {@link ResourcePattern} that matches topic 'payments.received'. This might include:
     * <ul>
     *     <li>A Literal pattern with the same type and name, e.g. {@code ResourcePattern(TOPIC, "payments.received", LITERAL)}</li>
     *     <li>A Wildcard pattern with the same type, e.g. {@code ResourcePattern(TOPIC, "*", LITERAL)}</li>
     *     <li>A Prefixed pattern with the same type and where the name is a matching prefix, e.g. {@code ResourcePattern(TOPIC, "payments.", PREFIXED)}</li>
     * </ul>
     */
    MATCH((byte) 2),

    /**
     * A literal resource name.
     *
     * A literal name defines the full name of a resource, e.g. topic with name 'foo', or group with name 'bob'.
     *
     * The special wildcard character {@code *} can be used to represent a resource with any name.
     */
    LITERAL((byte) 3),

    /**
     * A prefixed resource name.
     *
     * A prefixed name defines a prefix for a resource, e.g. topics with names that start with 'foo'.
     */
    PREFIXED((byte) 4);

    private final static Map<Byte, PatternType> CODE_TO_VALUE =
        Collections.unmodifiableMap(
            Arrays.stream(PatternType.values())
                .collect(Collectors.toMap(PatternType::code, Function.identity()))
        );

    private final static Map<String, PatternType> NAME_TO_VALUE =
        Collections.unmodifiableMap(
            Arrays.stream(PatternType.values())
                .collect(Collectors.toMap(PatternType::name, Function.identity()))
        );

    private final byte code;

    PatternType(byte code) {
        this.code = code;
    }

    /**
     * @return the code of this resource.
     */
    public byte code() {
        return code;
    }

    /**
     * @eturn whether this resource pattern type is UNKNOWN.
     */
    public boolean isUnknown() {
        return this == UNKNOWN;
    }

    /**
     * @return whether this resource pattern type is a concrete type, rather than UNKNOWN or one of the filter types.
     */
    public boolean isSpecific() {
        return this != UNKNOWN && this != ANY && this != MATCH;
    }

    /**
     * Return the PatternType with the provided code or {@link #UNKNOWN} if one cannot be found.
     */
    public static PatternType fromCode(byte code) {
        return CODE_TO_VALUE.getOrDefault(code, UNKNOWN);
    }

    /**
     * Return the PatternType with the provided name or {@link #UNKNOWN} if one cannot be found.
     */
    public static PatternType fromString(String name) {
        return NAME_TO_VALUE.getOrDefault(name, UNKNOWN);
    }
}
--------------------------------------------------------------------------------------------------------
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**
 * Annotation to inform users of how much to rely on a particular package, class or method not changing over time.
 * Currently the stability can be {@link Stable}, {@link Evolving} or {@link Unstable}.
 */
@InterfaceStability.Evolving
public class InterfaceStability {
    /**
     * Compatibility is maintained in major, minor and patch releases with one exception: compatibility may be broken
     * in a major release (i.e. 0.m) for APIs that have been deprecated for at least one major/minor release cycle.
     * In cases where the impact of breaking compatibility is significant, there is also a minimum deprecation period
     * of one year.
     *
     * This is the default stability level for public APIs that are not annotated.
     */
    @Documented
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Stable { }

    /**
     * Compatibility may be broken at minor release (i.e. m.x).
     */
    @Documented
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Evolving { }

    /**
     * No guarantee is provided as to reliability or stability across any level of release granularity.
     */
    @Documented
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Unstable { }
}
--------------------------------------------------------------------------------------------------------
./gradlew build --stacktrace --info
--------------------------------------------------------------------------------------------------------
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.stream.Stream;

public class LocalFileSystem implements FileSystem {

    @Override
    public boolean existingDirectory(Path pathToTest) {
        return (pathToTest != null) && (pathToTest.toFile().isDirectory());
    }

    @Override
    public Stream<Path> streamOfAllFilesFromPath(Path from) {
        try {
            return Files.list(from);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void move(Path from, Path to) throws IOException {
        ensureDirectoryStructureExists(to.getParent());
        Files.move(from, to);
    }

    private void ensureDirectoryStructureExists(Path directoryPath) {
        if (directoryPath != null && !directoryPath.toFile().exists()) {
            directoryPath.toFile().mkdirs();
        }
    }
}
import java.io.IOException;
import java.nio.file.Path;
import java.util.stream.Stream;

public interface FileSystem {

    void move(Path from, Path to) throws IOException;

    Stream<Path> streamOfAllFilesFromPath(Path from);

    boolean existingDirectory(Path from);
}
--------------------------------------------------------------------------------------------------------
    /**
     * GET  /languages : get all the languages.
     *
     * @param pageable the pagination information
     * @param criteria the criterias which the requested entities should match
     * @return the ResponseEntity with status 200 (OK) and the list of languages in body
     */
    @GetMapping("/languages")
    @Timed
    @JsonView(Format.Minimal.class)
    public ResponseEntity<List<LanguageDTO>> getAllLanguages(LanguageCriteria criteria, Pageable pageable) {
        log.debug("REST request to get Languages by criteria: {}", criteria);
        Page<LanguageDTO> page = languageQueryService.findByCriteria(criteria, pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(page, "/api/languages");
        return new ResponseEntity<>(page.getContent(), headers, HttpStatus.OK);
    }
--------------------------------------------------------------------------------------------------------
import org.combo.autocompletedtooptim.web.rest.util.HeaderUtil;

import org.springframework.dao.ConcurrencyFailureException;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.NativeWebRequest;
import org.zalando.problem.DefaultProblem;
import org.zalando.problem.Problem;
import org.zalando.problem.ProblemBuilder;
import org.zalando.problem.Status;
import org.zalando.problem.spring.web.advice.ProblemHandling;
import org.zalando.problem.violations.ConstraintViolationProblem;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.servlet.http.HttpServletRequest;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;

/**
 * Controller advice to translate the server side exceptions to client-friendly json structures.
 * The error response follows RFC7807 - Problem Details for HTTP APIs (https://tools.ietf.org/html/rfc7807)
 */
@ControllerAdvice
public class ExceptionTranslator implements ProblemHandling {

    /**
     * Post-process the Problem payload to add the message key for the front-end if needed
     */
    @Override
    public ResponseEntity<Problem> process(@Nullable ResponseEntity<Problem> entity, NativeWebRequest request) {
        if (entity == null) {
            return entity;
        }
        Problem problem = entity.getBody();
        if (!(problem instanceof ConstraintViolationProblem || problem instanceof DefaultProblem)) {
            return entity;
        }
        ProblemBuilder builder = Problem.builder()
            .withType(Problem.DEFAULT_TYPE.equals(problem.getType()) ? ErrorConstants.DEFAULT_TYPE : problem.getType())
            .withStatus(problem.getStatus())
            .withTitle(problem.getTitle())
            .with("path", request.getNativeRequest(HttpServletRequest.class).getRequestURI());

        if (problem instanceof ConstraintViolationProblem) {
            builder
                .with("violations", ((ConstraintViolationProblem) problem).getViolations())
                .with("message", ErrorConstants.ERR_VALIDATION);
        } else {
            builder
                .withCause(((DefaultProblem) problem).getCause())
                .withDetail(problem.getDetail())
                .withInstance(problem.getInstance());
            problem.getParameters().forEach(builder::with);
            if (!problem.getParameters().containsKey("message") && problem.getStatus() != null) {
                builder.with("message", "error.http." + problem.getStatus().getStatusCode());
            }
        }
        return new ResponseEntity<>(builder.build(), entity.getHeaders(), entity.getStatusCode());
    }

    @Override
    public ResponseEntity<Problem> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, @Nonnull NativeWebRequest request) {
        BindingResult result = ex.getBindingResult();
        List<FieldErrorVM> fieldErrors = result.getFieldErrors().stream()
            .map(f -> new FieldErrorVM(f.getObjectName(), f.getField(), f.getCode()))
            .collect(Collectors.toList());

        Problem problem = Problem.builder()
            .withType(ErrorConstants.CONSTRAINT_VIOLATION_TYPE)
            .withTitle("Method argument not valid")
            .withStatus(defaultConstraintViolationStatus())
            .with("message", ErrorConstants.ERR_VALIDATION)
            .with("fieldErrors", fieldErrors)
            .build();
        return create(ex, problem, request);
    }

    @ExceptionHandler
    public ResponseEntity<Problem> handleNoSuchElementException(NoSuchElementException ex, NativeWebRequest request) {
        Problem problem = Problem.builder()
            .withStatus(Status.NOT_FOUND)
            .with("message", ErrorConstants.ENTITY_NOT_FOUND_TYPE)
            .build();
        return create(ex, problem, request);
    }

    @ExceptionHandler
    public ResponseEntity<Problem> handleBadRequestAlertException(BadRequestAlertException ex, NativeWebRequest request) {
        return create(ex, request, HeaderUtil.createFailureAlert(ex.getEntityName(), ex.getErrorKey(), ex.getMessage()));
    }

    @ExceptionHandler
    public ResponseEntity<Problem> handleConcurrencyFailure(ConcurrencyFailureException ex, NativeWebRequest request) {
        Problem problem = Problem.builder()
            .withStatus(Status.CONFLICT)
            .with("message", ErrorConstants.ERR_CONCURRENCY_FAILURE)
            .build();
        return create(ex, problem, request);
    }
}
--------------------------------------------------------------------------------------------------------
import org.combo.autocompletedtooptim.domain.*;
import org.combo.autocompletedtooptim.service.dto.LanguageDTO;

import org.mapstruct.*;

/**
 * Mapper for the entity Language and its DTO LanguageDTO.
 */
@Mapper(componentModel = "spring", uses = {})
public interface LanguageMapper extends EntityMapper<LanguageDTO, Language> {



    default Language fromId(Long id) {
        if (id == null) {
            return null;
        }
        Language language = new Language();
        language.setId(id);
        return language;
    }
}
--------------------------------------------------------------------------------------------------------
import org.combo.autocompletedtooptim.domain.*;
import org.combo.autocompletedtooptim.service.dto.ContactDTO;

import org.mapstruct.*;

/**
 * Mapper for the entity Contact and its DTO ContactDTO.
 */
@Mapper(componentModel = "spring", uses = {LanguageMapper.class})
public interface ContactMapper extends EntityMapper<ContactDTO, Contact> {

    @Mapping(source = "language.id", target = "languageId")
    @Mapping(source = "language.name", target = "languageName")
    ContactDTO toDto(Contact contact);

    @Mapping(source = "languageId", target = "language")
    Contact toEntity(ContactDTO contactDTO);

    default Contact fromId(Long id) {
        if (id == null) {
            return null;
        }
        Contact contact = new Contact();
        contact.setId(id);
        return contact;
    }
}
--------------------------------------------------------------------------------------------------------
import org.combo.autocompletedtooptim.domain.User;
import org.combo.autocompletedtooptim.repository.UserRepository;
import org.hibernate.validator.internal.constraintvalidators.hv.EmailValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Authenticate a user from the database.
 */
@Component("userDetailsService")
public class DomainUserDetailsService implements UserDetailsService {

    private final Logger log = LoggerFactory.getLogger(DomainUserDetailsService.class);

    private final UserRepository userRepository;

    public DomainUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    @Transactional
    public UserDetails loadUserByUsername(final String login) {
        log.debug("Authenticating {}", login);

        if (new EmailValidator().isValid(login, null)) {
            return userRepository.findOneWithAuthoritiesByEmail(login)
                .map(user -> createSpringSecurityUser(login, user))
                .orElseThrow(() -> new UsernameNotFoundException("User with email " + login + " was not found in the database"));
        }

        String lowercaseLogin = login.toLowerCase(Locale.ENGLISH);
        return userRepository.findOneWithAuthoritiesByLogin(lowercaseLogin)
            .map(user -> createSpringSecurityUser(lowercaseLogin, user))
            .orElseThrow(() -> new UsernameNotFoundException("User " + lowercaseLogin + " was not found in the database"));

    }

    private org.springframework.security.core.userdetails.User createSpringSecurityUser(String lowercaseLogin, User user) {
        if (!user.getActivated()) {
            throw new UserNotActivatedException("User " + lowercaseLogin + " was not activated");
        }
        List<GrantedAuthority> grantedAuthorities = user.getAuthorities().stream()
            .map(authority -> new SimpleGrantedAuthority(authority.getName()))
            .collect(Collectors.toList());
        return new org.springframework.security.core.userdetails.User(user.getLogin(),
            user.getPassword(),
            grantedAuthorities);
    }
}
--------------------------------------------------------------------------------------------------------
import java.nio.charset.StandardCharsets;
import java.security.Key;
import java.util.*;
import java.util.stream.Collectors;
import javax.annotation.PostConstruct;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import io.github.jhipster.config.JHipsterProperties;
import io.jsonwebtoken.*;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;

@Component
public class TokenProvider {

    private final Logger log = LoggerFactory.getLogger(TokenProvider.class);

    private static final String AUTHORITIES_KEY = "auth";

    private Key key;

    private long tokenValidityInMilliseconds;

    private long tokenValidityInMillisecondsForRememberMe;

    private final JHipsterProperties jHipsterProperties;

    public TokenProvider(JHipsterProperties jHipsterProperties) {
        this.jHipsterProperties = jHipsterProperties;
    }

    @PostConstruct
    public void init() {
        byte[] keyBytes;
        String secret = jHipsterProperties.getSecurity().getAuthentication().getJwt().getSecret();
        if (!StringUtils.isEmpty(secret)) {
            log.warn("Warning: the JWT key used is not Base64-encoded. " +
                "We recommend using the `jhipster.security.authentication.jwt.base64-secret` key for optimum security.");
            keyBytes = secret.getBytes(StandardCharsets.UTF_8);
        } else {
            log.debug("Using a Base64-encoded JWT secret key");
            keyBytes = Decoders.BASE64.decode(jHipsterProperties.getSecurity().getAuthentication().getJwt().getBase64Secret());
        }
        this.key = Keys.hmacShaKeyFor(keyBytes);
        this.tokenValidityInMilliseconds =
            1000 * jHipsterProperties.getSecurity().getAuthentication().getJwt().getTokenValidityInSeconds();
        this.tokenValidityInMillisecondsForRememberMe =
            1000 * jHipsterProperties.getSecurity().getAuthentication().getJwt()
                .getTokenValidityInSecondsForRememberMe();
    }

    public String createToken(Authentication authentication, boolean rememberMe) {
        String authorities = authentication.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority)
            .collect(Collectors.joining(","));

        long now = (new Date()).getTime();
        Date validity;
        if (rememberMe) {
            validity = new Date(now + this.tokenValidityInMillisecondsForRememberMe);
        } else {
            validity = new Date(now + this.tokenValidityInMilliseconds);
        }

        return Jwts.builder()
            .setSubject(authentication.getName())
            .claim(AUTHORITIES_KEY, authorities)
            .signWith(key, SignatureAlgorithm.HS512)
            .setExpiration(validity)
            .compact();
    }

    public Authentication getAuthentication(String token) {
        Claims claims = Jwts.parser()
            .setSigningKey(key)
            .parseClaimsJws(token)
            .getBody();

        Collection<? extends GrantedAuthority> authorities =
            Arrays.stream(claims.get(AUTHORITIES_KEY).toString().split(","))
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());

        User principal = new User(claims.getSubject(), "", authorities);

        return new UsernamePasswordAuthenticationToken(principal, token, authorities);
    }

    public boolean validateToken(String authToken) {
        try {
            Jwts.parser().setSigningKey(key).parseClaimsJws(authToken);
            return true;
        } catch (io.jsonwebtoken.security.SecurityException | MalformedJwtException e) {
            log.info("Invalid JWT signature.");
            log.trace("Invalid JWT signature trace: {}", e);
        } catch (ExpiredJwtException e) {
            log.info("Expired JWT token.");
            log.trace("Expired JWT token trace: {}", e);
        } catch (UnsupportedJwtException e) {
            log.info("Unsupported JWT token.");
            log.trace("Unsupported JWT token trace: {}", e);
        } catch (IllegalArgumentException e) {
            log.info("JWT token compact of handler are invalid.");
            log.trace("JWT token compact of handler are invalid trace: {}", e);
        }
        return false;
    }
}
--------------------------------------------------------------------------------------------------------
   @JsonIgnore
    @ManyToMany
    @JoinTable(
        name = "aud_user_authority",
        joinColumns = {@JoinColumn(name = "user_id", referencedColumnName = "id")},
        inverseJoinColumns = {@JoinColumn(name = "authority_name", referencedColumnName = "name")})
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    @BatchSize(size = 20)
    private Set<Authority> authorities = new HashSet<>();
	
	
	 private LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory();
	 
	    private void addContextListener(LoggerContext context) {
        LogbackLoggerContextListener loggerContextListener = new LogbackLoggerContextListener();
        loggerContextListener.setContext(context);
        context.addListener(loggerContextListener);
    }
	
	
--------------------------------------------------------------------------------------------------------
import java.net.InetSocketAddress;
import java.util.Iterator;

import io.github.jhipster.config.JHipsterProperties;

import ch.qos.logback.classic.AsyncAppender;
import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.boolex.OnMarkerEvaluator;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.classic.spi.LoggerContextListener;
import ch.qos.logback.core.Appender;
import ch.qos.logback.core.filter.EvaluatorFilter;
import ch.qos.logback.core.spi.ContextAwareBase;
import ch.qos.logback.core.spi.FilterReply;
import net.logstash.logback.appender.LogstashTcpSocketAppender;
import net.logstash.logback.encoder.LogstashEncoder;
import net.logstash.logback.stacktrace.ShortenedThrowableConverter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;

@Configuration
public class LoggingConfiguration {

    private static final String LOGSTASH_APPENDER_NAME = "LOGSTASH";

    private static final String ASYNC_LOGSTASH_APPENDER_NAME = "ASYNC_LOGSTASH";

    private final Logger log = LoggerFactory.getLogger(LoggingConfiguration.class);

    private LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory();

    private final String appName;

    private final String serverPort;

    private final JHipsterProperties jHipsterProperties;

    public LoggingConfiguration(@Value("${spring.application.name}") String appName, @Value("${server.port}") String serverPort,
         JHipsterProperties jHipsterProperties) {
        this.appName = appName;
        this.serverPort = serverPort;
        this.jHipsterProperties = jHipsterProperties;
        if (jHipsterProperties.getLogging().getLogstash().isEnabled()) {
            addLogstashAppender(context);
            addContextListener(context);
        }
        if (jHipsterProperties.getMetrics().getLogs().isEnabled()) {
            setMetricsMarkerLogbackFilter(context);
        }
    }

    private void addContextListener(LoggerContext context) {
        LogbackLoggerContextListener loggerContextListener = new LogbackLoggerContextListener();
        loggerContextListener.setContext(context);
        context.addListener(loggerContextListener);
    }

    private void addLogstashAppender(LoggerContext context) {
        log.info("Initializing Logstash logging");

        LogstashTcpSocketAppender logstashAppender = new LogstashTcpSocketAppender();
        logstashAppender.setName(LOGSTASH_APPENDER_NAME);
        logstashAppender.setContext(context);
        String customFields = "{\"app_name\":\"" + appName + "\",\"app_port\":\"" + serverPort + "\"}";

        // More documentation is available at: https://github.com/logstash/logstash-logback-encoder
        LogstashEncoder logstashEncoder = new LogstashEncoder();
        // Set the Logstash appender config from JHipster properties
        logstashEncoder.setCustomFields(customFields);
        // Set the Logstash appender config from JHipster properties
        logstashAppender.addDestinations(new InetSocketAddress(jHipsterProperties.getLogging().getLogstash().getHost(), jHipsterProperties.getLogging().getLogstash().getPort()));

        ShortenedThrowableConverter throwableConverter = new ShortenedThrowableConverter();
        throwableConverter.setRootCauseFirst(true);
        logstashEncoder.setThrowableConverter(throwableConverter);
        logstashEncoder.setCustomFields(customFields);

        logstashAppender.setEncoder(logstashEncoder);
        logstashAppender.start();

        // Wrap the appender in an Async appender for performance
        AsyncAppender asyncLogstashAppender = new AsyncAppender();
        asyncLogstashAppender.setContext(context);
        asyncLogstashAppender.setName(ASYNC_LOGSTASH_APPENDER_NAME);
        asyncLogstashAppender.setQueueSize(jHipsterProperties.getLogging().getLogstash().getQueueSize());
        asyncLogstashAppender.addAppender(logstashAppender);
        asyncLogstashAppender.start();

        context.getLogger("ROOT").addAppender(asyncLogstashAppender);
    }

    // Configure a log filter to remove "metrics" logs from all appenders except the "LOGSTASH" appender
    private void setMetricsMarkerLogbackFilter(LoggerContext context) {
        log.info("Filtering metrics logs from all appenders except the {} appender", LOGSTASH_APPENDER_NAME);
        OnMarkerEvaluator onMarkerMetricsEvaluator = new OnMarkerEvaluator();
        onMarkerMetricsEvaluator.setContext(context);
        onMarkerMetricsEvaluator.addMarker("metrics");
        onMarkerMetricsEvaluator.start();
        EvaluatorFilter<ILoggingEvent> metricsFilter = new EvaluatorFilter<>();
        metricsFilter.setContext(context);
        metricsFilter.setEvaluator(onMarkerMetricsEvaluator);
        metricsFilter.setOnMatch(FilterReply.DENY);
        metricsFilter.start();

        for (ch.qos.logback.classic.Logger logger : context.getLoggerList()) {
            for (Iterator<Appender<ILoggingEvent>> it = logger.iteratorForAppenders(); it.hasNext();) {
                Appender<ILoggingEvent> appender = it.next();
                if (!appender.getName().equals(ASYNC_LOGSTASH_APPENDER_NAME)) {
                    log.debug("Filter metrics logs from the {} appender", appender.getName());
                    appender.setContext(context);
                    appender.addFilter(metricsFilter);
                    appender.start();
                }
            }
        }
    }

    /**
     * Logback configuration is achieved by configuration file and API.
     * When configuration file change is detected, the configuration is reset.
     * This listener ensures that the programmatic configuration is also re-applied after reset.
     */
    class LogbackLoggerContextListener extends ContextAwareBase implements LoggerContextListener {

        @Override
        public boolean isResetResistant() {
            return true;
        }

        @Override
        public void onStart(LoggerContext context) {
            addLogstashAppender(context);
        }

        @Override
        public void onReset(LoggerContext context) {
            addLogstashAppender(context);
        }

        @Override
        public void onStop(LoggerContext context) {
            // Nothing to do.
        }

        @Override
        public void onLevelChange(ch.qos.logback.classic.Logger logger, Level level) {
            // Nothing to do.
        }
    }

}
--------------------------------------------------------------------------------------------------------

import io.github.jhipster.config.JHipsterConstants;

import org.springframework.boot.SpringApplication;
import org.springframework.core.env.Environment;

import java.util.*;

/**
 * Utility class to load a Spring profile to be used as default
 * when there is no <code>spring.profiles.active</code> set in the environment or as command line argument.
 * If the value is not available in <code>application.yml</code> then <code>dev</code> profile will be used as default.
 */
public final class DefaultProfileUtil {

    private static final String SPRING_PROFILE_DEFAULT = "spring.profiles.default";

    private DefaultProfileUtil() {
    }

    /**
     * Set a default to use when no profile is configured.
     *
     * @param app the Spring application
     */
    public static void addDefaultProfile(SpringApplication app) {
        Map<String, Object> defProperties = new HashMap<>();
        /*
        * The default profile to use when no other profiles are defined
        * This cannot be set in the <code>application.yml</code> file.
        * See https://github.com/spring-projects/spring-boot/issues/1219
        */
        defProperties.put(SPRING_PROFILE_DEFAULT, JHipsterConstants.SPRING_PROFILE_DEVELOPMENT);
        app.setDefaultProperties(defProperties);
    }

    /**
     * Get the profiles that are applied else get default profiles.
     *
     * @param env spring environment
     * @return profiles
     */
    public static String[] getActiveProfiles(Environment env) {
        String[] profiles = env.getActiveProfiles();
        if (profiles.length == 0) {
            return env.getDefaultProfiles();
        }
        return profiles;
    }
}
--------------------------------------------------------------------------------------------------------
    /**
     * Method sorter
     */
    static class MethodSorter implements Comparator<Method> {

        /**
         * Constructor
         */
        MethodSorter() {
        }

        /**
         * {@inheritDoc}
         */
        public int compare(Method o1, Method o2) {
            int m1 = o1.getModifiers();
            int m2 = o2.getModifiers();

            if (Modifier.isPublic(m1))
                return -1;

            if (Modifier.isPublic(m2))
                return 1;

            if (Modifier.isProtected(m1))
                return -1;

            if (Modifier.isProtected(m2))
                return 1;

            if (Modifier.isPrivate(m1))
                return -1;

            if (Modifier.isPrivate(m2))
                return 1;

            return 0;
        }

        /**
         * {@inheritDoc}
         */
        public boolean equals(Object o) {
            if (this == o)
                return true;

            if (o == null || !(o instanceof MethodSorter))
                return false;

            return true;
        }

        /**
         * {@inheritDoc}
         */
        public int hashCode() {
            return 42;
        }
    }

    /**
     * Field sorter
     */
    static class FieldSorter implements Comparator<Field> {

        /**
         * Constructor
         */
        FieldSorter() {
        }

        /**
         * {@inheritDoc}
         */
        public int compare(Field o1, Field o2) {
            int m1 = o1.getModifiers();
            int m2 = o2.getModifiers();

            if (Modifier.isPublic(m1))
                return -1;

            if (Modifier.isPublic(m2))
                return 1;

            if (Modifier.isProtected(m1))
                return -1;

            if (Modifier.isProtected(m2))
                return 1;

            if (Modifier.isPrivate(m1))
                return -1;

            if (Modifier.isPrivate(m2))
                return 1;

            return 0;
        }

        /**
         * {@inheritDoc}
         */
        public boolean equals(Object o) {
            if (this == o)
                return true;

            if (o == null || !(o instanceof FieldSorter))
                return false;

            return true;
        }

        /**
         * {@inheritDoc}
         */
        public int hashCode() {
            return 42;
        }
    }
	
	
import java.util.HashMap;
import java.util.Map;

/**
 * The namespaces supported by the transactions extension.
 *
 * @author John E. Bailey
 */
enum Namespace {
    // must be first
    UNKNOWN(null),

    TRANSACTIONS_1_0("urn:jboss:domain:transactions:1.0"),
    TRANSACTIONS_1_1("urn:jboss:domain:transactions:1.1"),
    TRANSACTIONS_1_2("urn:jboss:domain:transactions:1.2"),
    TRANSACTIONS_1_3("urn:jboss:domain:transactions:1.3"),
    TRANSACTIONS_1_4("urn:jboss:domain:transactions:1.4"),
    TRANSACTIONS_2_0("urn:jboss:domain:transactions:2.0"),
    TRANSACTIONS_3_0("urn:jboss:domain:transactions:3.0"),
    ;

    /**
     * The current namespace version.
     */
    public static final Namespace CURRENT = TRANSACTIONS_3_0;

    private final String name;

    Namespace(final String name) {
        this.name = name;
    }

    /**
     * Get the URI of this namespace.
     *
     * @return the URI
     */
    public String getUriString() {
        return name;
    }

    private static final Map<String, Namespace> MAP;

    static {
        final Map<String, Namespace> map = new HashMap<String, Namespace>();
        for (Namespace namespace : values()) {
            final String name = namespace.getUriString();
            if (name != null) map.put(name, namespace);
        }
        MAP = map;
    }

    public static Namespace forUri(String uri) {
        final Namespace element = MAP.get(uri);
        return element == null ? UNKNOWN : element;
    }
}
--------------------------------------------------------------------------------------------------------
import org.agoncal.sample.mapstruct.relationandid.domain.Address;
import org.agoncal.sample.mapstruct.relationandid.dto.AddressDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

/**
 * Mapper for the entity Address and its DTO AddressDTO.
 */
@Mapper(uses = {CountryMapper.class})
public interface AddressMapper extends EntityMapper<AddressDTO, Address> {

    @Mapping(source = "country.id", target = "countryId")
    @Mapping(source = "country.name", target = "countryName")
    @Mapping(source = "country", target = "country")
    AddressDTO toDto(Address address);

    @Mapping(source = "countryId", target = "country.id")
    @Mapping(source = "countryName", target = "country.name")
    @Mapping(source = "country", target = "country")
    Address toEntity(AddressDTO addressDTO);

    default Address fromId(Long id) {
        if (id == null) {
            return null;
        }
        Address address = new Address();
        address.setId(id);
        return address;
    }
}

import org.agoncal.sample.mapstruct.relationandid.domain.Country;
import org.agoncal.sample.mapstruct.relationandid.dto.CountryDTO;
import org.mapstruct.Mapper;

/**
 * Mapper for the entity Country and its DTO CountryDTO.
 */
@Mapper
public interface CountryMapper extends EntityMapper<CountryDTO, Country> {



    default Country fromId(Long id) {
        if (id == null) {
            return null;
        }
        Country country = new Country();
        country.setId(id);
        return country;
    }
}
--------------------------------------------------------------------------------------------------------
# Default server configuration
#
server {
	listen 80 default_server;
	listen [::]:80 default_server;

	# SSL configuration
	#
	# listen 443 ssl default_server;
	# listen [::]:443 ssl default_server;
	#
	# Note: You should disable gzip for SSL traffic.
	# See: https://bugs.debian.org/773332
	#
	# Read up on ssl_ciphers to ensure a secure configuration.
	# See: https://bugs.debian.org/765782
	#
	# Self signed certs generated by the ssl-cert package
	# Don't use them in a production server!
	#
	# include snippets/snakeoil.conf;

	root /usr/share/nginx/html;

	# Add index.php to the list if you are using PHP
	index index.html index.htm index.nginx-debian.html;

	server_name _;

	location / {
		# First attempt to serve request as file, then
		# as directory, then fall back to displaying a 404.
		try_files $uri $uri/ =404;
        sub_filter 'localhost:8081' 'pi-grom-load-balancer:8081';
        sub_filter 'localhost:8084' 'pi-grom-server-01:8084';
        sub_filter 'localhost:8500' 'pi-grom-database:8500';
        sub_filter 'localhost:9000' 'pi-thrall-database:9000';
        sub_filter_once off;
        sub_filter_types *;
	}

	# pass PHP scripts to FastCGI server
	#
	#location ~ \.php$ {
	#	include snippets/fastcgi-php.conf;
	#
	#	# With php-fpm (or other unix sockets):
	#	fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;
	#	# With php-cgi (or other tcp sockets):
	#	fastcgi_pass 127.0.0.1:9000;
	#}

	# deny access to .htaccess files, if Apache's document root
	# concurs with nginx's one
	#
	#location ~ /\.ht {
	#	deny all;
	#}
}


# Virtual Host configuration for example.com
#
# You can move that to a different file under sites-available/ and symlink that
# to sites-enabled/ to enable it.
#
#server {
#	listen 80;
#	listen [::]:80;
#
#	server_name example.com;
#
#	root /var/www/example.com;
#	index index.html;
#
#	location / {
#		try_files $uri $uri/ =404;
#	}
#}
--------------------------------------------------------------------------------------------------------
public enum Placement {

    
    TOP("top"), BOTTOM("bottom"), LEFT("left"), RIGHT("right");
    
    private String position;
    
    private Placement(String position) {
        this.position = position;
    }
    
    public String getPosition() {
        return position;
    }
    
}

import java.io.File;
import java.util.Map;

public class OptionsBuilder {

    private Options options = new Options();

    private OptionsBuilder() {
        super();
    }

    /**
     * Creates options builder instance.
     * 
     * @return options builder instance.
     */
    public static OptionsBuilder options() {
        return new OptionsBuilder();
    }

    /**
     * Sets backend option.
     * 
     * @param backend
     *            value.
     * @return this instance.
     */
    public OptionsBuilder backend(String backend) {
        this.options.setBackend(backend);
        return this;
    }

    /**
     * Sets doctype option.
     * 
     * @param docType
     *            value.
     * @return this instance.
     */
    public OptionsBuilder docType(String docType) {
        this.options.setDocType(docType);
        return this;
    }

    /**
     * Sets in place attribute.
     * 
     * @param inPlace
     *            value.
     * @return this instance.
     */
    public OptionsBuilder inPlace(boolean inPlace) {
        this.options.setInPlace(inPlace);
        return this;
    }

    /**
     * Sets header footer attribute.
     * 
     * @param headerFooter
     *            value.
     * @return this instance.
     */
    public OptionsBuilder headerFooter(boolean headerFooter) {
        this.options.setHeaderFooter(headerFooter);
        return this;
    }

    /**
     * Sets template directory.
     * 
     * @param templateDir
     *            directory where templates are stored.
     * @return this instance.
     */
    public OptionsBuilder templateDir(File templateDir) {
        this.options.setTemplateDirs(templateDir.getAbsolutePath());
        return this;
    }

    /**
     * Sets template directories.
     * 
     * @param templateDirs
     *            directories where templates are stored.
     * @return this instance.
     */
    public OptionsBuilder templateDirs(File... templateDirs) {
        for (File templateDir : templateDirs) {
            this.options.setTemplateDirs(templateDir.getAbsolutePath());
        }
        return this;
    }

    /**
     * Sets the template engine.
     * 
     * @param templateEngine
     *            used to render the document.
     * @return this instance.
     */
    public OptionsBuilder templateEngine(String templateEngine) {
        this.options.setTemplateEngine(templateEngine);
        return this;
    }

    /**
     * Sets if Asciidoctor should use template cache or not.
     * 
     * @param templateCache
     *            true if template cache is required, false otherwise.
     * @return this instance.
     */
    public OptionsBuilder templateCache(boolean templateCache) {
        this.options.setTemplateCache(templateCache);
        return this;
    }

    /**
     * Sets attributes used for rendering input.
     * 
     * @param attributes
     *            map.
     * @return this instance.
     */
    public OptionsBuilder attributes(Map<String, Object> attributes) {
        this.options.setAttributes(attributes);
        return this;
    }

    /**
     * Sets attributes used for rendering input.
     * 
     * @param attributes
     *            map.
     * @return this instance.
     */
    public OptionsBuilder attributes(Attributes attributes) {
        this.options.setAttributes(attributes.map());
        return this;
    }
    
    /**
     * Sets attributes used for rendering input.
     * 
     * @param attributes
     *            builder.
     * @return this instance.
     */
    public OptionsBuilder attributes(AttributesBuilder attributes) {
        this.options.setAttributes(attributes.asMap());
        return this;
    }

    /**
     * Sets to file value. This toggles writing output to a file or returning output
     * as a string. If writing to a string, the header and footer are omitted from the
     * output by default.
     * 
     * @param toFile
     *            <code>true</code> to write output to a file, <code>false</code>
     *            to write output to a string.
     * @return this instance.
     */
    public OptionsBuilder toFile(boolean toFile) {
        this.options.setToFile(toFile);
        return this;
    }

    /**
     * Sets to file value. This is the destination file name.
     * 
     * @param toFile
     *            name of output file.
     * @return this instance.
     */
    public OptionsBuilder toFile(File toFile) {
        this.options.setToFile(toFile.getPath());
        return this;
    }

    /**
     * Sets to dir value. This is the destination directory.
     * 
     * @param directory
     *            where output is generated.
     * @return this instance.
     */
    public OptionsBuilder toDir(File directory) {
        this.options.setToDir(directory.getAbsolutePath());
        return this;
    }

    /**
     * Sets if asciidoctor should create output directory if it does not exist or not.
     * 
     * @param mkDirs
     *            true if directory must be created, false otherwise.
     * @return this instance.
     */
    public OptionsBuilder mkDirs(boolean mkDirs) {
        this.options.setMkDirs(mkDirs);
        return this;
    }

    /**
     * Sets the safe mode.
     * 
     * @param safeMode
     *            to run asciidoctor.
     * @return this instance.
     */
    public OptionsBuilder safe(SafeMode safeMode) {
        this.options.setSafe(safeMode);
        return this;
    }

    /**
     * Sets eruby implementation.
     * 
     * @param eruby
     *            implementation.
     * @return this instance.
     */
    public OptionsBuilder eruby(String eruby) {
        this.options.setEruby(eruby);
        return this;
    }

    /**
     * Compact the output removing blank lines.
     * 
     * @param compact
     *            value.
     * @return this instance.
     */
    public OptionsBuilder compact(boolean compact) {
        this.options.setCompact(compact);
        return this;
    }
    
    /**
     * Sets parse header only falg.
     * 
     * @param parseHeaderOnly
     *            value.
     * @return this instance.
     */
    public OptionsBuilder parseHeaderOnly(boolean parseHeaderOnly) {
        this.options.setParseHeaderOnly(parseHeaderOnly);
        return this;
    }

    /**
     * Destination output directory.
     * 
     * @param destinationDir
     *            destination directory.
     * @return this instance.
     */
    public OptionsBuilder destinationDir(File destinationDir) {
        this.options.setDestinationDir(destinationDir.getAbsolutePath());
        return this;
    }

    /**
     * Sets a custom or unlisted option.
     * 
     * @param option
     *            name.
     * @param value
     *            for given option.
     * @return this instance.
     */
    public OptionsBuilder option(String option, Object value) {
        this.options.setOption(option, value);
        return this;
    }

    
    
    /**
     * Sets base dir for working directory.
     * 
     * @param baseDir
     *            working directory.
     * @return this instance.
     */
    public OptionsBuilder baseDir(File baseDir) {
        this.options.setBaseDir(baseDir.getAbsolutePath());
        return this;
    }

    /**
     * Gets a map with configured options.
     * 
     * @return map with all options. By default an empty map is returned.
     */
    public Map<String, Object> asMap() {
        return this.options.map();
    }

    public Options get() {
        return this.options;
    }

}
--------------------------------------------------------------------------------------------------------
import org.jruby.Ruby;

import java.util.List;

public class RowImpl implements Row {

    private final List<Cell> cells;

    private final Ruby rubyRuntime;

    public RowImpl(List<Cell> cells, Ruby rubyRuntime) {
        this.rubyRuntime = rubyRuntime;

        this.cells = cells;
    }

    @Override
    public List<Cell> getCells() {
        return cells;
    }
}
--------------------------------------------------------------------------------------------------------
import java.util.List;
import java.util.stream.Stream;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;

import me.snowdrop.data.hibernatesearch.core.query.AbstractQueryAdapter;
import me.snowdrop.data.hibernatesearch.spi.DatasourceMapper;
import me.snowdrop.data.hibernatesearch.spi.QueryAdapter;
import me.snowdrop.data.hibernatesearch.util.Integers;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.Sort;
import org.hibernate.NonUniqueResultException;
import org.hibernate.Session;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.hibernate.search.FullTextQuery;
import org.hibernate.search.FullTextSession;
import org.hibernate.search.Search;
import org.hibernate.search.hcore.util.impl.ContextHelper;
import org.hibernate.search.spi.SearchIntegrator;
import org.springframework.dao.IncorrectResultSizeDataAccessException;
import org.springframework.orm.jpa.EntityManagerFactoryUtils;
import org.springframework.util.Assert;

/**
 * @author <a href="mailto:ales.justin@jboss.org">Ales Justin</a>
 */
public class JpaDatasourceMapper implements DatasourceMapper {

  private EntityManagerFactory emf;

  public JpaDatasourceMapper(EntityManagerFactory emf) {
    Assert.notNull(emf, "Null EntityManagerFactory!");
    this.emf = emf;
  }

  public <T> QueryAdapter<T> createQueryAdapter(Class<T> entityClass) {
    return new OrmQueryAdapter<>();
  }

  private class OrmQueryAdapter<T> extends AbstractQueryAdapter<T> {
    private SearchIntegrator searchIntegrator;

    private FullTextQuery fullTextQuery;
    private EntityManager entityManager;

    private void close() {
      if (entityManager != null) {
        entityManager.close();
      }
    }

    protected SearchIntegrator getSearchIntegrator() {
      if (searchIntegrator == null) {
        searchIntegrator = ContextHelper.getSearchIntegratorBySF(emf.unwrap(SessionFactoryImplementor.class));
      }
      return searchIntegrator;
    }

    protected void applyLuceneQuery(Query query) {
      EntityManager em = EntityManagerFactoryUtils.getTransactionalEntityManager(emf);
      if (em == null) {
        entityManager = emf.createEntityManager();
        em = entityManager;
      }
      FullTextSession fullTextSession = Search.getFullTextSession(em.unwrap(Session.class));
      fullTextQuery = fullTextSession.createFullTextQuery(query, entityClass);
    }

    protected void setSort(Sort sort) {
      fullTextQuery.setSort(sort);
    }

    protected void setFirstResult(long firstResult) {
      fullTextQuery.setFirstResult(Integers.safeCast(firstResult));
    }

    protected void setMaxResults(long maxResults) {
      fullTextQuery.setMaxResults(Integers.safeCast(maxResults));
    }

    protected long size() {
      try {
        return fullTextQuery.getResultSize();
      } finally {
        close();
      }
    }

    protected T single() {
      try {
        //noinspection unchecked
        return (T) fullTextQuery.uniqueResult();
      } catch (NonUniqueResultException ex) {
        throw new IncorrectResultSizeDataAccessException(ex.getMessage(), 1);
      } finally {
        close();
      }
    }

    protected List<T> list() {
      try {
        //noinspection unchecked
        return fullTextQuery.getResultList();
      } finally {
        close();
      }
    }

    protected Stream<T> stream() {
      //noinspection unchecked
      Stream<T> stream = fullTextQuery.stream();
      return stream.onClose(this::close);
    }
  }
}
--------------------------------------------------------------------------------------------------------
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Used when there are multiple fields on the same property.
 *
 * @author <a href="mailto:ales.justin@jboss.org">Ales Justin</a>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Documented
@Repeatable(TargetFields.class)
public @interface TargetField {

  /**
   * Property to map to.
   *
   * @return property
   */
  String property();

  /**
   * Mapped field.
   *
   * @return mapped field
   */
  String field();
}
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author <a href="mailto:ales.justin@jboss.org">Ales Justin</a>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Documented
public @interface Query {

  /**
   * HibernateSearch query to be used when executing query. May contain placeholders eg. ?0
   *
   * @return
   */
  String value() default "";

  /**
   * Named Query Named looked up by repository.
   *
   * @return
   */
  String name() default "";
}

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

import org.apache.lucene.search.BoostQuery;
import org.apache.lucene.search.Query;
import org.springframework.data.geo.Distance;
import org.springframework.data.geo.Metric;
import org.springframework.data.geo.Metrics;

/**
 * Converts Criteria to Lucene Queries
 *
 * @author Ales Justin
 */
public class CriteriaConverter {

  private final EntityMetadataContext entityMetadataContext;
  private final LuceneQueryBuilder queryBuilder;

  public CriteriaConverter(EntityMetadataContext entityMetadataContext, LuceneQueryBuilder queryBuilder) {
    this.entityMetadataContext = entityMetadataContext;
    this.queryBuilder = queryBuilder;
  }

  public Query convert(Criteria criteria) {
    if (criteria == null) {
      return queryBuilder.matchAll();
    }

    List<Query> shouldQueryList = new LinkedList<>();
    List<Query> mustNotQueryList = new LinkedList<>();
    List<Query> mustQueryList = new LinkedList<>();

    ListIterator<Criteria> chainIterator = criteria.getCriteriaChain().listIterator();

    Query firstQuery = null;
    boolean negateFirstQuery = false;

    while (chainIterator.hasNext()) {
      Criteria chainedCriteria = chainIterator.next();
      Query queryFragmentForCriteria = processCriteriaEntries(chainedCriteria);
      if (queryFragmentForCriteria != null) {
        if (firstQuery == null) {
          firstQuery = queryFragmentForCriteria;
          negateFirstQuery = chainedCriteria.isNegating();
          continue;
        }
        if (chainedCriteria.isOr()) {
          shouldQueryList.add(queryFragmentForCriteria);
        } else if (chainedCriteria.isNegating()) {
          mustNotQueryList.add(queryFragmentForCriteria);
        } else {
          mustQueryList.add(queryFragmentForCriteria);
        }
      }
    }

    if (firstQuery != null) {
      if (!shouldQueryList.isEmpty() && mustNotQueryList.isEmpty() && mustQueryList.isEmpty()) {
        shouldQueryList.add(0, firstQuery);
      } else {
        if (negateFirstQuery) {
          mustNotQueryList.add(0, firstQuery);
        } else {
          mustQueryList.add(0, firstQuery);
        }
      }
    }

    List<Query> queries = new ArrayList<>();
    if (!shouldQueryList.isEmpty()) {
      queries.add(queryBuilder.any(shouldQueryList));
    }
    if (!mustNotQueryList.isEmpty()) {
      queries.add(queryBuilder.not(queryBuilder.all(mustNotQueryList)));
    }
    if (!mustQueryList.isEmpty()) {
      queries.add(queryBuilder.all(mustQueryList));
    }
    return queryBuilder.all(queries);
  }

  public Query processCriteriaEntries(Criteria criteria) {
    List<Query> queries = new ArrayList<>();
    for (Criteria.CriteriaEntry criteriaEntry : criteria.getQueryCriteriaEntries()) {
      Query subQuery = processCriteriaEntry(criteria.getProperty(), criteriaEntry);
      if (!Float.isNaN(criteria.getBoost())) {
        subQuery = new BoostQuery(subQuery, criteria.getBoost());
      }
      queries.add(subQuery);
    }
    return queryBuilder.all(queries);
  }

  public Query processCriteriaEntry(Property property, Criteria.CriteriaEntry criteriaEntry) {
    Object value = criteriaEntry.getValue();

    String fieldName = entityMetadataContext.getFieldName(property.getName());

    switch (criteriaEntry.getKey()) {
      case EQUALS:
        return queryBuilder.equal(fieldName, value);
      case NOT_EQUALS:
        return queryBuilder.notEqual(fieldName, value);
      case IN:
        return queryBuilder.in(fieldName, (Collection<?>) value);
      case NOT_IN:
        return queryBuilder.notIn(fieldName, (Collection<?>) value);
      case GREATER:
        return queryBuilder.greaterThan(fieldName, value);
      case GREATER_EQUAL:
        return queryBuilder.greaterThanOrEqual(fieldName, value);
      case LESS:
        return queryBuilder.lessThan(fieldName, value);
      case LESS_EQUAL:
        return queryBuilder.lessThanOrEqual(fieldName, value);
      case BETWEEN:
        Object[] ranges = (Object[]) value;
        return queryBuilder.between(fieldName, ranges[0], ranges[1]);
      case CONTAINS:
        return queryBuilder.contains(fieldName, value);
      case NOT_CONTAINS:
        return queryBuilder.notContains(fieldName, value);
      case STARTS_WITH:
        return queryBuilder.startsWith(fieldName, value);
      case ENDS_WITH:
        return queryBuilder.endsWith(fieldName, value);
      case REGEXP:
        return queryBuilder.reqexp(fieldName, (String) value);
      case FUZZY:
        return queryBuilder.fuzzy(fieldName, value);
      case WITHIN:
        Object[] params = (Object[]) value;
        Double latitude = (Double) params[0];
        Double longitude = (Double) params[1];
        Distance distance = (Distance) params[2];
        double distanceInKm = toKm(distance);
        return queryBuilder.spatial(fieldName, latitude, longitude, distanceInKm);
      default:
        throw new IllegalArgumentException("Unknown operator " + criteriaEntry.getKey());
    }
  }

  private static double toKm(Distance distance) {
    Metric metric = distance.getMetric();
    if (Metrics.KILOMETERS.equals(metric)) {
      return distance.getValue();
    } else if (Metrics.MILES.equals(metric)) {
      return distance.getValue() * 1.609344;
    } else {
      throw new IllegalArgumentException("Unknown metric: " + metric);
    }
  }
}


https://github.com/agoncal/spring-data-hibernate-search/blob/master/core/src/main/java/me/snowdrop/data/hibernatesearch/core/query/AbstractHSQueryAdapter.java


import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author <a href="mailto:ales.justin@jboss.org">Ales Justin</a>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Documented
public @interface TargetFields {
  TargetField[] value();
}
--------------------------------------------------------------------------------------------------------
import javax.cache.Cache;
import javax.cache.CacheManager;
import javax.cache.configuration.MutableConfiguration;
import javax.cache.expiry.AccessedExpiryPolicy;
import javax.cache.expiry.Duration;
import javax.enterprise.inject.Produces;
import javax.enterprise.inject.spi.InjectionPoint;
import javax.inject.Inject;

public class CacheFactory {

    @Inject
    private CacheManager mgr;

    @Produces
    @MovieCache
    public Cache<Object, Object> createCache(final InjectionPoint injectionPoint) {

        final MovieCache movieCache = injectionPoint.getAnnotated().getAnnotation(MovieCache.class);

        Cache<Object, Object> cache = mgr.getCache(movieCache.name());
        if (cache == null) {
            final MutableConfiguration<Object, Object> config = new MutableConfiguration<Object, Object>()
                    .setTypes(Object.class, Object.class)
                    .setExpiryPolicyFactory(AccessedExpiryPolicy.factoryOf(Duration.ONE_HOUR))
                    .setStatisticsEnabled(false);

            cache = mgr.createCache(movieCache.name(), config);
        }

        return cache;
    }

}

import org.jsr107.ri.annotations.DefaultGeneratedCacheKey;
import org.superbiz.moviefun.persistence.Movie;

import javax.cache.annotation.CacheInvocationParameter;
import javax.cache.annotation.CacheKeyGenerator;
import javax.cache.annotation.CacheKeyInvocationContext;
import javax.cache.annotation.GeneratedCacheKey;
import java.lang.annotation.Annotation;

public class MovieIdCacheKeyGenerator implements CacheKeyGenerator {
    @Override
    public GeneratedCacheKey generateCacheKey(final CacheKeyInvocationContext<? extends Annotation> cacheKeyInvocationContext) {


        final CacheInvocationParameter[] allParameters = cacheKeyInvocationContext.getAllParameters();
        for (final CacheInvocationParameter parameter : allParameters) {
            if (Movie.class.equals(parameter.getRawType())) {
                final Movie movie = Movie.class.cast(parameter.getValue());
                return new DefaultGeneratedCacheKey(new Object[] { movie.getId() });
            }
        }

        throw new IllegalArgumentException("No movie argument found in method signature");
    }
}
--------------------------------------------------------------------------------------------------------
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Random;
import java.util.function.Supplier;

/**
 * @author Roberto Cortez
 */
public class WeightedRandomResult<T> implements Supplier<T> {
    private final Random random = new Random();
    private final List<T> results = new ArrayList<>();

    public WeightedRandomResult(final Collection<T> results) {
        this.results.addAll(results);
    }

    public T get() {
        return this.results.get(random.nextInt(this.results.size()));
    }
}
--------------------------------------------------------------------------------------------------------
@ExcludeSuperclassListeners()
@EntityListeners(CustomerListener.class)
@Entity

@Entity
@NamedStoredProcedureQuery(name = "archiveOldBooks", procedureName = "sp_archive_books",
        parameters = {
                @StoredProcedureParameter(name = "archiveDate", mode = ParameterMode.IN, type = Date.class),
                @StoredProcedureParameter(name = "warehouse", mode = ParameterMode.IN, type = String.class)
        })
@Table(name = "ex29_book")

@Entity
@Table(name = "ex21_customer")
@NamedQueries({
        @NamedQuery(name = "findAll", query = "select c from Customer21 c"),
        @NamedQuery(name = Customer21.FIND_ALL, query = "select c from Customer21 c"),
        @NamedQuery(name = "findVincent", query = "select c from Customer21 c where c.firstName = 'Vincent'"),
        @NamedQuery(name = "findWithParam", query = "select c from Customer21 c where c.firstName = :fname")
})
@NamedNativeQueries({
        @NamedNativeQuery(name = "findAllNative", query = "select * from JPQL_EX01_CUSTOMER", resultClass = Customer21.class)
})
public class Customer21 {}
--------------------------------------------------------------------------------------------------------
import javax.crypto.spec.SecretKeySpec;
import java.security.Key;

/**
 * @author Antonio Goncalves
 *         http://www.antoniogoncalves.org
 *         --
 */

public class SimpleKeyGenerator implements KeyGenerator {

    // ======================================
    // =          Business methods          =
    // ======================================

    @Override
    public Key generateKey() {
        String keyString = "simplekey";
        Key key = new SecretKeySpec(keyString.getBytes(), 0, keyString.getBytes().length, "DES");
        return key;
    }
}

import java.security.Key;

/**
 * @author Antonio Goncalves
 *         http://www.antoniogoncalves.org
 *         --
 */
public interface KeyGenerator {

    Key generateKey();
}
--------------------------------------------------------------------------------------------------------
import javax.validation.Constraint;
import javax.validation.Payload;
import javax.validation.ReportAsSingleViolation;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import java.lang.annotation.*;

/**
 * @author Antonio Goncalves
 *         http://www.antoniogoncalves.org
 *         --
 */

@Constraint(validatedBy = {})
@NotNull
@Size(min = 1)
@ReportAsSingleViolation
@Retention(RetentionPolicy.RUNTIME)
@Target( {ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER,
      ElementType.TYPE, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR})
@Documented
public @interface NotEmpty
{

   // ======================================
   // =             Attributes             =
   // ======================================

   String message() default "Should not be empty";

   Class<?>[] groups() default {};

   Class<? extends Payload>[] payload() default {};

   // ======================================
   // =          Inner Annotation          =
   // ======================================

   @Retention(RetentionPolicy.RUNTIME)
   @Target( {ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER,
         ElementType.TYPE, ElementType.ANNOTATION_TYPE,
         ElementType.CONSTRUCTOR})
   public @interface List
   {
      NotEmpty[] value();
   }
}
--------------------------------------------------------------------------------------------------------
        <properties>
            <property name="javax.persistence.schema-generation.database.action" value="drop-and-create"/>
            <property name="javax.persistence.schema-generation.scripts.action" value="drop-and-create"/>
            <property name="javax.persistence.schema-generation.scripts.create-target" value="scheduleCreate.ddl"/>
            <property name="javax.persistence.schema-generation.scripts.drop-target" value="scheduleDrop.ddl"/>
            <property name="javax.persistence.sql-load-script-source" value="insert.sql"/>
        </properties>
--------------------------------------------------------------------------------------------------------
os:
  - linux
services:
  - docker
language: java
jdk:
  - oraclejdk8
sudo: false
cache:
  directories:
    - $HOME/.m2
before_install:
  - mvn install -DskipTests=true -Dmaven.javadoc.skip=true -B -V
  - java -version
script:
  - mvn clean test
notifications:
  webhooks:
    on_success: change  # options: [always|never|change] default: always
    on_failure: always  # options: [always|never|change] default: always
    on_start: false     # default: false
--------------------------------------------------------------------------------------------------------
@RunWith(Arquillian.class)
    public class RestClientTestCase {

        @ArquillianResource
        private URL deploymentURL;

        @Deployment(testable = false)
        public static WebArchive create()
        {
            return ShrinkWrap.create(WebArchive.class)
                .addPackage(Customer.class.getPackage())
                .addClasses(CustomerResource.class, CustomerResourceImpl.class, JaxRsActivator.class);
        }

        /**
         * Arquillian calculates resource path by using deployment URL+ArquillianResteasyResource.value which is by default "rest".
         * If your API is located under different root i.e. "api_v2" then use @ArquillianResteasyResource("api_v2")
         *
         * @param customerResource configured resource ready for use, injected by Arquillian
         */
        @Test
        public void getCustomerById(@ArquillianResteasyResource CustomerResource customerResource)
        {
        //        Given
            final String name = "Acme Corporation";
            final long customerId = 1L;

        //        When
            final Customer result = customerResource.getCustomerById(customerId);

        //        Then
            assertNotNull(result);
            assertNotNull(result.getId());
            assertEquals(name, result.getName());
        }
    }
--------------------------------------------------------------------------------------------------------
@Entity
@DiscriminatorValue("B")
@NamedQuery(name = "findAllBooks", query = "SELECT b FROM Book b ORDER BY b.id DESC")
@EntityListeners(DebugListener.class)
public class Book extends Item {

    // ======================================
    // =             Attributes             =
    // ======================================

    private String isbn;
    private Integer nbOfPage;
    private Boolean illustrations;

    @Convert(converter = LanguageConverter.class)
    private Language contentLanguage;

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "tags")
    private List<String> tags = new ArrayList<>();

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    private List<Chapter> chapters = new ArrayList<>();

    // ======================================
    // =            Constructors            =
    // ======================================

    public Book() {
    }

    public Book(String title, Float price, String description, Integer nbOfPage, Boolean illustrations, Language contentLanguage) {
        super(title, price, description);
        this.nbOfPage = nbOfPage;
        this.illustrations = illustrations;
        this.contentLanguage = contentLanguage;
    }

    public Book(Long id, String title, Float price, String description, Integer nbOfPage, Boolean illustrations, Language contentLanguage) {
        super(id, title, price, description);
        this.nbOfPage = nbOfPage;
        this.illustrations = illustrations;
        this.contentLanguage = contentLanguage;
    }

    // ======================================
    // =          Getters & Setters         =
    // ======================================

    public String getIsbn() {
        return isbn;
    }

    public void setIsbn(String isbn) {
        this.isbn = isbn;
    }

    public Integer getNbOfPage() {
        return nbOfPage;
    }

    public void setNbOfPage(Integer nbOfPage) {
        this.nbOfPage = nbOfPage;
    }

    public Boolean getIllustrations() {
        return illustrations;
    }

    public void setIllustrations(Boolean illustrations) {
        this.illustrations = illustrations;
    }

    public Language getContentLanguage() {
        return contentLanguage;
    }

    public void setContentLanguage(Language contentLanguage) {
        this.contentLanguage = contentLanguage;
    }

    public List<String> getTags() {
        return tags;
    }

    public void setTags(List<String> tags) {
        this.tags = tags;
    }

    public List<Chapter> getChapters() {
        return chapters;
    }

    public void setChapters(List<Chapter> chapters) {
        this.chapters = chapters;
    }

    // ======================================
    // =         hash, equals, toString     =
    // ======================================

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder();
        sb.append("Book");
        sb.append("{id=").append(id);
        sb.append(", title='").append(title).append('\'');
        sb.append(", price=").append(price);
        sb.append(", description='").append(description).append('\'');
        sb.append(", isbn='").append(isbn).append('\'');
        sb.append(", nbOfPage=").append(nbOfPage);
        sb.append(", illustrations=").append(illustrations);
        sb.append(", contentLanguage=").append(contentLanguage);
        sb.append(", tags=").append(tags);
        sb.append(", chapters=").append(chapters);
        sb.append('}');
        return sb.toString();
    }
}
--------------------------------------------------------------------------------------------------------
/**
 * @author <a href="mailto:lincolnbaxter@gmail.com">Lincoln Baxter, III</a>
 */
public enum BeanScope
{
   DEPENDENT("", false),
   APPLICATION("javax.enterprise.context.ApplicationScoped", true),
   SESSION("javax.enterprise.context.SessionScoped", true),
   CONVERSATION("javax.enterprise.context.ConversationScoped", true),
   REQUEST("javax.enterprise.context.RequestScoped", false),
   CUSTOM(null, false);

   private String annotation;
   private boolean serializable;

   private BeanScope(String annotation, boolean serializable)
   {
      this.annotation = annotation;
      this.serializable = serializable;
   }

   public String getAnnotation()
   {
      return annotation;
   }

   public boolean isSerializable() {
      return serializable;
   }
}
--------------------------------------------------------------------------------------------------------
import java.lang.annotation.Annotation;

/**
 * JPA Entity lifecycle.
 *
 * @author <a href="mailto:lantonio.goncalves@gmail.com">Antonio Goncalves</a>
 */
public enum LifeCycle {

    PRE_PERSIST(javax.persistence.PrePersist.class),
    POST_PERSIST(javax.persistence.PostPersist.class),
    PRE_UPDATE(javax.persistence.PreUpdate.class),
    POST_UPDATE(javax.persistence.PostPersist.class),
    PRE_REMOVE(javax.persistence.PreRemove.class),
    POST_REMOVE(javax.persistence.PostRemove.class),
    POST_LOAD(javax.persistence.PostLoad.class);

    private Class<? extends Annotation> annotation;

    LifeCycle(Class<? extends Annotation> annotation) {
        this.annotation = annotation;
    }

    public Class<? extends Annotation> getAnnotation() {
        return annotation;
    }
}
--------------------------------------------------------------------------------------------------------
CREATE KEYSPACE IF NOT EXISTS example WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'}  AND durable_writes = true;
CREATE TABLE IF NOT EXISTS example.greetings (
    user text,
    id timeuuid,
    greet text,
    creation_date timestamp,
    PRIMARY KEY (user, id)
) WITH CLUSTERING ORDER BY (id DESC);
--------------------------------------------------------------------------------------------------------
import com.ioteam.model.Greeting;
import org.springframework.data.cassandra.repository.CassandraRepository;
import org.springframework.data.cassandra.repository.Query;

import java.util.UUID;

/**
 * Created by moussiaymen on 06/12/15.
 */
public interface GreetRepository extends CassandraRepository<Greeting> {
    @Query("SELECT*FROM greetings WHERE user=?0 LIMIT ?1")
    Iterable<Greeting> findByUser(String user,Integer limit);
    @Query("SELECT*FROM greetings WHERE user=?0 AND id<?1 LIMIT ?2")
    Iterable<Greeting> findByUserFrom(String user,UUID from,Integer limit);
}
--------------------------------------------------------------------------------------------------------
import com.datastax.driver.core.utils.UUIDs;
import org.springframework.cassandra.core.PrimaryKeyType;
import org.springframework.data.cassandra.mapping.Column;
import org.springframework.data.cassandra.mapping.PrimaryKeyColumn;
import org.springframework.data.cassandra.mapping.Table;
import java.util.Date;
import java.util.UUID;


/**
 * Created by moussiaymen on 06/12/15.
 */
@Table(value = "greetings")
public class Greeting {
    @PrimaryKeyColumn(name = "id", ordinal = 1, type = PrimaryKeyType.CLUSTERED)
    private UUID id = UUIDs.timeBased();
    @PrimaryKeyColumn(name = "user", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
    private String user;
    @Column(value = "greet")
    private String greet;
    @Column(value = "creation_date")
    private Date creationDate;

    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public Date getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(Date creationDate) {
        this.creationDate = creationDate;
    }

    public String getUser() {
        return user;
    }

    public void setUser(String user) {
        this.user = user;
    }

    public String getGreet() {
        return greet;
    }

    public void setGreet(String greet) {
        this.greet = greet;
    }

}
--------------------------------------------------------------------------------------------------------
import org.jasypt.springsecurity3.authentication.encoding.PasswordEncoder;
import org.jasypt.util.password.StrongPasswordEncryptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.UserDetailsService;

@Configuration
public class SpringSecConfig extends WebSecurityConfigurerAdapter {

    private AuthenticationProvider authenticationProvider;

    @Autowired
    @Qualifier("daoAuthenticationProvider")
    public void setAuthenticationProvider(AuthenticationProvider authenticationProvider) {
        this.authenticationProvider = authenticationProvider;
    }

    @Bean
    public PasswordEncoder passwordEncoder(StrongPasswordEncryptor passwordEncryptor){
        PasswordEncoder passwordEncoder = new PasswordEncoder();
        passwordEncoder.setPasswordEncryptor(passwordEncryptor);
        return passwordEncoder;
    }

    @Bean
    public DaoAuthenticationProvider daoAuthenticationProvider(PasswordEncoder passwordEncoder,
                                                               UserDetailsService userDetailsService){

        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();
        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder);
        daoAuthenticationProvider.setUserDetailsService(userDetailsService);
        return daoAuthenticationProvider;
    }

    @Autowired
    public void configureAuthManager(AuthenticationManagerBuilder authenticationManagerBuilder){
        authenticationManagerBuilder.authenticationProvider(authenticationProvider);
    }
    @Override
    protected void configure(HttpSecurity httpSecurity) throws Exception {
           httpSecurity
                .authorizeRequests().antMatchers("/","/products","/product/show/*","/console/*","/h2-console/**").permitAll()
                .anyRequest().authenticated()
                .and()
                .formLogin().loginPage("/login").permitAll()
                .and()
                .logout().permitAll();

        httpSecurity.csrf().disable();
        httpSecurity.headers().frameOptions().disable();
    }
}
--------------------------------------------------------------------------------------------------------
import java.io.Serializable;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.Table;


@Entity
@Table(name = "users")
public class Users implements Serializable {

	private static final long serialVersionUID = 1948638898199176136L;
	
	@Id
	@Column(name = "username", unique = true, nullable = false, length = 100)
	private String username;

	@Column(name = "password", nullable = false, length = 100)
	private String password;

	@Column(name = "failed_logins")
	private Integer failedLogins;

	@Column(name = "enabled")
	private Boolean enabled;

	@Column(name = "locked")
	private Boolean locked;

	@Column(name = "last_login_date", length = 23)
	private Date lastLoginDate;

	@ManyToMany(fetch = FetchType.LAZY)
	@JoinTable(name = "authorities", joinColumns = {
			@JoinColumn(name = "user", nullable = false, updatable = false) }, inverseJoinColumns = {
					@JoinColumn(name = "role", nullable = false, updatable = false) })
	private Set<Roles> roleses = new HashSet<Roles>(0);

	public Users() {
	}

	public Users(String username, String password) {
		this.username = username;
		this.password = password;
	}

	public Users(String username, String password, Integer failedLogins,
			Boolean enabled, Boolean locked, Date lastLoginDate,
			Set<Roles> roleses) {
		this.username = username;
		this.password = password;
		this.failedLogins = failedLogins;
		this.enabled = enabled;
		this.locked = locked;
		this.lastLoginDate = lastLoginDate;
		this.roleses = roleses;
	}

	public String getUsername() {
		return this.username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getPassword() {
		return this.password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public Integer getFailedLogins() {
		return this.failedLogins;
	}

	public void setFailedLogins(Integer failedLogins) {
		this.failedLogins = failedLogins;
	}

	public Boolean getEnabled() {
		return this.enabled;
	}

	public void setEnabled(Boolean enabled) {
		this.enabled = enabled;
	}

	public Boolean getLocked() {
		return this.locked;
	}

	public void setLocked(Boolean locked) {
		this.locked = locked;
	}

	public Date getLastLoginDate() {
		return this.lastLoginDate;
	}

	public void setLastLoginDate(Date lastLoginDate) {
		this.lastLoginDate = lastLoginDate;
	}

	public Set<Roles> getRoleses() {
		return this.roleses;
	}

	public void setRoleses(Set<Roles> roleses) {
		this.roleses = roleses;
	}

}
import java.io.Serializable;
import java.util.HashSet;
import java.util.Set;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.Table;


@Entity
@Table(name = "roles")
public class Roles implements Serializable {

	private static final long serialVersionUID = 8215940655966357715L;
	
	@Id
	@Column(name = "id", unique = true, nullable = false)
	private int id;

	@Column(name = "name", nullable = false, length = 50)
	private String name;

	@ManyToMany(fetch = FetchType.LAZY)
	@JoinTable(name = "authorities", joinColumns = {
			@JoinColumn(name = "role", nullable = false, updatable = false) }, inverseJoinColumns = {
					@JoinColumn(name = "user", nullable = false, updatable = false) })
	private Set<Users> users = new HashSet<Users>(0);

	public Roles() {
	}

	public Roles(int id, String name) {
		this.id = id;
		this.name = name;
	}

	public Roles(int id, String name, Set<Users> users) {
		this.id = id;
		this.name = name;
		this.users = users;
	}

	public int getId() {
		return this.id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return this.name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Set<Users> getUsers() {
		return this.users;
	}

	public void setUsers(Set<Users> users) {
		this.users = users;
	}

}
--------------------------------------------------------------------------------------------------------
import org.springframework.security.oauth2.core.OAuth2Error;
import org.springframework.security.oauth2.core.OAuth2TokenValidator;
import org.springframework.security.oauth2.core.OAuth2TokenValidatorResult;
import org.springframework.security.oauth2.jwt.Jwt;

public class AudienceValidator implements OAuth2TokenValidator<Jwt> {

    private final String audience;

    public AudienceValidator(String audience) {
        this.audience = audience;
    }

    @Override
    public OAuth2TokenValidatorResult validate(Jwt jwt) {
        OAuth2Error error = new OAuth2Error("invalid_token", "The required audience is missing", null);

        if (jwt.getAudience().contains(audience)) {
            return OAuth2TokenValidatorResult.success();
        }

        return OAuth2TokenValidatorResult.failure(error);
    }
}

import com.basaki.edge.exception.AuthenticationException;
import com.basaki.edge.security.Authenticator;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;

@Slf4j
public class JwtAuthenticator implements Authenticator<JwtCredentials> {

    private JwtExtractor extractor;

    private JwtDecoder decoder;

    @Autowired
    public JwtAuthenticator(JwtExtractor extractor, JwtDecoder decoder) {
        this.extractor = extractor;
        this.decoder = decoder;
    }

    @Override
    public JwtCredentials authenticate(ServerHttpRequest request) {
        String token = extractor.extract(request);

        try {
            Jwt jwt = decoder.decode(token);
            JwtCredentials credentials = new JwtCredentials();
            credentials.setJwt(jwt);

            return credentials;
        } catch (JwtException e) {
            log.error(e.getMessage());
            throw new AuthenticationException("Invalid token!");
        }
    }
}
--------------------------------------------------------------------------------------------------------
import com.basaki.edge.exception.BadCredentialsException;
import com.basaki.edge.security.AuthenticationExtractor;
import com.basaki.edge.util.Base64Encoder;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class BasicAuthExtractor implements AuthenticationExtractor<BasicAuthCredentials> {

    public static final String PREFIX_BASIC = "Basic ";

    private Base64Encoder encoder;

    @Autowired
    public BasicAuthExtractor(Base64Encoder encoder) {
        this.encoder = encoder;
    }

    public BasicAuthCredentials extract(ServerHttpRequest request) {
        List<String> headers = request.getHeaders().get(HttpHeaders.AUTHORIZATION);

        if (headers == null || headers.isEmpty()) {
            throw new BadCredentialsException("Authorization header is missing!");
        }

        String authorization = headers.get(0);

        if (StringUtils.isEmpty(authorization)) {
            throw new BadCredentialsException("No Credentials Provided");
        }

        if (!authorization.startsWith(PREFIX_BASIC)) {
            throw new BadCredentialsException("Invalid Authorization header provided");
        }

        String[] authSegments = encoder.decode(authorization.substring(PREFIX_BASIC.length())).split(":");

        BasicAuthCredentials credentials = new BasicAuthCredentials();
        credentials.setUser(authSegments[0]);
        credentials.setPassword(authSegments[1]);

        return credentials;
    }
}
--------------------------------------------------------------------------------------------------------
import com.basaki.edge.security.SecurityAuthProperties;
import com.basaki.edge.util.Base64Encoder;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.cloud.gateway.route.Route;
import org.springframework.cloud.gateway.support.ServerWebExchangeUtils;
import org.springframework.core.Ordered;
import org.springframework.http.HttpHeaders;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import static com.basaki.edge.filter.global.OrderConstant.FILTER_ORDER_AUTH_RELAY;

@Component
@Slf4j
public class BasicAuthRelayGlobalFilter implements GlobalFilter, Ordered {

    public static final String BASIC_AUTH_PREFIX = "Basic ";

    private SecurityAuthProperties properties;

    private Base64Encoder encoder;

    @Autowired
    public BasicAuthRelayGlobalFilter(SecurityAuthProperties properties, Base64Encoder encoder) {
        this.properties = properties;
        this.encoder = encoder;
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("BasicAuthRelayGlobalFilter - start");

        Route route = exchange.getAttribute(ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR);
        if (route != null) {
            SecurityAuthProperties.Route routeSecurity = properties.getRoutes().get(route.getId());

            if (routeSecurity.getUser() != null && routeSecurity.getPassword() != null) {
                String encodedAuth = BASIC_AUTH_PREFIX + encoder.encode(routeSecurity.getUser()
                                                                       + ":" + routeSecurity.getPassword());

                ServerHttpRequest request = exchange.getRequest()
                        .mutate()
                        .headers(httpHeaders -> httpHeaders.set(HttpHeaders.AUTHORIZATION, encodedAuth))
                        .build();

                return chain.filter(exchange.mutate().request(request).build());
            }
        }

        log.info("BasicAuthRelayGlobalFilter - end");

        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return FILTER_ORDER_AUTH_RELAY;
    }
}
--------------------------------------------------------------------------------------------------------
app6.pba.internal
--------------------------------------------------------------------------------------------------------
DeliveryInfoBiMatcherTest
MessageSourceHelperTest
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
kubectl create -f rbac-config.yaml

kubectl create -f k8s-dashboard-admin.yml
kubectl create -f k8s-dashboard-readonly-role.yml
kubectl create -f k8s-dashboard-user.yml
kubectl create -f k8s-dashboard-manager.yml

kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep psg-admin | awk '{print $1}')
kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep dashboard-user | awk '{print $1}')
kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep dashboard-manager | awk '{print $1}')

First, we will create a Kubernetes namespace for all our monitoring components. Execute the following command to create a new namespace called monitoring.

kubectl apply -f namespace.yaml
You need to assign cluster reader permission to this namespace so that Prometheus can fetch the metrics from kubernetes API’s

kubectl create -f clusterRole.yaml
We should create a config map with all the prometheus scrape config and alerting rules, which will be mounted to the Prometheus container in /etc/prometheus as prometheus.yaml and prometheus.rules files. The prometheus.yaml contains all the configuration to dynamically discover pods and services running in the kubernetes cluster. prometheus.rules will contain all the alert rules for sending alerts to alert manager.

kubectl create -f config-map.yaml -n monitoring
Apply Prometheus deployment (ensure you are using the latest stable version of Prometheus)

kubectl create  -f prometheus-deployment.yaml --namespace=monitoring
You can check the created deployment using the following command.

kubectl get deployments --namespace=monitoring
To access the Prometheus dashboard over a IP or a DNS name, you need to expose it as kubernetes service. Once created, you can access the Prometheus dashboard using any Kubernetes node IP on port 30090.

kubectl create -f prometheus-service.yaml --namespace=monitoring
--------------------------------------------------------------------------------------------------------
import com.basaki.edge.exception.AuthenticationException;
import com.basaki.edge.exception.BadCredentialsException;
import com.basaki.edge.security.Authenticator;
import com.basaki.edge.security.Credentials;
import com.basaki.edge.security.SecurityAuthProperties;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.cloud.gateway.route.Route;
import org.springframework.cloud.gateway.support.ServerWebExchangeUtils;
import org.springframework.core.Ordered;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import static com.basaki.edge.filter.global.OrderConstant.FILTER_ORDER_AUTHENTICATION;

@Component
@Slf4j
public class AuthenticationGlobalFilter implements GlobalFilter, Ordered {

    public static final String AUTH_CREDENTIALS = "AUTH_CREDENTIALS";

    private SecurityAuthProperties properties;

    @Autowired
    public AuthenticationGlobalFilter(SecurityAuthProperties properties) {
        this.properties = properties;
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("AuthenticationGlobalFilter - start");

        Route route = exchange.getAttribute(ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR);
        if (route != null) {
            SecurityAuthProperties.Route routeSecurity = properties.getRoutes().get(route.getId());

            Authenticator[] authenticators = routeSecurity.getAuthenticators();
            if (authenticators != null && authenticators.length > 0) {
                boolean success = false;
                for (Authenticator authenticator : authenticators) {
                    if (authenticate(exchange, authenticator)) {
                        success = true;
                        break;
                    }
                }

                if (!success) {
                    throw new AuthenticationException("Authentication failed");
                }
            }
        }

        log.info("AuthenticationGlobalFilter - end");

        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return FILTER_ORDER_AUTHENTICATION;
    }

    private boolean authenticate(ServerWebExchange exchange,
                                 Authenticator authenticator) {
        boolean success = false;
        Credentials credentials;

        try {
            credentials = authenticator.authenticate(exchange.getRequest());
            exchange.getAttributes().put(AUTH_CREDENTIALS, credentials);
            success = true;
        } catch (BadCredentialsException e) {
            log.info(e.getMessage());
        }

        return success;
    }
}

import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;

@Component
@Slf4j
@SuppressWarnings({"squid:S2094"})
public class AddResponseTimeHeaderPostFilter
        extends AbstractGatewayFilterFactory<AddResponseTimeHeaderPostFilter.Config> {

    public static final String HEADER_TXN_DATE = "X-TXN-COMPLETION-DATE";

    public AddResponseTimeHeaderPostFilter() {
        super(AddResponseTimeHeaderPostFilter.Config.class);
    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            String timestamp = LocalDateTime.now().toString();
            log.debug("Adding txn date header {}", timestamp);
            return chain.filter(exchange).then(Mono.fromRunnable(() -> exchange.getResponse().getHeaders().add(HEADER_TXN_DATE, timestamp)));
        };
    }

    public static class Config {

    }
}
--------------------------------------------------------------------------------------------------------
import com.basaki.edge.exception.BadConfigurationException;
import com.basaki.edge.security.Authenticator;
import com.basaki.edge.security.SecurityAuthProperties;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.SmartLifecycle;
import org.springframework.stereotype.Component;

@Component
@Slf4j
public class RoutePostProcessor implements SmartLifecycle {

    private ApplicationContext context;

    private SecurityAuthProperties properties;

    private boolean started;

    @Autowired
    public RoutePostProcessor(ApplicationContext context, SecurityAuthProperties properties) {
        this.context = context;
        this.properties = properties;
    }

    @Override
    public void start() {
        started = true;
        properties.getRoutes().forEach((id, route) -> {
            log.debug("Processing route {}", id);
            Class[] classes = route.getAuthenticatorClasses();
            Authenticator[] authenticators = new Authenticator[classes.length];

            for (int i = 0; i < classes.length; i++) {
                Authenticator bean;
                try {
                    bean = (Authenticator) context.getAutowireCapableBeanFactory().createBean(classes[i]);
                } catch (BeansException e) {
                    throw new BadConfigurationException(
                            "Could not find bean of requested type for route " + id);
                }

                if (bean == null) {
                    log.error("Invalid configuration of route {}.", route.getId());
                    throw new BadConfigurationException(
                            "Invalid configuration. Authentication must be an instance of Authenticator.");
                }
                authenticators[i] = bean;
            }
            route.setAuthenticators(authenticators);
        });
    }

    @Override
    public void stop() {
        started = false;
    }

    @Override
    public boolean isRunning() {
        return started;
    }
}

import com.basaki.edge.security.SecurityAuthProperties;
import com.basaki.edge.security.basic.BasicAuthProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SecurityBasicAuthConfiguration {

    private SecurityAuthProperties properties;

    @Autowired
    public SecurityBasicAuthConfiguration(SecurityAuthProperties properties) {
        this.properties = properties;
    }

    @Bean
    public BasicAuthProvider getBasicAuthProvider() {
        return new BasicAuthProvider(properties.getUser(), properties.getPassword());
    }
}

import com.basaki.edge.security.oauth2.AudienceValidator;
import com.basaki.edge.security.oauth2.JwtExtractor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.core.DelegatingOAuth2TokenValidator;
import org.springframework.security.oauth2.core.OAuth2TokenValidator;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtDecoders;
import org.springframework.security.oauth2.jwt.JwtValidators;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoderJwkSupport;

@Configuration
@ConditionalOnProperty(name = {"spring.security.oauth2.resourceserver.jwt.issuer-uri"})
public class SecurityOauth2Configuration {

    @Value("${spring.security.oauth2.resourceserver.jwt.audience}")
    private String audience;

    @Value("${spring.security.oauth2.resourceserver.jwt.issuer-uri:}")
    private String issuer;

    @Bean(name = "customJwtDecoder")
    public JwtDecoder getJwtDecoder() {
        NimbusJwtDecoderJwkSupport jwtDecoder = (NimbusJwtDecoderJwkSupport)
                JwtDecoders.fromOidcIssuerLocation(issuer);

        OAuth2TokenValidator<Jwt> audienceValidator = new AudienceValidator(audience);
        OAuth2TokenValidator<Jwt> withIssuer = JwtValidators.createDefaultWithIssuer(issuer);
        OAuth2TokenValidator<Jwt> withAudience = new DelegatingOAuth2TokenValidator<>(withIssuer, audienceValidator);

        jwtDecoder.setJwtValidator(withAudience);

        return jwtDecoder;
    }

    @Bean
    public JwtExtractor getJwtExtractor() {
        return new JwtExtractor();
    }
}
--------------------------------------------------------------------------------------------------------
import com.basaki.edge.exception.AuthenticationException;
import com.basaki.edge.exception.BadCredentialsException;
import com.basaki.edge.util.Base64Encoder;
import junitparams.JUnitParamsRunner;
import junitparams.Parameters;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.springframework.http.HttpHeaders;
import org.springframework.http.server.reactive.ServerHttpRequest;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.junit.Assert.assertNotNull;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@RunWith(JUnitParamsRunner.class)
public class BasicAuthenticatorTest {

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    private Base64Encoder encoder = new Base64Encoder();

    @Test
    @Parameters
    public void testAuthenticate(BasicAuthProvider provider,
                                 ServerHttpRequest request,
                                 Class<? extends Exception> expectedException) {
        if (expectedException != null) {
            thrown.expect(expectedException);
        }

        Base64Encoder encoder = new Base64Encoder();
        BasicAuthExtractor extractor = new BasicAuthExtractor(encoder);
        BasicAuthenticator authenticator = new BasicAuthenticator(extractor, provider);
        BasicAuthCredentials credentials = authenticator.authenticate(request);
        assertNotNull(credentials);
        assertNotNull(credentials.getUser());
        assertNotNull(credentials.getPassword());
    }

    public Iterable<Object[]> parametersForTestAuthenticate() {
        return Arrays.asList(new Object[][]{
                {new BasicAuthProvider("user01", "pwd01"),
                        getRequest(null, null), BadCredentialsException.class},
                {new BasicAuthProvider("user01", "pwd01"),
                        getRequest("Authorization", ""), BadCredentialsException.class},
                {new BasicAuthProvider("user01", "pwd01"),
                        getRequest("Authorization", "NotBasic"), BadCredentialsException.class},
                {new BasicAuthProvider("user01", "pwd01"),
                        getRequest("Authorization", "Basic " + encoder.encode("user01:password")),
                        AuthenticationException.class},
                {new BasicAuthProvider("user01", "pwd01"),
                        getRequest("Authorization", "Basic " + encoder.encode("user01:pwd01")), null},
        });
    }

    private ServerHttpRequest getRequest(String key, String value) {
        ServerHttpRequest request = mock(ServerHttpRequest.class);
        HttpHeaders headers = new HttpHeaders();
        when(request.getHeaders()).thenReturn(headers);

        if (key != null && value != null) {
            List<String> values = new ArrayList<>();
            values.add(value);
            headers.put(key, values);
        }

        return request;
    }
}
--------------------------------------------------------------------------------------------------------
import java.net.URL;
import java.net.URLClassLoader;

/**
 * {@code MyClassLoader} is a custom URL class loader which tries to load
 * classes (except 'java.' and 'javax.' classes) from the URLs before delegating
 * it to its parent.
 * <p/>
 *
 * @author Indra Basak
 * @since 10/3/17
 */
public class MyClassLoader extends URLClassLoader {

    /**
     * Constructs a custom class loader.
     *
     * @param urls   the URLs from which to load classes and resources
     * @param parent the parent class loader for delegation
     */
    public MyClassLoader(URL[] urls, ClassLoader parent) {
        super(urls, parent);
    }

    /**
     * Loads a class with the specified name.
     * <ol>
     * <li>Checks if a class has already been loaded.</li>
     * <li>If a class has not been loaded, delegates to the
     * parent class loaded if the class beloing to 'java.' or 'javax.'
     * packages.</li>
     * <ii>If the class is still null, tries to load the class from the
     * URLs.</ii>
     * <li>If the class is still null, tries to load it from the parent class
     * loader.</li>
     * <li>If the class is till not found, throws a class {@code
     * ClassNotFoundException}</li>
     * </ol>
     *
     * @param name    the name of the class to load
     * @param resolve indicates whether to resolve the loaded class or not.
     * @return the resulting object
     * @throws ClassNotFoundException if the class is not found
     */
    @Override
    protected synchronized Class<?> loadClass(String name,
            boolean resolve) throws ClassNotFoundException {

        // 1. Check if the class has already been loaded
        Class<?> clazz = findLoadedClass(name);

        ClassLoader parentCL = getParent();

        // 2. If the class is not loaded and the class name starts
        // with 'java.' or 'javax.', delegate loading to parent
        if (clazz == null && parentCL != null && (name.startsWith(
                "java.") || name.startsWith(
                "javax."))) {
            clazz = parentCL.loadClass(name);

        }

        // 3. If the class is still null, try to load the class from the URL
        // (since we have already taken care of 'java.' and 'javax.'
        if (clazz == null) {
            try {
                clazz = super.findClass(name);
            } catch (ClassNotFoundException e) {
                //don't do anything
            }
        }

        // 4. If the class is still null, let the parent class loader load it.
        // Previously, we allowed 'java.' and 'javax.' classes to be loaded
        // from parent
        if (clazz == null && parentCL != null) {
            clazz = parentCL.loadClass(name);
        }

        // 5. If the class is still null, throw a class not found exception
        if (clazz == null) {
            throw new ClassNotFoundException(name);
        }

        if (resolve) {
            resolveClass(clazz);
        }

        return clazz;
    }
}
--------------------------------------------------------------------------------------------------------
@SuppressWarnings({"squid:CommentedOutCodeLine", "squid:S106", "squid:S2142", "squid:S1148"})
--------------------------------------------------------------------------------------------------------

import java.security.InvalidAlgorithmParameterException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.ECGenParameterSpec;
import java.security.spec.EncodedKeySpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import javax.xml.bind.DatatypeConverter;

/**
 * {@code ECDSA} is an example of Elliptic Curve cryptography and converting
 * public/private ley to a hex string and reconverting the string back to its
 * corresponding key.
 * classpath.
 * <p/>
 * Answers to stackoverflow questions:
 * <ol>
 * <li>https://stackoverflow.com/questions/50275351/converting-ec-publickey-hex-string-to-publickey</li>
 * </ol>
 *
 * @author Indra Basak
 * @since 05/17/18
 */
public class ECDSA {

    public static KeyPair generateKeyPair() throws NoSuchAlgorithmException,
            InvalidAlgorithmParameterException, NoSuchProviderException {
        // KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC");
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("ECDSA", "BC");
        ECGenParameterSpec ecSpec = new ECGenParameterSpec("prime256v1");
        SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
        keyGen.initialize(ecSpec, random);
        KeyPair pair = keyGen.generateKeyPair();
        return pair;
    }

    public static PublicKey getPublicKey(
            byte[] pk) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {
        EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(pk);
        //KeyFactory kf = KeyFactory.getInstance("EC");
        KeyFactory kf = KeyFactory.getInstance("ECDSA", "BC");
        PublicKey pub = kf.generatePublic(publicKeySpec);
        return pub;
    }

    public static PrivateKey getPrivateKey(
            byte[] privk) throws NoSuchAlgorithmException,
            InvalidKeySpecException, NoSuchProviderException {
        // EncodedKeySpec privateKeySpec = new X509EncodedKeySpec(privk);
        EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(privk);
        //KeyFactory kf = KeyFactory.getInstance("EC");
        KeyFactory kf = KeyFactory.getInstance("ECDSA", "BC");
        PrivateKey privateKey = kf.generatePrivate(privateKeySpec);
        return privateKey;
    }

    public static String encodeByteToString(byte[] input) {
        return Base64.getEncoder().encodeToString(input);
    }

    public static byte[] decodeStringToByte(String input) {
        return Base64.getDecoder().decode(input);
    }

    public static String convertBytesToHex(byte[] bytes) {
        return DatatypeConverter.printHexBinary(bytes);
    }

    public static byte[] hexStringToByteArray(String hexString) {
        return DatatypeConverter.parseHexBinary(hexString);
    }
}

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.Scanner;

/**
 * {@code FindResource} is an example of loading a resource file from
 * classpath.
 * <p/>
 * Answers to stackoverflow questions:
 * <ol>
 * <li>https://stackoverflow.com/questions/46848816/jar-manifest-class-path-use-folder-instead-of-jar</li>
 * </ol>
 *
 * @author Indra Basak
 * @since 10/27/17
 */
@SuppressWarnings({"squid:S106", "squid:S1481", "squid:S1854", "squid:S1148"})
public class FindResource {

    public FindResource(String fileName) {
        StringBuilder result = new StringBuilder("");

        URL properties =
                this.getClass().getClassLoader().getResource(fileName);

        File file = new File(properties.getFile());

        try (Scanner scanner = new Scanner(file)) {

            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                result.append(line).append("\n");
            }

            scanner.close();

        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println(result.toString());

    }

    public static void main(String... args) {
        FindResource findResource = new FindResource("foo.properties");

        URL properties = FindResource.class.getClassLoader().getResource(
                "foo.properties");
        System.out.println("** " + properties.toString());

    }
}
--------------------------------------------------------------------------------------------------------
import com.basaki.annotation.Key;
import com.basaki.annotation.Wrappable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.ArrayList;
import java.util.List;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

/**
 * {@code WrappableAspect} intercepts any method execution if a
 * method is tagged with {@code com.basaki.annotation.Wrappable}
 * annotation.
 * <p>
 *
 * @author Indra Basak
 * @since 10/4/17
 */
@Aspect
@Component
@Slf4j
public class WrappableAspect {

    @After("@annotation(annotation) || @within(annotation)")
    public void wrapper(
            final JoinPoint pointcut,
            final Wrappable annotation) {
        log.info("Inside WrappableAspect.wrapper()");
        Wrappable anno = annotation;
        List<Parameter> keyParams = new ArrayList<>();

        if (annotation == null) {
            if (pointcut.getSignature() instanceof MethodSignature) {
                MethodSignature signature =
                        (MethodSignature) pointcut.getSignature();
                Method method = signature.getMethod();
                anno = method.getAnnotation(Wrappable.class);

                Parameter[] params = method.getParameters();
                for (Parameter param : params) {
                    try {
                        Annotation keyAnno = param.getAnnotation(Key.class);
                        keyParams.add(param);
                    } catch (Exception e) {
                        //do nothing
                    }
                }
            }
        }
    }
}
gdprStatus

{
	"requestId": <request-id>,
	"subjects":
	[{
		"sku": <sku>,
		"quantity": <quantity>
	}]
}

{
	"requestId": <request-id>,
	"subjects":
	[{
		"sku": <sku>,
		"quantity": <quantity>,
		"serialNumberPns":
		[
			"serialNumberPns-01",
			"serialNumberPns-02",
			"serialNumberPns-03",
			...
		]
	}]
}

{
	"id": <id>,
	"ownerId": <owner-id>
}

http://vdlg-pba11-redis-1.pba.internal:5027/api/v0/registry/applications/user?userid=<user-id>
--------------------------------------------------------------------------------------------------------
new NegatedRequestMatcher(authorizationHeaderRequestMatcher)

import java.nio.charset.StandardCharsets;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.*;
import org.thymeleaf.templateresolver.ClassLoaderTemplateResolver;

@Configuration
public class ThymeleafConfiguration {

    @SuppressWarnings("unused")
    private final Logger log = LoggerFactory.getLogger(ThymeleafConfiguration.class);

    @Bean
    @Description("Thymeleaf template resolver serving HTML 5 emails")
    public ClassLoaderTemplateResolver emailTemplateResolver() {
        ClassLoaderTemplateResolver emailTemplateResolver = new ClassLoaderTemplateResolver();
        emailTemplateResolver.setPrefix("mails/");
        emailTemplateResolver.setSuffix(".html");
        emailTemplateResolver.setTemplateMode("HTML");
        emailTemplateResolver.setCharacterEncoding(StandardCharsets.UTF_8.name());
        emailTemplateResolver.setOrder(1);
        return emailTemplateResolver;
    }
}

   /**
     * Initializes H2 console.
     */
    private void initH2Console(ServletContext servletContext) {
        log.debug("Initialize H2 console");
        try {
            // We don't want to include H2 when we are packaging for the "prod" profile and won't
            // actually need it, so we have to load / invoke things at runtime through reflection.
            ClassLoader loader = Thread.currentThread().getContextClassLoader();
            Class<?> servletClass = Class.forName("org.h2.server.web.WebServlet", true, loader);
            Servlet servlet = (Servlet) servletClass.newInstance();

            ServletRegistration.Dynamic h2ConsoleServlet = servletContext.addServlet("H2Console", servlet);
            h2ConsoleServlet.addMapping("/h2-console/*");
            h2ConsoleServlet.setInitParameter("-properties", "src/main/resources/");
            h2ConsoleServlet.setLoadOnStartup(1);

        } catch (ClassNotFoundException | LinkageError  e) {
            throw new RuntimeException("Failed to load and initialize org.h2.server.web.WebServlet", e);

        } catch (IllegalAccessException | InstantiationException e) {
            throw new RuntimeException("Failed to instantiate org.h2.server.web.WebServlet", e);
        }
    }<% } %>
	
	
	

import <%=packageName%>.domain.Authority;
import <%=packageName%>.domain.User;
import <%=packageName%>.security.AuthoritiesConstants;

import com.github.mongobee.changeset.ChangeLog;
import com.github.mongobee.changeset.ChangeSet;
import org.springframework.data.mongodb.core.MongoTemplate;

import java.time.Instant;
import java.util.Arrays;
import java.util.Collections;

/**
 * Creates the initial database setup
 */
@ChangeLog(order = "001")
public class InitialSetupMigration {

    @ChangeSet(order = "01", author = "initiator", id = "01-addAuthorities")
    public void addAuthorities(MongoTemplate mongoTemplate) {
        Authority adminAuthority = new Authority();
        adminAuthority.setName(AuthoritiesConstants.ADMIN);
        Authority userAuthority = new Authority();
        userAuthority.setName(AuthoritiesConstants.USER);
        mongoTemplate.save(adminAuthority);
        mongoTemplate.save(userAuthority);
    }

    @ChangeSet(order = "02", author = "initiator", id = "02-addUsers")
    public void addUsers(MongoTemplate mongoTemplate) {
        Authority adminAuthority = new Authority();
        adminAuthority.setName(AuthoritiesConstants.ADMIN);
        Authority userAuthority = new Authority();
        userAuthority.setName(AuthoritiesConstants.USER);

        User systemUser = new User();
        systemUser.setId("user-0");
        systemUser.setLogin("system");
        <%_ if (authenticationType !== 'oauth2') { _%>
        systemUser.setPassword("$2a$10$mE.qmcV0mFU5NcKh73TZx.z4ueI/.bDWbj0T1BYyqP481kGGarKLG");
        <%_ } _%>
        systemUser.setFirstName("");
        systemUser.setLastName("System");
        systemUser.setEmail("system@localhost");
        systemUser.setActivated(true);
        systemUser.setLangKey("en");
        systemUser.setCreatedBy(systemUser.getLogin());
        systemUser.setCreatedDate(Instant.now());
        systemUser.getAuthorities().add(adminAuthority);
        systemUser.getAuthorities().add(userAuthority);
        mongoTemplate.save(systemUser);

        User anonymousUser = new User();
        anonymousUser.setId("user-1");
        anonymousUser.setLogin("anonymoususer");
        <%_ if (authenticationType !== 'oauth2') { _%>
        anonymousUser.setPassword("$2a$10$j8S5d7Sr7.8VTOYNviDPOeWX8KcYILUVJBsYV83Y5NtECayypx9lO");
        <%_ } _%>
        anonymousUser.setFirstName("Anonymous");
        anonymousUser.setLastName("User");
        anonymousUser.setEmail("anonymous@localhost");
        anonymousUser.setActivated(true);
        anonymousUser.setLangKey("en");
        anonymousUser.setCreatedBy(systemUser.getLogin());
        anonymousUser.setCreatedDate(Instant.now());
        mongoTemplate.save(anonymousUser);

        User adminUser = new User();
        adminUser.setId("user-2");
        adminUser.setLogin("admin");
        <%_ if (authenticationType !== 'oauth2') { _%>
        adminUser.setPassword("$2a$10$gSAhZrxMllrbgj/kkK9UceBPpChGWJA7SYIb1Mqo.n5aNLq1/oRrC");
        <%_ } _%>
        adminUser.setFirstName("admin");
        adminUser.setLastName("Administrator");
        adminUser.setEmail("admin@localhost");
        adminUser.setActivated(true);
        adminUser.setLangKey("en");
        adminUser.setCreatedBy(systemUser.getLogin());
        adminUser.setCreatedDate(Instant.now());
        adminUser.getAuthorities().add(adminAuthority);
        adminUser.getAuthorities().add(userAuthority);
        mongoTemplate.save(adminUser);

        User userUser = new User();
        userUser.setId("user-3");
        userUser.setLogin("user");
        <%_ if (authenticationType !== 'oauth2') { _%>
        userUser.setPassword("$2a$10$VEjxo0jq2YG9Rbk2HmX9S.k1uZBGYUHdUcid3g/vfiEl7lwWgOH/K");
        <%_ } _%>
        userUser.setFirstName("");
        userUser.setLastName("User");
        userUser.setEmail("user@localhost");
        userUser.setActivated(true);
        userUser.setLangKey("en");
        userUser.setCreatedBy(systemUser.getLogin());
        userUser.setCreatedDate(Instant.now());
        userUser.getAuthorities().add(userAuthority);
        mongoTemplate.save(userUser);
    }
}
--------------------------------------------------------------------------------------------------------

import java.net.InetSocketAddress;
import java.util.Iterator;

import io.github.jhipster.config.JHipsterProperties;

import ch.qos.logback.classic.AsyncAppender;
import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.boolex.OnMarkerEvaluator;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.classic.spi.LoggerContextListener;
import ch.qos.logback.core.Appender;
import ch.qos.logback.core.filter.EvaluatorFilter;
import ch.qos.logback.core.spi.ContextAwareBase;
import ch.qos.logback.core.spi.FilterReply;
import net.logstash.logback.appender.LogstashTcpSocketAppender;
import net.logstash.logback.encoder.LogstashEncoder;
import net.logstash.logback.stacktrace.ShortenedThrowableConverter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
<%_ if (serviceDiscoveryType === "eureka") { _%>
import org.springframework.cloud.context.config.annotation.RefreshScope;
<%_ } _%>
<%_ if (serviceDiscoveryType === "consul") { _%>
import org.springframework.cloud.consul.ConditionalOnConsulEnabled;
import org.springframework.cloud.consul.serviceregistry.ConsulRegistration;
import org.springframework.cloud.context.config.annotation.RefreshScope;
<%_ } _%>
import org.springframework.context.annotation.Configuration;

@Configuration
<%_ if (serviceDiscoveryType === "eureka") { _%>
@RefreshScope
<%_ } _%>
<%_ if (serviceDiscoveryType === "consul") { _%>
@ConditionalOnConsulEnabled
@RefreshScope
<%_ } _%>
public class LoggingConfiguration {

    private static final String LOGSTASH_APPENDER_NAME = "LOGSTASH";

    private static final String ASYNC_LOGSTASH_APPENDER_NAME = "ASYNC_LOGSTASH";

    private final Logger log = LoggerFactory.getLogger(LoggingConfiguration.class);

    private LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory();

    private final String appName;

    private final String serverPort;
    <%_ if (serviceDiscoveryType === "consul") { _%>

    private final ConsulRegistration consulRegistration;
    <%_ } _%>
    <%_ if (serviceDiscoveryType && (applicationType === 'microservice' || applicationType === 'gateway' || applicationType === 'uaa')) { _%>

    private final String version;
    <%_ } _%>

    private final JHipsterProperties jHipsterProperties;

    public LoggingConfiguration(@Value("${spring.application.name}") String appName, @Value("${server.port}") String serverPort,
        <% if (serviceDiscoveryType === "consul") { %> ConsulRegistration consulRegistration,<% } %><% if (serviceDiscoveryType && (applicationType === 'microservice' || applicationType === 'gateway' || applicationType === 'uaa')) { %> @Value("${info.project.version}") String version,<% } %> JHipsterProperties jHipsterProperties) {
        this.appName = appName;
        this.serverPort = serverPort;
        <%_ if (serviceDiscoveryType === 'consul') { _%>
        this.consulRegistration = consulRegistration;
        <%_ } _%>
        <%_ if (serviceDiscoveryType && (applicationType === 'microservice' || applicationType === 'gateway' || applicationType === 'uaa')) { _%>
        this.version = version;
        <%_ } _%>
        this.jHipsterProperties = jHipsterProperties;
        if (jHipsterProperties.getLogging().getLogstash().isEnabled()) {
            addLogstashAppender(context);
            addContextListener(context);
        }
        if (jHipsterProperties.getMetrics().getLogs().isEnabled()) {
            setMetricsMarkerLogbackFilter(context);
        }
    }

    private void addContextListener(LoggerContext context) {
        LogbackLoggerContextListener loggerContextListener = new LogbackLoggerContextListener();
        loggerContextListener.setContext(context);
        context.addListener(loggerContextListener);
    }

    private void addLogstashAppender(LoggerContext context) {
        log.info("Initializing Logstash logging");

        LogstashTcpSocketAppender logstashAppender = new LogstashTcpSocketAppender();
        logstashAppender.setName(LOGSTASH_APPENDER_NAME);
        logstashAppender.setContext(context);
        <%_ if (serviceDiscoveryType && (applicationType === 'microservice' || applicationType === 'gateway' || applicationType === 'uaa')) { _%>
        String optionalFields = "";
        <%_ if (serviceDiscoveryType === 'consul') { _%>
        if (consulRegistration != null) {
            optionalFields = "\"instance_id\":\"" + consulRegistration.getInstanceId() + "\",";
        }
        <%_ } _%>
        String customFields = "{\"app_name\":\"" + appName + "\",\"app_port\":\"" + serverPort + "\"," +
            optionalFields + "\"version\":\"" + version + "\"}";
        <%_ } else { _%>
        String customFields = "{\"app_name\":\"" + appName + "\",\"app_port\":\"" + serverPort + "\"}";
        <%_ } _%>

        // More documentation is available at: https://github.com/logstash/logstash-logback-encoder
        LogstashEncoder logstashEncoder=new LogstashEncoder();
        // Set the Logstash appender config from JHipster properties
        logstashEncoder.setCustomFields(customFields);
        // Set the Logstash appender config from JHipster properties
        logstashAppender.addDestinations(new InetSocketAddress(jHipsterProperties.getLogging().getLogstash().getHost(),jHipsterProperties.getLogging().getLogstash().getPort()));

        ShortenedThrowableConverter throwableConverter = new ShortenedThrowableConverter();
        throwableConverter.setRootCauseFirst(true);
        logstashEncoder.setThrowableConverter(throwableConverter);
        logstashEncoder.setCustomFields(customFields);

        logstashAppender.setEncoder(logstashEncoder);
        logstashAppender.start();

        // Wrap the appender in an Async appender for performance
        AsyncAppender asyncLogstashAppender = new AsyncAppender();
        asyncLogstashAppender.setContext(context);
        asyncLogstashAppender.setName(ASYNC_LOGSTASH_APPENDER_NAME);
        asyncLogstashAppender.setQueueSize(jHipsterProperties.getLogging().getLogstash().getQueueSize());
        asyncLogstashAppender.addAppender(logstashAppender);
        asyncLogstashAppender.start();

        context.getLogger("ROOT").addAppender(asyncLogstashAppender);
    }

    // Configure a log filter to remove "metrics" logs from all appenders except the "LOGSTASH" appender
    private void setMetricsMarkerLogbackFilter(LoggerContext context) {
        log.info("Filtering metrics logs from all appenders except the {} appender", LOGSTASH_APPENDER_NAME);
        OnMarkerEvaluator onMarkerMetricsEvaluator = new OnMarkerEvaluator();
        onMarkerMetricsEvaluator.setContext(context);
        onMarkerMetricsEvaluator.addMarker("metrics");
        onMarkerMetricsEvaluator.start();
        EvaluatorFilter<ILoggingEvent> metricsFilter = new EvaluatorFilter<>();
        metricsFilter.setContext(context);
        metricsFilter.setEvaluator(onMarkerMetricsEvaluator);
        metricsFilter.setOnMatch(FilterReply.DENY);
        metricsFilter.start();

        for (ch.qos.logback.classic.Logger logger : context.getLoggerList()) {
            for (Iterator<Appender<ILoggingEvent>> it = logger.iteratorForAppenders(); it.hasNext();) {
                Appender<ILoggingEvent> appender = it.next();
                if (!appender.getName().equals(ASYNC_LOGSTASH_APPENDER_NAME)) {
                    log.debug("Filter metrics logs from the {} appender", appender.getName());
                    appender.setContext(context);
                    appender.addFilter(metricsFilter);
                    appender.start();
                }
            }
        }
    }

    /**
     * Logback configuration is achieved by configuration file and API.
     * When configuration file change is detected, the configuration is reset.
     * This listener ensures that the programmatic configuration is also re-applied after reset.
     */
    class LogbackLoggerContextListener extends ContextAwareBase implements LoggerContextListener {

        @Override
        public boolean isResetResistant() {
            return true;
        }

        @Override
        public void onStart(LoggerContext context) {
            addLogstashAppender(context);
        }

        @Override
        public void onReset(LoggerContext context) {
            addLogstashAppender(context);
        }

        @Override
        public void onStop(LoggerContext context) {
            // Nothing to do.
        }

        @Override
        public void onLevelChange(ch.qos.logback.classic.Logger logger, Level level) {
            // Nothing to do.
        }
    }
}

    @Bean
    @Qualifier("authorizationHeaderRequestMatcher")
    public RequestMatcher authorizationHeaderRequestMatcher() {
        return new RequestHeaderRequestMatcher("Authorization");
    }
	
package <%=packageName%>.config.metrics;
import com.datastax.driver.core.Session;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JHipsterHealthIndicatorConfiguration {

    private final Session session;

    public JHipsterHealthIndicatorConfiguration(Session session) {
        this.session = session;
    }

    @Bean
    public HealthIndicator cassandraHealthIndicator() {
        return new CassandraHealthIndicator(session);
    }
}

import com.datastax.driver.core.PreparedStatement;
import com.datastax.driver.core.ResultSet;
import com.datastax.driver.core.Session;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.boot.actuate.health.AbstractHealthIndicator;
import org.springframework.boot.actuate.health.Health;
import org.springframework.util.Assert;

/**
 * Simple implementation of a {@link org.springframework.boot.actuate.health.HealthIndicator} returning status information for
 * Cassandra data stores.
 */
public class CassandraHealthIndicator extends AbstractHealthIndicator {

    private static Log log = LogFactory.getLog(CassandraHealthIndicator.class);

    private Session session;

    private PreparedStatement validationStmt;

    public CassandraHealthIndicator(Session session) {
        Assert.notNull(session, "Cassandra session must not be null");
        this.session = session;
        this.validationStmt = session.prepare(
            "SELECT release_version FROM system.local");
    }

    @Override
    protected void doHealthCheck(Health.Builder builder) throws Exception {
        log.debug("Initializing Cassandra health indicator");
        try {
            ResultSet results = session.execute(validationStmt.bind());
            if (results.isExhausted()) {
                builder.up();
            } else {
                builder.up().withDetail("version", results.one().getString(0));
            }
        } catch (Exception e) {
            log.debug("Cannot connect to Cassandra cluster. Error: {}", e);
            builder.down(e);
        }
    }
}
--------------------------------------------------------------------------------------------------------
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

/**
 * To be independent from Springs annotation this annotation was introduced
 * which is a replacement for the {@link Component} annotation.
 * 
 * In future you may introduce different configuration options.
 * 
 * @author Marc Giffing
 *
 */
@Configuration
@Target({ ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Order(ApplicationInitExtension.DEFAULT_PRECEDENCE)
public @interface ApplicationInitExtension {

	int HIGHEST_PRECEDENCE = Integer.MIN_VALUE;
	
	int DEFAULT_PRECEDENCE = Integer.MAX_VALUE / 2;

	int LOWEST_PRECEDENCE = Integer.MAX_VALUE;

	String value() default "";
}
--------------------------------------------------------------------------------------------------------
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.context.annotation.Conditional;

/**
 * Conditional annotation to pre-check if an extension should be picked for autoconfiguration. 
 * 
 * You can define the major Wicket version on which the extension
 * should or should not be executed.
 * 
 * @author Marc Giffing
 */
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(WicketSettingsCondition.class)
public @interface ConditionalOnWicket {
	
	/**
	 * @return The major java version to check with the current value 
	 */
	int value();
	
	/**
	 * @return Defines how the given major version should be checked with the current version
	 */
	Range range() default Range.EQUALS_OR_HIGHER;

	

	
	enum Range {
		/**
		 * The Wicket major version equals the 
		 */
		EQUALS,
		/**
		 * The Wicket major version equals or is newer
		 */
		EQUALS_OR_HIGHER,
		
		/**
		 * The Wicket major version equals or is lower
		 */
		EQUALS_OR_LOWER,

	}
}


import java.util.Map;

import org.apache.wicket.settings.FrameworkSettings;
import org.springframework.boot.autoconfigure.condition.ConditionOutcome;
import org.springframework.boot.autoconfigure.condition.SpringBootCondition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.type.AnnotatedTypeMetadata;

import com.giffing.wicket.spring.boot.context.condition.ConditionalOnWicket.Range;

/**
 * Retrieves the current major Wicket Version from the classpath and matches it against
 * the given conditional value in the {@link ConditionalOnWicket} annotation.
 * 
 * @author Marc Giffing
 *
 */
public class WicketSettingsCondition extends SpringBootCondition {

	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		String implVersion = null;
		String wicketVersion = retrieveWicketVersion(implVersion);
		
		Map<String, Object> attributes = metadata
				.getAnnotationAttributes(ConditionalOnWicket.class.getName());
		Range range = (Range) attributes.get("range");
		int expectedVersion = (int) attributes.get("value");
		String[] splittedWicketVersion = wicketVersion.split("\\.");
		int majorWicketVersion = Integer.valueOf(splittedWicketVersion[0]);
		return getMatchOutcome(range, majorWicketVersion, expectedVersion);
	}

	protected ConditionOutcome getMatchOutcome(Range range, int runningVersion,
			int expectedVersion) {
		boolean match = matches(range, expectedVersion, runningVersion);
		return new ConditionOutcome(match, getMessage(match, range, runningVersion, expectedVersion));
	}

	private boolean matches(Range range, int expectedVersion, int runningVersion) {
		switch(range){
		case EQUALS:
			return runningVersion == expectedVersion;
		case EQUALS_OR_LOWER:
			return runningVersion <= expectedVersion;
		case EQUALS_OR_HIGHER:
			return runningVersion >= expectedVersion;
		default:
			return false;
		
		}
	}

	private String getMessage(boolean matches, Range range, int runningVersion,
			int expectedVersion) {
		if(matches){
			return "Wicket version matches current: " + runningVersion + " " + range + " expected: " + expectedVersion;
		}else {
			return "Wicket version does not match current: " + runningVersion + " " + range + " expected: " +  expectedVersion;
		}
	}
	
	private String retrieveWicketVersion(String implVersion) {
		
		Package pkg = FrameworkSettings.class.getPackage();
		if (pkg != null)
		{
			implVersion = pkg.getImplementationVersion();
		}
		String wicketVersion = isEmpty(implVersion) ? "0" : implVersion;
		return wicketVersion;
	}
	
	private boolean isEmpty(String stringToCheck){
		if(stringToCheck == null || stringToCheck.length() == 0){
			return true;
		}
		return false;
	}

}
--------------------------------------------------------------------------------------------------------
import java.util.Collection;
import java.util.Collections;
import java.util.Set;

import javax.annotation.PostConstruct;

import org.apache.wicket.Page;
import org.apache.wicket.markup.html.WebPage;
import org.springframework.beans.factory.BeanClassLoaderAware;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.boot.autoconfigure.AutoConfigurationPackages;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.core.io.ResourceLoader;
import org.springframework.core.type.filter.AnnotationTypeFilter;
import org.springframework.util.ClassUtils;
import org.springframework.util.StringUtils;

import com.giffing.wicket.spring.boot.context.scan.WicketAccessDeniedPage;
import com.giffing.wicket.spring.boot.context.scan.WicketExpiredPage;
import com.giffing.wicket.spring.boot.context.scan.WicketHomePage;
import com.giffing.wicket.spring.boot.context.scan.WicketInternalErrorPage;
import com.giffing.wicket.spring.boot.context.scan.WicketSignInPage;
import com.giffing.wicket.spring.boot.starter.app.classscanner.candidates.WicketClassCandidate;
import com.giffing.wicket.spring.boot.starter.app.classscanner.candidates.WicketClassCandidatesHolder;

/**
 * The candidate class scanner is used to find class with special annotations.
 * 
 * @author Marc Giffing
 *
 */
@Configuration
public class ClassCandidateScanner implements BeanClassLoaderAware {
	
	@Autowired
	private Environment environment;

	@Autowired
	private ResourceLoader resourceLoader;

	@Autowired
	private BeanFactory beanFactory;
	
	private ClassLoader classLoader;

	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		this.classLoader = classLoader;
	}
	
	@Bean
	public WicketClassCandidatesHolder pageCandidates() {
		return new WicketClassCandidatesHolder();
	}
	
	@PostConstruct
	public void postConstruct() {
		ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(
				false);
		scanner.setEnvironment(this.environment);
		scanner.setResourceLoader(this.resourceLoader);
		scanner.addIncludeFilter(new AnnotationTypeFilter(WicketHomePage.class));
		scanner.addIncludeFilter(new AnnotationTypeFilter(WicketSignInPage.class));
	    scanner.addIncludeFilter(new AnnotationTypeFilter(WicketAccessDeniedPage.class));
	    scanner.addIncludeFilter(new AnnotationTypeFilter(WicketExpiredPage.class));
	    scanner.addIncludeFilter(new AnnotationTypeFilter(WicketInternalErrorPage.class));
	    for (String basePackage : getMappingBasePackages(beanFactory)) {
			if (StringUtils.hasText(basePackage)) {
				pageCandidates().getBasePackages().add(basePackage);
				Set<BeanDefinition> beanDefinitions = scanner.findCandidateComponents(basePackage);
				for (BeanDefinition beanDefinition : beanDefinitions) {
					Class<?> beanClass;
					try {
						beanClass = ClassUtils.forName(beanDefinition.getBeanClassName(), classLoader);
					} catch (ClassNotFoundException e) {
						throw new IllegalStateException(e);
					}
					if(beanClass.isAnnotationPresent(WicketHomePage.class)){
						pageCandidates().getHomePageCandidates().add(new WicketClassCandidate<Page>((Class<Page>) beanClass));
					}
					if(beanClass.isAnnotationPresent(WicketSignInPage.class)){
						pageCandidates().getSignInPageCandidates().add(new WicketClassCandidate<WebPage>((Class<WebPage>) beanClass));
					}
					if(beanClass.isAnnotationPresent(WicketAccessDeniedPage.class)){
						pageCandidates().getAccessDeniedPageCandidates().add(new WicketClassCandidate<Page>((Class<Page>) beanClass));
					}
					if(beanClass.isAnnotationPresent(WicketExpiredPage.class)){
						pageCandidates().getExpiredPageCandidates().add(new WicketClassCandidate<Page>((Class<Page>) beanClass));
					}
					if(beanClass.isAnnotationPresent(WicketInternalErrorPage.class)){
						pageCandidates().getInternalErrorPageCandidates().add(new WicketClassCandidate<Page>((Class<Page>) beanClass));
					}
				}
				
			}
	    }
	}
	
	private static Collection<String> getMappingBasePackages(BeanFactory beanFactory) {
		try {
			return AutoConfigurationPackages.get(beanFactory);
		}
		catch (IllegalStateException ex) {
			// no auto-configuration package registered yet
			return Collections.emptyList();
		}
	}
}
--------------------------------------------------------------------------------------------------------
import java.lang.ref.WeakReference;

/**
 * @author Marc Giffing
 *
 * @param <T> candidate class type
 */
public class WicketClassCandidate<T> {

	private WeakReference<Class<T>> candidate;
	
	public WicketClassCandidate(Class<T> candidate) {
		this.candidate = new WeakReference<Class<T>>(candidate);
	}

	public Class<T> getCandidate() {
		return candidate.get();
	}
}
--------------------------------------------------------------------------------------------------------
import java.io.IOException;

import org.elasticsearch.client.Client;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.elasticsearch.core.ElasticsearchTemplate;
import org.springframework.data.elasticsearch.core.EntityMapper;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;

@Configuration
@EnableConfigurationProperties(ElasticsearchProperties.class)
@ConditionalOnProperty("spring.data.elasticsearch.cluster-nodes")
public class ElasticsearchConfiguration {

    @Bean
    public ElasticsearchTemplate elasticsearchTemplate(Client client, Jackson2ObjectMapperBuilder jackson2ObjectMapperBuilder) {
        return new ElasticsearchTemplate(client, new CustomEntityMapper(jackson2ObjectMapperBuilder.createXmlMapper(false).build()));
    }

    public class CustomEntityMapper implements EntityMapper {

        private ObjectMapper objectMapper;

        public CustomEntityMapper(ObjectMapper objectMapper) {
            this.objectMapper = objectMapper;
            objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
            objectMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);
        }

        @Override
        public String mapToString(Object object) throws IOException {
            return objectMapper.writeValueAsString(object);
        }

        @Override
        public <T> T mapToObject(String source, Class<T> clazz) throws IOException {
            return objectMapper.readValue(source, clazz);
        }
    }
}


    @Bean
    public MongoCustomConversions customConversions() {
        List<Converter<?, ?>> converters = new ArrayList<>();
        converters.add(DateToZonedDateTimeConverter.INSTANCE);
        converters.add(ZonedDateTimeToDateConverter.INSTANCE);
        return new MongoCustomConversions(converters);
    }
--------------------------------------------------------------------------------------------------------
import <%=packageName%>.AbstractCassandraTest;<% } %>
import cucumber.api.CucumberOptions;
import cucumber.api.junit.Cucumber;

@RunWith(Cucumber.class)
@CucumberOptions(plugin = "pretty", features = "<%= TEST_DIR %>features")
public class CucumberTest <% if (databaseType === 'cassandra') { %>extends AbstractCassandraTest<% } %> {

}


import cucumber.api.java.Before;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import <%=packageName%>.web.rest.UserResource;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

public class UserStepDefs extends StepDefs {

    @Autowired
    private UserResource userResource;

    private MockMvc restUserMockMvc;

    @Before
    public void setup() {
        this.restUserMockMvc = MockMvcBuilders.standaloneSetup(userResource).build();
    }

    @When("^I search user '(.*)'$")
    public void i_search_user_admin(String userId) throws Throwable {
        actions = restUserMockMvc.perform(get("/api/users/" + userId)
                .accept(MediaType.APPLICATION_JSON));
    }

    @Then("^the user is found$")
    public void the_user_is_found() throws Throwable {
        actions
            .andExpect(status().isOk())
            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8_VALUE));
    }

    @Then("^his last name is '(.*)'$")
    public void his_last_name_is(String lastName) throws Throwable {
        actions.andExpect(jsonPath("$.lastName").value(lastName));
    }

}

import <%=packageName%>.<%= mainClass %>;

import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.ResultActions;

import org.springframework.boot.test.context.SpringBootTest;

@WebAppConfiguration
@SpringBootTest
@ContextConfiguration(classes = <%= mainClass %>.class)
public abstract class StepDefs {

    protected ResultActions actions;

}
--------------------------------------------------------------------------------------------------------
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.index.query.functionscore.FunctionScoreQueryBuilder;
import org.elasticsearch.index.query.functionscore.ScoreFunctionBuilders;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.spring.springboot.domain.City;
import org.spring.springboot.repository.CityRepository;
import org.spring.springboot.service.CityService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.elasticsearch.core.query.NativeSearchQueryBuilder;
import org.springframework.data.elasticsearch.core.query.SearchQuery;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 城市 ES 业务逻辑实现类
 *
 * Created by bysocket on 07/02/2017.
 */
@Service
public class CityESServiceImpl implements CityService {

    private static final Logger LOGGER = LoggerFactory.getLogger(CityESServiceImpl.class);

    @Autowired
    CityRepository cityRepository;

    @Override
    public Long saveCity(City city) {

        City cityResult = cityRepository.save(city);
        return cityResult.getId();
    }

    @Override
    public List<City> searchCity(Integer pageNumber,
                                 Integer pageSize,
                                 String searchContent) {
        // 分页参数
        Pageable pageable = new PageRequest(pageNumber, pageSize);

        // Function Score Query
        FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery()
                .add(QueryBuilders.boolQuery().should(QueryBuilders.matchQuery("cityname", searchContent)),
                    ScoreFunctionBuilders.weightFactorFunction(1000))
                .add(QueryBuilders.boolQuery().should(QueryBuilders.matchQuery("description", searchContent)),
                        ScoreFunctionBuilders.weightFactorFunction(100));

        // 创建搜索 DSL 查询
        SearchQuery searchQuery = new NativeSearchQueryBuilder()
                .withPageable(pageable)
                .withQuery(functionScoreQueryBuilder).build();

        LOGGER.info("\n searchCity(): searchContent [" + searchContent + "] \n DSL  = \n " + searchQuery.getQuery().toString());

        Page<City> searchPageResults = cityRepository.search(searchQuery);
        return searchPageResults.getContent();
    }
}
--------------------------------------------------------------------------------------------------------
import com.google.common.base.Predicate;
import com.google.common.base.Strings;
import com.google.common.base.Throwables;
import com.google.common.io.ByteSink;
import com.google.common.io.ByteSource;
import com.google.common.io.ByteStreams;
import com.google.common.io.Files;
import com.metamx.common.guava.CloseQuietly;
import com.metamx.common.logger.Logger;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Enumeration;
import java.util.concurrent.Callable;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

public class CompressionUtils
{
  private static final Logger log = new Logger(CompressionUtils.class);
  private static final int DEFAULT_RETRY_COUNT = 3;

  public static final String GZ_SUFFIX = ".gz";
  public static final String ZIP_SUFFIX = ".zip";

  /**
   * Zip the contents of directory into the file indicated by outputZipFile. Sub directories are skipped
   *
   * @param directory     The directory whose contents should be added to the zip in the output stream.
   * @param outputZipFile The output file to write the zipped data to
   *
   * @return The number of bytes (uncompressed) read from the input directory.
   *
   * @throws IOException
   */
  public static long zip(File directory, File outputZipFile) throws IOException
  {
    if (!isZip(outputZipFile.getName())) {
      log.warn("No .zip suffix[%s], putting files from [%s] into it anyway.", outputZipFile, directory);
    }

    try (final FileOutputStream out = new FileOutputStream(outputZipFile)) {
      return zip(directory, out);
    }
  }

  /**
   * Zips the contents of the input directory to the output stream. Sub directories are skipped
   *
   * @param directory The directory whose contents should be added to the zip in the output stream.
   * @param out       The output stream to write the zip data to. It is closed in the process
   *
   * @return The number of bytes (uncompressed) read from the input directory.
   *
   * @throws IOException
   */
  public static long zip(File directory, OutputStream out) throws IOException
  {
    if (!directory.isDirectory()) {
      throw new IOException(String.format("directory[%s] is not a directory", directory));
    }
    final File[] files = directory.listFiles();

    long totalSize = 0;
    try (final ZipOutputStream zipOut = new ZipOutputStream(out)) {
      for (File file : files) {
        log.info("Adding file[%s] with size[%,d].  Total size so far[%,d]", file, file.length(), totalSize);
        if (file.length() >= Integer.MAX_VALUE) {
          zipOut.finish();
          throw new IOException(String.format("file[%s] too large [%,d]", file, file.length()));
        }
        zipOut.putNextEntry(new ZipEntry(file.getName()));
        totalSize += Files.asByteSource(file).copyTo(zipOut);
      }
      zipOut.closeEntry();
      // Workarround for http://hg.openjdk.java.net/jdk8/jdk8/jdk/rev/759aa847dcaf
      zipOut.flush();
    }

    return totalSize;
  }

  /**
   * Unzip the byteSource to the output directory. If cacheLocally is true, the byteSource is cached to local disk before unzipping.
   * This may cause more predictable behavior than trying to unzip a large file directly off a network stream, for example.
   * * @param byteSource The ByteSource which supplies the zip data
   *
   * @param byteSource   The ByteSource which supplies the zip data
   * @param outDir       The output directory to put the contents of the zip
   * @param shouldRetry  A predicate expression to determine if a new InputStream should be acquired from ByteSource and the copy attempted again
   * @param cacheLocally A boolean flag to indicate if the data should be cached locally
   *
   * @return A FileCopyResult containing the result of writing the zip entries to disk
   *
   * @throws IOException
   */
  public static FileUtils.FileCopyResult unzip(
      final ByteSource byteSource,
      final File outDir,
      final Predicate<Throwable> shouldRetry,
      boolean cacheLocally
  ) throws IOException
  {
    if (!cacheLocally) {
      try {
        return RetryUtils.retry(
            new Callable<FileUtils.FileCopyResult>()
            {
              @Override
              public FileUtils.FileCopyResult call() throws Exception
              {
                return unzip(byteSource.openStream(), outDir);
              }
            },
            shouldRetry,
            DEFAULT_RETRY_COUNT
        );
      }
      catch (Exception e) {
        throw Throwables.propagate(e);
      }
    } else {
      final File tmpFile = File.createTempFile("compressionUtilZipCache", ZIP_SUFFIX);
      try {
        FileUtils.retryCopy(
            byteSource,
            tmpFile,
            shouldRetry,
            DEFAULT_RETRY_COUNT
        );
        return unzip(tmpFile, outDir);
      }
      finally {
        if (!tmpFile.delete()) {
          log.warn("Could not delete zip cache at [%s]", tmpFile.toString());
        }
      }
    }
  }

  /**
   * Unzip the byteSource to the output directory. If cacheLocally is true, the byteSource is cached to local disk before unzipping.
   * This may cause more predictable behavior than trying to unzip a large file directly off a network stream, for example.
   *
   * @param byteSource   The ByteSource which supplies the zip data
   * @param outDir       The output directory to put the contents of the zip
   * @param cacheLocally A boolean flag to indicate if the data should be cached locally
   *
   * @return A FileCopyResult containing the result of writing the zip entries to disk
   *
   * @throws IOException
   */
  public static FileUtils.FileCopyResult unzip(
      final ByteSource byteSource,
      final File outDir,
      boolean cacheLocally
  ) throws IOException
  {
    return unzip(byteSource, outDir, FileUtils.IS_EXCEPTION, cacheLocally);
  }

  /**
   * Unzip the pulled file to an output directory. This is only expected to work on zips with lone files, and is not intended for zips with directory structures.
   *
   * @param pulledFile The file to unzip
   * @param outDir     The directory to store the contents of the file.
   *
   * @return a FileCopyResult of the files which were written to disk
   *
   * @throws IOException
   */
  public static FileUtils.FileCopyResult unzip(final File pulledFile, final File outDir) throws IOException
  {
    if (!(outDir.exists() && outDir.isDirectory())) {
      throw new ISE("outDir[%s] must exist and be a directory", outDir);
    }
    log.info("Unzipping file[%s] to [%s]", pulledFile, outDir);
    final FileUtils.FileCopyResult result = new FileUtils.FileCopyResult();
    try (final ZipFile zipFile = new ZipFile(pulledFile)) {
      final Enumeration<? extends ZipEntry> enumeration = zipFile.entries();
      while (enumeration.hasMoreElements()) {
        final ZipEntry entry = enumeration.nextElement();
        result.addFiles(
            FileUtils.retryCopy(
                new ByteSource()
                {
                  @Override
                  public InputStream openStream() throws IOException
                  {
                    return new BufferedInputStream(zipFile.getInputStream(entry));
                  }
                },
                new File(outDir, entry.getName()),
                FileUtils.IS_EXCEPTION,
                DEFAULT_RETRY_COUNT
            ).getFiles()
        );
      }
    }
    return result;
  }

  /**
   * Unzip from the input stream to the output directory, using the entry's file name as the file name in the output directory.
   * The behavior of directories in the input stream's zip is undefined.
   * If possible, it is recommended to use unzip(ByteStream, File) instead
   *
   * @param in     The input stream of the zip data. This stream is closed
   * @param outDir The directory to copy the unzipped data to
   *
   * @return The FileUtils.FileCopyResult containing information on all the files which were written
   *
   * @throws IOException
   */
  public static FileUtils.FileCopyResult unzip(InputStream in, File outDir) throws IOException
  {
    try (final ZipInputStream zipIn = new ZipInputStream(in)) {
      final FileUtils.FileCopyResult result = new FileUtils.FileCopyResult();
      ZipEntry entry;
      while ((entry = zipIn.getNextEntry()) != null) {
        final File file = new File(outDir, entry.getName());
        Files.asByteSink(file).writeFrom(zipIn);
        result.addFile(file);
        zipIn.closeEntry();
      }
      return result;
    }
  }

  /**
   * gunzip the file to the output file.
   *
   * @param pulledFile The source of the gz data
   * @param outFile    A target file to put the contents
   *
   * @return The result of the file copy
   *
   * @throws IOException
   */
  public static FileUtils.FileCopyResult gunzip(final File pulledFile, File outFile) throws IOException
  {
    return gunzip(Files.asByteSource(pulledFile), outFile);
  }

  /**
   * Unzips the input stream via a gzip filter. use gunzip(ByteSource, File, Predicate) if possible
   *
   * @param in      The input stream to run through the gunzip filter. This stream is closed
   * @param outFile The file to output to
   *
   * @throws IOException
   */
  public static FileUtils.FileCopyResult gunzip(InputStream in, File outFile) throws IOException
  {
    try (GZIPInputStream gzipInputStream = gzipInputStream(in)) {
      Files.asByteSink(outFile).writeFrom(gzipInputStream);
      return new FileUtils.FileCopyResult(outFile);
    }
  }

  /**
   * Fixes java bug 7036144 http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7036144 which affects concatenated GZip
   *
   * @param in The raw input stream
   *
   * @return A GZIPInputStream that can handle concatenated gzip streams in the input
   */
  public static GZIPInputStream gzipInputStream(final InputStream in) throws IOException
  {
    return new GZIPInputStream(
        new FilterInputStream(in)
        {
          @Override
          public int available() throws IOException
          {
            final int otherAvailable = super.available();
            // Hack. Docs say available() should return an estimate,
            // so we estimate about 1KB to work around available == 0 bug in GZIPInputStream
            return otherAvailable == 0 ? 1 << 10 : otherAvailable;
          }
        }
    );
  }

  /**
   * gunzip from the source stream to the destination stream.
   *
   * @param in  The input stream which is to be decompressed. This stream is closed.
   * @param out The output stream to write to. This stream is closed
   *
   * @return The number of bytes written to the output stream.
   *
   * @throws IOException
   */
  public static long gunzip(InputStream in, OutputStream out) throws IOException
  {
    try (GZIPInputStream gzipInputStream = gzipInputStream(in)) {
      final long result =  ByteStreams.copy(gzipInputStream, out);
      out.flush();
      return result;
    }
    finally {
      out.close();
    }
  }

  /**
   * A gunzip function to store locally
   *
   * @param in          The factory to produce input streams
   * @param outFile     The file to store the result into
   * @param shouldRetry A predicate to indicate if the Throwable is recoverable
   *
   * @return The count of bytes written to outFile
   */
  public static FileUtils.FileCopyResult gunzip(
      final ByteSource in,
      final File outFile,
      Predicate<Throwable> shouldRetry
  )
  {
    return FileUtils.retryCopy(
        new ByteSource()
        {
          @Override
          public InputStream openStream() throws IOException
          {
            return gzipInputStream(in.openStream());
          }
        },
        outFile,
        shouldRetry,
        DEFAULT_RETRY_COUNT
    );
  }


  /**
   * Gunzip from the input stream to the output file
   *
   * @param in      The compressed input stream to read from
   * @param outFile The file to write the uncompressed results to
   *
   * @return A FileCopyResult of the file written
   */
  public static FileUtils.FileCopyResult gunzip(final ByteSource in, File outFile)
  {
    return gunzip(in, outFile, FileUtils.IS_EXCEPTION);
  }

  /**
   * Copy inputStream to out while wrapping out in a GZIPOutputStream
   * Closes both input and output
   *
   * @param inputStream The input stream to copy data from. This stream is closed
   * @param out         The output stream to wrap in a GZIPOutputStream before copying. This stream is closed
   *
   * @return The size of the data copied
   *
   * @throws IOException
   */
  public static long gzip(InputStream inputStream, OutputStream out) throws IOException
  {
    try (GZIPOutputStream outputStream = new GZIPOutputStream(out)) {
      final long result = ByteStreams.copy(inputStream, outputStream);
      out.flush();
      return result;
    }
    finally {
      inputStream.close();
    }
  }

  /**
   * Gzips the input file to the output
   *
   * @param inFile      The file to gzip
   * @param outFile     A target file to copy the uncompressed contents of inFile to
   * @param shouldRetry Predicate on a potential throwable to determine if the copy should be attempted again.
   *
   * @return The result of the file copy
   *
   * @throws IOException
   */
  public static FileUtils.FileCopyResult gzip(final File inFile, final File outFile, Predicate<Throwable> shouldRetry)
      throws IOException
  {
    gzip(Files.asByteSource(inFile), Files.asByteSink(outFile), shouldRetry);
    return new FileUtils.FileCopyResult(outFile);
  }

  public static long gzip(final ByteSource in, final ByteSink out, Predicate<Throwable> shouldRetry)
      throws IOException
  {
    return StreamUtils.retryCopy(
        in,
        new ByteSink()
        {
          @Override
          public OutputStream openStream() throws IOException
          {
            return new GZIPOutputStream(out.openStream());
          }
        },
        shouldRetry,
        DEFAULT_RETRY_COUNT
    );
  }


  /**
   * GZip compress the contents of inFile into outFile
   *
   * @param inFile  The source of data
   * @param outFile The destination for compressed data
   *
   * @return A FileCopyResult of the resulting file at outFile
   *
   * @throws IOException
   */
  public static FileUtils.FileCopyResult gzip(final File inFile, final File outFile) throws IOException
  {
    return gzip(inFile, outFile, FileUtils.IS_EXCEPTION);
  }

  /**
   * Checks to see if fName is a valid name for a "*.zip" file
   *
   * @param fName The name of the file in question
   *
   * @return True if fName is properly named for a .zip file, false otherwise
   */
  public static boolean isZip(String fName)
  {
    if (Strings.isNullOrEmpty(fName)) {
      return false;
    }
    return fName.endsWith(ZIP_SUFFIX); // Technically a file named `.zip` would be fine
  }

  /**
   * Checks to see if fName is a valid name for a "*.gz" file
   *
   * @param fName The name of the file in question
   *
   * @return True if fName is a properly named .gz file, false otherwise
   */
  public static boolean isGz(String fName)
  {
    if (Strings.isNullOrEmpty(fName)) {
      return false;
    }
    return fName.endsWith(GZ_SUFFIX) && fName.length() > GZ_SUFFIX.length();
  }

  /**
   * Get the file name without the .gz extension
   *
   * @param fname The name of the gzip file
   *
   * @return fname without the ".gz" extension
   *
   * @throws com.metamx.common.IAE if fname is not a valid "*.gz" file name
   */
  public static String getGzBaseName(String fname)
  {
    final String reducedFname = Files.getNameWithoutExtension(fname);
    if (isGz(fname) && !reducedFname.isEmpty()) {
      return reducedFname;
    }
    throw new IAE("[%s] is not a valid gz file name", fname);
  }
}

/*
 * Copyright 2011 - 2015 Metamarkets Group Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.metamx.common.parsers;

import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.metamx.common.IAE;
import com.metamx.common.logger.Logger;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

public class TimestampParser
{

  public static Function<String, DateTime> createTimestampParser(
      final String format
  )
  {
    if (format.equalsIgnoreCase("auto")) {
      // Could be iso or millis
      return new Function<String, DateTime>()
      {
        @Override
        public DateTime apply(String input)
        {
          Preconditions.checkArgument(input != null && !input.isEmpty(), "null timestamp");

          for (int i = 0; i < input.length(); i++) {
            if (input.charAt(i) < '0' || input.charAt(i) > '9') {
              return new DateTime(ParserUtils.stripQuotes(input));
            }
          }

          return new DateTime(Long.parseLong(input));
        }
      };
    } else if (format.equalsIgnoreCase("iso")) {
      return new Function<String, DateTime>()
      {
        @Override
        public DateTime apply(String input)
        {
          Preconditions.checkArgument(input != null && !input.isEmpty(), "null timestamp");
          return new DateTime(ParserUtils.stripQuotes(input));
        }
      };
    } else if (format.equalsIgnoreCase("posix")
               || format.equalsIgnoreCase("millis")
               || format.equalsIgnoreCase("nano")) {
      final Function<Number, DateTime> numericFun = createNumericTimestampParser(format);
      return new Function<String, DateTime>()
      {
        @Override
        public DateTime apply(String input)
        {
          Preconditions.checkArgument(input != null && !input.isEmpty(), "null timestamp");
          return numericFun.apply(Long.parseLong(ParserUtils.stripQuotes(input)));
        }
      };
    } else if (format.equalsIgnoreCase("ruby")) {
      // Numeric parser ignores millis for ruby.
      final Function<Number, DateTime> numericFun = createNumericTimestampParser(format);
      return new Function<String, DateTime>()
      {
        @Override
        public DateTime apply(String input)
        {
          Preconditions.checkArgument(input != null && !input.isEmpty(), "null timestamp");
          return numericFun.apply(Double.parseDouble(ParserUtils.stripQuotes(input)));
        }
      };
    } else {
      try {
        final DateTimeFormatter formatter = DateTimeFormat.forPattern(format);
        return new Function<String, DateTime>()
        {
          @Override
          public DateTime apply(String input)
          {
            Preconditions.checkArgument(input != null && !input.isEmpty(), "null timestamp");
            return formatter.parseDateTime(ParserUtils.stripQuotes(input));
          }
        };
      }
      catch (Exception e) {
        throw new IAE(e, "Unable to parse timestamps with format [%s]", format);
      }
    }
  }

  public static Function<Number, DateTime> createNumericTimestampParser(
      final String format
  )
  {
    // Ignore millis for ruby
    if (format.equalsIgnoreCase("posix") || format.equalsIgnoreCase("ruby")) {
      return new Function<Number, DateTime>()
      {
        @Override
        public DateTime apply(Number input)
        {
          return new DateTime(input.longValue() * 1000);
        }
      };
    } else if (format.equalsIgnoreCase("nano")) {
      return new Function<Number, DateTime>()
      {
        @Override
        public DateTime apply(Number input)
        {
          return new DateTime(input.longValue() / 1000000L);
        }
      };
    } else {
      return new Function<Number, DateTime>()
      {
        @Override
        public DateTime apply(Number input)
        {
          return new DateTime(input.longValue());
        }
      };
    }
  }

  public static Function<Object, DateTime> createObjectTimestampParser(
      final String format
  )
  {
    final Function<String, DateTime> stringFun = createTimestampParser(format);
    final Function<Number, DateTime> numericFun = createNumericTimestampParser(format);

    return new Function<Object, DateTime>()
    {
      @Override
      public DateTime apply(Object o)
      {
        Preconditions.checkArgument(o != null, "null timestamp");

        if (o instanceof Number) {
          return numericFun.apply((Number) o);
        } else {
          return stringFun.apply(o.toString());
        }
      }
    };
  }
}

public class Parsers
{
  public static final String DEFAULT_LIST_DELIMITER = "\u0001";

  public static <K, V> Function<String, Map<K, V>> toFunction(final Parser p)
  {
    /**
     * Creates a Function object wrapping the given parser.
     * Parser inputs that throw an FormattedException are mapped to null.
     */
    return new Function<String, Map<K, V>>()
    {
      @Override
      public Map<K, V> apply(String input)
      {
        try {
          return p.parse(input);
        }
        catch (Exception e) {
          return null;
        }
      }
    };
  }
}
--------------------------------------------------------------------------------------------------------
/*
 * Copyright 2011,2012 Metamarkets Group Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.metamx.common.logger;

import com.metamx.common.StringUtils;
import org.slf4j.LoggerFactory;

/**
 */
public class Logger
{
  private final org.slf4j.Logger log;

  public Logger(String name)
  {
    log = LoggerFactory.getLogger(name);
  }

  public Logger(Class clazz)
  {
    log = LoggerFactory.getLogger(clazz);
  }

  public void trace(String message, Object... formatArgs)
  {
    if (log.isTraceEnabled()) {
      log.trace(StringUtils.safeFormat(message, formatArgs));
    }
  }

  public void trace(Throwable t, String message, Object... formatArgs)
  {
    if (log.isTraceEnabled()) {
      log.trace(StringUtils.safeFormat(message, formatArgs), t);
    }
  }

  public void debug(String message, Object... formatArgs)
  {
    if (log.isDebugEnabled()) {
      log.debug(StringUtils.safeFormat(message, formatArgs));
    }
  }

  public void debug(Throwable t, String message, Object... formatArgs)
  {
    if (log.isDebugEnabled()) {
      log.debug(StringUtils.safeFormat(message, formatArgs), t);
    }
  }

  public void info(String message, Object... formatArgs)
  {
    if (log.isInfoEnabled()) {
      log.info(StringUtils.safeFormat(message, formatArgs));
    }
  }

  public void info(Throwable t, String message, Object... formatArgs)
  {
    if (log.isInfoEnabled()) {
      log.info(StringUtils.safeFormat(message, formatArgs), t);
    }
  }

  /**
   * Protect against assuming slf4j convention. use `warn(Throwable t, String message, Object... formatArgs)` instead
   *
   * @param message The string message
   * @param t       The Throwable to log
   */
  @Deprecated
  public void warn(String message, Throwable t)
  {
    log.warn(message, t);
  }

  public void warn(String message, Object... formatArgs)
  {
    log.warn(StringUtils.safeFormat(message, formatArgs));
  }

  public void warn(Throwable t, String message, Object... formatArgs)
  {
    log.warn(StringUtils.safeFormat(message, formatArgs), t);
  }

  public void error(String message, Object... formatArgs)
  {
    log.error(StringUtils.safeFormat(message, formatArgs));
  }

  /**
   * Protect against assuming slf4j convention. use `error(Throwable t, String message, Object... formatArgs)` instead
   *
   * @param message The string message
   * @param t       The Throwable to log
   */
  @Deprecated
  public void error(String message, Throwable t)
  {
    log.error(message, t);
  }

  public void error(Throwable t, String message, Object... formatArgs)
  {
    log.error(StringUtils.safeFormat(message, formatArgs), t);
  }

  public void wtf(String message, Object... formatArgs)
  {
    log.error(StringUtils.safeFormat("WTF?!: " + message, formatArgs), new Exception());
  }

  public void wtf(Throwable t, String message, Object... formatArgs)
  {
    log.error(StringUtils.safeFormat("WTF?!: " + message, formatArgs), t);
  }

  public boolean isTraceEnabled()
  {
    return log.isTraceEnabled();
  }

  public boolean isDebugEnabled()
  {
    return log.isDebugEnabled();
  }

  public boolean isInfoEnabled()
  {
    return log.isInfoEnabled();
  }
}


Runtime.getRuntime().addShutdownHook(
          new Thread(
              new Runnable()
              {
                @Override
                public void run()
                {
                  log.info("Running shutdown hook");
                  stop();
                }
              }
          )
      );
	  
	  
import com.google.common.base.Charsets;
import com.google.common.base.Throwables;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.io.Closeables;
import com.google.common.io.Files;
import com.metamx.common.ByteBufferUtils;
import com.metamx.common.ISE;

import java.io.BufferedReader;
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Class that works in conjunction with FileSmoosher.  This class knows how to map in a set of files smooshed
 * by the FileSmoosher.
 */
public class SmooshedFileMapper implements Closeable
{
  public static SmooshedFileMapper load(File baseDir) throws IOException
  {
    File metaFile = FileSmoosher.metaFile(baseDir);

    BufferedReader in = null;
    try {
      in = new BufferedReader(new InputStreamReader(new FileInputStream(metaFile), Charsets.UTF_8));

      String line = in.readLine();
      if (line == null) {
        throw new ISE("First line should be version,maxChunkSize,numChunks, got null.");
      }

      String[] splits = line.split(",");
      if (!"v1".equals(splits[0])) {
        throw new ISE("Unknown version[%s], v1 is all I know.", splits[0]);
      }
      if (splits.length != 3) {
        throw new ISE("Wrong number of splits[%d] in line[%s]", splits.length, line);
      }
      final Integer numFiles = Integer.valueOf(splits[2]);
      List<File> outFiles = Lists.newArrayListWithExpectedSize(numFiles);

      for (int i = 0; i < numFiles; ++i) {
        outFiles.add(FileSmoosher.makeChunkFile(baseDir, i));
      }

      Map<String, Metadata> internalFiles = Maps.newTreeMap();
      while ((line = in.readLine()) != null) {
        splits = line.split(",");

        if (splits.length != 4) {
          throw new ISE("Wrong number of splits[%d] in line[%s]", splits.length, line);
        }
        internalFiles.put(
            splits[0],
            new Metadata(Integer.parseInt(splits[1]), Integer.parseInt(splits[2]), Integer.parseInt(splits[3]))
        );
      }

      return new SmooshedFileMapper(outFiles, internalFiles);
    }
    finally {
      Closeables.close(in, false);
    }
  }

  private final List<File> outFiles;
  private final Map<String, Metadata> internalFiles;
  private final List<MappedByteBuffer> buffersList = Lists.newArrayList();

  private SmooshedFileMapper(
      List<File> outFiles,
      Map<String, Metadata> internalFiles
  )
  {
    this.outFiles = outFiles;
    this.internalFiles = internalFiles;
  }

  public Set<String> getInternalFilenames()
  {
    return internalFiles.keySet();
  }

  public ByteBuffer mapFile(String name) throws IOException
  {
    final Metadata metadata = internalFiles.get(name);
    if (metadata == null) {
      return null;
    }

    final int fileNum = metadata.getFileNum();
    while (buffersList.size() <= fileNum) {
      buffersList.add(null);
    }

    MappedByteBuffer mappedBuffer = buffersList.get(fileNum);
    if (mappedBuffer == null) {
      mappedBuffer = Files.map(outFiles.get(fileNum));
      buffersList.set(fileNum, mappedBuffer);
    }

    ByteBuffer retVal = mappedBuffer.duplicate();
    retVal.position(metadata.getStartOffset()).limit(metadata.getEndOffset());
    return retVal.slice();
  }

  @Override
  public void close()
  {
    Throwable thrown = null;
    for (MappedByteBuffer mappedByteBuffer : buffersList) {
      try {
        ByteBufferUtils.unmap(mappedByteBuffer);
      } catch (Throwable t) {
        if (thrown == null) {
          thrown = t;
        } else {
          thrown.addSuppressed(t);
        }
      }
    }
    Throwables.propagateIfPossible(thrown);
  }
}
--------------------------------------------------------------------------------------------------------
import org.joda.time.Duration;
import org.joda.time.Period;
import org.skife.config.Coercer;
import org.skife.config.Coercible;

/**
*/
public class DurationCoercible implements Coercible<Duration>
{
  @Override
  public Coercer<Duration> accept(Class<?> clazz)
  {
    if (Duration.class != clazz) {
      return null;
    }

    return new Coercer<Duration>()
    {
      @Override
      public Duration coerce(String value)
      {
        return new Period(value).toStandardDuration();
      }
    };
  }
}
--------------------------------------------------------------------------------------------------------
package com.metamx.common.concurrent;

import com.google.common.base.Function;

import java.util.concurrent.ThreadFactory;

/**
 */
public class FunctionalThreadFactory implements ThreadFactory
{
  private final ThreadFactory delegate;

  public FunctionalThreadFactory(final String name)
  {
    this(
        new ThreadFactory()
        {
          @Override
          public Thread newThread(Runnable runnable)
          {
            return new Thread(runnable, name);
          }
        }
    );
  }

  public FunctionalThreadFactory(ThreadFactory delegate)
  {
    this.delegate = delegate;
  }

  @Override
  public Thread newThread(Runnable runnable)
  {
    return delegate.newThread(runnable);
  }

  public FunctionalThreadFactory transform(Function<ThreadFactory, ThreadFactory> fn)
  {
    return new FunctionalThreadFactory(fn.apply(delegate));
  }

  public FunctionalThreadFactory transformThread(final Function<Thread, Thread> fn)
  {
    return new FunctionalThreadFactory(new ThreadFactory()
    {
      @Override
      public Thread newThread(Runnable runnable)
      {
        return fn.apply(delegate.newThread(runnable));
      }
    });
  }

  public FunctionalThreadFactory daemonize()
  {
    return transformThread(
        new Function<Thread, Thread>()
        {
          @Override
          public Thread apply(Thread input)
          {
            input.setDaemon(true);
            return input;
          }
        }
    );
  }
}
--------------------------------------------------------------------------------------------------------
  public static enum Severity
  {
    ANOMALY
    {
      @Override
      public String toString()
      {
        return "anomaly";
      }
    },

    COMPONENT_FAILURE
    {
      @Override
      public String toString()
      {
        return "component-failure";
      }
    },

    SERVICE_FAILURE
    {
      @Override
      public String toString()
      {
        return "service-failure";
      }
    };

    public static final Severity DEFAULT = COMPONENT_FAILURE;
  }
--------------------------------------------------------------------------------------------------------
import com.google.common.base.Preconditions;
import com.google.common.base.Throwables;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.ImmutableSet;
import com.metamx.common.logger.Logger;

import java.io.Closeable;
import java.util.ArrayDeque;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 */
public class ResourcePool<K, V> implements Closeable
{
  private static final Logger log = new Logger(ResourcePool.class);
  private final LoadingCache<K, ImmediateCreationResourceHolder<K, V>> pool;
  private final AtomicBoolean closed = new AtomicBoolean(false);

  public ResourcePool(
      final ResourceFactory<K, V> factory,
      final ResourcePoolConfig config
  )
  {
    this.pool = CacheBuilder.newBuilder().build(
        new CacheLoader<K, ImmediateCreationResourceHolder<K, V>>()
        {
          @Override
          public ImmediateCreationResourceHolder<K, V> load(K input) throws Exception
          {
            return new ImmediateCreationResourceHolder<K, V>(
                config.getMaxPerKey(),
                config.getUnusedConnectionTimeoutMillis(),
                input,
                factory
            );
          }
        }
    );
  }

  public ResourceContainer<V> take(final K key)
  {
    if (closed.get()) {
      log.error(String.format("take(%s) called even though I'm closed.", key));
      return null;
    }

    final ImmediateCreationResourceHolder<K, V> holder;
    try {
      holder = pool.get(key);
    }
    catch (ExecutionException e) {
      throw Throwables.propagate(e);
    }
    final V value = holder.get();

    return new ResourceContainer<V>()
    {
      private final AtomicBoolean returned = new AtomicBoolean(false);

      @Override
      public V get()
      {
        Preconditions.checkState(!returned.get(), "Resource for key[%s] has been returned, cannot get().", key);
        return value;
      }

      @Override
      public void returnResource()
      {
        if (returned.getAndSet(true)) {
          log.warn(String.format("Resource at key[%s] was returned multiple times?", key));
        } else {
          holder.giveBack(value);
        }
      }

      @Override
      protected void finalize() throws Throwable
      {
        if (!returned.get()) {
          log.warn(
              String.format(
                  "Resource[%s] at key[%s] was not returned before Container was finalized, potential resource leak.",
                  value,
                  key
              )
          );
          returnResource();
        }
        super.finalize();
      }
    };
  }

  public void close()
  {
    closed.set(true);
    final Map<K, ImmediateCreationResourceHolder<K, V>> mapView = pool.asMap();
    for (K k : ImmutableSet.copyOf(mapView.keySet())) {
      mapView.remove(k).close();
    }
  }

  private static class ImmediateCreationResourceHolder<K, V>
  {
    private final int maxSize;
    private final K key;
    private final ResourceFactory<K, V> factory;
    private final ArrayDeque<ResourceHolder<V>> resourceHolderList;
    private int deficit = 0;
    private boolean closed = false;
    private final long unusedResourceTimeoutMillis;

    private ImmediateCreationResourceHolder(
        int maxSize,
        long unusedResourceTimeoutMillis,
        K key,
        ResourceFactory<K, V> factory
    )
    {
      this.maxSize = maxSize;
      this.key = key;
      this.factory = factory;
      this.unusedResourceTimeoutMillis = unusedResourceTimeoutMillis;
      this.resourceHolderList = new ArrayDeque<>();

      for (int i = 0; i < maxSize; ++i) {
        resourceHolderList.add(new ResourceHolder<>(
            System.currentTimeMillis(),
            Preconditions.checkNotNull(
                factory.generate(key),
                "factory.generate(key)"
            )
        ));
      }
    }

    V get()
    {
      // resourceHolderList can't have nulls, so we'll use a null to signal that we need to create a new resource.
      final V poolVal;
      synchronized (this) {
        while (!closed && resourceHolderList.size() == 0 && deficit == 0) {
          try {
            this.wait();
          }
          catch (InterruptedException e) {
            Thread.interrupted();
            return null;
          }
        }

        if (closed) {
          log.info(String.format("get() called even though I'm closed. key[%s]", key));
          return null;
        } else if (!resourceHolderList.isEmpty()) {
          ResourceHolder<V> holder = resourceHolderList.removeFirst();
          if (System.currentTimeMillis() - holder.getLastAccessedTime() > unusedResourceTimeoutMillis) {
            factory.close(holder.getResource());
            poolVal = factory.generate(key);
          } else {
            poolVal = holder.getResource();
          }
        } else if (deficit > 0) {
          deficit--;
          poolVal = null;
        } else {
          throw new IllegalStateException("WTF?! No objects left, and no object deficit. This is probably a bug.");
        }
      }

      // At this point, we must either return a valid resource or increment "deficit".
      final V retVal;
      try {
        if (poolVal != null && factory.isGood(poolVal)) {
          retVal = poolVal;
        } else {
          if (poolVal != null) {
            factory.close(poolVal);
          }
          retVal = factory.generate(key);
        }
      }
      catch (Throwable e) {
        synchronized (this) {
          deficit++;
          this.notifyAll();
        }
        throw Throwables.propagate(e);
      }

      return retVal;
    }

    void giveBack(V object)
    {
      Preconditions.checkNotNull(object, "object");

      synchronized (this) {
        if (closed) {
          log.info(String.format("giveBack called after being closed. key[%s]", key));
          factory.close(object);
          return;
        }

        if (resourceHolderList.size() >= maxSize) {
          if (holderListContains(object)) {
            log.warn(
                String.format(
                    "Returning object[%s] at key[%s] that has already been returned!? Skipping",
                    object,
                    key
                ),
                new Exception("Exception for stacktrace")
            );
          } else {
            log.warn(
                String.format(
                    "Returning object[%s] at key[%s] even though we already have all that we can hold[%s]!? Skipping",
                    object,
                    key,
                    resourceHolderList
                ),
                new Exception("Exception for stacktrace")
            );
          }
          return;
        }

        resourceHolderList.addLast(new ResourceHolder<>(System.currentTimeMillis(), object));
        this.notifyAll();
      }
    }

    private boolean holderListContains(V object)
    {
      return resourceHolderList.stream().anyMatch(a -> a.getResource().equals(object));
    }

    void close()
    {
      synchronized (this) {
        closed = true;
        resourceHolderList.forEach(v -> factory.close(v.getResource()));
        resourceHolderList.clear();
        this.notifyAll();
      }
    }
  }

  private static class ResourceHolder<V>
  {
    private long lastAccessedTime;
    private V resource;

    public ResourceHolder(long lastAccessedTime, V resource)
    {
      this.resource = resource;
      this.lastAccessedTime = lastAccessedTime;
    }

    public long getLastAccessedTime()
    {
      return lastAccessedTime;
    }

    public V getResource()
    {
      return resource;
    }

  }
}
--------------------------------------------------------------------------------------------------------
/**
 */
public class ClientResponse<T>
{
  private final boolean finished;
  private final T obj;

  public static <T> ClientResponse<T> finished(T obj)
  {
    return new ClientResponse<T>(true, obj);
  }

  public static <T> ClientResponse<T> unfinished(T obj)
  {
    return new ClientResponse<T>(false, obj);
  }

  protected ClientResponse(
    boolean finished,
    T obj
  )
  {
    this.finished = finished;
    this.obj = obj;
  }

  public boolean isFinished()
  {
    return finished;
  }

  public T getObj()
  {
    return obj;
  }
}
--------------------------------------------------------------------------------------------------------
import java.nio.ByteBuffer;
import java.util.UUID;

public class ByteUtils {
    final static char[] hexArray = "0123456789ABCDEF".toCharArray();

    /**
     * Transform a byte array into a hex string.
     *
     * @param bytes The byte array.
     * @return The bytes in hex format.
     */
    public static String hexFromBytes(byte[] bytes) {
        if (bytes == null) return "(null)";
        if (bytes.length == 0) return "[]";

        char[] hexChars = new char[bytes.length * 2];
        for (int j = 0; j < bytes.length; j++) {
            int v = bytes[j] & 0xFF;
            hexChars[j * 2] = hexArray[v >>> 4];
            hexChars[j * 2 + 1] = hexArray[v & 0x0F];
        }

        return new String(hexChars);
    }

    /**
     * Transform a hex string into a byte array.
     *
     * @param s The hex string.
     * @return The hex string translated to bytes.
     */
    public static byte[] bytesFromHex(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];

        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character
                    .digit(s.charAt(i + 1), 16));
        }

        return data;
    }

    /**
     * Transform a hex string into a byte array. Also checks if the input is in hex characters.
     *
     * @param s The hex string.
     * @return The hex string translated to bytes.
     */
    public static byte[] bytesFromHexCheckInput(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];

        boolean[] hexArrayContains = new boolean[2];
        for (int i = 0; i < len; i += 2) {
            Character hexFirstCharacter = Character.toUpperCase(s.charAt(i));
            Character hexSecondCharacter = Character.toUpperCase(s.charAt(i + 1));
            for (int j = 0; j < hexArray.length; j++) {

                if (hexArrayContains[0] == false && hexFirstCharacter == hexArray[j]) {
                    hexArrayContains[0] = true;
                }

                if (hexArrayContains[1] == false && hexSecondCharacter == hexArray[j]) {
                    hexArrayContains[1] = true;
                }
            }

            if (hexArrayContains[0] == false || hexArrayContains[1] == false) {
                throw new IllegalArgumentException("Not a hex string.");
            } else {
                hexArrayContains[0] = false;
                hexArrayContains[1] = false;
            }

            data[i / 2] = (byte) ((Character.digit(hexFirstCharacter, 16) << 4) + Character
                    .digit(hexSecondCharacter, 16));
        }

        return data;
    }

    /**
     * Tries to parse input to a byte array. First tries to parse the input as hex, then as base64.
     * Base64 string is detected quite fast but in case of hex it verifies all of the string's
     * characters. {@link #bytesFromHex(String)} is faster for strings that are known to be hex.
     *
     * @param input The input, in hex or base64.
     * @return The byte[] if parsing was successful.
     */
    public static byte[] bytesFromHexOrBase64(String input) {
        byte[] result;
        try {
            result = ByteUtils.bytesFromHexCheckInput(input);
            return result;
        } catch (Exception e) {
            try {
                result = Base64.decode(input);
                return result;
            } catch (Exception e2) {
                throw new IllegalArgumentException("Cannot parse the input string to a byte array" +
                        ": " + e2.getMessage());
            }
        }
    }

    /**
     * Concatenates two byte arrays.
     *
     * @param a A byte array that will get concatenated.
     * @param b A byte array that will get concatenated.
     * @return The concatenated byte array.
     */
    public static byte[] concatBytes(byte[] a, byte[] b) {
        int aLen = a.length;
        int bLen = b.length;
        byte[] c = new byte[aLen + bLen];
        System.arraycopy(a, 0, c, 0, aLen);
        System.arraycopy(b, 0, c, aLen, bLen);
        return c;
    }

    /**
     * Concatenates a byte array and a byte.
     *
     * @param a A byte array that will get concatenated.
     * @param b A byte array that will get concatenated.
     * @return The concatenated byte array.
     */
    public static byte[] concatBytes(byte[] a, byte b) {
        int aLen = a.length;

        byte[] c = new byte[aLen + 1];
        System.arraycopy(a, 0, c, 0, aLen);
        c[c.length - 1] = b;

        return c;
    }

    /**
     * Set the bytes in an array.
     *
     * @param inArray The array the bytes are set in.
     * @param toBytes The bytes that are set.
     * @param offset  The offset of the set bytes.
     */
    public static void setBytes(byte[] inArray, byte[] toBytes, int offset) {
        for (int i = offset; i < offset + toBytes.length; i++) {
            if (i > inArray.length - 1) return;
            inArray[offset + (i - offset)] = toBytes[i - offset];
        }
    }

    /**
     * Test whether a bit is set in a byte.
     *
     * @param fromByte The byte.
     * @param bitIndex The bit location.
     * @return True if the bit is 1.
     */
    public static boolean getBit(byte fromByte, int bitIndex) {
        return ((fromByte >> bitIndex) & 1) == 1;
    }

    /**
     * Does this byte array begin with match array content?
     *
     * @param source Byte array to examine
     * @param match  Byte array to locate in <code>source</code>
     * @return true If the starting bytes are equal
     */
    public static boolean startsWith(byte[] source, byte[] match) {
        return startsWith(source, 0, match);
    }

    /**
     * Does this byte array begin with match array content?
     *
     * @param source Byte array to examine
     * @param offset An offset into the <code>source</code> array
     * @param match  Byte array to locate in <code>source</code>
     * @return true If the starting bytes are equal
     */
    public static boolean startsWith(byte[] source, int offset, byte[] match) {

        if (match.length > (source.length - offset)) {
            return false;
        }

        for (int i = 0; i < match.length; i++) {
            if (source[offset + i] != match[i]) {
                return false;
            }
        }
        return true;
    }

    /**
     * Convert a byte array into UUID.
     *
     * @param bytes The byte array.
     * @return The UUID.
     */
    public static UUID UUIDFromByteArray(byte[] bytes) {
        ByteBuffer bb = ByteBuffer.wrap(bytes);
        long high = bb.getLong();
        long low = bb.getLong();
        UUID uuid = new UUID(high, low);
        return uuid;
    }

    /**
     * Convert a mac string into byte array
     *
     * @param mac The mac address in String format eg FF:FF:FF:FF:FF:FF
     * @return The
     */
    public static byte[] bytesFromMacString(String mac) {
        String[] macAddressParts = mac.split(":");

        // convert hex string to byte values
        byte[] macAddressBytes = new byte[6];
        for (int i = 0; i < 6; i++) {
            Integer hex = Integer.parseInt(macAddressParts[i], 16);
            macAddressBytes[i] = hex.byteValue();
        }

        return macAddressBytes;
    }

    /**
     * Trim the bytes to given length eg remove the elements that are over length.
     *
     * @param bytes  The bytes that will get trimmed.
     * @param length The length of the trimmed byte array.
     * @return The trimmed byte array.
     */
    public static byte[] trimmedBytes(byte[] bytes, int length) {
        if (bytes.length == length) return bytes;

        byte[] trimmedBytes = new byte[length];

        for (int i = 0; i < length; i++) {
            trimmedBytes[i] = bytes[i];
        }

        return trimmedBytes;
    }

    /**
     * Reverse the byte array.
     *
     * @param array The array to be reversed.
     */
    public static void reverse(byte[] array) {
        if (array == null) {
            return;
        }
        int i = 0;
        int j = array.length - 1;
        byte tmp;
        while (j > i) {
            tmp = array[j];
            array[j] = array[i];
            array[i] = tmp;
            j--;
            i++;
        }
    }
}
--------------------------------------------------------------------------------------------------------
public enum NotificationType {

	BACKUP("backup.email.subject", "backup.email.text", "backup.email.attachment"),
	REMIND("remind.email.subject", "remind.email.text", null);

	private String subject;
	private String text;
	private String attachment;

	NotificationType(String subject, String text, String attachment) {
		this.subject = subject;
		this.text = text;
		this.attachment = attachment;
	}

	public String getSubject() {
		return subject;
	}

	public String getText() {
		return text;
	}

	public String getAttachment() {
		return attachment;
	}
}

import com.piggymetrics.notification.domain.Recipient;
import org.springframework.data.mongodb.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface RecipientRepository extends CrudRepository<Recipient, String> {

	Recipient findByAccountName(String name);

	@Query("{ $and: [ {scheduledNotifications.BACKUP.active: true }, { $where: 'this.scheduledNotifications.BACKUP.lastNotified < " +
			"new Date(new Date().setDate(new Date().getDate() - this.scheduledNotifications.BACKUP.frequency ))' }] }")
	List<Recipient> findReadyForBackup();

	@Query("{ $and: [ {scheduledNotifications.REMIND.active: true }, { $where: 'this.scheduledNotifications.REMIND.lastNotified < " +
			"new Date(new Date().setDate(new Date().getDate() - this.scheduledNotifications.REMIND.frequency ))' }] }")
	List<Recipient> findReadyForRemind();

}

import java.util.stream.Stream;

public enum Frequency {

	WEEKLY(7), MONTHLY(30), QUARTERLY(90);

	private int days;

	Frequency(int days) {
		this.days = days;
	}

	public int getDays() {
		return days;
	}

	public static Frequency withDays(int days) {
		return Stream.of(Frequency.values())
				.filter(f -> f.getDays() == days)
				.findFirst()
				.orElseThrow(IllegalArgumentException::new);
	}
}
--------------------------------------------------------------------------------------------------------
@PreAuthorize("#oauth2.hasScope('server') or #name.equals('demo')")
--------------------------------------------------------------------------------------------------------
#!/bin/bash
if test -z "$MONGODB_PASSWORD"; then
    echo "MONGODB_PASSWORD not defined"
    exit 1
fi

auth="-u user -p $MONGODB_PASSWORD"

# MONGODB USER CREATION
(
echo "setup mongodb auth"
create_user="if (!db.getUser('user')) { db.createUser({ user: 'user', pwd: '$MONGODB_PASSWORD', roles: [ {role:'readWrite', db:'piggymetrics'} ]}) }"
until mongo piggymetrics --eval "$create_user" || mongo piggymetrics $auth --eval "$create_user"; do sleep 5; done
killall mongod
sleep 1
killall -9 mongod
) &

# INIT DUMP EXECUTION
(
if test -n "$INIT_DUMP"; then
    echo "execute dump file"
	until mongo piggymetrics $auth $INIT_DUMP; do sleep 5; done
fi
) &

echo "start mongodb without auth"
chown -R mongodb /data/db
gosu mongodb mongod "$@"

echo "restarting with auth on"
sleep 5
exec gosu mongodb mongod --auth "$@"
--------------------------------------------------------------------------------------------------------
/**
 * Creates pre-filled demo account
 */

print('dump start');

db.accounts.update(
    { "_id": "demo" },
    {
    "_id": "demo",
    "lastSeen": new Date(),
    "note": "demo note",
    "expenses": [
        {
            "amount": 1300,
            "currency": "USD",
            "icon": "home",
            "period": "MONTH",
            "title": "Rent"
        },
        {
            "amount": 120,
            "currency": "USD",
            "icon": "utilities",
            "period": "MONTH",
            "title": "Utilities"
        },
        {
            "amount": 20,
            "currency": "USD",
            "icon": "meal",
            "period": "DAY",
            "title": "Meal"
        },
        {
            "amount": 240,
            "currency": "USD",
            "icon": "gas",
            "period": "MONTH",
            "title": "Gas"
        },
        {
            "amount": 3500,
            "currency": "EUR",
            "icon": "island",
            "period": "YEAR",
            "title": "Vacation"
        },
        {
            "amount": 30,
            "currency": "EUR",
            "icon": "phone",
            "period": "MONTH",
            "title": "Phone"
        },
        {
            "amount": 700,
            "currency": "USD",
            "icon": "sport",
            "period": "YEAR",
            "title": "Gym"
        }
    ],
    "incomes": [
        {
            "amount": 42000,
            "currency": "USD",
            "icon": "wallet",
            "period": "YEAR",
            "title": "Salary"
        },
        {
            "amount": 500,
            "currency": "USD",
            "icon": "edu",
            "period": "MONTH",
            "title": "Scholarship"
        }
    ],
    "saving": {
            "amount": 5900,
            "capitalization": false,
            "currency": "USD",
            "deposit": true,
            "interest": 3.32
        }
    },
    { upsert: true }
);

print('dump complete');
--------------------------------------------------------------------------------------------------------
import org.hswebframework.web.logging.AccessLoggerListener;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * AOP 访问日志记录自动配置
 *
 * @author zhouhao
 * @see org.hswebframework.web.logging.AccessLogger
 * @see AopAccessLoggerSupport
 */
@ConditionalOnClass(AccessLoggerListener.class)
@Configuration
public class AopAccessLoggerSupportAutoConfiguration {

    @Bean
    public AopAccessLoggerSupport aopAccessLoggerSupport() {
        return new AopAccessLoggerSupport();
    }

    @Bean
    public DefaultAccessLoggerParser defaultAccessLoggerParser(){
        return new DefaultAccessLoggerParser();
    }

    @Bean
    @ConditionalOnClass(name = "io.swagger.annotations.Api")
    public SwaggerAccessLoggerParser swaggerAccessLoggerParser(){
        return new SwaggerAccessLoggerParser();
    }
    @Bean
    public ListenerProcessor listenerProcessor() {
        return new ListenerProcessor();
    }

    public static class ListenerProcessor implements BeanPostProcessor {

        @Autowired
        private AopAccessLoggerSupport aopAccessLoggerSupport;

        @Override
        public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
            return bean;
        }

        @Override
        public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
            if (bean instanceof AccessLoggerListener) {
                aopAccessLoggerSupport.addListener(((AccessLoggerListener) bean));
            }  if (bean instanceof AccessLoggerParser) {
                aopAccessLoggerSupport.addParser(((AccessLoggerParser) bean));
            }
            return bean;
        }
    }
}
--------------------------------------------------------------------------------------------------------
  @Authorize(action = Permission.ACTION_DELETE)
--------------------------------------------------------------------------------------------------------
    static class DefaultInstanceGetter<T> implements Supplier<T> {
        Class<T> type;

        public DefaultInstanceGetter(Class<T> type) {
            this.type = type;
        }

        @Override
        public T get() {
            try {
                return type.newInstance();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }
	
	    public static class Mapper<T> {
        Class<T>    target;
        Supplier<T> instanceGetter;

        public Mapper(Class<T> target, Supplier<T> instanceGetter) {
            this.target = target;
            this.instanceGetter = instanceGetter;
        }

        public Class<T> getTarget() {
            return target;
        }

        public Supplier<T> getInstanceGetter() {
            return instanceGetter;
        }
    }
	
	    static final String[] ipHeaders = {
            "X-Forwarded-For",
            "X-Real-IP",
            "Proxy-Client-IP",
            "WL-Proxy-Client-IP"
    };
--------------------------------------------------------------------------------------------------------
import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

/**
 * ThreadLocal 工具类,通过在ThreadLocal存储map信息,来实现在ThreadLocal中维护多个信息
 * <br>e.g.<code>
 * ThreadLocalUtils.put("key",value);<br>
 * ThreadLocalUtils.get("key");<br>
 * ThreadLocalUtils.remove("key");<br>
 * ThreadLocalUtils.getAndRemove("key");<br>
 * ThreadLocalUtils.get("key",()-&gt;defaultValue);<br>
 * ThreadLocalUtils.clear();<br>
 * </code>
 *
 * @author zhouhao
 * @since 2.0
 */
@SuppressWarnings("unchecked")
public final class ThreadLocalUtils {

    private ThreadLocalUtils() {
    }

    private static final ThreadLocal<Map<String, Object>> local = ThreadLocal.withInitial(HashMap::new);

    /**
     * @return threadLocal中的全部值
     */
    public static Map<String, Object> getAll() {
        return local.get();
    }

    /**
     * 设置一个值到ThreadLocal
     *
     * @param key   键
     * @param value 值
     * @param <T>   值的类型
     * @return 被放入的值
     * @see Map#put(Object, Object)
     */
    public static <T> T put(String key, T value) {
        local.get().put(key, value);
        return value;
    }

    /**
     * 删除参数对应的值
     *
     * @param key
     * @see Map#remove(Object)
     */
    public static void remove(String key) {
        local.get().remove(key);
    }

    /**
     * 清空ThreadLocal
     *
     * @see Map#clear()
     */
    public static void clear() {
        local.remove();
    }

    /**
     * 从ThreadLocal中获取值
     *
     * @param key 键
     * @param <T> 值泛型
     * @return 值, 不存在则返回null, 如果类型与泛型不一致, 可能抛出{@link ClassCastException}
     * @see Map#get(Object)
     * @see ClassCastException
     */
    public static <T> T get(String key) {
        return ((T) local.get().get(key));
    }

    /**
     * 从ThreadLocal中获取值,并指定一个当值不存在的提供者
     *
     * @see Supplier
     * @since 3.0
     */
    public static <T> T get(String key, Supplier<T> supplierOnNull) {
        return ((T) local.get().computeIfAbsent(key, k -> supplierOnNull.get()));
    }

    /**
     * 获取一个值后然后删除掉
     *
     * @param key 键
     * @param <T> 值类型
     * @return 值, 不存在则返回null
     * @see this#get(String)
     * @see this#remove(String)
     */
    public static <T> T getAndRemove(String key) {
        try {
            return get(key);
        } finally {
            remove(key);
        }
    }
}
--------------------------------------------------------------------------------------------------------
import org.hswebframework.web.commons.entity.GenericEntity;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.cache.annotation.Caching;

import java.util.List;

/**
 * 启用缓冲的通用实体曾删改查服务,继承此类
 * 在类上注解{@link org.springframework.cache.annotation.CacheConfig}即可
 *
 * @author zhouhao
 * @see org.springframework.cache.annotation.CacheConfig
 * @see Cacheable
 * @see CacheEvict
 * @since 3.0
 */
public abstract class EnableCacheGenericEntityService<E extends GenericEntity<PK>, PK> extends GenericEntityService<E, PK> {

    @Override
    @Cacheable(key = "'id:'+#pk")
    public E selectByPk(PK pk) {
        return super.selectByPk(pk);
    }

    @Override
    @CacheEvict(allEntries = true)
    public int updateByPk(List<E> data) {
        return super.updateByPk(data);
    }

    @Override
    @Caching(
            evict = {
                    @CacheEvict(key = "'id:'+#pk"),
                    @CacheEvict(key = "'all'"),
                    @CacheEvict(key = "'count'")
            }
    )
    public int updateByPk(PK pk, E entity) {
        return super.updateByPk(pk, entity);
    }

    @Override
    @Caching(
            evict = {
                    @CacheEvict(key = "'id:'+#result"),
                    @CacheEvict(key = "'all'"),
                    @CacheEvict(key = "'count'")
            }
    )
    public PK insert(E entity) {
        return super.insert(entity);
    }

    @Override
    @Caching(
            evict = {
                    @CacheEvict(key = "'id:'+#pk"),
                    @CacheEvict(key = "'all'"),
                    @CacheEvict(key = "'count'")
            }
    )
    public int deleteByPk(PK pk) {
        return super.deleteByPk(pk);
    }

    @Override
    @Caching(
            evict = {
                    @CacheEvict(key = "'id:'+#result"),
                    @CacheEvict(key = "'all'"),
                    @CacheEvict(key = "'count'")
            }
    )
    public PK saveOrUpdate(E entity) {
        return super.saveOrUpdate(entity);
    }

    @Override
    @Cacheable(key = "'all'")
    public List<E> select() {
        return super.select();
    }

    @Override
    @Cacheable(key = "'count'")
    public int count() {
        return super.count();
    }
}
--------------------------------------------------------------------------------------------------------
    @Bean
    public CorsFilter corsFilter(CorsConfiguration corsConfiguration) {
        UrlBasedCorsConfigurationSource corsConfigurationSource = new UrlBasedCorsConfigurationSource();
        corsConfigurationSource.registerCorsConfiguration("/**", corsConfiguration);
        return new CorsFilter(corsConfigurationSource);
    }
--------------------------------------------------------------------------------------------------------
import org.springframework.boot.autoconfigure.condition.ConditionOutcome;
import org.springframework.boot.autoconfigure.condition.SpringBootCondition;
import org.springframework.boot.context.properties.bind.Bindable;
import org.springframework.boot.context.properties.bind.Binder;
import org.springframework.boot.context.properties.source.ConfigurationPropertySource;
import org.springframework.boot.context.properties.source.ConfigurationPropertySources;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.type.AnnotatedTypeMetadata;

/**
 * This condition checks if the client should be enabled. Two properties are checked:
 * spring.boot.admin.client.enabled and spring.boot.admin.url. The following table shows under which conditions the
 * client is active.
 * <pre>
 *           | enabled: false | enabled: true (default) |
 * --------- | -------------- | ----------------------- |
 * url empty | inactive       | inactive                |
 * (default) |                |                         |
 * --------- | -------------- | ----------------------- |
 * url set   | inactive       | active                  |
 * </pre>
 */
public class SpringBootAdminClientEnabledCondition extends SpringBootCondition {
    @Override
    public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata annotatedTypeMetadata) {
        ClientProperties clientProperties = getClientProperties(context);

        if (!clientProperties.isEnabled()) {
            return ConditionOutcome.noMatch(
                    "Spring Boot Client is disabled, because 'spring.boot.admin.client.enabled' is false.");
        }

        if (clientProperties.getUrl().length == 0) {
            return ConditionOutcome.noMatch("Spring Boot Client is disabled, because 'spring.boot.admin.url' is empty.");
        }

        return ConditionOutcome.match();
    }

    private ClientProperties getClientProperties(ConditionContext context) {
        Iterable<ConfigurationPropertySource> sources = ConfigurationPropertySources.get(context.getEnvironment());
        ClientProperties clientProperties = new ClientProperties();
        new Binder(sources).bind("spring.boot.admin.client", Bindable.ofInstance(clientProperties));
        return clientProperties;
    }
}
--------------------------------------------------------------------------------------------------------
    @Bean
    public SpringResourceTemplateResolver adminTemplateResolver() {
        SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver();
        resolver.setApplicationContext(this.applicationContext);
        resolver.setPrefix(uiProperties.getTemplateLocation());
        resolver.setSuffix(".html");
        resolver.setTemplateMode("HTML");
        resolver.setCharacterEncoding("UTF-8");
        resolver.setCacheable(uiProperties.isCacheTemplates());
        resolver.setOrder(10);
        resolver.setCheckExistence(true);
        return resolver;
    }
--------------------------------------------------------------------------------------------------------
import java.util.HashMap;
import java.util.Map;

import org.apache.ibatis.session.SqlSession;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;

import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.CacheManager;
import org.springframework.cache.interceptor.CacheInterceptor;
import org.springframework.context.ApplicationContext;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.interceptor.TransactionInterceptor;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Integration tests for {@link MybatisTest}.
 *
 * @author wonwoo
 * @since 1.2.1
 */
@RunWith(SpringRunner.class)
@MybatisTest
@TestPropertySource(properties = {
  "mybatis.type-aliases-package=org.mybatis.spring.boot.test.autoconfigure",
  "logging.level.org.springframework.jdbc=debug",
  "spring.datasource.schema=classpath:org/mybatis/spring/boot/test/autoconfigure/schema.sql"
})
public class MybatisTestIntegrationTest {

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Autowired
  private SampleMapper sampleMapper;

  @Autowired
  private SqlSession sqlSession;

  @Autowired
  private ApplicationContext applicationContext;

  @Test
  public void testSqlSession() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put("id", 1);
    parameters.put("name", "wonwoo");
    sqlSession.insert("saveSample", parameters);
    Sample findSample = sqlSession.selectOne("findSample", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo("wonwoo");
  }

  @Test
  public void testMapper() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put("id", 1);
    parameters.put("name", "wonwoo");
    sqlSession.insert("saveSample", parameters);
    Sample sample = sampleMapper.findByName("wonwoo");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo("wonwoo");
  }

  @Test
  public void testAutoConfigureComponents() {
    // @AutoConfigureMybatis
    this.applicationContext.getBean(JdbcTemplate.class);
    this.applicationContext.getBean(NamedParameterJdbcTemplate.class);
    this.applicationContext.getBean(DataSourceTransactionManager.class);
    this.applicationContext.getBean(TransactionInterceptor.class);
    // @AutoConfigureCache
    this.applicationContext.getBean(CacheManager.class);
    this.applicationContext.getBean(CacheInterceptor.class);
  }

  @Test
  public void didNotInjectExampleComponent() {
    this.thrown.expect(NoSuchBeanDefinitionException.class);
    this.applicationContext.getBean(ExampleComponent.class);
  }
}
--------------------------------------------------------------------------------------------------------
	@HystrixCommand(fallbackMethod = "getFallbackCommentsForTask", commandProperties = {
			@HystrixProperty(name = "execution.isolation.strategy", value = "SEMAPHORE"),
			@HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "10"),
			@HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds", value = "1000") })
	public CommentCollectionResource getCommentsForTask(String taskId) {
		// Get the comments for this task
		return restTemplate.getForObject(String.format("http://comments-webservice/comments/%s", taskId),
				CommentCollectionResource.class);

	}
--------------------------------------------------------------------------------------------------------
import java.io.Serializable;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Clock;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.impl.DefaultClock;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mobile.device.Device;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

@Component
public class JwtTokenUtil implements Serializable {

    private static final long serialVersionUID = -3301605591108950415L;

    static final String CLAIM_KEY_USERNAME = "sub";
    static final String CLAIM_KEY_AUDIENCE = "aud";
    static final String CLAIM_KEY_CREATED = "iat";

    static final String AUDIENCE_UNKNOWN = "unknown";
    static final String AUDIENCE_WEB = "web";
    static final String AUDIENCE_MOBILE = "mobile";
    static final String AUDIENCE_TABLET = "tablet";

    @SuppressFBWarnings(value = "SE_BAD_FIELD", justification = "It's okay here")
    private Clock clock = DefaultClock.INSTANCE;

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration}")
    private Long expiration;

    public String getUsernameFromToken(String token) {
        return getClaimFromToken(token, Claims::getSubject);
    }

    public Date getIssuedAtDateFromToken(String token) {
        return getClaimFromToken(token, Claims::getIssuedAt);
    }

    public Date getExpirationDateFromToken(String token) {
        return getClaimFromToken(token, Claims::getExpiration);
    }

    public String getAudienceFromToken(String token) {
        return getClaimFromToken(token, Claims::getAudience);
    }

    public <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = getAllClaimsFromToken(token);
        return claimsResolver.apply(claims);
    }

    private Claims getAllClaimsFromToken(String token) {
        return Jwts.parser()
                .setSigningKey(secret)
                .parseClaimsJws(token)
                .getBody();
    }

    private Boolean isTokenExpired(String token) {
        final Date expiration = getExpirationDateFromToken(token);
        return expiration.before(clock.now());
    }

    private Boolean isCreatedBeforeLastPasswordReset(Date created, Date lastPasswordReset) {
        return (lastPasswordReset != null && created.before(lastPasswordReset));
    }

    private String generateAudience(Device device) {
        String audience = AUDIENCE_UNKNOWN;
        if (device.isNormal()) {
            audience = AUDIENCE_WEB;
        } else if (device.isTablet()) {
            audience = AUDIENCE_TABLET;
        } else if (device.isMobile()) {
            audience = AUDIENCE_MOBILE;
        }
        return audience;
    }

    private Boolean ignoreTokenExpiration(String token) {
        String audience = getAudienceFromToken(token);
        return (AUDIENCE_TABLET.equals(audience) || AUDIENCE_MOBILE.equals(audience));
    }

    public String generateToken(UserDetails userDetails, Device device) {
        Map<String, Object> claims = new HashMap<>();
        return doGenerateToken(claims, userDetails.getUsername(), generateAudience(device));
    }

    private String doGenerateToken(Map<String, Object> claims, String subject, String audience) {
        final Date createdDate = clock.now();
        final Date expirationDate = calculateExpirationDate(createdDate);

        System.out.println("doGenerateToken " + createdDate);

        return Jwts.builder()
                .setClaims(claims)
                .setSubject(subject)
                .setAudience(audience)
                .setIssuedAt(createdDate)
                .setExpiration(expirationDate)
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }

    public Boolean canTokenBeRefreshed(String token, Date lastPasswordReset) {
        final Date created = getIssuedAtDateFromToken(token);
        return !isCreatedBeforeLastPasswordReset(created, lastPasswordReset)
                && (!isTokenExpired(token) || ignoreTokenExpiration(token));
    }

    public String refreshToken(String token) {
        final Date createdDate = clock.now();
        final Date expirationDate = calculateExpirationDate(createdDate);

        final Claims claims = getAllClaimsFromToken(token);
        claims.setIssuedAt(createdDate);
        claims.setExpiration(expirationDate);

        return Jwts.builder()
                .setClaims(claims)
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }

    public Boolean validateToken(String token, UserDetails userDetails) {
        JwtUser user = (JwtUser) userDetails;
        final String username = getUsernameFromToken(token);
        final Date created = getIssuedAtDateFromToken(token);
        //final Date expiration = getExpirationDateFromToken(token);
        return (
              username.equals(user.getUsername())
                    && !isTokenExpired(token)
                    && !isCreatedBeforeLastPasswordReset(created, user.getLastPasswordResetDate())
        );
    }

    private Date calculateExpirationDate(Date createdDate) {
        return new Date(createdDate.getTime() + expiration * 1000);
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.zerhusen.security.JwtAuthenticationEntryPoint;
import org.zerhusen.security.JwtAuthenticationTokenFilter;

@SuppressWarnings("SpringJavaAutowiringInspection")
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private JwtAuthenticationEntryPoint unauthorizedHandler;

    @Autowired
    private UserDetailsService userDetailsService;

    @Autowired
    public void configureAuthentication(AuthenticationManagerBuilder authenticationManagerBuilder) throws Exception {
        authenticationManagerBuilder
                .userDetailsService(this.userDetailsService)
                .passwordEncoder(passwordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public JwtAuthenticationTokenFilter authenticationTokenFilterBean() throws Exception {
        return new JwtAuthenticationTokenFilter();
    }

    @Override
    protected void configure(HttpSecurity httpSecurity) throws Exception {
        httpSecurity
                // we don't need CSRF because our token is invulnerable
                .csrf().disable()

                .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and()

                // don't create session
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()

                .authorizeRequests()
                //.antMatchers(HttpMethod.OPTIONS, "/**").permitAll()

                // allow anonymous resource requests
                .antMatchers(
                        HttpMethod.GET,
                        "/",
                        "/*.html",
                        "/favicon.ico",
                        "/**/*.html",
                        "/**/*.css",
                        "/**/*.js"
                ).permitAll()

                // Un-secure H2 Database
                .antMatchers("/h2-console/**/**").permitAll()

                .antMatchers("/auth/**").permitAll()
                .anyRequest().authenticated();

        // Custom JWT based security filter
        httpSecurity
                .addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter.class);

        // disable page caching
        httpSecurity
                .headers()
                .frameOptions().sameOrigin()  // required to set for H2 else H2 Console will be blank.
                .cacheControl();
    }
}
--------------------------------------------------------------------------------------------------------
 * class WorkerRunnable implements Runnable {
 *   private final CountDownLatch doneSignal;
 *   private final int i;
 *   WorkerRunnable(CountDownLatch doneSignal, int i) {
 *     this.doneSignal = doneSignal;
 *     this.i = i;
 *   }
 *   public void run() {
 *     try {
 *       doWork(i);
 *       doneSignal.countDown();
 *     } catch (InterruptedException ex) {} // return;
 *   }
 *
 *   void doWork() { ... }
 * }}
--------------------------------------------------------------------------------------------------------
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.DefaultTokenServices;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.InMemoryTokenStore;

@Configuration
public class OAuth2ServerConfiguration {

	private static final String RESOURCE_ID = "restservice";

	@Configuration
	@EnableResourceServer
	protected static class ResourceServerConfiguration extends
			ResourceServerConfigurerAdapter {

		@Override
		public void configure(ResourceServerSecurityConfigurer resources) {
			// @formatter:off
			resources
				.resourceId(RESOURCE_ID);
			// @formatter:on
		}

		@Override
		public void configure(HttpSecurity http) throws Exception {
			// @formatter:off
			http
				.authorizeRequests()
					.antMatchers("/users").hasRole("ADMIN")
					.antMatchers("/greeting").authenticated();
			// @formatter:on
		}

	}

	@Configuration
	@EnableAuthorizationServer
	protected static class AuthorizationServerConfiguration extends
			AuthorizationServerConfigurerAdapter {

		private TokenStore tokenStore = new InMemoryTokenStore();

		@Autowired
		@Qualifier("authenticationManagerBean")
		private AuthenticationManager authenticationManager;

		@Autowired
		private CustomUserDetailsService userDetailsService;

		@Override
		public void configure(AuthorizationServerEndpointsConfigurer endpoints)
				throws Exception {
			// @formatter:off
			endpoints
				.tokenStore(this.tokenStore)
				.authenticationManager(this.authenticationManager)
				.userDetailsService(userDetailsService);
			// @formatter:on
		}

		@Override
		public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
			// @formatter:off
			clients
				.inMemory()
					.withClient("clientapp")
						.authorizedGrantTypes("password", "refresh_token")
						.authorities("USER")
						.scopes("read", "write")
						.resourceIds(RESOURCE_ID)
						.secret("123456");
			// @formatter:on
		}

		@Bean
		@Primary
		public DefaultTokenServices tokenServices() {
			DefaultTokenServices tokenServices = new DefaultTokenServices();
			tokenServices.setSupportRefreshToken(true);
			tokenServices.setTokenStore(this.tokenStore);
			return tokenServices;
		}

	}

}
--------------------------------------------------------------------------------------------------------
import com.google.common.util.concurrent.RateLimiter;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.netflix.feign.EnableFeignClients;
import org.springframework.cloud.netflix.feign.FeignClient;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.annotation.Bean;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.util.ReflectionUtils;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@EnableCircuitBreaker
@EnableFeignClients
@EnableZuulProxy
@EnableDiscoveryClient
@SpringBootApplication
public class GreetingsClientApplication {

    @Bean
    @LoadBalanced
    RestTemplate restTemplate() {
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(GreetingsClientApplication.class, args);
    }
}

@FeignClient("greetings-service")
interface GreetingsClient {

    @RequestMapping(method = RequestMethod.GET, value = "/greetings/{name}")
    Greeting greet(@PathVariable("name") String name);
}

@RestController
class GreetingsApiGatewayRestController {

    private final GreetingsClient greetingsClient;

    @Autowired
    public GreetingsApiGatewayRestController(GreetingsClient client) {
        this.greetingsClient = client;
    }

    public String fallback(String name) {
        return "ohai!";
    }

    @HystrixCommand(fallbackMethod = "fallback")
    @RequestMapping(method = RequestMethod.GET, value = "/hi/{name}")
    String greet(@PathVariable String name) {
        return this.greetingsClient.greet(name).getGreeting();
    }
}

class Greeting {
    private String greeting;

    public String getGreeting() {
        return greeting;
    }
}

//@Component
class RateLimitingZuulFilter extends ZuulFilter {

    private final RateLimiter rateLimiter = RateLimiter.create(1.0 / 30.0);

    @Override
    public String filterType() {
        return "pre";
    }

    @Override
    public int filterOrder() {
        return Ordered.HIGHEST_PRECEDENCE + 100;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() {
        try {
            RequestContext currentContext = RequestContext.getCurrentContext();
            HttpServletResponse response = currentContext.getResponse();

            if (!this.rateLimiter.tryAcquire()) {
                response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
                response.getWriter().append(HttpStatus.TOO_MANY_REQUESTS.getReasonPhrase());
                currentContext.setSendZuulResponse(false);
            }
        } catch (IOException e) {
            ReflectionUtils.rethrowRuntimeException(e);
        }
        return null;
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.BeanPropertyItemSqlParameterSourceProvider;
import org.springframework.batch.item.database.JdbcBatchItemWriter;
import org.springframework.batch.item.file.FlatFileItemReader;
import org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper;
import org.springframework.batch.item.file.mapping.DefaultLineMapper;
import org.springframework.batch.item.file.transform.DelimitedLineTokenizer;
import org.springframework.boot.autoconfigure.batch.JobExecutionEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Configuration
public class ContactBatchJobConfiguration {

	@Bean
	public ItemProcessor<Contact, Contact> processor() {
		return (person) -> new Contact(person.getFirstName(), person.getLastName(),
				person.getEmail().toLowerCase());
	}

	@Bean
	public ItemReader<Contact> reader() {
		FlatFileItemReader<Contact> reader = new FlatFileItemReader<>();
		reader.setResource(new ClassPathResource("data.csv"));
		reader.setLineMapper(new DefaultLineMapper<Contact>() {
			{
				setLineTokenizer(new DelimitedLineTokenizer() {
					{
						setNames(new String[] { "firstName", "lastName", "email" });
					}
				});
				setFieldSetMapper(new BeanWrapperFieldSetMapper<Contact>() {
					{
						setTargetType(Contact.class);
					}
				});
			}
		});
		return reader;
	}

	@Bean
	public ItemWriter<Contact> writer(DataSource dataSource) {
		JdbcBatchItemWriter<Contact> writer = new JdbcBatchItemWriter<>();
		writer.setItemSqlParameterSourceProvider(
				new BeanPropertyItemSqlParameterSourceProvider<>());
		writer.setSql("INSERT INTO contact (first_name, last_name, email) "
				+ "VALUES (:firstName, :lastName, :email)");
		writer.setDataSource(dataSource);
		return writer;
	}

	@Bean
	public Job importUserJob(JobBuilderFactory jobs, Step s1) {
		return jobs.get("importUserJob").incrementer(new RunIdIncrementer()).flow(s1)
				.end().build();
	}

	@Bean
	public Step step1(StepBuilderFactory stepBuilderFactory, ItemReader<Contact> reader,
			ItemWriter<Contact> writer, ItemProcessor<Contact, Contact> processor) {
		return stepBuilderFactory.get("step1").<Contact, Contact>chunk(10).reader(reader)
				.processor(processor).writer(writer).build();
	}

	@Bean
	public JdbcTemplate jdbcTemplate(DataSource dataSource) {
		return new JdbcTemplate(dataSource);
	}

	@Component
	public static class BatchJobFinishedListener
			implements ApplicationListener<JobExecutionEvent> {

		private final JdbcTemplate jdbcTemplate;

		public BatchJobFinishedListener(JdbcTemplate jdbcTemplate) {
			this.jdbcTemplate = jdbcTemplate;
		}

		@Override
		public void onApplicationEvent(JobExecutionEvent event) {
			System.out.println("finished " + event.getJobExecution().toString());
			this.jdbcTemplate
					.query("SELECT first_name, last_name, email FROM contact",
							(rs, i) -> new Contact(rs.getString("first_name"),
									rs.getString("last_name"), rs.getString("email")))
					.forEach(System.out::println);
		}

	}

}
--------------------------------------------------------------------------------------------------------
import javax.servlet.http.HttpServletRequest;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.StringTokenizer;

/**
 * 其他工具类
 */
public class Tools {
    /**
     * 获取Timestamp
     */
    public static Timestamp getTimestamp(){
        String nowTime = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
        return Timestamp.valueOf(nowTime);
    }
    public static List<String> getTagList(String tagStr){
        List<String> tagList=new ArrayList<>();
        StringTokenizer token = new StringTokenizer(tagStr, ",");
        while (token.hasMoreTokens()) {
            tagList.add(token.nextToken());
        }
        return tagList;
    }

    /**
     *从request中获取用户真实ip
     */
    public static String getIpAddress(HttpServletRequest request) {
        String ip = request.getHeader("x-forwarded-for");
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_CLIENT_IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_X_FORWARDED_FOR");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        return ip;
    }
}

import me.jcala.blog.domain.BlogView;
import org.apache.ibatis.annotations.*;
import org.apache.ibatis.mapping.StatementType;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * mybatis的mapper
 * 映射所有博客操作的sql语句
 */
@Repository
@Mapper
public interface BlogMapper {
      @Select({
              "select vid,title,tags",
              "from blog_view",
              "limit #{st},10"
      })
      List<BlogView> selectTenBlogs(@Param("st") int start);

      @Select("select count(*) from blog_view")
      int selectBlogNum();

      @Select("select distinct name from view_tag")
      @ResultType(String.class)
      List<String> selectTags();

      @Select({"select vid,date,title",
              "from blog_view",
              "order by date desc",
              "limit #{st},12"})
      List<BlogView> selectArc(@Param("st") int start);

      @Select({
              "select title,tags,md",
              "from blog_view",
              "where vid = #{id}",
              "limit 1"
      })
      BlogView selectAdmin(@Param("id") int id);

      @Select({
              "select title,article",
              "from blog_view",
              "where vid = #{id}",
              "limit 1"
      })
      BlogView selectView(@Param("id") int id);

      @Select({
              "select vid,title ",
              "from blog_view",
              "where vid < #{id}",
              "order by vid desc",
              "limit 1"
      })
      BlogView selectPreView(@Param("id") int vid);

      @Select({
              "select vid,title ",
              "from blog_view",
              "where vid > #{id}",
              "limit 1"
      })
      BlogView selectNextView(@Param("id") int vid);

      @Select({
              "select distinct vid",
              "from view_tag",
              "where name = #{tag}"
      })
      List<Integer> selectVidBytag(@Param("tag") String tagName);

      @Select({
              "select date,title",
              "from blog_view",
              "where vid = #{vid}",
              "limit 1"
      })
      BlogView selectTagView(@Param("vid") int vid);

      @Insert({"insert into blog_view " ,
              "(date,title,article,tags,md) " ,
              "values(#{bv.date},#{bv.title}," ,
              "#{bv.article},#{bv.tags},#{bv.md})"})
      @SelectKey(before=false,keyProperty="bv.vid",resultType=Integer.class,
              statementType= StatementType.STATEMENT,statement="SELECT LAST_INSERT_ID() AS id")
      int insertBlog(@Param("bv") BlogView blogView);

      @Insert("insert ignore into view_tag (name,vid) values(#{tn},#{id})")
      int insertViewTag(@Param("tn") String tagName, @Param("id") int vid);

      @Delete("delete from view_tag where vid = #{vid}")
      int deleteViewTag(@Param("vid") int vid);

      @Delete("delete from blog_view where vid =#{vid} limit 1")
      int deleteBlogView(@Param("vid") int vid);

      @Update({
            "update blog_view",
              "set title = #{bv.title},",
              "tags = #{bv.tags},",
              "md = #{bv.md},",
              "article = #{bv.article}",
              "where vid = #{bv.vid}"
      })
      void updateBlogView(@Param("bv") BlogView blogView);
}
--------------------------------------------------------------------------------------------------------
public enum Types {
    TAG("tag"),
    CATEGORY("category"),
    ARTICLE("post"),
    PUBLISH("publish"),
    PAGE("page"),
    DRAFT("draft"),
    LINK("link"),
    IMAGE("image"),
    FILE("file"),
    CSRF_TOKEN("csrf_token"),
    COMMENTS_FREQUENCY("comments:frequency"),

    /**
     * 附件存放的URL，默认为网站地址，如集成第三方则为第三方CDN域名
     */
    ATTACH_URL("attach_url"),

    /**
     * 网站要过滤，禁止访问的ip列表
     */
    BLOCK_IPS("site_block_ips");


    private String type;

    public java.lang.String getType() {
        return type;
    }

    public void setType(java.lang.String type) {
        this.type = type;
    }

    Types(java.lang.String type) {
        this.type = type;
    }
}
--------------------------------------------------------------------------------------------------------
    public static boolean isChinese(String chinese) {
        String regex = "^[\u4E00-\u9FA5]+$";
        return Pattern.matches(regex,chinese);
    }
--------------------------------------------------------------------------------------------------------
/**
 * Created by BlueT on 2017/3/16.
 */

import java.util.regex.Pattern;

/**
 * 正则工具类
 * 提供验证邮箱、手机号、电话号码、身份证号码、数字等方法
 *
 */
public final class PatternKit {

    /**
     * 验证Email
     * @param email email地址，格式：zhangsan@sina.com，zhangsan@xxx.com.cn，xxx代表邮件服务商
     * @return 验证成功返回true，验证失败返回false
     */
    public static boolean isEmail(String email) {
        String regex = "\\w+@\\w+\\.[a-z]+(\\.[a-z]+)?";
        return Pattern.matches(regex, email);
    }

    /**
     * 验证身份证号码
     * @param idCard 居民身份证号码15位或18位，最后一位可能是数字或字母
     * @return 验证成功返回true，验证失败返回false
     */
    public static boolean isIdCard(String idCard) {
        String regex = "[1-9]\\d{13,16}[a-zA-Z0-9]{1}";
        return Pattern.matches(regex,idCard);
    }

    public static boolean isImage(String suffix) {
        if(null != suffix && !"".equals(suffix)){
            String regex = "(.*?)(?i)(jpg|jpeg|png|gif|bmp|webp)";
            return Pattern.matches(regex, suffix);
        }
        return false;
    }

    /**
     * 验证手机号码（支持国际格式，+86135xxxx...（中国内地），+00852137xxxx...（中国香港））
     * @param mobile 移动、联通、电信运营商的号码段
     *<p>移动的号段：134(0-8)、135、136、137、138、139、147（预计用于TD上网卡）
     *、150、151、152、157（TD专用）、158、159、187（未启用）、188（TD专用）</p>
     *<p>联通的号段：130、131、132、155、156（世界风专用）、185（未启用）、186（3g）</p>
     *<p>电信的号段：133、153、180（未启用）、189</p>
     * @return 验证成功返回true，验证失败返回false
     */
    public static boolean isMobile(String mobile) {
        String regex = "(\\+\\d+)?1[34578]\\d{9}$";
        return Pattern.matches(regex,mobile);
    }

    /**
     * 验证固定电话号码
     * @param phone 电话号码，格式：国家（地区）电话代码 + 区号（城市代码） + 电话号码，如：+8602085588447
     * <p><b>国家（地区） 代码 ：</b>标识电话号码的国家（地区）的标准国家（地区）代码。它包含从 0 到 9 的一位或多位数字，
     *  数字之后是空格分隔的国家（地区）代码。</p>
     * <p><b>区号（城市代码）：</b>这可能包含一个或多个从 0 到 9 的数字，地区或城市代码放在圆括号——
     * 对不使用地区或城市代码的国家（地区），则省略该组件。</p>
     * <p><b>电话号码：</b>这包含从 0 到 9 的一个或多个数字 </p>
     * @return 验证成功返回true，验证失败返回false
     */
    public static boolean isPhone(String phone) {
        String regex = "(\\+\\d+)?(\\d{3,4}\\-?)?\\d{7,8}$";
        return Pattern.matches(regex, phone);
    }

    /**
     * 验证整数（正整数和负整数）
     * @param digit 一位或多位0-9之间的整数
     * @return 验证成功返回true，验证失败返回false
     */
    public static boolean isDigit(String digit) {
        String regex = "\\-?[1-9]\\d+";
        return Pattern.matches(regex,digit);
    }

    /**
     * 验证整数和浮点数（正负整数和正负浮点数）
     * @param decimals 一位或多位0-9之间的浮点数，如：1.23，233.30
     * @return 验证成功返回true，验证失败返回false
     */
    public static boolean isDecimals(String decimals) {
        String regex = "\\-?[1-9]\\d+(\\.\\d+)?";
        return Pattern.matches(regex,decimals);
    }

    /**
     * 验证空白字符
     * @param blankSpace 空白字符，包括：空格、\t、\n、\r、\f、\x0B
     * @return 验证成功返回true，验证失败返回false
     */
    public static boolean isBlankSpace(String blankSpace) {
        String regex = "\\s+";
        return Pattern.matches(regex,blankSpace);
    }

    /**
     * 验证中文
     * @param chinese 中文字符
     * @return 验证成功返回true，验证失败返回false
     */
    public static boolean isChinese(String chinese) {
        String regex = "^[\u4E00-\u9FA5]+$";
        return Pattern.matches(regex,chinese);
    }

    /**
     * 验证中文字母数字空格
     * @param chinese 中文字符
     * @return 验证成功返回true，验证失败返回false
     */
    public static boolean isRealName(String chinese) {
        String regex = "^[A-Za-z0-9\\s\u4E00-\u9FA5]+$";
        return Pattern.matches(regex,chinese);
    }

    /**
     * 检测是否是数字
     * @param str
     * @return
     */
    public static boolean isNumber(String str) {
        String regex = "^[1-9]\\d*$";
        return Pattern.matches(regex,str);
    }

    /**
     * 验证学生学号
     * @param num
     * @return
     */
    public static boolean isStudentNum(String num) {
        String regex = "^[A-Za-z0-9-_]+$";
        return Pattern.matches(regex,num);
    }

    /**
     * 验证日期（年月日）
     * @param birthday 日期，格式：1992-09-03，或1992.09.03
     * @return 验证成功返回true，验证失败返回false
     */
    public static boolean isBirthday(String birthday) {
        String regex = "^(\\d{4})-(\\d{2})-(\\d{2})$";
        return Pattern.matches(regex,birthday);
    }

    /**
     * 验证URL地址
     * @param url 格式：http://blog.csdn.net:80/xyang81/article/details/7705960? 或 http://www.csdn.net:80
     * @return 验证成功返回true，验证失败返回false
     */
    public static boolean isURL(String url) {
        String regex = "(https?://(w{3}\\.)?)?\\w+\\.\\w+(\\.[a-zA-Z]+)*(:\\d{1,5})?(/\\w*)*(\\??(.+=.*)?(&.+=.*)?)?";
        return Pattern.matches(regex, url);
    }

    /**
     * 匹配中国邮政编码
     * @param postcode 邮政编码
     * @return 验证成功返回true，验证失败返回false
     */
    public static boolean isPostcode(String postcode) {
        String regex = "[1-9]\\d{5}";
        return Pattern.matches(regex, postcode);
    }

    /**
     * 匹配IP地址(简单匹配，格式，如：192.168.1.1，127.0.0.1，没有匹配IP段的大小)
     * @param ipAddress IPv4标准地址
     * @return 验证成功返回true，验证失败返回false
     */
    public static boolean isIpAddress(String ipAddress) {
        String regex = "[1-9](\\d{1,2})?\\.(0|([1-9](\\d{1,2})?))\\.(0|([1-9](\\d{1,2})?))\\.(0|([1-9](\\d{1,2})?))";
        return Pattern.matches(regex, ipAddress);
    }
}

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * zip压缩工具类
 */
public class ZipUtils {

    public static void zipFolder(String srcFolder, String destZipFile) throws Exception {
        ZipOutputStream zip = null;
        FileOutputStream fileWriter = null;

        fileWriter = new FileOutputStream(destZipFile);
        zip = new ZipOutputStream(fileWriter);

        addFolderToZip("", srcFolder, zip);
        zip.flush();
        zip.close();
    }

    public static void zipFile(String filePath, String zipPath) throws Exception{
        byte[] buffer = new byte[1024];
        FileOutputStream fos = new FileOutputStream(zipPath);
        ZipOutputStream zos = new ZipOutputStream(fos);
        ZipEntry ze= new ZipEntry("spy.log");
        zos.putNextEntry(ze);
        FileInputStream in = new FileInputStream(filePath);
        int len;
        while ((len = in.read(buffer)) > 0) {
            zos.write(buffer, 0, len);
        }
        in.close();
        zos.closeEntry();
        //remember close it
        zos.close();
    }

    public static void addFileToZip(String path, String srcFile, ZipOutputStream zip)
            throws Exception {

        File folder = new File(srcFile);
        if (folder.isDirectory()) {
            addFolderToZip(path, srcFile, zip);
        } else {
            byte[] buf = new byte[1024];
            int len;
            FileInputStream in = new FileInputStream(srcFile);
            zip.putNextEntry(new ZipEntry(path + "/" + folder.getName()));
            while ((len = in.read(buf)) > 0) {
                zip.write(buf, 0, len);
            }
        }
    }

    public static void addFolderToZip(String path, String srcFolder, ZipOutputStream zip) throws Exception {
        File folder = new File(srcFolder);
        if (null != path && folder.isDirectory()) {
            String[] fileList = folder.list();
            if (fileList != null) {
                for (String fileName : fileList) {
                    if (path.equals("")) {
                        addFileToZip(folder.getName(), srcFolder + "/" + fileName, zip);
                    } else {
                        addFileToZip(path + "/" + folder.getName(), srcFolder + "/" + fileName, zip);
                    }
                }
            }
        }
    }
}



import java.util.Arrays;
import java.util.Random;

/**
 * 封装UUID
 */
public abstract class UUID {

    static Random r = new Random();

    /**
     * 根据一个范围，生成一个随机的整数
     * 
     * @param min
     *            最小值（包括）
     * @param max
     *            最大值（包括）
     * @return 随机数
     */
    public static int random(int min, int max) {
        return r.nextInt(max - min + 1) + min;
    }

    private static final char[] _UU64 = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".toCharArray();
    private static final char[] _UU32 = "0123456789abcdefghijklmnopqrstuv".toCharArray();

    /**
     * @return 64进制表示的紧凑格式的 UUID
     */
    public static String UU64() {
        return UU64(java.util.UUID.randomUUID());
    }

    /**
     * 返回一个 UUID ，并用 64 进制转换成紧凑形式的字符串，内容为 [\\-0-9a-zA-Z_]
     * <p>
     * 比如一个类似下面的 UUID:
     * 
     * <pre>
     * a6c5c51c-689c-4525-9bcd-c14c1e107c80
     * 一共 128 位，分做L64 和 R64，分为为两个 64位数（两个 long）
     *    > L = uu.getLeastSignificantBits();
     *    > UUID = uu.getMostSignificantBits();
     * 而一个 64 进制数，是 6 位，因此我们取值的顺序是
     * 1. 从L64位取10次，每次取6位
     * 2. 从L64位取最后的4位 ＋ R64位头2位拼上
     * 3. 从R64位取10次，每次取6位
     * 4. 剩下的两位最后取
     * 这样，就能用一个 22 长度的字符串表示一个 32 长度的UUID，压缩了 1/3
     * </pre>
     * 
     * @param uu
     *            UUID 对象
     * @return 64进制表示的紧凑格式的 UUID
     */
    public static String UU64(java.util.UUID uu) {
        int index = 0;
        char[] cs = new char[22];
        long L = uu.getMostSignificantBits();
        long R = uu.getLeastSignificantBits();
        long mask = 63;
        // 从L64位取10次，每次取6位
        for (int off = 58; off >= 4; off -= 6) {
            long hex = (L & (mask << off)) >>> off;
            cs[index++] = _UU64[(int) hex];
        }
        // 从L64位取最后的4位 ＋ R64位头2位拼上
        int l = (int) (((L & 0xF) << 2) | ((R & (3 << 62)) >>> 62));
        cs[index++] = _UU64[l];
        // 从R64位取10次，每次取6位
        for (int off = 56; off >= 2; off -= 6) {
            long hex = (R & (mask << off)) >>> off;
            cs[index++] = _UU64[(int) hex];
        }
        // 剩下的两位最后取
        cs[index++] = _UU64[(int) (R & 3)];
        // 返回字符串
        return new String(cs);
    }

    /**
     * 从一个 UU64 恢复回一个 UUID 对象
     * 
     * @param uu64
     *            64进制表示的 UUID, 内容为 [\\-0-9a-zA-Z_]
     * @return UUID 对象
     */
    public static java.util.UUID fromUU64(String uu64) {
        String uu16 = UU16FromUU64(uu64);
        return java.util.UUID.fromString(UU(uu16));
    }

    public static String UU32(java.util.UUID uu) {
        StringBuilder sb = new StringBuilder();
        long m = uu.getMostSignificantBits();
        long l = uu.getLeastSignificantBits();
        for (int i = 0; i < 13; i++) {
            sb.append(_UU32[(int) (m >> ((13 - i - 1) * 5)) & 31]);
        }
        for (int i = 0; i < 13; i++) {
            sb.append(_UU32[(int) (l >> ((13 - i - 1)) * 5) & 31]);
        }
        return sb.toString();
    }

    public static String UU32() {
        return UU32(java.util.UUID.randomUUID());
    }

    public static java.util.UUID fromUU32(String u32) {
        return new java.util.UUID(parseUnsignedLong(u32.substring(0, 13), 32),
                        parseUnsignedLong(u32.substring(13), 32));
    }

    public static long parseUnsignedLong(String s, int radix) {
        int len = s.length();
        long first = Long.parseLong(s.substring(0, len - 1), radix);
        int second = Character.digit(s.charAt(len - 1), radix);
        return first * radix + second;
    }

    /**
     * 将紧凑格式的 UU16 字符串变成标准 UUID 格式的字符串
     * 
     * @param uu16
     * @return 标准 UUID 字符串
     */
    public static String UU(String uu16) {
        StringBuilder sb = new StringBuilder();
        sb.append(uu16.substring(0, 8));
        sb.append('-');
        sb.append(uu16.substring(8, 12));
        sb.append('-');
        sb.append(uu16.substring(12, 16));
        sb.append('-');
        sb.append(uu16.substring(16, 20));
        sb.append('-');
        sb.append(uu16.substring(20));
        return sb.toString();
    }

    private static final char[] _UU16 = "0123456789abcdef".toCharArray();

    /**
     * 将一个 UU64 表示的紧凑字符串，变成 UU16 表示的字符串
     * 
     * <pre>
     * 每次取2个字符，恢复成3个byte，重复10次， 最后一次，是用最后2个字符，恢复回2个byte </prev>
     * 
     * @param uu64
     *            uu64 64进制表示的 UUID, 内容为 [\\-0-9a-zA-Z_]
     * @return 16进制表示的紧凑格式的 UUID
     */
    public static String UU16FromUU64(String uu64) {
        byte[] bytes = new byte[32];
        char[] cs = uu64.toCharArray();
        int index = 0;
        // 每次取2个字符，恢复成3个byte，重复10次，
        for (int i = 0; i < 10; i++) {
            int off = i * 2;
            char cl = cs[off];
            char cr = cs[off + 1];
            int l = Arrays.binarySearch(_UU64, cl);
            int r = Arrays.binarySearch(_UU64, cr);
            int n = (l << 6) | r;
            bytes[index++] = (byte) ((n & 0xF00) >>> 8);
            bytes[index++] = (byte) ((n & 0xF0) >>> 4);
            bytes[index++] = (byte) (n & 0xF);
        }
        // 最后一次，是用最后2个字符，恢复回2个byte
        char cl = cs[20];
        char cr = cs[21];
        int l = Arrays.binarySearch(_UU64, cl);
        int r = Arrays.binarySearch(_UU64, cr);
        int n = (l << 2) | r;
        bytes[index++] = (byte) ((n & 0xF0) >>> 4);
        bytes[index++] = (byte) (n & 0xF);

        // 返回 UUID 对象
        char[] names = new char[32];
        for (int i = 0; i < bytes.length; i++)
            names[i] = _UU16[bytes[i]];
        return new String(names);
    }

    /**
     * 返回指定长度由随机数字+小写字母组成的字符串
     * 
     * @param length
     *            指定长度
     * @return 随机字符串
     */
    public static String captchaChar(int length) {
        return captchaChar(length, false);
    }

    /**
     * 返回指定长度随机数字+字母(大小写敏感)组成的字符串
     * 
     * @param length
     *            指定长度
     * @param caseSensitivity
     *            是否区分大小写
     * @return 随机字符串
     */
    public static String captchaChar(int length, boolean caseSensitivity) {
        StringBuilder sb = new StringBuilder();
        Random rand = new Random();// 随机用以下三个随机生成器
        Random randdata = new Random();
        int data = 0;
        for (int i = 0; i < length; i++) {
            int index = rand.nextInt(caseSensitivity ? 3 : 2);
            // 目的是随机选择生成数字，大小写字母
            switch (index) {
            case 0:
                data = randdata.nextInt(10);// 仅仅会生成0~9, 0~9的ASCII为48~57
                sb.append(data);
                break;
            case 1:
                data = randdata.nextInt(26) + 97;// 保证只会产生ASCII为97~122(a-z)之间的整数,
                sb.append((char) data);
                break;
            case 2: // caseSensitivity为true的时候, 才会有大写字母
                data = randdata.nextInt(26) + 65;// 保证只会产生ASCII为65~90(A~Z)之间的整数
                sb.append((char) data);
                break;
            }
        }
        return sb.toString();
    }

    /**
     * 返回指定长度随机数字组成的字符串
     * 
     * @param length
     *            指定长度
     * @return 随机字符串
     */
    public static String captchaNumber(int length) {
        StringBuilder sb = new StringBuilder();
        Random rand = new Random();
        for (int i = 0; i < length; i++) {
            sb.append(rand.nextInt(10));
        }
        return sb.toString();
    }
}
--------------------------------------------------------------------------------------------------------
https://github.com/xiaomoinfo
--------------------------------------------------------------------------------------------------------
import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

/**
 * @author : xiaomo
 */
@Component
@RabbitListener(queues = "hello")
public class Receiver {

    @RabbitHandler
    public void process(String hello) {
        System.out.println("Receiver : " + hello);
    }
}

import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Date;

/**
 * @author : xiaomo
 */
@Component
public class Sender {

    private final AmqpTemplate rabbitTemplate;

    @Autowired
    public Sender(AmqpTemplate rabbitTemplate) {
        this.rabbitTemplate = rabbitTemplate;
    }

    public void send() {
        String context = "hello " + new Date();
        System.out.println("Sender : " + context);
        this.rabbitTemplate.convertAndSend("hello", context);
    }
}


    /**
     * 登录
     *
     * @return result
     */
    @ApiOperation(value = "登录", notes = "登录", httpMethod = "POST", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
    @ApiImplicitParams({
            @ApiImplicitParam(name = "email", value = "邮箱", required = true, dataType = "String", paramType = "path"),
            @ApiImplicitParam(name = "password", value = "密码", required = true, dataType = "String", paramType = "path")
    })
    @RequestMapping(value = "login/{email}/{password}", method = RequestMethod.POST)
    public Result login(@PathVariable("email") String email, @PathVariable("password") String password) {
        UserModel userModel = service.findUserByEmail(email);
        //找不到用户
        if (userModel == null) {
            return new Result(CodeConst.USER_NOT_FOUND.getResultCode(), CodeConst.USER_NOT_FOUND.getMessage());
        }
        //密码不正确
        if (!Md5Util.encode(password, userModel.getSalt()).equals(userModel.getPassword())) {
            return new Result(CodeConst.AUTH_FAILED.getResultCode(), CodeConst.AUTH_FAILED.getMessage());
        }
        return new Result<>(userModel);
    }
--------------------------------------------------------------------------------------------------------
import info.xiaomo.website.model.UserModel;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 把今天最好的表现当作明天最新的起点．．～
 * いま 最高の表現 として 明日最新の始発．．～
 * Today the best performance  as tomorrow newest starter!
 * Created by IntelliJ IDEA.
 *
 * @author : xiaomo
 * github: https://github.com/xiaomoinfo
 * email: xiaomo@xiaomo.info
 * <p>
 * Date: 2016/11/21 10:42
 * Copyright(©) 2015 by xiaomo.
 **/

public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {
        UserModel user = (UserModel) httpServletRequest.getSession().getAttribute("currentUser");
        if (user == null) {
            //用户没有登录
            httpServletResponse.sendRedirect(httpServletRequest.getContextPath() + "/user/toLogin");
            return false;
        }
        //用户已经登录
        return true;

    }

    @Override
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {

    }
}

    private static Session getSession() throws IOException {
        Properties props = new Properties();
        String dir = System.getProperty("user.dir");
        FileInputStream is = new FileInputStream(dir + "/website/src/main/resources/config/application.properties");
        props.load(is);
        USERNAME = String.valueOf(props.get("mail.username"));
        PASSWORD = String.valueOf(props.get("mail.password"));
        Authenticator authenticator = new Authenticator() {
            @Override
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication(USERNAME, PASSWORD);
            }
        };
        return Session.getDefaultInstance(props, authenticator);
    }
--------------------------------------------------------------------------------------------------------
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Primary;
import org.springframework.jdbc.core.JdbcTemplate;

import javax.sql.DataSource;

/**
 * 把今天最好的表现当作明天最新的起点．．～
 * いま 最高の表現 として 明日最新の始発．．～
 * Today the best performance  as tomorrow newest starter!
 * Created by IntelliJ IDEA.
 *
 * @author : xiaomo
 * github: https://github.com/xiaomoinfo
 * email: xiaomo@xiaomo.info

 * Date: 2016/11/16 10:34
 * Description: 多数据源(在配置文件中自定义字段,在这里取出并创建不同的数据源)
 * Copyright(©) 2015 by xiaomo.
 **/

@SpringBootApplication
public class MultipleSourceMain {

    public static void main(String[] args) {
        SpringApplication.run(MultipleSourceMain.class, args);
    }


    /**
     * 第一个数据源
     * @return 数据源实例
     */
    @Bean(name = "primaryDataSource")
    @Qualifier("primaryDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.primary")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().build();
    }

    /**
     * 第二个数据源
     * @return 数据源实例
     */
    @Bean(name = "secondaryDataSource")
    @Qualifier("secondaryDataSource")
    @Primary
    @ConfigurationProperties(prefix = "spring.datasource.secondary")
    public DataSource secondaryDataSource() {
        return DataSourceBuilder.create().build();
    }

    /**
     * 第一个JDBC模板
     * @param dataSource dataSource
     * @return JDBC模板
     */
    @Bean(name = "primaryJdbcTemplate")
    public JdbcTemplate primaryJdbcTemplate(
            @Qualifier("primaryDataSource") DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }

    /**
     * 第二个JDBC模板
     * @param dataSource dataSource
     * @return JDBC模板
     */
    @Bean(name = "secondaryJdbcTemplate")
    public JdbcTemplate secondaryJdbcTemplate(
            @Qualifier("secondaryDataSource") DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }

}

import info.xiaomo.core.untils.HtmlUtil;
import info.xiaomo.core.untils.TimeUtil;
import lombok.Data;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;
import java.io.IOException;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * 把今天最好的表现当作明天最新的起点．．～
 * いま 最高の表現 として 明日最新の始発．．～
 * Today the best performance  as tomorrow newest starter!
 * Created by IntelliJ IDEA.
 * <p>
 *
 * @author : xiaomo
 * github: https://github.com/xiaomoinfo
 * email: xiaomo@xiaomo.info
 * <p>
 * Date: 2016/11/3 16:36
 * Description: 用户实体类
 * Copyright(©) 2015 by xiaomo.
 **/

@ServerEndpoint("/websocket")
@Component
@Data
public class MyWebSocket {

    private static final Logger LOGGER = LoggerFactory.getLogger(MyWebSocket.class);
    private static int onlineCount = 0;
    private static CopyOnWriteArraySet<MyWebSocket> webSocketSet = new CopyOnWriteArraySet<>();
    private Session session;

    /**
     * 获取在线人数
     *
     * @return 在线人数
     */
    private static synchronized int getOnlineCount() {
        return MyWebSocket.onlineCount;
    }

    /**
     * 添加在线人数
     */
    private static synchronized void addOnlineCount() {
        MyWebSocket.onlineCount++;
    }

    /**
     * 减少在线人数
     */
    private static synchronized void subOnlineCount() {
        MyWebSocket.onlineCount--;
    }

    /**
     * 有人进入房间
     *
     * @param session session
     */
    @OnOpen
    public void onOpen(Session session) {
        this.session = session;
        webSocketSet.add(this);
        addOnlineCount();
        LOGGER.info("有新用户加入!当前在线人数为:{}", getOnlineCount());
    }

    /**
     * 有人离开房间
     */
    @OnClose
    public void onClose() {
        webSocketSet.remove(this);
        subOnlineCount();
        System.out.println("有一用户关闭!当前在线人数为" + getOnlineCount());
    }

    /**
     * 发消息
     *
     * @param message message
     * @throws IOException IOException
     */
    @OnMessage
    public void onMessage(String message) throws IOException {
        String date = "<font color='green'>" + TimeUtil.getDateNow(TimeUtil.DATE_PATTERN) + "</font></br>";
        // 群发消息
        for (MyWebSocket item : webSocketSet) {
            item.sendMessage(date + message);
        }
        LOGGER.info("客户端消息:{}", HtmlUtil.delHTMLTag(message));
    }

    /**
     * 发送消息
     *
     * @param message message
     * @throws IOException IOException
     */
    private void sendMessage(String message) throws IOException {
        this.session.getBasicRemote().sendText(message);
    }
}
--------------------------------------------------------------------------------------------------------
    /**
     * 获取ip
     *
     * @return ip 如果返回null,说明是一个不合法的ip地址格式
     */
    public static String getIP(HttpServletRequest request) {
        String ip = request.getHeader("X-Requested-For");
        String unknown = "unknown";
        if (StringUtils.isBlank(ip) || unknown.equalsIgnoreCase(ip)) {
            ip = request.getHeader("X-Forwarded-For");
        }
        if (StringUtils.isBlank(ip) || unknown.equalsIgnoreCase(ip)) {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (StringUtils.isBlank(ip) || unknown.equalsIgnoreCase(ip)) {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (StringUtils.isBlank(ip) || unknown.equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_CLIENT_IP");
        }
        if (StringUtils.isBlank(ip) || unknown.equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_X_FORWARDED_FOR");
        }
        if (StringUtils.isBlank(ip) || unknown.equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        if (!ip.matches(IP_REGEX)) {
            return null;
        }
        return ip;
    }
--------------------------------------------------------------------------------------------------------
    /**
     * 代码转换，GBK转换为ISO-8859-1
     *
     * @param tempSql 要转换的字符串
     */
    public static String isocode(String tempSql) {

        String returnString = convertNullCode(tempSql);

        try {
            byte[] ascii = returnString.getBytes("GBK");
            returnString = new String(ascii, "ISO-8859-1");
        } catch (Exception e) {
            e.printStackTrace();
        }
        return returnString;
    }

    /**
     * 代码转换，ISO-8859-1转换为GBK
     *
     * @param tempSql 要转换的字符串
     * @return
     */
    public static String gbkcode(String tempSql) {
        String returnString = convertNullCode(tempSql);
        try {
            byte[] ascii = returnString.getBytes("ISO-8859-1");
            returnString = new String(ascii, "GBK");
        } catch (Exception e) {
            e.printStackTrace();
        }
        return returnString;
    }
	
	    /**
     * 数字的金额表达式
     */
    public static String convertNumToMoney(int num) {
        NumberFormat formatc = NumberFormat.getCurrencyInstance(Locale.CHINA);
        return formatc.format(num);
    }


    /**
     * 数字的金额表达式
     *
     * @param num      金额
     * @param inLocale 币种
     * @return 处理好的币种
     */
    public static String convertNumToMoney(int num, Locale inLocale) {
        NumberFormat formatc = NumberFormat.getCurrencyInstance(inLocale);
        return formatc.format(num);
    }
--------------------------------------------------------------------------------------------------------
    public static String objectToString(Object obj) {
        if (obj.getClass().equals(String.class)) {
            return obj.toString();
        } else {
            ByteArrayOutputStream out = new ByteArrayOutputStream();

            try {
                ObjectOutputStream e = new ObjectOutputStream(out);
                e.writeObject(obj);
                byte[] bytes = out.toByteArray();
                return new String(bytes, "ISO-8859-1");
            } catch (IOException var4) {
                var4.printStackTrace();
                return null;
            }
        }
    }

    public static Object stringToObject(String string) {
        try {
            byte[] e = string.getBytes("ISO-8859-1");
            ByteArrayInputStream in = new ByteArrayInputStream(e);
            ObjectInputStream ois = new ObjectInputStream(in);
            return ois.readObject();
        } catch (IOException | ClassNotFoundException var4) {
            var4.printStackTrace();
        }

        return null;
    }
--------------------------------------------------------------------------------------------------------
import com.alibaba.fastjson.JSONObject;
import info.xiaomo.core.constant.SymbolConst;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Token 帮助类
 *
 * @author : xiaomo
 */
public class TokenUtil {

    private static final String STR_S = "abcdefghijklmnopqrstuvwxyz0123456789";

    /**
     * 参考自 qq sdk
     *
     * @param string string
     * @return String    返回类型
     */
    public static String getAccessToken(String string) {
        String accessToken = "";
        try {
            JSONObject json = JSONObject.parseObject(string);
            if (null != json) {
                accessToken = json.getString("access_token");
            }
        } catch (Exception e) {
            String regex = "^access_token=(\\w+)&expires_in=(\\w+)&refresh_token=(\\w+)$";
            Matcher m = Pattern.compile(regex).matcher(string);
            if (m.find()) {
                accessToken = m.group(1);
            } else {
                String regex1 = "^access_token=(\\w+)&expires_in=(\\w+)$";
                Matcher m2 = Pattern.compile(regex1).matcher(string);
                if (m2.find()) {
                    accessToken = m2.group(1);
                } else {
                    String temp = string.split(SymbolConst.DENGHAO)[1];
                    accessToken = temp.split(SymbolConst.AND)[0];
                }
            }
        }
        return accessToken;
    }

    /**
     * 匹配openid
     *
     * @return String    返回类型
     */
    public static String getOpenId(String string) {
        String openid = null;
        String regex = "\"openid\"\\s*:\\s*\"(\\w+)\"";
        Matcher m = Pattern.compile(regex).matcher(string);
        if (m.find()) {
            openid = m.group(1);
        }
        return openid;
    }

    /**
     * sina uid于qq分离
     *
     * @return String    返回类型
     */
    public static String getUid(String string) {
        JSONObject json = JSONObject.parseObject(string);
        return json.getString("uid");
    }
}
--------------------------------------------------------------------------------------------------------
#!/bin/sh

while true
do
	case "$(cat /run/secrets/payment_token)" in
	staging)
		echo "$(date '+%s') | OK | Authenticated in staging mode, waiting for transactions..."
		;;
	production)
		echo "$(date '+%s') | OK | PRODUCTION MODE! WE'RE READY TO ROCK AND ROLL!"
		;;
	*)
		RED='\033[0;31m'
		NC='\033[0m'
		echo -e "${RED}$(date '+%s') | ERROR | Payment token WRONG!!!!!!! :(${NC}"
		exit 1
		;;
	esac
	sleep 1
done
--------------------------------------------------------------------------------------------------------
@EnableMongoRepositories
@EnableMongoAuditing
--------------------------------------------------------------------------------------------------------
import com.timeyang.account.Account;
import com.timeyang.address.AddressType;
import com.timeyang.order.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.oauth2.client.OAuth2RestTemplate;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * 订单服务
 *
 * @author yangck
 */
@Service
public class OrderServiceV1 {

    private final Log log = LogFactory.getLog(getClass());

    @Autowired
    private OrderRepositroy orderRepositroy;

    @Autowired
    private OrderEventRepository orderEventRepository;

    @Autowired
    private OAuth2RestTemplate oAuth2RestTemplate;

    public Order createOrder(List<OrderItem> orderItems) {
        Account[] accounts = oAuth2RestTemplate.getForObject("http://account-service/v1/accounts", Account[].class);

        Account defaultAccount = Arrays.stream(accounts)
                .filter(Account::isDefaultAccount)
                .findFirst().orElse(null);

        if(defaultAccount == null) {
            return null;
        }

        Order newOrder = new Order(defaultAccount.getAccountNumber(),
                defaultAccount.getAddresses().stream()
                        .filter(address -> address.getAddressType() == AddressType.SHIPPING)
                        .findFirst()
                        .orElseThrow(() -> new RuntimeException("默认账户没有收货地址")));
        newOrder.setOrderItems(orderItems);
        newOrder = orderRepositroy.save(newOrder);

        return newOrder;
    }

    public Boolean addOrderEvent(OrderEvent orderEvent, Boolean validate) throws Exception {
        // 得到订单事件对应的订单
        Order order = orderRepositroy.findOne(orderEvent.getOrderId());

        if(validate) {
            // 验证事件对应的订单的账户号(account number)属于用户。
            validateAccountNumber(order.getAccountNumber());
        }

        // 保存订单事件
        orderEventRepository.save(orderEvent);

        return true;
    }

    public Order getOrder(String orderId, Boolean validate) {
        // 获取订单
        Order order = orderRepositroy.findOne(orderId);

        if(validate) {
            // 验证事件对应的订单的账户号(account number)属于用户
            try {
                validateAccountNumber(order.getAccountNumber());
            } catch (Exception e) {
                return null;
            }
        }

        Flux<OrderEvent> orderEvents = Flux.fromStream(orderEventRepository.findOrderEventsByOrderId(orderId));

        // 聚合订单状态
        return orderEvents.takeWhile(orderEvent -> orderEvent.getType() != OrderEventType.DELIVERED)
                .reduceWith(() -> order, Order::incorporate)
                .get();
    }

    public List<Order> getOrdersForAccount(String accountNUmber) throws Exception {
        validateAccountNumber(accountNUmber);

        List<Order> orders = orderRepositroy.findByAccountNumber(accountNUmber);

        return orders.stream()
                .map(order -> getOrder(order.getOrderId(), true))
                .filter(order -> order != null)
                .collect(Collectors.toList());
    }

    /**
     * 验证账户号是否有效
     * @param accountNumber
     * @return 一个布尔值表示账户号是否有效
     * @throws Exception 账户号无效时抛出异常
     */
    public boolean validateAccountNumber(String accountNumber) throws Exception {
        Account[] accounts = oAuth2RestTemplate.getForObject("http://account-service/v1/accounts", Account[].class);

        // 确保账户号被当前验证用户拥有
        if(accounts != null && !Arrays.stream(accounts).anyMatch(account -> Objects.equals(account.getAccountNumber(), accountNumber))) {
            log.error("账户号无效:" + accountNumber);
            throw new Exception("账户号无效:" + accountNumber);
        }

        return true;
    }

}
--------------------------------------------------------------------------------------------------------
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.messaging.simp.SimpMessageSendingOperations;
import org.springframework.messaging.simp.config.ChannelRegistration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.scheduling.TaskScheduler;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.SchedulingConfigurer;
import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;
import org.springframework.scheduling.config.ScheduledTaskRegistrar;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.util.Assert;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import java.util.Collection;
import java.util.Date;

@ComponentScan
@EnableAutoConfiguration
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}


@EnableScheduling
@EnableWebSocketMessageBroker
@Configuration
class WebSocketConfiguration
        extends AbstractWebSocketMessageBrokerConfigurer
        implements SchedulingConfigurer {

    @Bean
    ThreadPoolTaskScheduler reservationPool() {
        return new ThreadPoolTaskScheduler();
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/notifications").withSockJS();
    }

    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
    }

    @Override
    public void configureClientOutboundChannel(ChannelRegistration registration) {
        registration.taskExecutor().corePoolSize(4).maxPoolSize(10);
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableSimpleBroker("/queue/", "/topic/");
        registry.setApplicationDestinationPrefixes("/app");
    }

    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        taskRegistrar.setTaskScheduler(reservationPool());
    }
}


@Entity
class Booking {

    @Id
    @GeneratedValue
    private Long id;

    private int groupSize = 1;
    private Date dateAndTime;
    private String bookingName;

    @Override
    public String toString() {
        return "Reservation{" +
                "groupSize=" + groupSize +
                ", dateAndTime=" + dateAndTime +
                ", id=" + id +
                ", bookingName='" + bookingName + '\'' +
                '}';
    }

    public int getGroupSize() {
        return groupSize;
    }

    public Date getDateAndTime() {
        return dateAndTime;
    }

    public Long getId() {
        return id;
    }

    public String getBookingName() {
        return bookingName;
    }

}


/**
 * Spring Data JPA-powered <em>repository</em> interface.
 * Supports common operations like {@link #findAll()} and {@link #save(Object)} against JPA entities.
 * This particular repository deals in {@link demo.Booking booking} objects.
 */
interface BookingRepository extends JpaRepository<Booking, Long> {
    Collection<Booking> findByBookingName(@Param("bookingName") String bookingName);
}

/**
 * Handles REST-API calls for {@link demo.Booking booking data}.
 */
@RestController
@RequestMapping("/bookings")
class BookingRestController {

    private SimpMessageSendingOperations messagingTemplate;

    private TaskScheduler taskScheduler;

    private BookingRepository bookingRepository;

    @Autowired
    BookingRestController(
            @Qualifier("reservationPool") TaskScheduler taskScheduler,
            BookingRepository bookingRepository,
            SimpMessageSendingOperations messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
        this.taskScheduler = (taskScheduler);
        this.bookingRepository = bookingRepository;
    }

    void schedule(final Booking booking) {
        Assert.notNull(booking.getDateAndTime());
        this.taskScheduler.schedule(new Runnable() {
            @Override
            public void run() {
                messagingTemplate.convertAndSend("/topic/alarms", booking);
            }
        }, booking.getDateAndTime());
        LogFactory.getLog(getClass()).info("at " + new Date(
                System.currentTimeMillis()) + "# scheduling "
                + booking.getId() + " for " + booking.getDateAndTime());
    }

    @RequestMapping(method = RequestMethod.DELETE, value = "/{id}")
    void delete(@PathVariable Long id) {
        this.bookingRepository.delete(id);
        reservationEvents("delete#" + id);
    }

    protected void reservationEvents(String event) {
        messagingTemplate.convertAndSend("/topic/reservationEvents", event);
    }

    @RequestMapping(method = RequestMethod.POST)
    Booking add(@RequestBody Booking b) {
        Booking result = this.bookingRepository.save(b);
        schedule(b);
        reservationEvents("add#" + b.getId());
        return result;
    }

    @RequestMapping(method = RequestMethod.GET)
    Collection<Booking> all() {
        return this.bookingRepository.findAll(
                new Sort(Sort.Direction.ASC, "dateAndTime"));
    }
}

/**
 * Handles the Thymeleaf-powered view responses.
 */
@Controller
class BookingHtmlController {

    @Autowired
    BookingRepository bookingRepository;

    @RequestMapping(method = RequestMethod.GET, value = "/bookings.html")
    String all(Model model) {
        model.addAttribute("bookings", this.bookingRepository.findAll());
        return "bookings";
    }
}
--------------------------------------------------------------------------------------------------------
/*
 * Copyright 2016 The original authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.vaadin.spring.security.shared;

import javax.servlet.ServletContext;

import org.atmosphere.cpr.Action;
import org.atmosphere.cpr.AtmosphereInterceptorAdapter;
import org.atmosphere.cpr.AtmosphereResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeansException;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.context.HttpRequestResponseHolder;
import org.springframework.security.web.context.HttpSessionSecurityContextRepository;
import org.springframework.security.web.context.SecurityContextRepository;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.support.WebApplicationContextUtils;

/**
 * An Atmosphere interceptor that populates the {@link SecurityContextHolder} with a security context
 * read from a {@link SecurityContextRepository}. The interceptor will attempt to use any repository defined
 * in the application context. If no repository is found, a new {@link HttpSessionSecurityContextRepository} is created
 * and used as-is.
 *
 * @author Petter Holmström (petter@vaadin.com)
 */
public class PushSecurityInterceptor extends AtmosphereInterceptorAdapter {

    private static final Logger LOGGER = LoggerFactory.getLogger(PushSecurityInterceptor.class);

    private SecurityContextRepository securityContextRepository;

    private synchronized SecurityContextRepository getSecurityContextRepository(ServletContext servletContext) {
        if (securityContextRepository == null) {
            final WebApplicationContext applicationContext = WebApplicationContextUtils
                .getWebApplicationContext(servletContext);
            try {
                securityContextRepository = applicationContext.getBean(SecurityContextRepository.class);
            } catch (BeansException ex) {
                LOGGER.info(
                    "Found no SecurityContextRepository in the application context, using HttpSessionSecurityContextRepository");
                securityContextRepository = new HttpSessionSecurityContextRepository();
            }
        }
        return securityContextRepository;
    }

    @Override
    public Action inspect(AtmosphereResource r) {
        final SecurityContextRepository securityContextRepo = getSecurityContextRepository(
            r.getAtmosphereConfig().getServletContext());
        if (securityContextRepo.containsContext(r.getRequest())) {
            LOGGER.trace("Loading the security context from the session");
            final HttpRequestResponseHolder requestResponse = new HttpRequestResponseHolder(r.getRequest(),
                r.getResponse());
            final SecurityContext securityContext = securityContextRepo.loadContext(requestResponse);
            SecurityContextHolder.setContext(securityContext);
        }
        return Action.CONTINUE;
    }

    @Override
    public void postInspect(AtmosphereResource r) {
        LOGGER.trace("Clearing security context");
        SecurityContextHolder.clearContext();
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.context.annotation.Condition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.type.AnnotatedTypeMetadata;
import org.springframework.web.servlet.DispatcherServlet;

import com.vaadin.flow.server.VaadinServlet;

/**
 * Condition to check whether the Vaadin servlet is mapped to the root
 * ({@literal "/*"}).
 * <p>
 * In this case a {@link DispatcherServlet} is used. It's mapped to the root
 * instead of VaadinServlet and forwards requests to {@link VaadinServlet}. If
 * there are other mappings (via Spring endpoints e.g.) then
 * {@link DispatcherServlet} makes it possible to handle them properly via those
 * endpoints. Otherwise {@link VaadinServlet} will handle all the URLs because
 * it has the highest priority.
 *
 * @author Vaadin Ltd
 *
 */
public class RootMappedCondition implements Condition {

    public static final String URL_MAPPING_PROPERTY = "vaadin.urlMapping";

    @Override
    public boolean matches(ConditionContext context,
            AnnotatedTypeMetadata metadata) {
        return isRootMapping(
                context.getEnvironment().getProperty(URL_MAPPING_PROPERTY));
    }

    /**
     * Returns {@code true} if {@code mapping} is the root mapping
     * ({@literal "/*"}).
     * <p>
     * The mapping is controlled via the {@code vaadin.urlMapping} property
     * value. By default it's {@literal "/*"}.
     *
     * @param mapping
     *            the mapping string to check
     * @return {@code true} if {@code mapping} is the root mapping and
     *         {@code false} otherwise
     */
    public static boolean isRootMapping(String mapping) {
        if (mapping == null) {
            return true;
        }
        return mapping.trim().replaceAll("(/\\**)?$", "").isEmpty();
    }
}
--------------------------------------------------------------------------------------------------------
import java.io.*;
import java.text.MessageFormat;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Implementation of {@link org.vaadin.spring.i18n.MessageProvider} that reads messages
 * from {@link java.util.ResourceBundle}s with a specific base name.
 *
 * @author Petter Holmström (petter@vaadin.com)
 */
public class ResourceBundleMessageProvider implements MessageProvider {

    private static final Logger LOGGER = LoggerFactory.getLogger(ResourceBundleMessageProvider.class);

    private final String baseName;
    private final String encoding;

    /**
     * Creates a new {@code ResourceBundleMessageProvider} with the given base name and UTF-8 encoding.
     *
     * @param baseName the base name to use, must not be {@code null}.
     */
    public ResourceBundleMessageProvider(String baseName) {
        this(baseName, "UTF-8");
    }

    /**
     * Creates a new {@code ResourceBundleMessageProvider} with the given base name and encoding.
     *
     * @param baseName the base name to use, must not be {@code null}.
     * @param encoding the encoding to use when reading the resource bundle, must not be {@code null}.
     */
    public ResourceBundleMessageProvider(String baseName, String encoding) {
        this.baseName = baseName;
        this.encoding = encoding;
    }

    @Override
    public MessageFormat resolveCode(String s, Locale locale) {
        final ResourceBundle resourceBundle = getResourceBundle(locale);
        final String message = getString(resourceBundle, s);
        return getMessageFormat(message, locale);
    }

    @Override
    public void clearCache() {
        ResourceBundle.clearCache(this.getClass().getClassLoader());
    }

    private ResourceBundle getResourceBundle(Locale locale) {
        try {
            return ResourceBundle.getBundle(baseName, locale, this.getClass().getClassLoader(), new MessageControl());
        } catch (MissingResourceException ex) {
            LOGGER.warn("No message bundle with basename [{}] found for locale [{}]", baseName, locale);
            return null;
        }
    }

    private static String getString(ResourceBundle bundle, String s) {
        if (bundle == null) {
            return null;
        }
        try {
            return bundle.getString(s);
        } catch (MissingResourceException ex) {
            return null;
        }
    }

    private static MessageFormat getMessageFormat(String message, Locale locale) {
        if (message == null) {
            return null;
        }
        return new MessageFormat(message, locale);
    }

    private class MessageControl extends ResourceBundle.Control {
        @Override
        public ResourceBundle newBundle(String baseName, Locale locale, String format, ClassLoader loader,
            boolean reload) throws IllegalAccessException, InstantiationException, IOException {
            if ("java.properties".equals(format)) {
                final String resourceName = toResourceName(toBundleName(baseName, locale), "properties");
                final InputStream stream = loader.getResourceAsStream(resourceName);
                if (stream == null) {
                    return null; // Not found
                }
                Reader reader = null;
                try {
                    reader = new InputStreamReader(stream, encoding);
                    return new PropertyResourceBundle(reader);
                } catch (UnsupportedEncodingException ex) {
                    stream.close();
                    throw ex;
                } finally {
                    if (reader != null) {
                        reader.close();
                    }
                }
            } else {
                return super.newBundle(baseName, locale, format, loader, reload);
            }
        }
    }
}
--------------------------------------------------------------------------------------------------------
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.Aware;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ConfigurableApplicationContext;
import org.vaadin.spring.security.VaadinSecurity;
import org.vaadin.spring.security.VaadinSecurityAware;
import org.vaadin.spring.security.VaadinSecurityContext;
import org.vaadin.spring.security.VaadinSecurityContextAware;

/**
 * {@link org.springframework.beans.factory.config.BeanPostProcessor}
 * implementation that passes the VaadinSecurity to beans that
 * implement the {@link org.vaadin.spring.security.VaadinSecurityAware} interface
 * 
 * @author Gert-Jan Timmer (gjr.timmer@gmail.com)
 * @since 12.23.2014
 * @see org.vaadin.spring.security.VaadinSecurityAware
 */
public class VaadinSecurityAwareProcessor implements ApplicationContextAware, BeanPostProcessor {

    private ConfigurableApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = (ConfigurableApplicationContext) applicationContext;
    }

    @Override
    public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {

        AccessControlContext acc = null;

        if ( System.getSecurityManager() != null && (bean instanceof VaadinSecurityAware) ) {
            acc = this.applicationContext.getBeanFactory().getAccessControlContext();
        }

        if (acc != null) {
            AccessController.doPrivileged(new PrivilegedAction<Object>() {

                @Override
                public Object run() {
                    invokeAwareInterfaces(bean);
                    return null;
                }

            }, acc);
        }
        else {
            invokeAwareInterfaces(bean);
        }

        return bean;

    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }

    private void invokeAwareInterfaces(Object bean) {

        if ( bean instanceof Aware ) {

            if ( bean instanceof VaadinSecurityAware ) {
                ((VaadinSecurityAware) bean).setVaadinSecurity(this.applicationContext.getBean(VaadinSecurity.class));
            }

            if ( bean instanceof VaadinSecurityContextAware ) {
                ((VaadinSecurityContextAware) bean).setVaadinSecurityContext(this.applicationContext.getBean(VaadinSecurityContext.class));
            }
        }
    }
}
--------------------------------------------------------------------------------------------------------
@Configuration
public class RequestLoggingFilterConfig {
 
    @Bean
    public CommonsRequestLoggingFilter logFilter() {
        CommonsRequestLoggingFilter filter
          = new CommonsRequestLoggingFilter();
        filter.setIncludeQueryString(true);
        filter.setIncludePayload(true);
        filter.setMaxPayloadLength(10000);
        filter.setIncludeHeaders(false);
        filter.setAfterMessagePrefix("REQUEST DATA : ");
        return filter;
    }
}

public class CustomeRequestLoggingFilter 
  extends CommonsRequestLoggingFilter {
 
    public CustomeRequestLoggingFilter() {
        super.setIncludeQueryString(true);
        super.setIncludePayload(true);
        super.setMaxPayloadLength(10000);
    }
}

@Component
public class TaxiFareRequestInterceptor 
  extends HandlerInterceptorAdapter {
 
    @Override
    public boolean preHandle(
      HttpServletRequest request, 
      HttpServletResponse response, 
      Object handler) {
        return true;
    }
 
    @Override
    public void afterCompletion(
      HttpServletRequest request, 
      HttpServletResponse response, 
      Object handler, 
      Exception ex) {
        //
    }
}

https://www.baeldung.com/spring-http-logging
--------------------------------------------------------------------------------------------------------
import java.io.File;
import java.io.Serializable;
import java.util.Collections;
import java.util.Locale;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.concurrent.ConcurrentHashMap;

import com.vaadin.server.Resource;
import com.vaadin.server.ThemeResource;

/**
 * Utility class that can figure out mime-types and icons related to files.
 * <p>
 * Note : The icons are associated purely to mime-types, so a file may not have
 * a custom icon accessible with this class.
 * </p>
 *
 * @author Vaadin Ltd.
 * @since 3.0
 */
@SuppressWarnings("serial")
public class FileTypeResolver {

    /**
     * Default icon given if no icon is specified for a mime-type.
     */
    public static Resource DEFAULT_ICON = new ThemeResource(
            "../runo/icons/16/document.png");

    /**
     * Default mime-type.
     */
    public static String DEFAULT_MIME_TYPE = "application/octet-stream";

    /**
     * Initial file extension to mime-type mapping.
     */
    private static final String INITIAL_EXT_TO_MIME_MAP = "application/cu-seeme                            csm cu,"
            + "application/dsptype                             tsp,"
            + "application/futuresplash                        spl,"
            + "application/mac-binhex40                        hqx,"
            + "application/msaccess                            mdb,"
            + "application/msword                              doc dot,"
            + "application/octet-stream                        bin,"
            + "application/oda                                 oda,"
            + "application/pdf                                 pdf,"
            + "application/pgp-signature                       pgp,"
            + "application/postscript                          ps ai eps,"
            + "application/rtf                                 rtf,"
            + "application/vnd.ms-excel                        xls xlb,"
            + "application/vnd.ms-powerpoint                   ppt pps pot,"
            + "application/vnd.wap.wmlc                        wmlc,"
            + "application/vnd.wap.wmlscriptc                  wmlsc,"
            + "application/wordperfect5.1                      wp5,"
            + "application/zip                                 zip,"
            + "application/x-123                               wk,"
            + "application/x-bcpio                             bcpio,"
            + "application/x-chess-pgn                         pgn,"
            + "application/x-cpio                              cpio,"
            + "application/x-debian-package                    deb,"
            + "application/x-director                          dcr dir dxr,"
            + "application/x-dms                               dms,"
            + "application/x-dvi                               dvi,"
            + "application/x-xfig                              fig,"
            + "application/x-font                              pfa pfb gsf pcf pcf.Z,"
            + "application/x-gnumeric                          gnumeric,"
            + "application/x-gtar                              gtar tgz taz,"
            + "application/x-hdf                               hdf,"
            + "application/x-httpd-php                         phtml pht php,"
            + "application/x-httpd-php3                        php3,"
            + "application/x-httpd-php3-source                 phps,"
            + "application/x-httpd-php3-preprocessed           php3p,"
            + "application/x-httpd-php4                        php4,"
            + "application/x-ica                               ica,"
            + "application/x-java-archive                      jar,"
            + "application/x-java-serialized-object            ser,"
            + "application/x-java-vm                           class,"
            + "application/x-javascript                        js,"
            + "application/x-kchart                            chrt,"
            + "application/x-killustrator                      kil,"
            + "application/x-kpresenter                        kpr kpt,"
            + "application/x-kspread                           ksp,"
            + "application/x-kword                             kwd kwt,"
            + "application/x-latex                             latex,"
            + "application/x-lha                               lha,"
            + "application/x-lzh                               lzh,"
            + "application/x-lzx                               lzx,"
            + "application/x-maker                             frm maker frame fm fb book fbdoc,"
            + "application/x-mif                               mif,"
            + "application/x-msdos-program                     com exe bat dll,"
            + "application/x-msi                               msi,"
            + "application/x-netcdf                            nc cdf,"
            + "application/x-ns-proxy-autoconfig               pac,"
            + "application/x-object                            o,"
            + "application/x-ogg                               ogg,"
            + "application/x-oz-application                    oza,"
            + "application/x-perl                              pl pm,"
            + "application/x-pkcs7-crl                         crl,"
            + "application/x-redhat-package-manager            rpm,"
            + "application/x-shar                              shar,"
            + "application/x-shockwave-flash                   swf swfl,"
            + "application/x-star-office                       sdd sda,"
            + "application/x-stuffit                           sit,"
            + "application/x-sv4cpio                           sv4cpio,"
            + "application/x-sv4crc                            sv4crc,"
            + "application/x-tar                               tar,"
            + "application/x-tex-gf                            gf,"
            + "application/x-tex-pk                            pk PK,"
            + "application/x-texinfo                           texinfo texi,"
            + "application/x-trash                             ~ % bak old sik,"
            + "application/x-troff                             t tr roff,"
            + "application/x-troff-man                         man,"
            + "application/x-troff-me                          me,"
            + "application/x-troff-ms                          ms,"
            + "application/x-ustar                             ustar,"
            + "application/x-wais-source                       src,"
            + "application/x-wingz                             wz,"
            + "application/x-x509-ca-cert                      crt,"
            + "audio/basic                                     au snd,"
            + "audio/midi                                      mid midi,"
            + "audio/mpeg                                      mpga mpega mp2 mp3,"
            + "audio/mpegurl                                   m3u,"
            + "audio/prs.sid                                   sid,"
            + "audio/x-aiff                                    aif aiff aifc,"
            + "audio/x-gsm                                     gsm,"
            + "audio/x-pn-realaudio                            ra rm ram,"
            + "audio/x-scpls                                   pls,"
            + "audio/x-wav                                     wav,"
            + "audio/ogg                                       ogg,"
            + "audio/mp4                                       m4a,"
            + "audio/x-aac                                     aac,"
            + "image/bitmap                                    bmp,"
            + "image/gif                                       gif,"
            + "image/ief                                       ief,"
            + "image/jpeg                                      jpeg jpg jpe,"
            + "image/pcx                                       pcx,"
            + "image/png                                       png,"
            + "image/svg+xml                                   svg svgz,"
            + "image/tiff                                      tiff tif,"
            + "image/vnd.wap.wbmp                              wbmp,"
            + "image/x-cmu-raster                              ras,"
            + "image/x-coreldraw                               cdr,"
            + "image/x-coreldrawpattern                        pat,"
            + "image/x-coreldrawtemplate                       cdt,"
            + "image/x-corelphotopaint                         cpt,"
            + "image/x-jng                                     jng,"
            + "image/x-portable-anymap                         pnm,"
            + "image/x-portable-bitmap                         pbm,"
            + "image/x-portable-graymap                        pgm,"
            + "image/x-portable-pixmap                         ppm,"
            + "image/x-rgb                                     rgb,"
            + "image/x-xbitmap                                 xbm,"
            + "image/x-xpixmap                                 xpm,"
            + "image/x-xwindowdump                             xwd,"
            + "text/comma-separated-values                     csv,"
            + "text/css                                        css,"
            + "text/html                                       htm html xhtml,"
            + "text/mathml                                     mml,"
            + "text/plain                                      txt text diff,"
            + "text/richtext                                   rtx,"
            + "text/tab-separated-values                       tsv,"
            + "text/vnd.wap.wml                                wml,"
            + "text/vnd.wap.wmlscript                          wmls,"
            + "text/xml                                        xml,"
            + "text/x-c++hdr                                   h++ hpp hxx hh,"
            + "text/x-c++src                                   c++ cpp cxx cc,"
            + "text/x-chdr                                     h,"
            + "text/x-csh                                      csh,"
            + "text/x-csrc                                     c,"
            + "text/x-java                                     java,"
            + "text/x-moc                                      moc,"
            + "text/x-pascal                                   p pas,"
            + "text/x-setext                                   etx,"
            + "text/x-sh                                       sh,"
            + "text/x-tcl                                      tcl tk,"
            + "text/x-tex                                      tex ltx sty cls,"
            + "text/x-vcalendar                                vcs,"
            + "text/x-vcard                                    vcf,"
            + "video/dl                                        dl,"
            + "video/fli                                       fli,"
            + "video/gl                                        gl,"
            + "video/mpeg                                      mpeg mpg mpe,"
            + "video/quicktime                                 qt mov,"
            + "video/x-mng                                     mng,"
            + "video/x-ms-asf                                  asf asx,"
            + "video/x-msvideo                                 avi,"
            + "video/x-sgi-movie                               movie,"
            + "video/ogg                                       ogv,"
            + "video/mp4                                       mp4,"
            + "x-world/x-vrml                                  vrm vrml wrl";

    /**
     * File extension to MIME type mapping. All extensions are in lower case.
     */
    private static final Map<String, String> EXT_TO_MIME_MAP = new ConcurrentHashMap<>();

    static {

        // Initialize extension to MIME map
        final StringTokenizer lines = new StringTokenizer(
                INITIAL_EXT_TO_MIME_MAP, ",");
        while (lines.hasMoreTokens()) {
            final String line = lines.nextToken();
            final StringTokenizer exts = new StringTokenizer(line);
            final String type = exts.nextToken();
            while (exts.hasMoreTokens()) {
                final String ext = exts.nextToken();
                addExtension(ext, type);
            }
        }

    }

    /**
     * Gets the mime-type of a file. Currently the mime-type is resolved based
     * only on the file name extension.
     *
     * @param fileName
     *            the name of the file whose mime-type is requested.
     * @return mime-type <code>String</code> for the given filename
     */
    public static String getMIMEType(String fileName) {

        // Checks for nulls
        if (fileName == null) {
            throw new NullPointerException("Filename can not be null");
        }

        // Calculates the extension of the file
        int dotIndex = fileName.indexOf('.');
        while (dotIndex >= 0 && fileName.indexOf('.', dotIndex + 1) >= 0) {
            dotIndex = fileName.indexOf('.', dotIndex + 1);
        }
        dotIndex++;

        if (fileName.length() > dotIndex) {
            String ext = fileName.substring(dotIndex);

            // Ignore any query parameters
            int queryStringStart = ext.indexOf('?');
            if (queryStringStart > 0) {
                ext = ext.substring(0, queryStringStart);
            }

            // Return type from extension map, if found
            final String type = EXT_TO_MIME_MAP
                    .get(ext.toLowerCase(Locale.ROOT));
            if (type != null) {
                return type;
            }
        }

        return DEFAULT_MIME_TYPE;
    }

    /**
     * Gets the mime-type for a file. Currently the returned file type is
     * resolved by the filename extension only.
     *
     * @param file
     *            the file whose mime-type is requested.
     * @return the files mime-type <code>String</code>
     */
    public static String getMIMEType(File file) {

        // Checks for nulls
        if (file == null) {
            throw new NullPointerException("File can not be null");
        }

        // Directories
        if (file.isDirectory()) {
            // Drives
            if (file.getParentFile() == null) {
                return "inode/drive";
            } else {
                return "inode/directory";
            }
        }

        // Return type from extension
        return getMIMEType(file.getName());
    }

    /**
     * Adds a mime-type mapping for the given filename extension. If the
     * extension is already in the internal mapping it is overwritten.
     *
     * @param extension
     *            the filename extension to be associated with
     *            <code>MIMEType</code>.
     * @param mimeType
     *            the new mime-type for <code>extension</code>.
     */
    public static void addExtension(String extension, String mimeType) {
        EXT_TO_MIME_MAP.put(extension.toLowerCase(Locale.ROOT), mimeType);
    }

    /**
     * Gets the internal file extension to mime-type mapping.
     *
     * @return unmodifiable map containing the current file extension to
     *         mime-type mapping
     */
    public static Map<String, String> getExtensionToMIMETypeMapping() {
        return Collections.unmodifiableMap(EXT_TO_MIME_MAP);
    }

    protected FileTypeResolver() {
    }
}
--------------------------------------------------------------------------------------------------------
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.Conventions;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.test.context.TestContext;
import org.springframework.test.context.support.AbstractTestExecutionListener;
import org.vaadin.spring.test.annotation.VaadinAppConfiguration;

/**
 * @author Petter Holmström (petter@vaadin.com)
 */
public class VaadinTestExecutionListener extends AbstractTestExecutionListener {

    public static final String SET_UP_SCOPES_ATTRIBUTE = Conventions.getQualifiedAttributeName(
            VaadinTestExecutionListener.class, "setUpScopes");
    private static final Logger logger = LoggerFactory.getLogger(VaadinTestExecutionListener.class);

    @Override
    public void prepareTestInstance(TestContext testContext) throws Exception {
        setUpVaadinScopesIfNecessary(testContext);
    }

    @Override
    public void beforeTestMethod(TestContext testContext) throws Exception {
        setUpVaadinScopesIfNecessary(testContext);
    }

    @Override
    public void afterTestMethod(TestContext testContext) throws Exception {
        tearDownVaadinScopesIfNecessary(testContext);
    }

    private boolean notAnnotatedWithVaadinAppConfiguration(TestContext testContext) {
        return AnnotationUtils.findAnnotation(testContext.getTestClass(), VaadinAppConfiguration.class) == null;
    }

    private static boolean alreadySetUpVaadinScopes(TestContext testContext) {
        return Boolean.TRUE.equals(testContext.getAttribute(SET_UP_SCOPES_ATTRIBUTE));
    }

    private synchronized void setUpVaadinScopesIfNecessary(TestContext testContext) {
        if (notAnnotatedWithVaadinAppConfiguration(testContext) || alreadySetUpVaadinScopes(testContext)) {
            logger.debug("No need to set up Vaadin scopes for test context [{}]", testContext);
            return;
        }

        VaadinScopes.setUp();
        testContext.setAttribute(SET_UP_SCOPES_ATTRIBUTE, Boolean.TRUE);
    }

    private synchronized void tearDownVaadinScopesIfNecessary(TestContext testContext) {
        if (notAnnotatedWithVaadinAppConfiguration(testContext) || !alreadySetUpVaadinScopes(testContext)) {
            logger.debug("No need to tear down Vaadin scopes for test context [{}]", testContext);
            return;
        }
        VaadinScopes.tearDown();
        testContext.removeAttribute(SET_UP_SCOPES_ATTRIBUTE);
    }
}
--------------------------------------------------------------------------------------------------------
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@WebAppConfiguration
@TestExecutionListeners({
        VaadinTestExecutionListener.class,
        DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class
})
public @interface VaadinAppConfiguration {
}
--------------------------------------------------------------------------------------------------------
@Configuration
public class TaxiFareMVCConfig implements WebMvcConfigurer {
 
    @Autowired
    private TaxiFareRequestInterceptor taxiFareRequestInterceptor;
 
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(taxiFareRequestInterceptor)
          .addPathPatterns("/**/taxifare/**/");
    }
}
--------------------------------------------------------------------------------------------------------
{
  "timestamp": 1500645243383,
  "status": 400,
  "error": "Bad Request",
  "exception": "org.springframework.http.converter
    .HttpMessageNotReadableException",
  "message": "Could not read document: Stream closed; 
    nested exception is java.io.IOException: Stream closed",
  "path": "/rest-log/taxifare/calculate/"
}
--------------------------------------------------------------------------------------------------------

IDP_HOST=idp.ssocircle.com
IDP_PORT=443
CERTIFICATE_FILE=ssocircle.cert
KEYSTORE_FILE=samlKeystore.jks
KEYSTORE_PASSWORD=nalle123

openssl s_client -host $IDP_HOST -port $IDP_PORT -prexit -showcerts </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > $CERTIFICATE_FILE
keytool -delete -alias ssocircle -keystore $KEYSTORE_FILE -storepass $KEYSTORE_PASSWORD
keytool -import -alias ssocircle -file $CERTIFICATE_FILE -keystore $KEYSTORE_FILE -storepass $KEYSTORE_PASSWORD -noprompt

rm $CERTIFICATE_FILE
--------------------------------------------------------------------------------------------------------
    /**
     * A request wrapper that overrides the value of the remember me parameter based on the values provided in the
     * constructor. This makes it possible to plug into the existing remember me architecture of Spring Security.
     */
    protected final class RememberMeRequestWrapper extends HttpServletRequestWrapper {

        private final String parameter;
        private final String rememberMe;

        public RememberMeRequestWrapper(HttpServletRequest request, boolean rememberMe, String parameter) {
            super(request);
            this.rememberMe = Boolean.toString(rememberMe);
            this.parameter = parameter;
        }

        @Override
        public String getParameter(String name) {
            if (parameter.equals(name)) {
                return rememberMe;
            }
            return super.getParameter(name);
        }
    }
--------------------------------------------------------------------------------------------------------
import org.mybatis.generator.api.IntrospectedColumn;
import org.mybatis.generator.api.IntrospectedTable;
import org.mybatis.generator.api.dom.java.Field;
import org.mybatis.generator.internal.DefaultCommentGenerator;

/**
 * 生成model中，字段增加注释
 */
public class CommentGenerator extends DefaultCommentGenerator {

	@Override
	public void addFieldComment(Field field, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) {
		super.addFieldComment(field, introspectedTable, introspectedColumn);
		if (introspectedColumn.getRemarks() != null && !introspectedColumn.getRemarks().equals("")) {
			field.addJavaDocLine("/**");
			field.addJavaDocLine(" * " + introspectedColumn.getRemarks());
			addJavadocTag(field, false);
			field.addJavaDocLine(" */");
		}
	}

}
--------------------------------------------------------------------------------------------------------

import org.springframework.security.config.annotation.SecurityConfigurerAdapter;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.DefaultSecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

/**
 * @author Philip W. Sorst (philip@sorst.net)
 * @author Josh Long (josh@joshlong.com)
 */
public class XAuthTokenConfigurer extends SecurityConfigurerAdapter<DefaultSecurityFilterChain, HttpSecurity> {

	private UserDetailsService detailsService;

	public XAuthTokenConfigurer(UserDetailsService detailsService) {
		this.detailsService = detailsService;
	}
	
	@Override
	public void configure(HttpSecurity http) throws Exception {
		XAuthTokenFilter customFilter = new XAuthTokenFilter(detailsService);
		http.addFilterBefore(customFilter, UsernamePasswordAuthenticationFilter.class);
	}

}
--------------------------------------------------------------------------------------------------------

import com.timeyang.data.BaseEntity;
import org.springframework.data.mongodb.core.mapping.event.AbstractMongoEventListener;
import org.springframework.data.mongodb.core.mapping.event.BeforeSaveEvent;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.Date;

/**
 * @author yangck
 */
@Component
public class BeforeSaveListener extends AbstractMongoEventListener<BaseEntity> {
    @Override
    public void onBeforeSave(BeforeSaveEvent<BaseEntity> event) {
        Date date = Date.from(Instant.now());
        if(event.getSource().getCreatedAt() == null)
            event.getSource().setCreatedAt(date);
        event.getSource().setLastModified(date);
        super.onBeforeSave(event);
    }
}
--------------------------------------------------------------------------------------------------------

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

/**
 * 目录服务
 *
 * @author chaokunyang
 */
@SpringBootApplication
@EnableHystrix
@EnableDiscoveryClient
public class CatalogServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(CatalogServiceApplication.class, args);
    }

    @Bean

    
    @LoadBalanced
    public RestTemplate loadRestTemplate() {
        return new RestTemplate();
    }

}
--------------------------------------------------------------------------------------------------------
user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    gzip  on;

    include /etc/nginx/conf.d/*.conf;

    server {
        listen 80;
        server_name atseashop.com;
        return 301 https://$host$request_uri;
    }

    server {
        listen 443;
        ssl on;
        ssl_certificate /run/secrets/revprox_cert;
        ssl_certificate_key /run/secrets/revprox_key;
        server_name atseashop.com;
        access_log /dev/stdout;
        error_log /dev/stderr;

        location / {
            proxy_pass http://appserver:8080;
        }
    }
}
--------------------------------------------------------------------------------------------------------
@authcomment@

# TYPE  DATABASE        USER            ADDRESS                 METHOD

@remove-line-for-nolocal@
# "local" is for Unix domain socket connections only
@@remove-line-for-nolocal@local all all @authmethod@
# IPv4 local connections:
host    all             all             0.0.0.0/0            trust
# IPv6 local connections:
host    all             all             ::1/128                 @authmethodhost@
# Allow replication connections from localhost, by a user with the
# replication privilege.
@remove-line-for-nolocal@
#local   replication     @default_username@                                @authmethodlocal@
#host    replication     @default_username@        127.0.0.1/32            @authmethodhost@
#host    replication     @default_username@        ::1/128                 @authmethodhost@
--------------------------------------------------------------------------------------------------------
    public static char regularize(char input) {
        if (input == 12288) {
            input = (char) 32;
        } else if (input > 65280 && input < 65375) {
            input = (char) (input - 65248);
        } else {
            char a = 'A';
            char z = 'Z';
            if (input >= a && input <= z) {
                input += 32;
            }
        }
        return input;
    }
--------------------------------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<configuration scan="true">

    <appender name="stdout" class="ch.qos.logback.core.ConsoleAppender">
        <encoder charset="UTF-8">
            <pattern>[%d{yyyy-MM-dd HH:mm:ss} [%thread] %highlight(%-5level) %cyan(%logger{15}) - %highlight(%msg) %n</pattern>
        </encoder>
    </appender>

    <root level="INFO">
        <appender-ref ref="stdout"/>
    </root>

    <logger name="info.xiaomo" level="DEBUG"/>

</configuration>
--------------------------------------------------------------------------------------------------------
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.Properties;

/**
 * @author : xiaomo
 */
public class PropsUtil {

    /**
     * 构造函数
     * 找到数据源，并用这个数据源创建连接
     */
    private PropsUtil() {

    }

    public static Properties getProperties(String url) {
        Properties properties = null;
        try {
            InputStream fs = new FileInputStream(url);
            properties = new Properties();
            properties.load(fs);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return properties;
    }

}
--------------------------------------------------------------------------------------------------------
    private static byte charToByte(char c) {
        return (byte) "0123456789ABCDEF".indexOf(c);
    }
--------------------------------------------------------------------------------------------------------
rver.port=8080
server.session.timeout=1800
server.max-http-header-size=20971520
# \u914D\u7F6E\u8FD9\u4E2A\u503C\u5C31\u53EF\u4EE5\u683C\u5F0F\u5316\u65F6\u95F4
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8

logging.config=classpath:config/logback-dev.xml
server.port=8080
server.session.timeout=1800
server.max-http-header-size=20971520

# redis
# Redis\u6570\u636E\u5E93\u7D22\u5F15\uFF08\u9ED8\u8BA4\u4E3A0\uFF09
spring.redis.database=0
spring.redis.host=ip
spring.redis.port=6379
# Redis\u670D\u52A1\u5668\u8FDE\u63A5\u5BC6\u7801\uFF08\u9ED8\u8BA4\u4E3A\u7A7A\uFF09
spring.redis.password=
# \u8FDE\u63A5\u6C60\u6700\u5927\u8FDE\u63A5\u6570\uFF08\u4F7F\u7528\u8D1F\u503C\u8868\u793A\u6CA1\u6709\u9650\u5236\uFF09
spring.redis.pool.max-active=8
# \u8FDE\u63A5\u6C60\u6700\u5927\u963B\u585E\u7B49\u5F85\u65F6\u95F4\uFF08\u4F7F\u7528\u8D1F\u503C\u8868\u793A\u6CA1\u6709\u9650\u5236\uFF09
spring.redis.pool.max-wait=-1
spring.redis.pool.max-idle=8
spring.redis.pool.min-idle=0
spring.redis.timeout=0
--------------------------------------------------------------------------------------------------------
import com.alibaba.druid.pool.DruidDataSource;
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.sql.DataSource;

@MapperScan("com.my.blog.website.dao")
@SpringBootApplication
@EnableTransactionManagement
public class CoreApplication {
    @Bean(initMethod = "init", destroyMethod = "close")
    @ConfigurationProperties(prefix = "spring.datasource")
    public DataSource dataSource() {
        return new DruidDataSource();
    }

    @Bean
    public SqlSessionFactory sqlSessionFactoryBean() throws Exception {
        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource());
        sqlSessionFactoryBean.setMapperLocations(resolver.getResources("classpath*:/mapper/*Mapper.xml"));
        return sqlSessionFactoryBean.getObject();
    }

    @Bean
    public PlatformTransactionManager transactionManager() {
        return new DataSourceTransactionManager(dataSource());
    }


    public static void main(String[] args) {
        SpringApplication.run(CoreApplication.class, args);
    }
}
--------------------------------------------------------------------------------------------------------
import org.modelmapper.ConfigurationException;
import org.modelmapper.spi.ErrorMessage;

import org.springframework.boot.diagnostics.AbstractFailureAnalyzer;
import org.springframework.boot.diagnostics.FailureAnalysis;

public class ModelMapConfigurationFailureAnalyzer
		extends AbstractFailureAnalyzer<ConfigurationException> {

	@Override
	protected FailureAnalysis analyze(Throwable rootFailure,
			ConfigurationException cause) {
		StringBuilder description = new StringBuilder();
		description.append("ModelMapper configuration failed:\n");
		for (ErrorMessage message : cause.getErrorMessages()) {
			description.append(message.getMessage());
		}
		return new FailureAnalysis(description.toString(),
				"Fix ModelMapper configuration", cause);
	}

}
--------------------------------------------------------------------------------------------------------
import com.ctrip.framework.apollo.spring.annotation.EnableApolloConfig;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableApolloConfig
@SpringBootApplication
@EnableTransactionManagement
@MapperScan(basePackages = "cn.binux.mapper")
public class XbinStoreServiceOrderApplication {

	public static void main(String[] args) {
		SpringApplication.run(XbinStoreServiceOrderApplication.class, args);

	}
}
--------------------------------------------------------------------------------------------------------

    @Override
    public int compareTo(Version o) {
        if (null == o) {
            return -1;
        }
        if (o.getMajorVersion() > this.getMajorVersion()) {
            return -1;
        }
        if (o.getMajorVersion() == this.getMajorVersion()) {
            if (o.getMinorVersion() > this.getMinorVersion()) {
                return -1;
            }
            if (o.getMinorVersion() == this.getMinorVersion()) {
                if (o.getRevisionVersion() > this.getRevisionVersion()) {
                    return -1;
                }
                if (o.getRevisionVersion() == this.getRevisionVersion()) {
                    return 0;
                }
                return 1;
            } else {
                return 1;
            }
        } else {
            return 1;
        }
    }
--------------------------------------------------------------------------------------------------------
   @Bean
    public AopMethodAuthorizeDefinitionCustomizerParser customizerParser(){
        //自定义权限声明
        //所有控制都通过
        return (type,method,context) -> EmptyAuthorizeDefinition.instance;
    }
	
	@EnableAspectJAutoProxy
	

import org.hswebframework.web.authorization.cloud.EnableAuthorizationClient;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.feign.EnableFeignClients;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;
import org.springframework.context.annotation.Configuration;

@SpringBootApplication
@EnableDiscoveryClient
@EnableHystrix
@Configuration
@EnableFeignClients("org.hswebframework.web.authorization.cloud.client.feign")
@EnableAuthorizationClient
public class Service01Application {

    public static void main(String[] args) {
        SpringApplication.run(Service01Application.class, args);
    }
}
--------------------------------------------------------------------------------------------------------
import org.hswebframework.web.authorization.Authentication;
import org.hswebframework.web.authorization.AuthenticationManager;

import java.util.HashMap;
import java.util.Map;

public class MemoryAuthenticationManager implements AuthenticationManager {
    static Map<String, Authentication> users = new HashMap<>();

    public static void addAuthentication(Authentication authentication) {
        users.put(authentication.getUser().getId(), authentication);
    }

    @Override
    public Authentication getByUserId(String userId) {

        return users.get(userId);
    }

    @Override
    public Authentication sync(Authentication authentication) {
        return authentication;
    }
}
--------------------------------------------------------------------------------------------------------
import com.piggymetrics.auth.service.security.MongoUserDetailsService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.InMemoryTokenStore;

@SpringBootApplication
@EnableResourceServer
@EnableDiscoveryClient
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class AuthApplication {

	public static void main(String[] args) {
		SpringApplication.run(AuthApplication.class, args);
	}

	@Configuration
	@EnableWebSecurity
	protected static class webSecurityConfig extends WebSecurityConfigurerAdapter {

		@Autowired
		private MongoUserDetailsService userDetailsService;

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			// @formatter:off
			http
				.authorizeRequests().anyRequest().authenticated()
			.and()
				.csrf().disable();
			// @formatter:on
		}

		@Override
		protected void configure(AuthenticationManagerBuilder auth) throws Exception {
			auth.userDetailsService(userDetailsService)
					.passwordEncoder(new BCryptPasswordEncoder());
		}

		@Override
		@Bean
		public AuthenticationManager authenticationManagerBean() throws Exception {
			return super.authenticationManagerBean();
		}
	}

	@Configuration
	@EnableAuthorizationServer
	protected static class OAuth2AuthorizationConfig extends AuthorizationServerConfigurerAdapter {

		private TokenStore tokenStore = new InMemoryTokenStore();

		@Autowired
		@Qualifier("authenticationManagerBean")
		private AuthenticationManager authenticationManager;

		@Autowired
		private MongoUserDetailsService userDetailsService;

		@Autowired
		private Environment env;

		@Override
		public void configure(ClientDetailsServiceConfigurer clients) throws Exception {

			// TODO persist clients details

			// @formatter:off
			clients.inMemory()
					.withClient("browser")
					.authorizedGrantTypes("refresh_token", "password")
					.scopes("ui")
			.and()
					.withClient("account-service")
					.secret(env.getProperty("ACCOUNT_SERVICE_PASSWORD"))
					.authorizedGrantTypes("client_credentials", "refresh_token")
					.scopes("server")
			.and()
					.withClient("statistics-service")
					.secret(env.getProperty("STATISTICS_SERVICE_PASSWORD"))
					.authorizedGrantTypes("client_credentials", "refresh_token")
					.scopes("server")
			.and()
					.withClient("notification-service")
					.secret(env.getProperty("NOTIFICATION_SERVICE_PASSWORD"))
					.authorizedGrantTypes("client_credentials", "refresh_token")
					.scopes("server");
			// @formatter:on
		}

		@Override
		public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
			endpoints
					.tokenStore(tokenStore)
					.authenticationManager(authenticationManager)
					.userDetailsService(userDetailsService);
		}

		@Override
		public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {
			oauthServer
					.tokenKeyAccess("permitAll()")
					.checkTokenAccess("isAuthenticated()");
		}
	}
}
--------------------------------------------------------------------------------------------------------
/* ZOOM AVATAR */
@-webkit-keyframes zoomavatar {
	0% {
		-webkit-transform: scale(0.1);
	}
	60% {
		-webkit-transform: scale(1.3);
	}
	100% {
		-webkit-transform: scale(1);
	}
}
@-moz-keyframes zoomavatar {
	0% {
		-moz-transform: scale(0.1);
	}
	80% {
		-moz-transform: scale(1.3);
	}
	100% {
		-moz-transform: scale(1);
	}
}
@-o-keyframes zoomavatar {
	0% {
		-o-transform: scale(0.1);
	}
	60% {
		-o-transform: scale(1.3);
	}
	100% {
		-o-transform: scale(1);
	}
}
@-ms-keyframes zoomavatar {
	0% {
		-ms-transform: scale(0.1);
	}
	60% {
		-ms-transform: scale(1.3);
	}
	100% {
		-ms-transform: scale(1);
	}
}
@keyframes zoomavatar {
	0% {
		transform: scale(0.1);
	}
	60% {
		transform: scale(1.3);
	}
	100% {
		transform: scale(1);
	}
}
/* UNZOOM AVATAR */
@-webkit-keyframes unzoomavatar {
	0% {
		-webkit-transform: scale(1);
	}
	40% {
		-webkit-transform: scale(1.3);
	}
	100% {
		-webkit-transform: scale(0.1);
	}
}
@-moz-keyframes unzoomavatar {
	0% {
		-moz-transform: scale(1);
	}
	40% {
		-moz-transform: scale(1.3);
	}
	100% {
		-moz-transform: scale(0.1);
	}
}
@-o-keyframes unzoomavatar {
	0% {
		-o-transform: scale(1);
	}
	40% {
		-o-transform: scale(1.3);
	}
	100% {
		-o-transform: scale(0.1);
	}
}
@-ms-keyframes unzoomavatar {
	0% {
		-ms-transform: scale(1);
	}
	40% {
		-ms-transform: scale(1.3);
	}
	100% {
		-ms-transform: scale(0.1);
	}
}
@keyframes unzoomavatar {
	0% {
		transform: scale(1);
	}
	40% {
		transform: scale(1.3);
	}
	100% {
		transform: scale(0.1);
	}
}
/* GO LEFT */
@-webkit-keyframes goleft {
	0% {
		right: 100px; left:0%;
	}
	60% {
		right: 300px; left:-20%;
	}
	100% {
		right: 300px; left:-18%;
	}
}
@-moz-keyframes goleft {
	0% {
		right: 100px; left:0%;
	}
	60% {
		right: 300px; left:-20%;
	}
	100% {
		right: 300px; left:-18%;
	}
}
@-o-keyframes goleft {
	0% {
		right: 100px; left:0%;
	}
	60% {
		right: 300px; left:-20%;
	}
	100% {
		right: 300px; left:-18%;
	}
}
@-ms-keyframes goleft {
	0% {
		right: 100px; left:0%;
	}
	60% {
		right: 300px; left:-20%;
	}
	100% {
		right: 300px; left:-18%;
	}
}
@keyframes goleft {
	0% {
		right: 100px; left:0%;
	}
	60% {
		right: 300px; left:-20%;
	}
	100% {
		right: 300px; left:-18%;
	}
}
/* GO RIGHT */
@-webkit-keyframes goright {
	0% {
		right: -100px; left:0%;
	}
	60% {
		right: -300px; left:20%;
	}
	100% {
		right: -300px; left:18%;
	}
}
@-moz-keyframes goright {
	0% {
		right: -100px; left:0%;
	}
	60% {
		right: -300px; left:20%;
	}
	100% {
		right: -300px; left:18%;
	}
}
@-o-keyframes goright {
	0% {
		right: -100px; left:0%;
	}
	60% {
		right: -300px; left:20%;
	}
	100% {
		right: -300px; left:18%;
	}
}
@-ms-keyframes goright {
	0% {
		right: -100px; left:0%;
	}
	60% {
		right: -300px; left:20%;
	}
	100% {
		right: -300px; left:18%;
	}
}
@keyframes goright {
	0% {
		right: -100px; left:0%;
	}
	60% {
		right: -300px; left:20%;
	}
	100% {
		right: -300px; left:18%;
	}
}
/* GO DOWN */
@-webkit-keyframes godown {
	0% {
		bottom:20%;
	}
	60% {
		bottom:4%;
	}
	100% {
		bottom:8%;
	}
}
@-moz-keyframes godown {
	0% {
		bottom:20%;
	}
	60% {
		bottom:4%;
	}
	100% {
		bottom:8%;
	}
}
@-o-keyframes godown {
	0% {
		bottom:20%;
	}
	60% {
		bottom:4%;
	}
	100% {
		bottom:8%;
	}
}
@-ms-keyframes godown {
	0% {
		bottom:20%;
	}
	60% {
		bottom:4%;
	}
	100% {
		bottom:8%;
	}
}
@keyframes godown {
	0% {
		bottom:20%;
	}
	60% {
		bottom:4%;
	}
	100% {
		bottom:8%;
	}
}
/* PLUS */
@-webkit-keyframes plus {
	0% {
		-webkit-transform: scale(0.85);
	}
	8% {
		-webkit-transform: scale(1);
	}
	80% {
		-webkit-transform: scale(0.85);
	}
	100% {
		-webkit-transform: scale(0.85);
	}
}
@-moz-keyframes plus {
	0% {
		-moz-transform: scale(0.85);
	}
	8% {
		-moz-transform: scale(1);
	}
	80% {
		-moz-transform: scale(0.85);
	}
	100% {
		-moz-transform: scale(0.85);
	}
}
@-o-keyframes plus {
	0% {
		-o-transform: scale(0.85);
	}
	8% {
		-o-transform: scale(1);
	}
	80% {
		-o-transform: scale(0.85);
	}
	100% {
		-o-transform: scale(0.85);
	}
}
@-ms-keyframes plus {
	0% {
		-ms-transform: scale(0.85);
	}
	8% {
		-ms-transform: scale(1);
	}
	80% {
		-ms-transform: scale(0.85);
	}
	100% {
		-ms-transform: scale(0.85);
	}
}
@keyframes plus {
	0% {
		transform: scale(0.85);
	}
	8% {
		transform: scale(1);
	}
	80% {
		transform: scale(0.85);
	}
	100% {
		transform: scale(0.85);
	}
}

/* SLIDER */
@-webkit-keyframes endoflist {
	0% {
		-webkit-transform: translateY(0px);
	}
	20% {
		-webkit-transform: translateY(-60px);
	}
	100% {
		-webkit-transform: translateY(0px);
	}
}
@-moz-keyframes endoflist {
	0% {
		-moz-transform: translateY(0px);
	}
	20% {
		-moz-transform: translateY(-60px);
	}
	100% {
		-moz-transform: translateY(0px);
	}
}
@-o-keyframes endoflist {
	0% {
		-o-transform: translateY(0px);
	}
	20% {
		-o-transform: translateY(-60px);
	}
	100% {
		-o-transform: translateY(0px);
	}
}
@-ms-keyframes endoflist {
	0% {
		-ms-transform: translateY(0px);
	}
	20% {
		-ms-transform: translateY(-60px);
	}
	100% {
		-ms-transform: translateY(0px);
	}
}
@keyframes endoflist {
	0% {
		transform: translateY(0px);
	}
	20% {
		transform: translateY(-60px);
	}
	100% {
		transform: translateY(0px);
	}
}

@-webkit-keyframes startoflist {
	0% {
		-webkit-transform: translateY(0px);
	}
	20% {
		-webkit-transform: translateY(60px);
	}
	100% {
		-webkit-transform: translateY(0px);
	}
}
@-moz-keyframes startoflist {
	0% {
		-moz-transform: translateY(0px);
	}
	20% {
		-moz-transform: translateY(60px);
	}
	100% {
		-moz-transform: translateY(0px);
	}
}
@-o-keyframes startoflist {
	0% {
		-o-transform: translateY(0px);
	}
	20% {
		-o-transform: translateY(60px);
	}
	100% {
		-o-transform: translateY(0px);
	}
}
@-ms-keyframes startoflist {
	0% {
		-ms-transform: translateY(0px);
	}
	20% {
		-ms-transform: translateY(60px);
	}
	100% {
		-ms-transform: translateY(0px);
	}
}
@keyframes startoflist {
	0% {
		transform: translateY(0px);
	}
	20% {
		transform: translateY(60px);
	}
	100% {
		transform: translateY(0px);
	}
}


@-webkit-keyframes frameanimate {
	0% {
		-webkit-transform: translateY(-284px);
	}
	50% {
		-webkit-transform: translateY(50px);
	}
	100% {
		-webkit-transform: translateY(0px);
	}
}
@-moz-keyframes frameanimate {
	0% {
		-moz-transform: translateY(-284px);
	}
	50% {
		-moz-transform: translateY(100px);
	}
	100% {
		-moz-transform: translateY(0px);
	}
}
@-o-keyframes frameanimate {
	0% {
		-o-transform: translateY(-284px);
	}
	50% {
		-o-transform: translateY(100px);
	}
	100% {
		-o-transform: translateY(0px);
	}
}
@-ms-keyframes frameanimate {
	0% {
		-ms-transform: translateY(-284px);
	}
	50% {
		-ms-transform: translateY(100px);
	}
	100% {
		-ms-transform: translateY(0px);
	}
}
@keyframes frameanimate {
	0% {
		transform: translateY(-284px);
	}
	50% {
		transform: translateY(100px);
	}
	100% {
		transform: translateY(0px);
	}
}

/*MODAL WINDOWS*/

/* MODAL FORWARD */
@-webkit-keyframes modalforward {
	0% {
		-webkit-transform: scale(0.4);
	}
	60% {
		-webkit-transform: scale(1.1);
	}
	100% {
		-webkit-transform: scale(1);
	}
}
@-moz-keyframes modalforward {
	0% {
		-moz-transform: scale(0.4);
	}
	80% {
		-moz-transform: scale(1.1);
	}
	100% {
		-moz-transform: scale(1);
	}
}
@-o-keyframes modalforward {
	0% {
		-o-transform: scale(0.4);
	}
	60% {
		-o-transform: scale(1.1);
	}
	100% {
		-o-transform: scale(1);
	}
}
@-ms-keyframes modalforward {
	0% {
		-ms-transform: scale(0.4);
	}
	60% {
		-ms-transform: scale(1.1);
	}
	100% {
		-ms-transform: scale(1);
	}
}
@keyframes modalforward {
	0% {
		transform: scale(0.4);
	}
	60% {
		transform: scale(1.1);
	}
	100% {
		transform: scale(1);
	}
}
/* UNZOOM REVERSE */
@-webkit-keyframes modalreverse {
	0% {
		-webkit-transform: scale(1);
	}
	40% {
		-webkit-transform: scale(1.06);
	}
	100% {
		-webkit-transform: scale(0.6);
	}
}
@-moz-keyframes modalreverse {
	0% {
		-moz-transform: scale(1);
	}
	40% {
		-moz-transform: scale(1.06);
	}
	100% {
		-moz-transform: scale(0.6);
	}
}
@-o-keyframes modalreverse {
	0% {
		-o-transform: scale(1);
	}
	40% {
		-o-transform: scale(1.06);
	}
	100% {
		-o-transform: scale(0.6);
	}
}
@-ms-keyframes modalreverse {
	0% {
		-ms-transform: scale(1);
	}
	40% {
		-ms-transform: scale(1.06);
	}
	100% {
		-ms-transform: scale(0.6);
	}
}
@keyframes modalreverse {
	0% {
		transform: scale(1);
	}
	40% {
		transform: scale(1.06);
	}
	100% {
		transform: scale(0.6);
	}
}
/* MODAL VALUE ERROR */
@-webkit-keyframes modalvalueerror {
	0% {
		-webkit-transform: scale(1);
	}
	50% {
		-webkit-transform: scale(1.5);
	}
	100% {
		-webkit-transform: scale(1);
	}
}
@-moz-keyframes modalvalueerror {
	0% {
		-moz-transform: scale(1);
	}
	40% {
		-moz-transform: scale(1.5);
	}
	100% {
		-moz-transform: scale(1);
	}
}
@-o-keyframes modalvalueerror {
	0% {
		-o-transform: scale(1);
	}
	40% {
		-o-transform: scale(1.5);
	}
	100% {
		-o-transform: scale(1);
	}
}
@-ms-keyframes modalvalueerror {
	0% {
		-ms-transform: scale(1);
	}
	40% {
		-ms-transform: scale(1.5);
	}
	100% {
		-ms-transform: scale(1);
	}
}
@keyframes modalvalueerror {
	0% {
		transform: scale(1);
	}
	40% {
		transform: scale(1.5);
	}
	100% {
		transform: scale(1);
	}
}
/* NEW ITEM ADDED */
@-webkit-keyframes newitemadded {
	20% {
		background-color: #f2f2f2;
	}
	70% {
		background-color: #f2f2f2;
	}
	100% {
		background-color: white;
	}
}
@-moz-keyframes newitemadded {
	30% {
		background-color: #f2f2f2;
	}
	70% {
		background-color: #f2f2f2;
	}
	100% {
		background-color: white;
	}
}
@-o-keyframes newitemadded {
	30% {
		background-color: #f2f2f2;
	}
	70% {
		background-color: #f2f2f2;
	}
	100% {
		background-color: white;
	}
}
@-ms-keyframes newitemadded {
	30% {
		background-color: #f2f2f2;
	}
	70% {
		background-color: #f2f2f2;
	}
	100% {
		background-color: white;
	}
}
@keyframes newitemadded {
	30% {
		background-color: #f2f2f2;
	}
	70% {
		background-color: #f2f2f2;
	}
	100% {
		background-color: white;
	}
}
/* BUBBLE */

@-webkit-keyframes bubble {
	5% {
		opacity: 0;
		background-position: -280px 0;
		top: 21px; right: 10px;
	}
	10% {
		opacity: 0;
		background-position: -240px 0;
		top: 12px; right: 12px;
	}
	40% {
		opacity: 1;
		background-position: -240px 0;
		top: 12px; right: 12px;
	}
	80% {
		opacity: 1;
		background-position: -240px 0;
		top: 12px; right: 12px;
	}
	90% {
		opacity: 0;
		background-position: -240px 0;
		top: 12px; right: 12px;
	}
	95% {
		opacity: 0;
		background-position: -280px 0;
		top: 21px; right: 10px;
	}
	100% {
		opacity: 1;
		background-position: -280px 0;
		top: 21px; right: 10px;
	}
}
@-moz-keyframes bubble {
	5% {
		opacity: 0;
		background-position: -280px 0;
		top: 21px; right: 10px;
	}
	10% {
		opacity: 0;
		background-position: -240px 0;
		top: 12px; right: 12px;
	}
	40% {
		opacity: 1;
		background-position: -240px 0;
		top: 12px; right: 12px;
	}
	80% {
		opacity: 1;
		background-position: -240px 0;
		top: 12px; right: 12px;
	}
	90% {
		opacity: 0;
		background-position: -240px 0;
		top: 12px; right: 12px;
	}
	95% {
		opacity: 0;
		background-position: -280px 0;
		top: 21px; right: 10px;
	}
	100% {
		opacity: 1;
		background-position: -280px 0;
		top: 21px; right: 10px;
	}
}
@keyframes bubble {
	5% {
		opacity: 0;
		background-position: -280px 0;
		top: 21px; right: 10px;
	}
	10% {
		opacity: 0;
		background-position: -240px 0;
		top: 12px; right: 12px;
	}
	40% {
		opacity: 1;
		background-position: -240px 0;
		top: 12px; right: 12px;
	}
	80% {
		opacity: 1;
		background-position: -240px 0;
		top: 12px; right: 12px;
	}
	90% {
		opacity: 0;
		background-position: -240px 0;
		top: 12px; right: 12px;
	}
	95% {
		opacity: 0;
		background-position: -280px 0;
		top: 21px; right: 10px;
	}
	100% {
		opacity: 1;
		background-position: -280px 0;
		top: 21px; right: 10px;
	}
}
@-webkit-keyframes spincircle {
	0% {
		-webkit-transform: rotate(0deg);
	}
	95% {
		-webkit-transform: rotate(360deg);
	}
	100% {
		-webkit-transform: rotate(370deg);
	}
}
@-moz-keyframes spincircle {
	0% {
		-moz-transform: rotate(0deg);
	}
	95% {
		-moz-transform: rotate(360deg);
	}
	100% {
		-moz-transform: rotate(370deg);
	}
}
@-o-keyframes spincircle {
	0% {
		-o-transform: rotate(0deg);
	}
	95% {
		-o-transform: rotate(360deg);
	}
	100% {
		-o-transform: rotate(370deg);
	}
}
@-ms-keyframes spincircle {
	0% {
		-ms-transform: rotate(0deg);
	}
	95% {
		-ms-transform: rotate(360deg);
	}
	100% {
		-ms-transform: rotate(370deg);
	}
}
@keyframes spincircle {
	0% {
		transform: rotate(0deg);
	}
	95% {
		-transform: rotate(360deg);
	}
	100% {
		transform: rotate(370deg);
	}
}
--------------------------------------------------------------------------------------------------------
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;
import org.springframework.cloud.netflix.turbine.stream.EnableTurbineStream;

@SpringBootApplication
@EnableTurbineStream
@EnableHystrixDashboard
public class MonitoringApplication {

	public static void main(String[] args) {
		SpringApplication.run(MonitoringApplication.class, args);
	}
}
--------------------------------------------------------------------------------------------------------
import com.mongodb.BasicDBObject;
import com.mongodb.DBObject;
import com.piggymetrics.statistics.domain.timeseries.DataPointId;
import org.springframework.core.convert.converter.Converter;
import org.springframework.stereotype.Component;

@Component
public class DataPointIdWriterConverter implements Converter<DataPointId, DBObject> {

	private static final int FIELDS = 2;

	@Override
	public DBObject convert(DataPointId id) {

		DBObject object = new BasicDBObject(FIELDS);

		object.put("date", id.getDate());
		object.put("account", id.getAccount());

		return object;
	}
}

import com.mongodb.DBObject;
import com.piggymetrics.statistics.domain.timeseries.DataPointId;
import org.springframework.core.convert.converter.Converter;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class DataPointIdReaderConverter implements Converter<DBObject, DataPointId> {

	@Override
	public DataPointId convert(DBObject object) {

		Date date = (Date) object.get("date");
		String account = (String) object.get("account");

		return new DataPointId(account, date);
	}
}
--------------------------------------------------------------------------------------------------------
	/**
	 * {@inheritDoc}
	 */
	@Override
	public BigDecimal convert(Currency from, Currency to, BigDecimal amount) {

		Assert.notNull(amount);

		Map<Currency, BigDecimal> rates = getCurrentRates();
		BigDecimal ratio = rates.get(to).divide(rates.get(from), 4, RoundingMode.HALF_UP);

		return amount.multiply(ratio);
	}
--------------------------------------------------------------------------------------------------------
import com.piggymetrics.auth.domain.User;
import com.piggymetrics.auth.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class MongoUserDetailsService implements UserDetailsService {

	@Autowired
	private UserRepository repository;

	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {

		User user = repository.findOne(username);

		if (user == null) {
			throw new UsernameNotFoundException(username);
		}

		return user;
	}
}
--------------------------------------------------------------------------------------------------------
    private static Properties loadProperties(InputStream inputStream) {
        try {
            final Properties properties = new Properties();
            try {
                properties.load(inputStream);
                return properties;
            } finally {
                if (inputStream != null) {
                    inputStream.close();
                }
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
--------------------------------------------------------------------------------------------------------
import com.metamx.common.logger.Logger;

import java.util.HashMap;
import java.util.Map;

public class KeyedDiff
{
  private static final Logger log = new Logger(KeyedDiff.class);

  private final Map<String, Map<String, Long>> prevs = new HashMap<String, Map<String, Long>>();

  public Map<String, Long> to(String key, Map<String, Long> curr)
  {
    final Map<String, Long> prev = prevs.put(key, curr);
    if (prev != null) {
      return subtract(curr, prev);
    }
    else {
      log.debug("No previous data for key[%s]", key);
      return null;
    }
  }

  public static Map<String, Long> subtract(Map<String, Long> xs, Map<String, Long> ys)
  {
    assert xs.keySet().equals(ys.keySet());
    final Map<String, Long> zs = new HashMap<String, Long>();
    for (String k : xs.keySet()) {
      zs.put(k, xs.get(k) - ys.get(k));
    }
    return zs;
  }
}
--------------------------------------------------------------------------------------------------------
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Properties;

public class Props {

  public static Properties fromFilename(String filename) throws IOException {
    final Properties props = new Properties();
    props.load(new FileInputStream(filename));
    return props;
  }

  public static Properties fromEnvs(String prefix) {
    final Properties props = new Properties();
    for (Map.Entry<String, String> env: System.getenv().entrySet()) {
      if (env.getKey().startsWith(prefix)) {
        props.put(env.getKey().replaceAll("_", "."), env.getValue());
      }
    }
    return props;
  }

}
--------------------------------------------------------------------------------------------------------
import javax.servlet.http.Cookie;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * A Collection of Cookies that allows modification - unlike a mere array.
 * <p>
 * Since {@link Cookie} doesn't implement <code>hashCode</code> nor <code>equals</code>,
 * we cannot simply put it into a <code>HashSet</code>.
 */
public class CookieCollection implements Collection<Cookie> {
    private final Map<String, Cookie> cookieMap;

    public CookieCollection() {
        cookieMap = new HashMap<>();
    }

    public CookieCollection(Cookie... cookies) {
        this(Arrays.asList(cookies));
    }

    public CookieCollection(Collection<? extends Cookie> cookies) {
        cookieMap = new HashMap<>(cookies.size());
        addAll(cookies);
    }

    @Override
    public int size() {
        return cookieMap.size();
    }

    @Override
    public boolean isEmpty() {
        return cookieMap.isEmpty();
    }

    @Override
    public boolean contains(Object o) {
        if(o instanceof String) {
            return cookieMap.containsKey(o);
        }
        if(o instanceof Cookie) {
            return cookieMap.containsValue(o);
        }
        return false;
    }

    @Override
    public Iterator<Cookie> iterator() {
        return cookieMap.values().iterator();
    }

    public Cookie []toArray() {
        Cookie []cookies=new Cookie[cookieMap.size()];
        return toArray(cookies);
    }

    @Override
    public <T> T[] toArray(T[] ts) {
        return cookieMap.values().toArray(ts);
    }

    @Override
    public boolean add(Cookie cookie) {
        if(cookie==null) {
            return false;
        }
        cookieMap.put(cookie.getName(), cookie);
        return true;
    }

    @Override
    public boolean remove(Object o) {
        if(o instanceof String) {
            return cookieMap.remove((String)o) != null;
        }
        if(o instanceof Cookie) {
            Cookie c=(Cookie)o;
            return cookieMap.remove(c.getName()) != null;
        }
        return false;
    }

    public Cookie get(String name) {
        return cookieMap.get(name);
    }

    @Override
    public boolean containsAll(Collection<?> collection) {
        for(Object o : collection) {
            if(!contains(o)) {
                return false;
            }
        }
        return true;
    }

    @Override
    public boolean addAll(Collection<? extends Cookie> collection) {
        boolean result = false;
        for(Cookie cookie : collection) {
            result|= add(cookie);
        }
        return result;
    }

    @Override
    public boolean removeAll(Collection<?> collection) {
        boolean result = false;
        for(Object cookie : collection) {
            result|= remove(cookie);
        }
        return result;
    }

    @Override
    public boolean retainAll(Collection<?> collection) {
        boolean result=false;
        Iterator<Map.Entry<String, Cookie>> it=cookieMap.entrySet().iterator();
        while(it.hasNext()) {
            Map.Entry<String, Cookie> e=it.next();
            if(!collection.contains(e.getKey()) && !collection.contains(e.getValue())) {
                it.remove();
                result=true;
            }
        }
        return result;
    }

    @Override
    public void clear() {
        cookieMap.clear();
    }
}
--------------------------------------------------------------------------------------------------------
<bean id="xaDataSourceMySQL-01" class="com.mysql.cj.jdbc.
MysqlXADataSource">
 <property name="url">
 <value>jdbc:mysql://localhost:3306/ecom01</value>
 </property>
 <property name="user"><value>root</value></property>
 <property name="password"><value>rootpassword</value></property>
</bean>

server.port=8080
spring.datasource.url = jdbc:mysql://localhost:3306/ecom01?autoReconnect=true&
useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&useSSL=false
spring.datasource.username = root
spring.datasource.password = rootpassword
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.
MySQL5Dialect
spring.jpa.hibernate.ddl-auto = update
spring.freemarker.cache=false

ch13\ch13-01\XA-TX-Distributed\Settlement-Web\src\main\resources\
application.properties
server.port=8081
spring.datasource.url=jdbc:derby://localhost:1527/D:/Applns/apache/Derby/
derbydb/exampledb;create=false
spring.datasource.initialize=false
spring.datasource.driver-class-name=org.apache.derby.jdbc.ClientDriver
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.
DerbyTenSevenDialect
spring.freemarker.cache=false
--------------------------------------------------------------------------------------------------------
#0.3.0-alpha-0352-ef7813f
--------------------------------------------------------------------------------------------------------
   @After("@annotation(annotation) || @within(annotation)")
    public void wrapper(
            final JoinPoint pointcut,
            final Wrappable annotation)
--------------------------------------------------------------------------------------------------------
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

/**
 * {@code SpringFrameworkClassAspect} is an example to illustrate that you
 * cannot
 * intercepting Spring framework classes using Spring AOP. This aspect,  fails
 * to intercepts calls to method {@code ignoreResourceType} of class {@code
 * CommonAnnotationBeanPostProcessor}.
 * <p>
 *
 * @author Indra Basak
 * @since 11/11/17
 */
@Component
@Aspect
@Slf4j
public class SpringFrameworkClassAspect {

    @Pointcut("execution(* org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.ignoreResourceType(..))")
    public void intercept() {
    }

    @Around("intercept()")
    public Object advice(ProceedingJoinPoint joinPoint) throws Throwable {
        return joinPoint.getArgs();
    }
}

import lombok.extern.java.Log;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

/**
 * {@code SecurityAspect} intercepts any calls to {@code PersonRepository}
 * and logs oauth2 token and user information.
 * <p>
 *
 * @author Indra Basak
 * @since 10/29/17
 */
@Component
@Aspect
@Log
public class SecurityAspect {

    //@Autowired
    //private OAuth2ClientContext oauth2ClientContext;

    @Pointcut("execution(public * com.basaki.data.repository.PersonRepository.*(..))")
    public void pointcut() {
    }

    @Around("pointcut()")
    public Object advice(ProceedingJoinPoint pjp) throws Throwable {
        log.info(
                "Entering SecurityAspect.advice() in class "
                        + pjp.getSignature().getDeclaringTypeName()
                        + " - method: " + pjp.getSignature().getName());

/*        OAuth2AccessToken accessToken = oauth2ClientContext.getAccessToken();
        log.info("AccessToken:: " + accessToken);
        if (SecurityContextHolder.getContext().getAuthentication()
                instanceof OAuth2Authentication) {
            OAuth2Authentication authentication =
                    (OAuth2Authentication) SecurityContextHolder.getContext().getAuthentication();
            if (authentication.getUserAuthentication() instanceof UsernamePasswordAuthenticationToken) {
                UsernamePasswordAuthenticationToken userToken =
                        (UsernamePasswordAuthenticationToken) authentication.getUserAuthentication();
                log.info("Principal id: " + userToken.getPrincipal());
                if (userToken.getDetails() instanceof Map) {
                    Map details = (Map) userToken.getDetails();
                    log.info("Principal Name: " + details.get("name"));
                }
            }
        }*/

        return pjp.proceed();
    }
}

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

/**
 * {@code ParamAspect} is an example of intercepting calls to parameterized
 * method of a generic class and further filtering based on concrete argument
 * type. The paramter information is lost drring erasure. Please see
 * https://www.eclipse.org/aspectj/doc/released/adk15notebook/generics-inAspectJ5.html.
 * <p>
 *
 * @author Indra Basak
 * @since 10/12/17
 */
@Component
@Aspect
public class ParamAspect {

    @Pointcut("execution(public * com.basaki.model.Param+.execute(..))")
    public void pointcut() {
    }

    @Before("pointcut()")
    public void intercept(JoinPoint jp) {
        System.out.println(
                "Entering class: " + jp.getSignature().getDeclaringTypeName() +
                        " - before method: " + jp.getSignature().getName());
        for (Object obj : jp.getArgs()) {
            System.out.println(obj);
        }

        Object[] args = jp.getArgs();
        if (args.length == 1) {
            if (args[0] instanceof String) {
                System.out.println("1. parameter type is string");
            } else {
                System.out.println("2. parameter type is not string");
            }
        }
    }
}

import com.basaki.annotation.NewLogArguments;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Component
@Aspect
@Slf4j
public class NewLogArgumentsAspect {

    @Around("@annotation(annotation) || @within(annotation)")
    public Object logArguments(ProceedingJoinPoint joinPoint,
            NewLogArguments annotation) throws Throwable {
        log.info("Inside NewLogArgumentsAspect.logArguments()");

        return joinPoint.proceed();
    }
}

import java.lang.reflect.Method;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

/**
 * {@code MethodArgValueAspect} intercepts when any method in class {@class
 * BookController} is invoked.
 * <p>
 *
 * @author Indra Basak
 * @since 10/11/17
 */
@Component
@Aspect
@Slf4j
public class MethodArgValueAspect {

    @Pointcut("execution(public * com.basaki.controller.BookController.*(..))")
    public void pointcut() {
    }

    @Around("pointcut()")
    public Object advice(ProceedingJoinPoint pjp) throws Throwable {
        log.info(
                "Entering MethodArgValueAspect.advice() in class "
                        + pjp.getSignature().getDeclaringTypeName()
                        + " - method: " + pjp.getSignature().getName());

        if (pjp.getSignature() instanceof MethodSignature) {
            MethodSignature signature =
                    (MethodSignature) pjp.getSignature();
            Method method = signature.getMethod();

            String type = "";
            Object[] args = pjp.getArgs();
            for (Object arg : args) {
                Class clazz = arg.getClass();
                try {
                    Method mthd = arg.getClass().getMethod("getResponderType");
                    if (mthd != null) {
                        type = (String) clazz.getMethod(
                                "getResponderType").invoke(arg);
                        break;
                    }
                } catch (Exception e) {
                    //do nothing
                }
            }
        }

        return pjp.proceed();
    }
}

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

/**
 * {@code MasterLoggerAspect} intercepts any method in classes under package
 * com.basaki including sub-packages before its execution abd logs a message.
 * <p>
 *
 * @author Indra Basak
 * @since 10/11/17
 */
@Component
@Aspect
public class MasterLoggerAspect {

    //@Pointcut("execution(* com.basaki..*.*(..))")
    public void logForAllMethods() {
    }

    @Before("execution(* com.basaki.controller.*.*(..) )")
    public void doForEveryServicesMethod(JoinPoint jp) {
        System.out.println(
                "hurray! In class: " + jp.getSignature().getDeclaringTypeName() + " - before method: " + jp.getSignature().getName());
    }

    @Before("execution(* com.basaki..*.*(..) )")
    public void doForEveryMainClassMethod(JoinPoint jp) {
        System.out.println(
                "hurray! In class: " + jp.getClass() + " - before method: " + jp.getSignature().getName());
    }
}

import com.basaki.annotation.EnableHttpLogging;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

/**
 * {@code LoggerAspect} intercepts any method tagged with {@code
 * com.basaki.annotation.EnableHttpLogging}. It is an example of {@code Around}
 * aspect.
 * <p>
 *
 * @author Indra Basak
 * @since 10/11/17
 */
@Aspect
@Component
@Slf4j
public class LoggerAspect {

    @Around("execution(* *(..)) && @annotation(annotation)")
    public Object handleController(
            final ProceedingJoinPoint proceedingJoinPoint,
            EnableHttpLogging annotation)
            throws Throwable {

        log.info("controller....before ");
        return proceedingJoinPoint.proceed();

    }
}

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

/**
 * {@code HelloAspect} intercepts all public methods in {@code
 * com.basaki.service.Hello} which as return type of {@code String}.
 * <p>
 *
 * @author Indra Basak
 * @since 10/12/17
 */
@Component
@Aspect
public class HelloAspect {

    @Pointcut("execution(public String com.basaki.service.Hello.*(..))")
    public void pointcut() {
    }

    @Around("pointcut()")
    public Object advice(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("---------- HelloAspect.advice() ");
        System.out.println(
                "In class: " + pjp.getSignature().getDeclaringTypeName() + " - method: " + pjp.getSignature().getName());
        // do something...
        Object result = pjp.proceed();
        // do something...
        return result;
    }
}

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * {@code Wrappable} is annotation for marking a method.
 * <p/>
 * Given a method like this:
 * <pre><code>
 *     {@literal @}Wrappable(name = "fancyName")
 *     public String someMethod(String name) {
 *         return "Hello " + name;
 *     }
 * </code></pre>
 * <p>
 *
 * @author Indra Basak
 * @since 10/4/17
 */
@Inherited
@Documented
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Wrappable {
    String name() default "";
}

java -jar swagger-codegen-cli-2.4.7.jar generate \
  -i http://localhost:8080/v2/api-docs?group=employee \
  -l java 
  -o swagger-codegen-client
--------------------------------------------------------------------------------------------------------
mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes
 -DgroupId=com.wiley.beginningspring -DartifactId=spring-book-ch2-exercise1
--------------------------------------------------------------------------------------------------------
java -cp "/opt/testng-6.8.jar:bin" org.testng.TestNG testng.xml
--------------------------------------------------------------------------------------------------------
/*
 * Swagger Code Generation Example
 * An example of generating client code from a Swagger application using codegen util.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: indra@basak.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client;

import java.io.IOException;

import java.util.Map;
import java.util.List;

/**
 * Callback for asynchronous API call.
 *
 * @param <T> The return type
 */
public interface ApiCallback<T> {
    /**
     * This is called when the API call fails.
     *
     * @param e The exception causing the failure
     * @param statusCode Status code of the response if available, otherwise it would be 0
     * @param responseHeaders Headers of the response if available, otherwise it would be null
     */
    void onFailure(ApiException e, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API call succeeded.
     *
     * @param result The result deserialized from response
     * @param statusCode Status code of the response
     * @param responseHeaders Headers of the response
     */
    void onSuccess(T result, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API upload processing.
     *
     * @param bytesWritten bytes Written
     * @param contentLength content length of request body
     * @param done write end
     */
    void onUploadProgress(long bytesWritten, long contentLength, boolean done);

    /**
     * This is called when the API downlond processing.
     *
     * @param bytesRead bytes Read
     * @param contentLength content lenngth of the response
     * @param done Read end
     */
    void onDownloadProgress(long bytesRead, long contentLength, boolean done);
}
--------------------------------------------------------------------------------------------------------
@JsonSetter(nulls= Nulls.AS_EMPTY)

import com.basaki.model.Book;
import com.basaki.model.Language;
import com.basaki.service.LanguageService;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonNode;
import java.io.IOException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * {@code BookDeserializer} deserializes JSON into a {@code Book} object.
 * <p/>
 *
 * @author Indra Basak
 * @since 10/30/17
 */
@Component
public class BookDeserializer extends JsonDeserializer<Book> {

    @Autowired
    private LanguageService service;

    @Override
    public Book deserialize(JsonParser parser,
            DeserializationContext context) throws IOException, JsonProcessingException {
        Book book = null;

        JsonNode node = parser.readValueAsTree();
        if (node != null) {
            Integer id = null;
            String title = null;
            String author = null;
            Language language = null;

            JsonNode idField = node.get("id");
            if (idField != null) {
                id = Integer.parseInt(idField.asText());
            }

            JsonNode titleField = node.get("title");
            if (idField != null) {
                title = titleField.asText();
            }

            JsonNode authorField = node.get("author");
            if (authorField != null) {
                author = authorField.asText();
            }

            JsonNode langField = node.get("language");
            if (langField != null) {
                JsonNode codeField = node.get("code");
                if (codeField != null) {
                    language = service.read(codeField.asText());
                }
            }

            if (language == null) {
                language = service.read("es");
            }

            book = new Book(id, title, author, language);
        }

        return book;
    }
}

import com.basaki.mapper.BookDelegateDeserializer;
import com.basaki.model.Book;
import com.basaki.service.LanguageService;
import com.fasterxml.jackson.databind.BeanDescription;
import com.fasterxml.jackson.databind.DeserializationConfig;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;
import com.fasterxml.jackson.databind.module.SimpleModule;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver;


/**
 * {@code SpringConfiguration} configures resources for localization, exception
 * handling, etc.
 * <p/>
 *
 * @author Indra Basak
 * @since 10/4/17
 */
@Configuration
public class SpringConfiguration {

    /**
     * Creates the exception resolver bean for converting an exception message
     * to JSON.
     *
     * @return exception resolver
     */
    @Bean
    public ExceptionHandlerExceptionResolver createExceptionResolver() {
        ExceptionHandlerExceptionResolver resolver =
                new ExceptionHandlerExceptionResolver();

        MappingJackson2HttpMessageConverter converter =
                new MappingJackson2HttpMessageConverter();
        converter.setPrefixJson(false);

        List<MediaType> mediaTypes = Arrays.asList(MediaType.TEXT_PLAIN,
                MediaType.APPLICATION_JSON);
        converter.setSupportedMediaTypes(mediaTypes);

        List<HttpMessageConverter<?>> msgConverters = new ArrayList<>();
        msgConverters.add(converter);
        resolver.setMessageConverters(msgConverters);

        return resolver;
    }

    //    @Bean
    //    public Jackson2ObjectMapperBuilder objectMapperBuilder(
    //            LanguageDeserializer deserializer) {
    //        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
    //
    //        SimpleModule module = new SimpleModule();
    //        module.addDeserializer(Language.class, deserializer);
    //        builder.modules(module);
    //
    //        return builder;
    //    }

    //    @Bean
    //    public Jackson2ObjectMapperBuilder objectMapperBuilder(
    //            BookDeserializer deserializer) {
    //        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
    //
    //        SimpleModule module = new SimpleModule();
    //        module.addDeserializer(Book.class, deserializer);
    //        builder.modules(module);
    //
    //        return builder;
    //    }

    @Bean
    public Jackson2ObjectMapperBuilder objectMapperBuilder(
            final LanguageService service) {
        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();

        SimpleModule module = new SimpleModule();
        module.setDeserializerModifier(new BeanDeserializerModifier() {
            @Override
            public JsonDeserializer<?> modifyDeserializer(
                    DeserializationConfig config, BeanDescription beanDesc,
                    JsonDeserializer<?> deserializer) {
                if (beanDesc.getBeanClass() == Book.class) {
                    return new BookDelegateDeserializer(deserializer, service);
                }

                return deserializer;
            }
        });

        builder.modules(module);

        return builder;
    }
}



import com.basaki.service.TenantService;
import java.io.IOException;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.crypto.codec.Base64;
import org.springframework.web.filter.OncePerRequestFilter;

/**
 * {@code CustomPreAuthFilter} is a custom pre-authentication filter.
 * <p/>
 *
 * @author Indra Basak
 * @since 10/5/17
 */
public class CustomPreAuthFilter extends OncePerRequestFilter {

    private TenantService service;

    public CustomPreAuthFilter(TenantService service) {
        this.service = service;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
            HttpServletResponse response,
            FilterChain chain) throws ServletException, IOException {

        String header = request.getHeader("Authorization");

        if (header == null || !header.startsWith("Basic ")) {
            chain.doFilter(request, response);
            return;
        }

        try {
            String[] tokens = extractAndDecodeHeader(header, request);
            assert tokens.length == 2;

            String username = tokens[0];
            service.sayHello(username);

        } catch (Exception e) {
            //do nothing
        }

        chain.doFilter(request, response);
    }

    /**
     * Decodes the header into a username and password.
     *
     * @throws BadCredentialsException if the Basic header is not present or is
     *                                 not valid
     *                                 Base64
     */
    private String[] extractAndDecodeHeader(String header,
            HttpServletRequest request)
            throws IOException {

        byte[] base64Token = header.substring(6).getBytes("UTF-8");
        byte[] decoded;
        try {
            decoded = Base64.decode(base64Token);
        } catch (IllegalArgumentException e) {
            throw new BadCredentialsException(
                    "Failed to decode basic authentication token");
        }

        String token = new String(decoded, "UTF-8");

        int delim = token.indexOf(":");

        if (delim == -1) {
            throw new BadCredentialsException(
                    "Invalid basic authentication token");
        }
        return new String[]{token.substring(0, delim), token.substring(
                delim + 1)};
    }
}

import com.basaki.annotation.MyAnno;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

/**
 * {@code MyAspect} intercepts any private method execution if a
 * method is tagged with {@code com.basaki.annotation.MyAnno}
 * annotation.
 * <p>
 *
 * @author Indra Basak
 * @since 11/3/17
 */
@Component
@Aspect
public class MyAspect {

    @Before("@annotation(myAnnoAnnotation) && execution(private * *(..))")
    public void myAnnoAspect(JoinPoint jp, MyAnno myAnnoAnnotation) {
        System.out.println(
                "Entering MyAspect.myAnnoAspect() in class "
                        + jp.getSignature().getDeclaringTypeName()
                        + " - method: " + jp.getSignature().getName());
    }
}
--------------------------------------------------------------------------------------------------------
import com.codahale.metrics.MetricRegistry;
import com.codahale.metrics.Timer;
import com.codahale.metrics.annotation.Timed;
import java.lang.reflect.Method;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * {@code TimedAspect} intercepts any method execution if a class or
 * method is tagged with {@code com.codahale.metrics.annotation.Timed}
 * annotation.
 * <p>
 *
 * @author Indra Basak
 * @since 10/17/16
 */
@Aspect
@Component
public class TimedAspect extends AbstractMetricAspect<Timed> {

    public static final String METRIC_PREFIX = "timer.";

    @Autowired
    public TimedAspect(MetricRegistry registry) {
        super(registry);
    }

    /**
     * Generates timer metric of type {@code com.codahale.metrics.Timer}.
     * It measures the time it take to invoke a method.
     *
     * @param pointcut   aspect point cut
     * @param annotation the {@code Timed} annotation declared at the class
     *                   level. It will be null if it's declared at method
     *                   level
     * @return the return value from the invoked target object's method
     * @throws Throwable any exception encountered during target method
     *                   execution
     */
    @Around("@annotation(annotation) || @within(annotation)")
    public Object generateMetric(
            final ProceedingJoinPoint pointcut,
            final Timed annotation) throws Throwable {
        Timed anno = getAnnotation(pointcut, annotation);
        String metricName = getMetricName(METRIC_PREFIX,
                pointcut.getSignature().getDeclaringType(),
                pointcut.getSignature().getName(), anno.name(),
                anno.absolute());
        final Timer timer = getRegistry().timer(metricName);
        final Timer.Context context = timer.time();

        try {
            return pointcut.proceed();
        } finally {
            context.stop();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Timed getAnnotation(final ProceedingJoinPoint pointcut,
            final Timed annotation) {
        if (annotation != null) {
            return annotation;
        }

        Timed retAnnotation = null;
        if (pointcut.getSignature() instanceof MethodSignature) {
            MethodSignature signature =
                    (MethodSignature) pointcut.getSignature();
            Method method = signature.getMethod();
            retAnnotation = method.getAnnotation(Timed.class);
        }

        return retAnnotation;
    }
}
import com.codahale.metrics.Meter;
import com.codahale.metrics.MetricRegistry;
import com.codahale.metrics.annotation.Metered;
import java.lang.reflect.Method;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * {@code MeteredAspect} intercepts any method execution if a class or
 * method is tagged with <code>com.codahale.metrics.annotation.Metered</code>
 * annotation.
 * <p>
 *
 * @author Indra Basak
 * @since 10/18/16
 */
@Aspect
@Component
public class MeteredAspect extends AbstractMetricAspect<Metered> {

    public static final String METRIC_PREFIX = "meter.";

    @Autowired
    public MeteredAspect(MetricRegistry registry) {
        super(registry);
    }

    /**
     * Generates meter metric of type {@code com.codahale.metrics.Meter}.
     * It increases the invocation count when a method is executed.
     *
     * @param pointcut   aspect point cut
     * @param annotation the {@code Metered} annotation declared at the
     *                   class level. It will be null if it's declared at
     *                   method
     *                   level
     * @return the return value from the invoked target object's method
     * @throws Throwable any exception encountered during target method
     *                   execution
     */
    @Around("@annotation(annotation) @within(annotation)")
    public Object generateMetric(
            final ProceedingJoinPoint pointcut,
            final Metered annotation) throws Throwable {
        Metered anno = getAnnotation(pointcut, annotation);

        String metricName = getMetricName(METRIC_PREFIX,
                pointcut.getSignature().getDeclaringType(),
                pointcut.getSignature().getName(), anno.name(),
                anno.absolute());
        final Meter meter = getRegistry().meter(metricName);

        meter.mark();
        return pointcut.proceed();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Metered getAnnotation(final ProceedingJoinPoint pointcut,
            final Metered annotation) {
        if (annotation != null) {
            return annotation;
        }

        Metered retAnnotation = null;
        if (pointcut.getSignature() instanceof MethodSignature) {
            MethodSignature signature =
                    (MethodSignature) pointcut.getSignature();
            Method method = signature.getMethod();
            retAnnotation = method.getAnnotation(Metered.class);
        }

        return retAnnotation;
    }
}
--------------------------------------------------------------------------------------------------------
import com.codahale.metrics.MetricRegistry;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.joda.JodaModule;
import java.util.UUID;
import javax.annotation.PostConstruct;
import org.basaki.example.book.util.UuidBeanFactory;
import org.basaki.metrics.set.JmxGaugeSet;
import org.dozer.DozerBeanMapper;
import org.dozer.Mapper;
import org.dozer.loader.api.BeanMappingBuilder;
import org.dozer.loader.api.TypeMappingOptions;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

/**
 * Created by indra.basak on 3/8/17.
 */
@Configuration
public class SpringConfiguration {

    @Autowired
    private MetricRegistry registry;

    @Bean
    public static Mapper getMapper() {
        BeanMappingBuilder builder = new BeanMappingBuilder() {
            protected void configure() {
                mapping(UUID.class, UUID.class, TypeMappingOptions.oneWay(),
                        TypeMappingOptions.beanFactory(
                                UuidBeanFactory.class.getName()));
            }
        };

        DozerBeanMapper mapper = new DozerBeanMapper();
        mapper.addMapping(builder);

        return mapper;
    }

    @Primary
    @Bean
    public ObjectMapper createCustomObjectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        mapper.registerModule(new JodaModule());

        return mapper;
    }

    @PostConstruct
    public void init() {
        registry.register(
                MetricRegistry.name("tomcat", "threadpool", "http-nio-8080"),
                new JmxGaugeSet("Tomcat:type=ThreadPool,name=\"http-nio-8080\""));
    }
}
--------------------------------------------------------------------------------------------------------
import com.codahale.metrics.MetricRegistry;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.joda.JodaModule;
import java.util.UUID;
import javax.annotation.PostConstruct;
import org.basaki.example.book.util.UuidBeanFactory;
import org.basaki.metrics.set.JmxGaugeSet;
import org.dozer.DozerBeanMapper;
import org.dozer.Mapper;
import org.dozer.loader.api.BeanMappingBuilder;
import org.dozer.loader.api.TypeMappingOptions;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

/**
 * Created by indra.basak on 3/8/17.
 */
@Configuration
public class SpringConfiguration {

    @Autowired
    private MetricRegistry registry;

    @Bean
    public static Mapper getMapper() {
        BeanMappingBuilder builder = new BeanMappingBuilder() {
            protected void configure() {
                mapping(UUID.class, UUID.class, TypeMappingOptions.oneWay(),
                        TypeMappingOptions.beanFactory(
                                UuidBeanFactory.class.getName()));
            }
        };

        DozerBeanMapper mapper = new DozerBeanMapper();
        mapper.addMapping(builder);

        return mapper;
    }

    @Primary
    @Bean
    public ObjectMapper createCustomObjectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        mapper.registerModule(new JodaModule());

        return mapper;
    }

    @PostConstruct
    public void init() {
        registry.register(
                MetricRegistry.name("tomcat", "threadpool", "http-nio-8080"),
                new JmxGaugeSet("Tomcat:type=ThreadPool,name=\"http-nio-8080\""));
    }
}

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.security.Key;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.jose4j.jws.AlgorithmIdentifiers;
import org.jose4j.keys.HmacKey;

/**
 * {@code JwtKeyUtil}
 *
 * @author Indra Basak
 * @since 1/24/17
 */
@Slf4j
public class JwtKeyUtil {

    public static Key generateKey(AlgorithmType algo, String subscriberId,
            String user,
            String password) throws JwtException {
        //SHA256($subscriber_id + "/" + $sub + ":" + SHA256($subscriber_id + $password))
        Key key;

        try {
            String subIdPwd = String.format("%1$s%2$s", subscriberId, password);
            subIdPwd = StringUtils.replace(subIdPwd, "*", "%2A");
            byte[] pwdHash = getShaHash(algo, subIdPwd.getBytes("UTF-8"));
            String subIdUser = String.format("%1$s/%2$s:", subscriberId, user);
            byte[] subIdUserPwdHash =
                    ArrayUtils.addAll(subIdUser.getBytes("UTF-8"), pwdHash);
            byte[] hash = getShaHash(algo, subIdUserPwdHash);
            key = new HmacKey(hash);
        } catch (UnsupportedEncodingException e) {
            throw new JwtException("Failed to create key.", e);
        }

        return key;
    }

    public static Key deriveKey(AlgorithmType algo, String subscriberId,
            String user,
            String encodedpassword) throws JwtException {

        Key key;

        try {
            byte[] pwdHash = Hex.decodeHex(encodedpassword.toCharArray());
            String subIdUser = String.format("%1$s/%2$s:", subscriberId, user);
            byte[] subIdUserPwdHash =
                    ArrayUtils.addAll(subIdUser.getBytes("UTF-8"), pwdHash);
            byte[] hash = getShaHash(algo, subIdUserPwdHash);
            key = new HmacKey(hash);
        } catch (DecoderException e) {
            throw new JwtException("Failed to decode password", e);
        } catch (UnsupportedEncodingException e) {
            throw new JwtException(e);
        }

        return key;
    }

    public static byte[] getShaHash(AlgorithmType algo, byte[] data)
            throws UnsupportedEncodingException {
        byte[] hash;

        switch (algo) {
            case SHA384:
                hash = DigestUtils.sha384(data);
                break;
            case SHA512:
                hash = DigestUtils.sha512(data);
                break;
            default:
                hash = DigestUtils.sha256(data);
                System.out.println("&&&&&&& " + DigestUtils.sha256Hex(data));
        }

        return hash;
    }

    public static AlgorithmType getAlgorithmType(
            String alg) throws JwtException {

        AlgorithmType algoType = null;

        if (alg == null) {
            throw new JwtException("Null hash algorithm");
        }

        switch (alg.toUpperCase()) {
            case AlgorithmIdentifiers.HMAC_SHA256:
            case "S256":
            case "SHA256":
                algoType = AlgorithmType.SHA256;
                break;
            case AlgorithmIdentifiers.HMAC_SHA384:
            case "S384":
            case "SHA384":
                algoType = AlgorithmType.SHA384;
                break;
            case AlgorithmIdentifiers.HMAC_SHA512:
            case "S512":
            case "SHA512":
                algoType = AlgorithmType.SHA384;
                break;
            default:
                throw new JwtException("Unknown hash algorithm " + alg);
        }

        return algoType;
    }

    public static String urlEncode(String value) {
        return urlEncode(value, "UTF-8");
    }

    public static String urlEncode(String value, String encoding) {
        try {
            return value == null ? "" : (StringUtils.isBlank(
                    value) ? value : URLEncoder.encode(value, encoding));
        } catch (UnsupportedEncodingException var3) {
            log.error(var3.getMessage(), var3);
            return null;
        }
    }
}
--------------------------------------------------------------------------------------------------------
import com.basaki.security.jwt.core.exception.InvalidCryptoException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public enum HashType {

    SHA256("SHA-256"), SHA512_384("SHA-384"), SHA512("SHA-512");

    private String algorithm;

    HashType(String algorithm) {
        this.algorithm = algorithm;
    }

    public MessageDigest getMessageDigest() {
        try {
            return MessageDigest.getInstance(algorithm);
        } catch (NoSuchAlgorithmException e) {
            String msg =
                    "Failed to create a message digest for algorithm " + algorithm;
            log.error(msg, e);
            throw new InvalidCryptoException(msg, e);
        }
    }
}
--------------------------------------------------------------------------------------------------------
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
public class LogoutController {

	@RequestMapping(value = "/logout", method = RequestMethod.GET)
	public String logout(HttpServletRequest request,
			HttpServletResponse response) {
		Authentication auth = SecurityContextHolder.getContext()
				.getAuthentication();

		if (auth != null) {
			new SecurityContextLogoutHandler().logout(request, response, auth);
			request.getSession().invalidate();
		}
		return "redirect:/";
	}
}
--------------------------------------------------------------------------------------------------------
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

//@FeignClient(name="currency-exchange-service", url="localhost:8000")
//@FeignClient(name="currency-exchange-service")
@FeignClient(name="netflix-zuul-api-gateway-server")
@RibbonClient(name="currency-exchange-service")
public interface CurrencyExchangeServiceProxy {
	//@GetMapping("/currency-exchange/from/{from}/to/{to}")
	@GetMapping("/currency-exchange-service/currency-exchange/from/{from}/to/{to}")
	public CurrencyConversionBean retrieveExchangeValue
		(@PathVariable("from") String from, @PathVariable("to") String to);
}
--------------------------------------------------------------------------------------------------------
	@Bean
	public LocaleResolver localeResolver() {
		AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
		localeResolver.setDefaultLocale(Locale.US);
		return localeResolver;
	}
--------------------------------------------------------------------------------------------------------
import java.util.Arrays;
import java.util.List;

import org.springframework.http.converter.json.MappingJacksonValue;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import com.fasterxml.jackson.databind.ser.FilterProvider;
import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;
import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;

@RestController
public class FilteringController {

	// field1,field2
	@GetMapping("/filtering")
	public MappingJacksonValue retrieveSomeBean() {
		SomeBean someBean = new SomeBean("value1", "value2", "value3");

		SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept("field1", "field2");

		FilterProvider filters = new SimpleFilterProvider().addFilter("SomeBeanFilter", filter);

		MappingJacksonValue mapping = new MappingJacksonValue(someBean);

		mapping.setFilters(filters);

		return mapping;
	}

	// field2, field3
	@GetMapping("/filtering-list")
	public MappingJacksonValue retrieveListOfSomeBeans() {
		List<SomeBean> list = Arrays.asList(new SomeBean("value1", "value2", "value3"),
				new SomeBean("value12", "value22", "value32"));

		SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept("field2", "field3");

		FilterProvider filters = new SimpleFilterProvider().addFilter("SomeBeanFilter", filter);

		MappingJacksonValue mapping = new MappingJacksonValue(list);

		mapping.setFilters(filters);

		return mapping;
	}

}
--------------------------------------------------------------------------------------------------------
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import com.in28minutes.database.databasedemo.entity.Person;

@Repository
public class PersonJbdcDao {

	@Autowired
	JdbcTemplate jdbcTemplate;
	
	class PersonRowMapper implements RowMapper<Person>{
		@Override
		public Person mapRow(ResultSet rs, int rowNum) throws SQLException {
			Person person = new Person();
			person.setId(rs.getInt("id"));
			person.setName(rs.getString("name"));
			person.setLocation(rs.getString("location"));
			person.setBirthDate(rs.getTimestamp("birth_date"));
			return person;
		}
		
	}
	
	public List<Person> findAll() {
		return jdbcTemplate.query("select * from person", new PersonRowMapper());
	}

	public Person findById(int id) {
		return jdbcTemplate.queryForObject("select * from person where id=?", new Object[] { id },
				new BeanPropertyRowMapper<Person>(Person.class));
	}

	public int deleteById(int id) {
		return jdbcTemplate.update("delete from person where id=?", new Object[] { id });
	}

	public int insert(Person person) {
		return jdbcTemplate.update("insert into person (id, name, location, birth_date) " + "values(?,  ?, ?, ?)",
				new Object[] { person.getId(), person.getName(), person.getLocation(),
						new Timestamp(person.getBirthDate().getTime()) });
	}

	public int update(Person person) {
		return jdbcTemplate.update("update person " + " set name = ?, location = ?, birth_date = ? " + " where id = ?",
				new Object[] { person.getName(), person.getLocation(), new Timestamp(person.getBirthDate().getTime()),
						person.getId() });
	}

}


import org.aspectj.lang.annotation.Pointcut;

public class CommonJoinPointConfig {
	
	@Pointcut("execution(* com.in28minutes.spring.aop.springaop.data.*.*(..))")
	public void dataLayerExecution(){}
	
	@Pointcut("execution(* com.in28minutes.spring.aop.springaop.business.*.*(..))")
	public void businessLayerExecution(){}
	
	@Pointcut("dataLayerExecution() && businessLayerExecution()")
	public void allLayerExecution(){}
	
	@Pointcut("bean(*dao*)")
	public void beanContainingDao(){}
	
	@Pointcut("within(com.in28minutes.spring.aop.springaop.data..*)")
	public void dataLayerExecutionWithWithin(){}

	@Pointcut("@annotation(com.in28minutes.spring.aop.springaop.aspect.TrackTime)")
	public void trackTimeAnnotation(){}

}
--------------------------------------------------------------------------------------------------------
import java.io.Serializable;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Clock;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.impl.DefaultClock;

@Component
public class JwtTokenUtil implements Serializable {

  static final String CLAIM_KEY_USERNAME = "sub";
  static final String CLAIM_KEY_CREATED = "iat";
  private static final long serialVersionUID = -3301605591108950415L;
  private Clock clock = DefaultClock.INSTANCE;

  @Value("${jwt.signing.key.secret}")
  private String secret;

  @Value("${jwt.token.expiration.in.seconds}")
  private Long expiration;

  public String getUsernameFromToken(String token) {
    return getClaimFromToken(token, Claims::getSubject);
  }

  public Date getIssuedAtDateFromToken(String token) {
    return getClaimFromToken(token, Claims::getIssuedAt);
  }

  public Date getExpirationDateFromToken(String token) {
    return getClaimFromToken(token, Claims::getExpiration);
  }

  public <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
    final Claims claims = getAllClaimsFromToken(token);
    return claimsResolver.apply(claims);
  }

  private Claims getAllClaimsFromToken(String token) {
    return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();
  }

  private Boolean isTokenExpired(String token) {
    final Date expiration = getExpirationDateFromToken(token);
    return expiration.before(clock.now());
  }

  private Boolean ignoreTokenExpiration(String token) {
    // here you specify tokens, for that the expiration is ignored
    return false;
  }

  public String generateToken(UserDetails userDetails) {
    Map<String, Object> claims = new HashMap<>();
    return doGenerateToken(claims, userDetails.getUsername());
  }

  private String doGenerateToken(Map<String, Object> claims, String subject) {
    final Date createdDate = clock.now();
    final Date expirationDate = calculateExpirationDate(createdDate);

    return Jwts.builder().setClaims(claims).setSubject(subject).setIssuedAt(createdDate)
        .setExpiration(expirationDate).signWith(SignatureAlgorithm.HS512, secret).compact();
  }

  public Boolean canTokenBeRefreshed(String token) {
    return (!isTokenExpired(token) || ignoreTokenExpiration(token));
  }

  public String refreshToken(String token) {
    final Date createdDate = clock.now();
    final Date expirationDate = calculateExpirationDate(createdDate);

    final Claims claims = getAllClaimsFromToken(token);
    claims.setIssuedAt(createdDate);
    claims.setExpiration(expirationDate);

    return Jwts.builder().setClaims(claims).signWith(SignatureAlgorithm.HS512, secret).compact();
  }

  public Boolean validateToken(String token, UserDetails userDetails) {
    JwtUserDetails user = (JwtUserDetails) userDetails;
    final String username = getUsernameFromToken(token);
    return (username.equals(user.getUsername()) && !isTokenExpired(token));
  }

  private Date calculateExpirationDate(Date createdDate) {
    return new Date(createdDate.getTime() + expiration * 1000);
  }
}

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth
            .userDetailsService(jwtInMemoryUserDetailsService)
            .passwordEncoder(passwordEncoderBean());
    }
--------------------------------------------------------------------------------------------------------
import org.springframework.security.config.annotation.SecurityConfigurerAdapter;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.DefaultSecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

public class JWTConfigurer extends SecurityConfigurerAdapter<DefaultSecurityFilterChain, HttpSecurity> {

    public static final String AUTHORIZATION_HEADER = "Authorization";

    private TokenProvider tokenProvider;

    public JWTConfigurer(TokenProvider tokenProvider) {
        this.tokenProvider = tokenProvider;
    }

    @Override
    public void configure(HttpSecurity http) throws Exception {
        JWTFilter customFilter = new JWTFilter(tokenProvider);
        http.addFilterBefore(customFilter, UsernamePasswordAuthenticationFilter.class);
    }
}
--------------------------------------------------------------------------------------------------------
@RequestMapping("{en|fr}/user/*")

<dependency>
 <groupId>org.testng</groupId>
 <artifactId>testng</artifactId>
 <version>6.1.1</version>
 <scope>test</scope>
</dependency>

<dependency>
 <groupId>org.springframework.mobile</groupId>
 <artifactId>spring-mobile-device</artifactId>
 <version>1.1.3.RELEASE</version>
</dependency>

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import
org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
public class PromoCodeInterceptor extendsHandlerInterceptorAdapter {
private String promoCode;
private String errorRedirect;
private String offerRedirect;
public boolean preHandle(HttpServletRequest
request,HttpServletResponse response, Object handler) throwsException {
String givenPromoCode =request.getParameterValues("promo")==null
?"":request.getParameterValues("promo")[0];
if(request.getRequestURI().endsWith("products/specialOffer")){
if(givenPromoCode.equals(promoCode)){
response.sendRedirect(request.getContextPath()+"/"+offerRedirect);
} else{
response.sendRedirect(errorRedirect);
}
return false;
}
return true;
}
public String getPromoCode() {
return promoCode;
}
public void setPromoCode(String promoCode) {
this.promoCode = promoCode;
}
public String getErrorRedirect() {
return errorRedirect;
}
public void setErrorRedirect(String errorRedirect) {
this.errorRedirect = errorRedirect;
}
public String getOfferRedirect() {
return offerRedirect;
}
public void setOfferRedirect(String offerRedirect) {
this.offerRedirect = offerRedirect;
}
}
--------------------------------------------------------------------------------------------------------
public class SomeService {
 @Transactional
 public void transactionalMethod() {
 try {
 //perform business logic which may cause exceptions...
 } catch(Exception e) {
 Tra nsactionAspectSupport.currentTransactionStatus()
.setRollbackOnly();
 }
 }
 }
--------------------------------------------------------------------------------------------------------
import java.util.UUID;
import org.dozer.BeanFactory;

/**
 * {@code UuidBeanFactory} configures Dozer mapper to map UUID fields.
 * <p/>
 *
 * @author Indra Basak
 * @since 3/18/17
 */
public class UuidBeanFactory implements BeanFactory {
    @Override
    public Object createBean(Object source, Class<?> sourceClass,
            String targetBeanId) {
        if (source == null) {
            return null;
        }

        UUID uuidSrc = (UUID) source;
        return new UUID(uuidSrc.getMostSignificantBits(),
                uuidSrc.getLeastSignificantBits());
    }
}
--------------------------------------------------------------------------------------------------------
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import lombok.Getter;
import lombok.ToString;

/**
 * This enum defines account-levels, that are expected to be present at any given time.
 * <p>
 * The administrators / coders may include more levels, e.g. more USER-levels.
 * 
 * @author divstar
 *
 */
@Getter
@ToString
public enum AccountLevels {
	/**
	 * Account is (possibly forcefully) suspended.
	 * <p>
	 * {@code level = -1000;}
	 */
	BANNED(-1000),

	/**
	 * Account is (possibly forcefully) suspended for a certain time.
	 * <p>
	 * {@code level = -100;}
	 */
	BANNED_TEMPORARILY(-100),

	/**
	 * Account has not yet been registered, yet is in use.
	 * <p>
	 * {@code level = 0;}
	 * <p>
	 * <i>Note:</i> this level might be used if a response has to be sent to anonymous (<i>not yet logged in</i>) users.
	 */
	ANONYMOUS(0),

	/**
	 * Account is deactivated (usually, because it has not been used for too long).
	 * <p>
	 * {@code level = 10;}
	 */
	DEACTIVATED(10),

	/**
	 * Account activation / confirmation is pending.
	 * <p>
	 * {@code level = 50;}
	 */
	PENDING(50),

	/**
	 * Account belongs to a regular user.
	 * <p>
	 * {@code level = 100;}
	 */
	USER(100),

	/**
	 * Account belongs to a moderator.
	 * <p>
	 * {@code level = 1000;}
	 */
	MODERATOR(1000),

	/**
	 * Account belongs to an administrator.
	 * <p>
	 * {@code level = 10000;}
	 */
	ADMINISTRATOR(10000),

	/**
	 * Account belongs to a SysOp (usually the owner).
	 * <p>
	 * {@code level = 50000;}
	 */
	SYSOP(50000),

	/**
	 * Account belongs to a coder.
	 * <p>
	 * {@code level = 100000;}
	 */
	CODER(100000);

	private static final List<AccountLevels> ACCOUNT_LEVELS = Stream.of(AccountLevels.values())
																	.sorted((v1, v2) -> Integer.compare(v1.getLevel(), v2.getLevel()))
																	.collect(Collectors.toList());

	private final int level;

	/**
	 * Default private constructor.
	 * 
	 * @param level
	 *            (int) level associated with a given constant
	 */
	private AccountLevels(final int level) {
		this.level = level;
	}

	/**
	 * This method determines the actual {@link AccountLevels}-object by a level (int).
	 * <p>
	 * <i>Note:</i> since custom levels are allowed, this method simply maps the given level to the closest value,
	 * that is smaller than the given level value.
	 * <p>
	 * <table style="border: 1px dotted #000;" border="1" cellpadding="2">
	 * <tr><th>Given this input level...</th><th>You would get this enum value</th></tr>
	 * <tr><td>level = 9000</td><td>{@link AccountLevels#MODERATOR}</td></tr>
	 * <tr><td>level = -1500</td><td>{@link AccountLevels#BANNED}</td></tr>
	 * <tr><td>level = 111111</td><td>{@link AccountLevels#CODER}</td></tr>
	 * </table>
	 * 
	 * @param level
	 *            (int) any integer specifying an account level;
	 *            it does not have to correspond to one of the enum values defined in this enum
	 * @return ({@link AccountLevels}) the closest enum value
	 */
	public static AccountLevels fromLevel(final int level) {
		AccountLevels previousLevel = AccountLevels.ACCOUNT_LEVELS.get(0);

		for (int i = 1; i < AccountLevels.ACCOUNT_LEVELS.size(); i++) {
			if (level >= AccountLevels.ACCOUNT_LEVELS.get(i).level) {
				previousLevel = AccountLevels.ACCOUNT_LEVELS.get(i);
			} else if (level < AccountLevels.ACCOUNT_LEVELS.get(i).level) {
				break;
			}
		}
		return previousLevel;
	}
}

import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Paths;

import org.springframework.stereotype.Component;

@Component
public class SecretKeyProvider {
	public byte[] getKey() throws URISyntaxException, IOException {
		return Files.readAllBytes(Paths.get(this.getClass().getResource("/jwt.key").toURI()));
	}
}
import java.io.IOException;

import org.springframework.beans.factory.annotation.Autowired;

import com.divstar.particle.authservice.rest.languageservice.LanguageService;
import com.divstar.particle.authservice.rest.tos.Language;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonNode;

/**
 * This class is a custom {@link JsonDeserializer}-derived deserializer for {@link Language}-objects.
 * <p>
 * It tells jackson2 how to convert the value of a given JSON-property ("language") to a {@link Language}-object.
 * 
 * @author divstar
 *
 */
public class LanguageDeserializer extends JsonDeserializer<Language> {

	@Autowired
	private LanguageService languageService;

	/**
	 * This method deserializes a given excerpt of the original JSON-string (usually just the string containing the value
	 * (e.g. "en" or "de")) to a corresponding {@link Language}-object.
	 * 
	 * @see JsonDeserializer#deserialize(JsonParser, DeserializationContext)
	 */
	@Override
	public Language deserialize(final JsonParser p, final DeserializationContext ctxt) throws IOException, JsonProcessingException {
		final JsonNode node = p.readValueAsTree();
		final String languageCode = node.asText();
		return languageService.getLanguage(languageCode);
	}
}
--------------------------------------------------------------------------------------------------------
import java.io.Serializable;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.Properties;
import org.hibernate.HibernateException;
import org.hibernate.engine.spi.SessionImplementor;
import org.hibernate.usertype.EnhancedUserType;
import org.hibernate.usertype.ParameterizedType;
import org.postgresql.util.PGobject;

/**
 * {@code PGEnumUserType} converts a Java Enum to Postgres Enum type and vice
 * versa.
 * <p/>
 *
 * @since 3/8/17
 */
public class PGEnumUserType implements EnhancedUserType, ParameterizedType {
    private Class<Enum> enumClass;

    public void setParameterValues(Properties parameters) {
        String enumClassName = parameters.getProperty("enumClassName");
        try {
            enumClass = (Class<Enum>) Class.forName(enumClassName);
        } catch (ClassNotFoundException cnfe) {
            throw new HibernateException("Enum class not found", cnfe);
        }
    }

    public Object assemble(Serializable cached, Object owner)
            throws HibernateException {
        return cached;
    }

    public Object deepCopy(Object value) throws HibernateException {
        return value;
    }

    public Serializable disassemble(Object value) throws HibernateException {
        return (Enum) value;
    }

    public boolean equals(Object x, Object y) throws HibernateException {
        return x == y;
    }

    public int hashCode(Object x) throws HibernateException {
        return x.hashCode();
    }

    @Override
    public Object nullSafeGet(ResultSet rs, String[] names,
            SessionImplementor session,
            Object owner) throws HibernateException, SQLException {
        Object object = rs.getObject(names[0]);
        if (rs.wasNull()) {
            return null;
        }

        // Converts a PostGrem Enum from PGobject to Java Enum
        if (object instanceof PGobject) {
            PGobject pg = (PGobject) object;
            return Enum.valueOf(enumClass, pg.getValue());
        }
        return null;
    }

    @Override
    public void nullSafeSet(PreparedStatement st, Object value, int index,
            SessionImplementor session) throws HibernateException, SQLException {
        if (value == null) {
            st.setNull(index, Types.VARCHAR);
        } else {
            // Types.OTHER (1111) gets mapped to Postgres Enum
            st.setObject(index, ((Enum) value), Types.OTHER);
        }
    }

    public boolean isMutable() {
        return false;
    }

    public Object replace(Object original, Object target, Object owner)
            throws HibernateException {
        return original;
    }

    public Class returnedClass() {
        return enumClass;
    }

    public int[] sqlTypes() {
        return new int[]{Types.VARCHAR};
    }

    public Object fromXMLString(String xmlValue) {
        return Enum.valueOf(enumClass, xmlValue);
    }

    public String objectToSQLString(Object value) {
        return '\'' + ((Enum) value).name() + '\'';
    }

    public String toXMLString(Object value) {
        return ((Enum) value).name();
    }
}

package com.paragon.mailingcontour.commons.datasource.type;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.hibernate.HibernateException;
import org.hibernate.engine.spi.SharedSessionContractImplementor;
import org.hibernate.usertype.ParameterizedType;
import org.hibernate.usertype.UserType;

import java.io.IOException;
import java.io.Serializable;
import java.io.StringWriter;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.Properties;

/**
 * {@code JsonbUserType} converts a Postgres JSONB data type to a Java object
 * and vice versa
 * <p/>
 */
public class JsonbUserType implements UserType, ParameterizedType {
    private static final ObjectMapper MAPPER = new ObjectMapper();

    private Class<?> clazz;

    @Override
    public void setParameterValues(final Properties params) {
        final String className = params.getProperty("className");
        try {
            clazz = Class.forName(className);
        } catch (ClassNotFoundException cnfe) {
            throw new HibernateException("className not found", cnfe);
        }
    }

    @Override
    public int[] sqlTypes() {
        return new int[]{Types.JAVA_OBJECT};
    }

    @Override
    public Class returnedClass() {
        return this.clazz;
    }

    @Override
    public boolean equals(final Object x, final Object y) {
        return x.equals(y);
    }

    @Override
    public int hashCode(Object x) {
        return x.hashCode();
    }

    @Override
    public Object nullSafeGet(final ResultSet rs, final String[] names, final SharedSessionContractImplementor session, final Object owner) throws SQLException {
        final String json = rs.getString(names[0]);
        if (json == null) {
            return null;
        }

        try {
            return MAPPER.readValue(json.getBytes("UTF-8"), returnedClass());
        } catch (IOException e) {
            throw new RuntimeException(
                    "Failed to convert String to " + returnedClass() + e.getMessage(),
                    e);
        }
    }

    @Override
    public void nullSafeSet(final PreparedStatement st, final Object value, final int index, final SharedSessionContractImplementor session) throws SQLException {
        if (value == null) {
            st.setNull(index, Types.OTHER);
        } else {
            try {
                final StringWriter writer = new StringWriter();
                MAPPER.writeValue(writer, value);
                writer.flush();
                st.setObject(index, writer.toString(), Types.OTHER);
            } catch (IOException e) {
                throw new RuntimeException(
                        "Failed to convert " + returnedClass() + " to String " + e.getMessage(),
                        e);
            }
        }
    }

    @Override
    public Object deepCopy(Object value) {
        if (value != null) {
            try {
                return MAPPER.readValue(MAPPER.writeValueAsString(value),
                        returnedClass());
            } catch (IOException e) {
                throw new HibernateException("Failed to deep copy object", e);
            }
        }
        return null;
    }

    @Override
    public boolean isMutable() {
        return true;
    }

    @Override
    public Serializable disassemble(Object value) {
        try {
            return MAPPER.writeValueAsString(value);
        } catch (JsonProcessingException e) {
            throw new HibernateException("Failed to disassemble object", e);
        }
    }

    @Override
    public Object assemble(Serializable cached,
                           Object owner) {
        return deepCopy(cached);
    }

    @Override
    public Object replace(Object original, Object target,
                          Object owner) {
        return deepCopy(original);
    }
}

--------------------------------------------------------------------------------------------------------
import com.basaki.config.SwaggerJson;
import javax.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;
import springfox.documentation.spring.web.json.Json;

/**
 * {@code SwaggerJsonController} is responsible for fulfilling Swagger/SpringFox
 * related requests .
 * <p/>
 *
 * @author Indra Basak
 * @since 11/23/17
 */
@RestController
@Slf4j
public class SwaggerJsonController {

    private static String swaggerResource = "[\n" +
            "  {\n" +
            "    \"name\": \"gson\",\n" +
            "    \"location\": \"/v2/api-docs?group=gson\",\n" +
            "    \"swaggerVersion\": \"2.0\"\n" +
            "  }\n" +
            "]";

    private static String uiConfiguration = "{\n" +
            "  \"docExpansion\": \"none\",\n" +
            "  \"apisSorter\": \"alpha\",\n" +
            "  \"defaultModelRendering\": \"schema\",\n" +
            "  \"supportedSubmitMethods\": [\n" +
            "    \"get\",\n" +
            "    \"post\",\n" +
            "    \"put\",\n" +
            "    \"delete\",\n" +
            "    \"patch\"\n" +
            "  ],\n" +
            "  \"jsonEditor\": false,\n" +
            "  \"showRequestHeaders\": true\n" +
            "}";

    private static String securityConfiguration = "{\n" +
            "  \"apiKeyName\": \"api_key\",\n" +
            "  \"scopeSeparator\": \",\",\n" +
            "  \"apiKeyVehicle\": \"header\"\n" +
            "}";

    private SwaggerJson swaggerJson;

    @Autowired
    public SwaggerJsonController(SwaggerJson swaggerJson) {
        this.swaggerJson = swaggerJson;
    }

    /**
     * Responsible for returning the Swagger JSON document.
     *
     * @param swaggerGroup
     * @param servletRequest
     * @return
     */
    @RequestMapping(
            value = {"/v2/api-docs"},
            method = {RequestMethod.GET},
            produces = {"application/json", "application/hal+json"}
    )
    @ResponseBody
    public ResponseEntity<Json> getDocumentation(
            @RequestParam(value = "group", required = false) String swaggerGroup,
            HttpServletRequest servletRequest) {

        return new ResponseEntity(swaggerJson.getJson(), HttpStatus.OK);
    }

    /**
     * Responsible for returning {@code SwaggerResource} when requested by
     * swagger-ui.html.
     *
     * @param servletRequest
     * @return
     */
    @RequestMapping(value = {"/swagger-resources"},
            method = {RequestMethod.GET},
            produces = {"application/json"})
    @ResponseBody
    public ResponseEntity<Json> getSwaggerResource(
            HttpServletRequest servletRequest) {
        return new ResponseEntity(swaggerResource, HttpStatus.OK);
    }

    /**
     * Responsible for returning {@code UIConfiguration} when requested by
     * swagger-ui.html.
     *
     * @param servletRequest
     * @return
     */
    @RequestMapping(value = {"/swagger-resources/configuration/ui"},
            method = {RequestMethod.GET},
            produces = {"application/json"})
    @ResponseBody
    public ResponseEntity<Json> getUIConfiguration(
            HttpServletRequest servletRequest) {

        return new ResponseEntity(uiConfiguration, HttpStatus.OK);
    }

    /**
     * Responsible for returning {@code SecurityConfiguration} when requested by
     * swagger-ui.html.
     *
     * @param servletRequest
     * @return
     */
    @RequestMapping(value = {"/swagger-resources/configuration/security"},
            method = {RequestMethod.GET},
            produces = {"application/json"})
    @ResponseBody
    public ResponseEntity<Json> getSecurityConfiguration(
            HttpServletRequest servletRequest) {

        return new ResponseEntity(securityConfiguration, HttpStatus.OK);
    }
}
--------------------------------------------------------------------------------------------------------
    private static Predicate<RequestHandler> exactPackage(final String pkg) {
        return input -> input.declaringClass().getPackage().getName().equals(
                pkg);
    }
--------------------------------------------------------------------------------------------------------
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;

/**
 * {@code MultiSecurityConfiguration} configures basic and form Spring security
 * with in memory authentication.
 * <p/>
 *
 * @author Indra Basak
 * @since 12/11/17
 */
@Configuration
@EnableWebSecurity
@Slf4j
public class MultiSecurityConfiguration {

    @Autowired
    public void configureGlobal(
            AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication().withUser("user").password(
                "password").roles("USER");
        auth.inMemoryAuthentication().withUser("admin").password(
                "password").roles("USER");
    }

    @Configuration
    @Order(1)
    public static class BasicWebSecurityConfigurationAdapter extends WebSecurityConfigurerAdapter {
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.antMatcher(
                    "/camel/**").authorizeRequests().anyRequest().hasRole(
                    "USER")
                    .and().httpBasic()
                    .and().csrf().disable();
        }
    }

    @Configuration
    public static class FormLoginWebSecurityConfigurationAdapter extends WebSecurityConfigurerAdapter {
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.authorizeRequests().antMatchers("/").permitAll()
                    .anyRequest().authenticated()
                    .and().formLogin().loginPage("/login")
                    .failureUrl("/login?error")
                    .permitAll()
                    .and().logout().logoutRequestMatcher(
                    new AntPathRequestMatcher(
                            "/hawtio/auth/logout/*"))
                    .logoutSuccessUrl("/login?logout")
                    .and().csrf().disable();
        }

        @Override
        public void configure(WebSecurity web) throws Exception {
            web.ignoring().antMatchers("/resources/**");
            web.ignoring().antMatchers("/resources/static/**");
            web.ignoring().antMatchers("/webjars/**");
            web.ignoring().antMatchers("/css/**");
            web.ignoring().antMatchers("/jolokia/**");
        }
    }
}

import io.hawt.springboot.HawtPlugin;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * {@code HawtioConfiguration} configures custom Hawtio login plugin.
 * authentication.
 * <p/>
 *
 * @author Indra Basak
 * @since 12/7/17
 */
@Configuration
public class HawtioConfiguration {

    /**
     * Loading the login plugin. It's used for redirecting to hawtio index.html
     * after login.
     */
    @Bean
    public HawtPlugin samplePlugin() {
        return new HawtPlugin("login-plugin",
                "/hawtio/plugins",
                "",
                new String[]{"plugin/js/login-plugin.js"});
    }
}
--------------------------------------------------------------------------------------------------------
System.out.println(Comparator.comparingInt( (Student x) -> x.id)
 .compare(s1, s2));
--------------------------------------------------------------------------------------------------------
    private static final class ArraySpliterator implements Spliterator<Integer> {
        private final Integer[] array;
        private int cursor;

        public ArraySpliterator(final Integer... values) {
            this.array = Arrays.copyOf(values, values.length);
            this.cursor = 0;
        }

        @Override
        public int characteristics() {
            return SIZED | SUBSIZED | ORDERED | NONNULL;
        }

        @Override
        public long estimateSize() {
            return this.array.length;
        }

        @Override
        public Spliterator<Integer> trySplit() {
            final int midpoint = this.array.length / 2;
            final Integer[] temp = new Integer[midpoint];
            Integer[] temp2;
            if (this.array.length % 2 > 0)
                temp2 = new Integer[midpoint + 1];
            else
                temp2 = new Integer[midpoint];
            for (int i = 0; i < midpoint; i++) {
                temp[i] = this.array[i];
            }
            for (int i = midpoint; i < this.array.length; i++) {
                temp2[i - midpoint] = this.array[i];
            }
            this.array = temp2;
            return new ArraySpliterator(temp);
        }

        @Override
        public boolean tryAdvance(final Consumer<? super Integer> action) {
            boolean result = true;
            action.accept(this.array[cursor]);
            this.cursor++;
            if (this.cursor >= this.array.length) {
                result = false;
            }
            return result;
        }
    }
	
javadoc -d Documents -author *.java 

javadoc -d Documents -private *.java
--------------------------------------------------------------------------------------------------------
import java.lang.reflect.Array;

/**
 * Collected methods which allow easy implementation of <code>hashCode</code>.
 * Based on the recommendations of Effective Java, by Joshua Bloch.
 * 
 * Example use case:
 * 
 * <pre>
 * public int hashCode()
 * {
 * 	int result = HashCodeUtil.SEED;
 * 	// collect the contributions of various fields
 * 	result = HashCodeUtil.hash(result, fPrimitive);
 * 	result = HashCodeUtil.hash(result, fObject);
 * 	result = HashCodeUtil.hash(result, fArray);
 * 	return result;
 * }
 * </pre>
 */
public final class HashCodeUtil
{
	/**
	 * An initial value for a <code>hashCode</code>, to which is added
	 * contributions from fields. Using a non-zero value decreases collisions of
	 * <code>hashCode</code> values.
	 */
	public static final int SEED = 23;

	/**
	 * booleans.
	 */
	public static int hash(int aSeed, boolean aBoolean)
	{
		return firstTerm(aSeed) + (aBoolean ? 1 : 0);
	}

	/**
	 * chars.
	 */
	public static int hash(int aSeed, char aChar)
	{
		return firstTerm(aSeed) + (int) aChar;
	}

	/**
	 * ints.
	 */
	public static int hash(int aSeed, int aInt)
	{
		/*
		 * Implementation Note Note that byte and short are handled by this
		 * method, through implicit conversion.
		 */
		return firstTerm(aSeed) + aInt;
	}

	/**
	 * longs.
	 */
	public static int hash(int aSeed, long aLong)
	{
		return firstTerm(aSeed) + (int) (aLong ^ (aLong >>> 32));
	}

	/**
	 * floats.
	 */
	public static int hash(int aSeed, float aFloat)
	{
		return hash(aSeed, Float.floatToIntBits(aFloat));
	}

	/**
	 * doubles.
	 */
	public static int hash(int aSeed, double aDouble)
	{
		return hash(aSeed, Double.doubleToLongBits(aDouble));
	}

	/**
	 * <code>aObject</code> is a possibly-null object field, and possibly an
	 * array.
	 * 
	 * If <code>aObject</code> is an array, then each element may be a primitive
	 * or a possibly-null object.
	 */
	public static int hash(int aSeed, Object aObject)
	{
		int result = aSeed;
		if (aObject == null)
		{
			result = hash(result, 0);
		}
		else if (!isArray(aObject))
		{
			result = hash(result, aObject.hashCode());
		}
		else
		{
			int length = Array.getLength(aObject);
			for (int idx = 0; idx < length; ++idx)
			{
				Object item = Array.get(aObject, idx);
				// recursive call!
				result = hash(result, item);
			}
		}
		return result;
	}

	// / PRIVATE ///
	private static final int fODD_PRIME_NUMBER = 31;

	private static int firstTerm(int aSeed)
	{
		return fODD_PRIME_NUMBER * aSeed;
	}

	private static boolean isArray(Object aObject)
	{
		return aObject.getClass().isArray();
	}
}

import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * <p>
 * Represents a <code>Future</code> that's already completed. All methods
 * return immediately. The result of the future is provided in this class'
 * constructor.
 * </p>
 * 
 * @author Borislav Iordanov
 *
 * @param <V>
 */
public class CompletedFuture<V> implements Future<V>
{
    private static final CompletedFuture<Object> null_instance = new CompletedFuture<Object>(null);
    
    @SuppressWarnings("unchecked")
    public static <T> CompletedFuture<T> getNull() { return (CompletedFuture<T>)null_instance; }
    
    V result;
    
    public CompletedFuture(V result)
    {
        this.result = result;
    }
    
    public boolean cancel(boolean mayInterruptIfRunning)
    {
        return false;
    }

    public V get() throws InterruptedException, ExecutionException
    {
        return result;
    }

    public V get(long timeout, TimeUnit unit) throws InterruptedException,
            ExecutionException, TimeoutException
    {
        return result;
    }
    
    public boolean isCancelled()
    {
        return false;
    }

    
    public boolean isDone()
    {
        return true;
    }
}

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * 
 * <p>
 * An <code>CallbackFuture</code> offers the possibility to call back a registered
 * listener when it is completed. To avoid taking up a thread and waiting for
 * completion, this is accomplished by required the creator of the future
 * to invoke the <code>completed</code> method when the result this 
 * <code>Future</code> represents has been computed. 
 * </p>
 *
 * <p>
 * Only one listener can be registered for call back and it is of type
 * Mapping<CallbackFuture<T>, T>. That is, a mapping that will receive
 * the <code>CallbackFuture</code> itself as an argument and must return
 * the result of the <code>Future</code>. Typically the mapping will
 * just return the <code>CallbackFuture</code>'s own result by
 * calling the <code>getResult</code>, but it may choose to assign a different 
 * result. Note that blocking calls to <code>get</code> will not return
 * until the registered listener (if any) returns, so the listener
 * must rely on the provided <code>getResult</code> to obtain the 
 * <code>Future</code>'s result value. 
 * </p>
 *
 * <p>
 * This class may be extended to provide semantics for cancellation. In this
 * case the <code>cancel</code> method must be overridden and the 
 * <code>canceled</code> flag must be set to <code>true</code> if cancellation
 * was successful. 
 * </p>
 * 
 * @author Borislav Iordanov
 *
 */
public class CallbackFuture<T> implements Future<T>
{
    private CountDownLatch latch;	
	private T result;
	private Mapping<CallbackFuture<T>, T> listener;
	protected volatile boolean canceled = false;
	
	public CallbackFuture()
	{
		latch = new CountDownLatch(1);
	}	
	public synchronized void setCompletionListener(Mapping<CallbackFuture<T>, T> listener)
	{
		this.listener = listener;
	}
	
	public synchronized void complete(T result)
	{
		if (isDone())
			throw new IllegalStateException("JobFuture completion attempted after it was done.");
		this.result = result;
		latch.countDown();
		if (listener != null)
			result = listener.eval(this);
	}
	
	public T getResult()
	{
		return result;
	}
	
	public boolean cancel(boolean mayInterruptIfRunning)
	{
		return false;
	}

	public T get() throws InterruptedException, ExecutionException
	{
		latch.await();
		return result;
	}

	public T get(long timeout, TimeUnit unit) throws InterruptedException,
			ExecutionException, TimeoutException
	{
		if (latch.await(timeout, unit))
			return result;
		else
			return null;
	}
	
	public boolean isCancelled()
	{
		return canceled;
	}

	public boolean isDone()
	{
		return latch.getCount() == 0 && !canceled;
	}
}

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * <p>
 * An <code>AggregateFuture</code> encapsulates several <code>Future</code>
 * into a single one. The result of an aggregate future is the list of 
 * results of all its components in the order in which they were added.
 * </p>
 */
public class AggregateFuture<T> implements Future<List<T>>
{	
	private List<Future<T>> components = new ArrayList<Future<T>>();

    /**
     * <p>
     * Construct from a set of futures which is copied
     * internally.
     * </p>
     */
    public AggregateFuture(Future<T>...futures)
    {
        for (Future<T> f : futures)
            components.add(f);
    }
    
	/**
	 * <p>
	 * Construct from a non-null list of components which is copied
	 * internally.
	 * </p>
	 */
	public AggregateFuture(List<Future<T>> components)
	{
		this.components.addAll(components);
	}
	
	/**
	 * <p>Canceling an aggregate future succeeds only if canceling
	 * all of its components succeeds. Note that during the process
	 * some components may be canceled while others not which would
	 * lead to an inconsistent state.</p>
	 */
	public boolean cancel(boolean mayInterruptIfRunning)
	{
		for (Future<T> f : components)
			if (!f.cancel(mayInterruptIfRunning))
				return false;
		return true;
	}

	public List<T> get() throws InterruptedException, ExecutionException
	{
		List<T> value = new ArrayList<T>();
		for (Future<T> f : components)
			value.add(f.get());
		return value;
	}

	public List<T> get(long timeout, TimeUnit unit) 
		throws InterruptedException, ExecutionException, TimeoutException
	{
		List<T> value = new ArrayList<T>();
		for (Future<T> f : components)
			value.add(f.get(timeout, unit));
		return value;
	}

	/**
	 * An aggregate is canceled iff at least one of its components is canceled.
	 */
	public boolean isCancelled()
	{
		for (Future<T> f : components)
			if (f.isCancelled())
				return true;
		return false;
	}

	/**
	 * An aggregate is done iff all of its components are done.
	 */
	public boolean isDone()
	{
		for (Future<T> f : components)
			if (!f.isDone())
				return false;
		return true;
	}
}
--------------------------------------------------------------------------------------------------------
/**
 * <p>
 * This class contains some utilities methods to read/write primitively typed values from/to
 * a byte buffer.
 * </p>
 *  
 * @author Borislav Iordanov
 */
public class BAUtils 
{
  public static long readLong(byte [] data, int offset)
  {
  	return readUnsignedLong(data, offset) ^ 0x8000000000000000L;
  }
  
  private static long readUnsignedLong(byte [] data, int offset)
  {
    return (((long)(data[offset] & 255) << 56) +
            ((long)(data[offset + 1] & 255) << 48) +
            ((long)(data[offset + 2] & 255) << 40) +
            ((long)(data[offset + 3] & 255) << 32) +
            ((long)(data[offset + 4] & 255) << 24) +
            ((long)(data[offset + 5] & 255) << 16) + 
            ((long)(data[offset + 6] & 255) <<  8) + 
            ((long)(data[offset + 7] & 255) <<  0)); 
  }
  

  public static void writeLong(long v, byte [] data, int offset)
  {
    writeUnsignedLong(v ^ 0x8000000000000000L, data, offset);
  }
  
  public static void writeUnsignedLong(long v, byte [] data, int offset)
  {
    data[offset] = (byte) ((v >>> 56)); 
    data[offset + 1] = (byte) ((v >>> 48));
    data[offset + 2] = (byte) ((v >>> 40)); 
    data[offset + 3] = (byte) ((v >>> 32));
    data[offset + 4] = (byte) ((v >>> 24)); 
    data[offset + 5] = (byte) ((v >>> 16));
    data[offset + 6] = (byte) ((v >>> 8)); 
    data[offset + 7] = (byte) ((v >>> 0));
  }
    
	public static int readInt(byte[] data, int offset)
	{
    return (int) (readUnsignedInt(data, offset) ^ 0x80000000);
	}
	
	public static long readUnsignedInt(byte[] data, int offset)
	{
    long c1 = (data[offset] & 0xFF);
    long c2 = (data[offset + 1] & 0xFF);
    long c3 = (data[offset + 2] & 0xFF);
    long c4 = (data[offset + 3] & 0xFF);
    return ((c1 << 24) | (c2 << 16) | (c3 << 8) | c4);
	}
	
	public static void writeInt(int val, byte[] data, int offset)
	{
    writeUnsignedInt(val ^ 0x80000000, data, offset);
	}
	
	public static void writeUnsignedInt(long c, byte[] data, int offset)
	{
		data[offset + 0] = (byte) ((c >>> 24) & 0xFF);
		data[offset + 1] = (byte) ((c >>> 16) & 0xFF);
		data[offset + 2] = (byte) ((c >>> 8) & 0xFF);
		data[offset + 3] = (byte) ((c >>> 0) & 0xFF);
	}
	
	public static boolean eq(byte[] left, int leftPos, byte[] right, int rightPos, int size)
	{
		int i = leftPos, j = rightPos;
		if (leftPos + size > left.length)
			return false;
		if (rightPos + size > right.length)
			return false;
		while (size > 0)
		{
			if (left[i++] != right[j++])
				return false;
			size--;
		}
		return true;
	}
	
	public static int compare(byte[] left, int leftPos, byte[] right, int rightPos, int max)
	{
		int maxLeft = leftPos + max;
		int maxRight = rightPos + max;
		int i = leftPos;
		int j = rightPos;
		int comp = 0;
		while (comp == 0 && i < maxLeft && j < maxRight)
			comp = left[i++] - right[j++];
		return comp;
	}
}
--------------------------------------------------------------------------------------------------------

import java.io.Serializable;

/**
 * <b>NOTE - code adapted from JUG libary (Copyright (c) 2002- Tatu Saloranta, tatu.saloranta@iki.fi)</b>. See
 * http://jug.safehaus.org/.
 *
 * This code only support type 4 UUID - randomly generated ones. 
 */

public class UUID implements Serializable, Cloneable, Comparable<UUID>
{
	private final static long serialVersionUID = -1;
	
    private final static String kHexChars = "0123456789abcdefABCDEF";

    public final static byte INDEX_CLOCK_HI = 6;
    public final static byte INDEX_CLOCK_MID = 4;
    public final static byte INDEX_CLOCK_LO = 0;

    public final static byte INDEX_TYPE = 6;
    // Clock seq. & variant are multiplexed...
    public final static byte INDEX_CLOCK_SEQUENCE = 8;
    public final static byte INDEX_VARIATION = 8;

    public final static byte TYPE_NULL = 0;
    public final static byte TYPE_TIME_BASED = 1;
    public final static byte TYPE_DCE = 2; // Not used
    public final static byte TYPE_NAME_BASED = 3;
    public final static byte TYPE_RANDOM_BASED = 4;

    /* 'Standard' namespaces defined (suggested) by UUID specs:
     */
    public final static String NAMESPACE_DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    public final static String NAMESPACE_URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    public final static String NAMESPACE_OID = "6ba7b812-9dad-11d1-80b4-00c04fd430c8";
    public final static String NAMESPACE_X500 = "6ba7b814-9dad-11d1-80b4-00c04fd430c8";

    /**
     * The shared null UUID. Would be nice to do lazy instantiation, but
     * if the instance really has to be a singleton, that would mean
     * class-level locking (synchronized getNullUUID()), which would
     * be some overhead... So let's just bite the bullet the first time
     * assuming creation of the null UUID (plus wasted space if it's
     * not needed) can be ignored.
     */
    private final static UUID sNullUUID = new UUID();

    final byte[] mId = new byte[16];
    // Both string presentation and hash value may be cached...
//    private transient String mDesc = null;
    private transient int mHashCode = 0;

    /* *** Object creation: *** */

    /**
     * Default constructor creates a NIL UUID, one that contains all
     * zeroes
     *
     * Note that the clearing of array is actually unnecessary as
     * JVMs are required to clear up the allocated arrays by default.
     */
    public UUID()
    {
        /*
          for (int i = 0; i < 16; ++i) {
          mId[i] = (byte)0;
          }
        */
    }

    /**
     * Constructor for cases where you already have the 16-byte binary
     * representation of the UUID (for example if you save UUIDs binary
     * takes less than half of space string representation takes).
     *
     * @param data array that contains the binary representation of UUID
     */
    public UUID(byte[] data)
    {
        /* Could call the other constructor... and/or use System.arraycopy.
         * However, it's likely that those would make this slower to use,
         * and initialization is really simple as is in any case.
         */
        for (int i = 0; i < 16; ++i) {
            mId[i] = data[i];
        }
    }

    /**
     * Constructor for cases where you already have the binary
     * representation of the UUID (for example if you save UUIDs binary
     * takes less than half of space string representation takes) in
     * a byte array
     *
     * @param data array that contains the binary representation of UUID
     * @param start byte offset where UUID starts
     */
    public UUID(byte[] data, int start)
    {
        for (int i = 0; i < 16; ++i) {
            mId[i] = data[start + i];
        }
    }

    /**
     * Protected constructor used by UUIDGenerator
     *
     * @param type UUID type
     * @param data 16 byte UUID contents
     */
    UUID(int type, byte[] data)
    {
        for (int i = 0; i < 16; ++i) {
            mId[i] = data[i];
        }
        // Type is multiplexed with time_hi:
        mId[INDEX_TYPE] &= (byte) 0x0F;
        mId[INDEX_TYPE] |= (byte) (type << 4);
        // Variant masks first two bits of the clock_seq_hi:
        mId[INDEX_VARIATION] &= (byte) 0x3F;
        mId[INDEX_VARIATION] |= (byte) 0x80;
    }

    /**
     * Constructor for creating UUIDs from the canonical string
     * representation
     *
     * Note that implementation is optimized for speed, not necessarily
     * code clarity... Also, since what we get might not be 100% canonical
     * (see below), let's not yet populate mDesc here.
     *
     * @param id String that contains the canonical representation of
     *   the UUID to build; 36-char string (see UUID specs for details).
     *   Hex-chars may be in upper-case too; UUID class will always output
     *   them in lowercase.
     */
    public UUID(String id)
        throws NumberFormatException
    {
        if (id == null) {
            throw new NullPointerException();
        }
        if (id.length() != 36) {
            throw new NumberFormatException("UUID has to be represented by the standard 36-char representation");
        }

        for (int i = 0, j = 0; i < 36; ++j) {
            // Need to bypass hyphens:
            switch (i) {
            case 8:
            case 13:
            case 18:
            case 23:
                if (id.charAt(i) != '-') {
                    throw new NumberFormatException("UUID has to be represented by the standard 36-char representation");
                }
                ++i;
            }

            char c = id.charAt(i);

            if (c >= '0' && c <= '9') {
                mId[j] = (byte) ((c - '0') << 4);
            } else if (c >= 'a' && c <= 'f') {
                mId[j] = (byte) ((c - 'a' + 10) << 4);
            } else if (c >= 'A' && c <= 'F') {
                mId[j] = (byte) ((c - 'A' + 10) << 4);
            } else {
                throw new NumberFormatException("Non-hex character '"+c+"'");
            }

            c = id.charAt(++i);

            if (c >= '0' && c <= '9') {
                mId[j] |= (byte) (c - '0');
            } else if (c >= 'a' && c <= 'f') {
                mId[j] |= (byte) (c - 'a' + 10);
            } else if (c >= 'A' && c <= 'F') {
                mId[j] |= (byte) (c - 'A' + 10);
            } else {
                throw new NumberFormatException("Non-hex character '"+c+"'");
            }
            ++i;
        }
    }

    /**
     * Default cloning behaviour (bitwise copy) is just fine...
     *
     * Could clear out cached string presentation, but there's
     * probably no point in doing that.
     */
    public Object clone()
    {
        try {
            return super.clone();
        } catch (CloneNotSupportedException e) {
            // shouldn't happen
            return null;
        }
    }

    /* *** Accessors: *** */

    /**
     * Accessor for getting the shared null UUID
     *
     * @return the shared null UUID
     */
    public static UUID getNullUUID()
    {
        return sNullUUID;
    }

    public boolean isNullUUID()
    {
        // Assuming null uuid is usually used for nulls:
        if (this == sNullUUID) {
            return true;
        }
        // Could also check hash code; null uuid has -1 as hash?
        byte[] data = mId;
        int i = mId.length;
        byte zero = (byte) 0;
        while (--i >= 0) {
            if (data[i] != zero) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns the UUID type code
     *
     * @return UUID type
     */
    public int getType()
    {
        return (mId[INDEX_TYPE] & 0xFF) >> 4;
    }

    /**
     * Returns the UUID as a 16-byte byte array
     *
     * @return 16-byte byte array that contains UUID bytes in the network
     *   byte order
     */
    public byte[] asByteArray()
    {
        byte[] result = new byte[16];
        toByteArray(result);
        return result;
    }

    /**
     * Fills in the 16 bytes (from index pos) of the specified byte array
     * with the UUID contents.
     *
     * @param dst Byte array to fill
     * @param pos Offset in the array
     */
    public void toByteArray(byte[] dst, int pos)
    {
        byte[] src = mId;
        for (int i = 0; i < 16; ++i) {
            dst[pos+i] = src[i];
        }
    }

    public void toByteArray(byte[] dst) { toByteArray(dst, 0); }

    /**
     * 'Synonym' for 'asByteArray'
     */
    public byte[] toByteArray() { return asByteArray(); }
    
    /* *** Standard methods from Object overridden: *** */

    /**
     * Could use just the default hash code, but we can probably create
     * a better identity hash (ie. same contents generate same hash)
     * manually, without sacrificing speed too much. Although multiplications
     * with modulos would generate better hashing, let's use just shifts,
     * and do 2 bytes at a time.
     *<p>
     * Of course, assuming UUIDs are randomized enough, even simpler
     * approach might be good enough?
     *<p>
     * Is this a good hash? ... one of these days I better read more about
     * basic hashing techniques I swear!
     */
    private final static int[] kShifts = {
        3, 7, 17, 21, 29, 4, 9
    };

    public int hashCode()
    {
        if (mHashCode == 0) {
            // Let's handle first and last byte separately:
            int result = mId[0] & 0xFF;
	    
            result |= (result << 16);
            result |= (result << 8);
	    
            for (int i = 1; i < 15; i += 2) {
                int curr = (mId[i] & 0xFF) << 8 | (mId[i+1] & 0xFF);
                int shift = kShifts[i >> 1];
		
                if (shift > 16) {
                    result ^= (curr << shift) | (curr >>> (32 - shift));
                } else {
                    result ^= (curr << shift);
                }
            }

            // and then the last byte:
            int last = mId[15] & 0xFF;
            result ^= (last << 3);
            result ^= (last << 13);

            result ^= (last << 27);
            // Let's not accept hash 0 as it indicates 'not hashed yet':
            if (result == 0) {
                mHashCode = -1;
            } else {
                mHashCode = result;
            }
        }
        return mHashCode;
    }

    public String toString()
    {    	
    	StringBuffer b = new StringBuffer(36);
	    for (int i = 0; i < 16; ++i) 
	    {
            // Need to bypass hyphens:
            switch (i) 
            {
	            case 4:
	            case 6:
	            case 8:
	            case 10:
	                b.append('-');
	        }
            int hex = mId[i] & 0xFF;
            b.append(kHexChars.charAt(hex >> 4));
            b.append(kHexChars.charAt(hex & 0x0f));
        }
	    return b.toString();
    }

    public int compareTo(UUID o)
    {
        UUID other = (UUID) o;
        byte[] thisId = mId;
        byte[] thatId = other.mId;
        for (int i = 0; i < 16; ++i) {
            int cmp = (((int) thisId[i]) & 0xFF) - (((int) thatId[i]) & 0xFF);
            if (cmp != 0) {
                return cmp;
            }
        }
        return 0;
    }

    /**
     * Checking equality of UUIDs is easy; just compare the 128-bit
     * number.
     */
    public boolean equals(Object o)
    {
        if (!(o instanceof UUID)) {
            return false;
        }
        byte[] otherId = ((UUID) o).mId;
        byte[] thisId = mId;
        for (int i = 0; i < 16; ++i) {
            if (otherId[i] != thisId[i]) {
                return false;
            }
        }
        return true;
    }

    /**
     * Constructs a new UUID instance given the canonical string
     * representation of an UUID.
     *
     * Note that calling this method returns the same result as would
     * using the matching (1 string arg) constructor.
     *
     * @param id Canonical string representation used for constructing
     *  an UUID instance
     *
     * @throws NumberFormatException if 'id' is invalid UUID
     */
    public static UUID valueOf(String id)
        throws NumberFormatException
    {
        return new UUID(id);
    }

    /**
     * Constructs a new UUID instance given a byte array that contains
     * the (16 byte) binary representation.
     *
     * Note that calling this method returns the same result as would
     * using the matching constructor
     *
     * @param src Byte array that contains the UUID definition
     * @param start Offset in the array where the UUID starts
     */
    public static UUID valueOf(byte[] src, int start)
    {
        return new UUID(src, start);
    }

    /**
     * Constructs a new UUID instance given a byte array that contains
     * the (16 byte) binary representation.
     *
     * Note that calling this method returns the same result as would
     * using the matching constructor
     *
     * @param src Byte array that contains the UUID definition
     */
    public static UUID valueOf(byte[] src)
    {
        return new UUID(src);
    }
}
--------------------------------------------------------------------------------------------------------
import org.hypergraphdb.HGPersistentHandle;
import org.hypergraphdb.HGRandomAccessResult;
import org.hypergraphdb.HGSearchResult;
import org.hypergraphdb.storage.BAUtils;
import org.hypergraphdb.storage.BAtoString;
import org.hypergraphdb.storage.ByteArrayConverter;

import java.io.File;
import java.io.IOException;
import java.util.*;

import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertTrue;

/**
 * @author Yuriy Sechko
 */
public class TestUtils
{
	/**
	 * Creates list which contains given items.
	 * <p/>
	 * Items in the list appear in the same order as in parameters. More items
	 * can be added to the list later.
	 * <p/>
	 * Usage scenario of this method:
	 *
	 * <pre>
	 * {@code
	 * List<Integer> list = list(1, 2, 3); // we have list with 3 items here }
	 * </pre>
	 *
	 * @param items
	 *            items of the list
	 * @param <T>
	 *            type of the items in the list
	 */
	public static <T> List<T> list(final T... items)
	{
		return new ArrayList<T>(Arrays.asList(items));
	}

	/**
	 * Deletes directory's content and then deletes directory itself. Deleting
	 * is not recursive.
	 *
	 * @param directory
	 */
	public static void deleteDirectory(final File directory)
	{
		final File[] filesInTestDir = directory.listFiles();
		if (filesInTestDir != null)
		{
			for (final File eachFile : filesInTestDir)
			{
				eachFile.delete();
			}
		}
		directory.delete();
	}

	/**
	 * Iterates through result and copies encountered items to the list.
	 */
	public static <T> List<T> list(final HGSearchResult<T> result)
	{
		final List<T> outputList = new ArrayList<T>();
		while (result.hasNext())
		{
			final T currentValue = result.next();
			outputList.add(currentValue);
		}
		return outputList;
	}

	/**
	 * Iterates through result and copies encountered items to the list.
	 */
	public static <T> List<T> listAndClose(final HGSearchResult<T> result)
	{
		final List<T> outputList = new ArrayList<T>();
		while (result.hasNext())
		{
			final T currentValue = result.next();
			outputList.add(currentValue);
		}
		result.close();
		return outputList;
	}

	/**
	 * Puts all handles which are accessible from given result set into hash
	 * set. In some test cases stored data returned as
	 * {@link HGRandomAccessResult}. Two results cannot be compared directly. So
	 * we put all handles into set and that compare two sets. The order of
	 * handles in result set (obtained from database) is difficult to predict.
	 */
	public static Set<HGPersistentHandle> set(
			final HGRandomAccessResult<HGPersistentHandle> handles)
	{
		final Set<HGPersistentHandle> allHandles = new HashSet<HGPersistentHandle>();
		while (handles.hasNext())
		{
			allHandles.add(handles.next());
		}
		return allHandles;
	}

	/**
	 * Creates temporary file with given prefix and suffix.
	 *
	 * @return link to the created file instance
	 */
	public static File createTempFile(final String prefix, final String suffix)
	{
		File tempFile;
		try
		{
			tempFile = File.createTempFile(prefix, suffix);
		}
		catch (IOException ioException)
		{
			throw new IllegalStateException(ioException);
		}
		return tempFile;
	}

	/**
	 * Shortcut for the {@link java.io.File#getCanonicalPath()}. But throws
	 * {@link java.lang.IllegalStateException } if something went wrong.
	 *
	 * @return
	 */
	public static String getCanonicalPath(final File file)
	{
		String canonicalPath;
		try
		{
			canonicalPath = file.getCanonicalPath();
		}
		catch (IOException ioException)
		{
			throw new IllegalStateException(ioException);
		}
		return canonicalPath;
	}

	/**
	 * Converts from Integer number to appropriate byte array (in terms of
	 * HyperGraphDB)
	 */
	public static class ByteArrayConverterForInteger implements
			ByteArrayConverter<Integer>
	{
		public byte[] toByteArray(final Integer input)
		{
			final byte[] buffer = new byte[4];
			BAUtils.writeInt(input, buffer, 0);
			return buffer;
		}

		public Integer fromByteArray(final byte[] byteArray, final int offset,
				final int length)
		{
			return BAUtils.readInt(byteArray, 0);
		}
	}

	/**
	 * Converts from String object number to appropriate byte array (in terms of
	 * HyperGraphDB)
	 */
	public static class ByteArrayConverterForString implements
			ByteArrayConverter<String>
	{
		public byte[] toByteArray(final String input)
		{
			return BAtoString.getInstance().toByteArray(input);
		}

		public String fromByteArray(final byte[] byteArray, final int offset,
				final int length)
		{
			return BAtoString.getInstance().fromByteArray(byteArray, offset,
					length);
		}
	}

	// TODO: investigate how to compare messages but don't take Sleepycat's
	// TODO: library version into account
	/**
	 * Compares two instances which represent exceptions by:
	 * <ul>
	 * <li>by object's class</li>
	 * <li>by message</li>
	 * </ul>
	 *
	 * TestNG assertion are in use.
	 */
	public static void assertExceptions(final Exception occurred,
			final Exception expected)
	{
		assertEquals(occurred.getClass(), expected.getClass());
		assertEquals(occurred.getMessage(), expected.getMessage());
	}

	/**
	 * Verifies that given exception is an instance of certain class. Also
	 * verifies that exception contains all specified strings in its message.
	 * 
	 * @param occurred
	 *            exception to be verified
	 * @param expectedClass
	 *            expected class name
	 * @param expectedMessageParts
	 *            strings than should be contained in the exception's message
	 */
	public static void assertExceptions(final Exception occurred,
			final Class expectedClass, final String... expectedMessageParts)
	{
		assertEquals(occurred.getClass(), expectedClass);
		final String actualMessage = occurred.getMessage();
		final List<String> parts = Arrays.asList(expectedMessageParts);
		for (final String currentPart : parts)
			assertTrue(actualMessage.contains(currentPart), String.format(
					"Actual exception's message [%s] does not contain [%s] text.",
					actualMessage, currentPart));
	}

	/**
	 * Returns array like [1..N][1] composed from given [1..N] list.
	 * <p>
	 * 2D arrays used for providing parameters in test cases written with
	 * TestNG.
	 */
	public static Object[][] like2DArray(final Class... clazz)
	{
		final int totalItems = clazz.length;
		final Object[][] objects = new Object[totalItems][1];
		for (int i = 0; i < totalItems; i++)
		{
			objects[i][0] = clazz[i];
		}
		return objects;
	}
}
public class RandomStringUtils {

    /**
     * <p>Random object used by random method. This has to be not local
     * to the random method so as to not return the same value in the 
     * same millisecond.</p>
     */
    private static final Random RANDOM = new Random();

    /**
     * <p><code>RandomStringUtils</code> instances should NOT be constructed in
     * standard programming. Instead, the class should be used as
     * <code>RandomStringUtils.random(5);</code>.</p>
     *
     * <p>This constructor is public to permit tools that require a JavaBean instance
     * to operate.</p>
     */
    public RandomStringUtils() {
        super ();
    }

    // Random
    //-----------------------------------------------------------------------
    /**
     * <p>Creates a random string whose length is the number of characters
     * specified.</p>
     *
     * <p>Characters will be chosen from the set of all characters.</p>
     *
     * @param count  the length of random string to create
     * @return the random string
     */
    public static String random(int count) {
        return random(count, false, false);
    }

    /**
     * <p>Creates a random string whose length is the number of characters
     * specified.</p>
     *
     * <p>Characters will be chosen from the set of characters whose
     * ASCII value is between <code>32</code> and <code>126</code> (inclusive).</p>
     *
     * @param count  the length of random string to create
     * @return the random string
     */
    public static String randomAscii(int count) {
        return random(count, 32, 127, false, false);
    }

    /**
     * <p>Creates a random string whose length is the number of characters
     * specified.</p>
     *
     * <p>Characters will be chosen from the set of alphabetic
     * characters.</p>
     *
     * @param count  the length of random string to create
     * @return the random string
     */
    public static String randomAlphabetic(int count) {
        return random(count, true, false);
    }

    /**
     * <p>Creates a random string whose length is the number of characters
     * specified.</p>
     *
     * <p>Characters will be chosen from the set of alpha-numeric
     * characters.</p>
     *
     * @param count  the length of random string to create
     * @return the random string
     */
    public static String randomAlphanumeric(int count) {
        return random(count, true, true);
    }

    /**
     * <p>Creates a random string whose length is the number of characters
     * specified.</p>
     *
     * <p>Characters will be chosen from the set of numeric
     * characters.</p>
     *
     * @param count  the length of random string to create
     * @return the random string
     */
    public static String randomNumeric(int count) {
        return random(count, false, true);
    }

    /**
     * <p>Creates a random string whose length is the number of characters
     * specified.</p>
     *
     * <p>Characters will be chosen from the set of alpha-numeric
     * characters as indicated by the arguments.</p>
     *
     * @param count  the length of random string to create
     * @param letters  if <code>true</code>, generated string will include
     *  alphabetic characters
     * @param numbers  if <code>true</code>, generated string will include
     *  numeric characters
     * @return the random string
     */
    public static String random(int count, boolean letters,
            boolean numbers) {
        return random(count, 0, 0, letters, numbers);
    }

    /**
     * <p>Creates a random string whose length is the number of characters
     * specified.</p>
     *
     * <p>Characters will be chosen from the set of alpha-numeric
     * characters as indicated by the arguments.</p>
     *
     * @param count  the length of random string to create
     * @param start  the position in set of chars to start at
     * @param end  the position in set of chars to end before
     * @param letters  if <code>true</code>, generated string will include
     *  alphabetic characters
     * @param numbers  if <code>true</code>, generated string will include
     *  numeric characters
     * @return the random string
     */
    public static String random(int count, int start, int end,
            boolean letters, boolean numbers) {
        return random(count, start, end, letters, numbers, null, RANDOM);
    }

    /**
     * <p>Creates a random string based on a variety of options, using
     * default source of randomness.</p>
     *
     * <p>This method has exactly the same semantics as
     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but
     * instead of using an externally supplied source of randomness, it uses
     * the internal static {@link Random} instance.</p>
     *
     * @param count  the length of random string to create
     * @param start  the position in set of chars to start at
     * @param end  the position in set of chars to end before
     * @param letters  only allow letters?
     * @param numbers  only allow numbers?
     * @param chars  the set of chars to choose randoms from.
     *  If <code>null</code>, then it will use the set of all chars.
     * @return the random string
     * @throws ArrayIndexOutOfBoundsException if there are not
     *  <code>(end - start) + 1</code> characters in the set array.
     */
    public static String random(int count, int start, int end,
            boolean letters, boolean numbers, char[] chars) {
        return random(count, start, end, letters, numbers, chars,
                RANDOM);
    }

    /**
     * <p>Creates a random string based on a variety of options, using
     * supplied source of randomness.</p>
     *
     * <p>If start and end are both <code>0</code>, start and end are set
     * to <code>' '</code> and <code>'z'</code>, the ASCII printable
     * characters, will be used, unless letters and numbers are both
     * <code>false</code>, in which case, start and end are set to
     * <code>0</code> and <code>Integer.MAX_VALUE</code>.
     *
     * <p>If set is not <code>null</code>, characters between start and
     * end are chosen.</p>
     *
     * <p>This method accepts a user-supplied {@link Random}
     * instance to use as a source of randomness. By seeding a single 
     * {@link Random} instance with a fixed seed and using it for each call,
     * the same random sequence of strings can be generated repeatedly
     * and predictably.</p>
     *
     * @param count  the length of random string to create
     * @param start  the position in set of chars to start at
     * @param end  the position in set of chars to end before
     * @param letters  only allow letters?
     * @param numbers  only allow numbers?
     * @param chars  the set of chars to choose randoms from.
     *  If <code>null</code>, then it will use the set of all chars.
     * @param random  a source of randomness.
     * @return the random string
     * @throws ArrayIndexOutOfBoundsException if there are not
     *  <code>(end - start) + 1</code> characters in the set array.
     * @throws IllegalArgumentException if <code>count</code> &lt; 0.
     * @since 2.0
     */
    public static String random(int count, int start, int end,
            boolean letters, boolean numbers, char[] chars,
            Random random) {
        if (count == 0) {
            return "";
        } else if (count < 0) {
            throw new IllegalArgumentException(
                    "Requested random string length " + count
                            + " is less than 0.");
        }
        if ((start == 0) && (end == 0)) {
            end = 'z' + 1;
            start = ' ';
            if (!letters && !numbers) {
                start = 0;
                end = Integer.MAX_VALUE;
            }
        }

        char[] buffer = new char[count];
        int gap = end - start;

        while (count-- != 0) {
            char ch;
            if (chars == null) {
                ch = (char) (random.nextInt(gap) + start);
            } else {
                ch = chars[random.nextInt(gap) + start];
            }
            if ((letters && Character.isLetter(ch))
                    || (numbers && Character.isDigit(ch))
                    || (!letters && !numbers)) {
                if (ch >= 56320 && ch <= 57343) {
                    if (count == 0) {
                        count++;
                    } else {
                        // low surrogate, insert high surrogate after putting it in
                        buffer[count] = ch;
                        count--;
                        buffer[count] = (char) (55296 + random
                                .nextInt(128));
                    }
                } else if (ch >= 55296 && ch <= 56191) {
                    if (count == 0) {
                        count++;
                    } else {
                        // high surrogate, insert low surrogate before putting it in
                        buffer[count] = (char) (56320 + random
                                .nextInt(128));
                        count--;
                        buffer[count] = ch;
                    }
                } else if (ch >= 56192 && ch <= 56319) {
                    // private high surrogate, no effing clue, so skip it
                    count++;
                } else {
                    buffer[count] = ch;
                }
            } else {
                count++;
            }
        }
        return new String(buffer);
    }

    /**
     * <p>Creates a random string whose length is the number of characters
     * specified.</p>
     *
     * <p>Characters will be chosen from the set of characters
     * specified.</p>
     *
     * @param count  the length of random string to create
     * @param chars  the String containing the set of characters to use,
     *  may be null
     * @return the random string
     * @throws IllegalArgumentException if <code>count</code> &lt; 0.
     */
    public static String random(int count, String chars) {
        if (chars == null) {
            return random(count, 0, 0, false, false, null, RANDOM);
        }
        return random(count, chars.toCharArray());
    }

    /**
     * <p>Creates a random string whose length is the number of characters
     * specified.</p>
     *
     * <p>Characters will be chosen from the set of characters specified.</p>
     *
     * @param count  the length of random string to create
     * @param chars  the character array containing the set of characters to use,
     *  may be null
     * @return the random string
     * @throws IllegalArgumentException if <code>count</code> &lt; 0.
     */
    public static String random(int count, char[] chars) {
        if (chars == null) {
            return random(count, 0, 0, false, false, null, RANDOM);
        }
        return random(count, 0, chars.length, false, false, chars,
                RANDOM);
    }
}
--------------------------------------------------------------------------------------------------------
  interface MyList<T> {

    T head();

    MyList<T> tail();

    default boolean isEmpty() {
      return true;
    }

    MyList<T> filter(Predicate<T> p);

  }

  static class MyLinkedList<T> implements MyList<T> {

    final T head;
    final MyList<T> tail;

    public MyLinkedList(T head, MyList<T> tail) {
      this.head = head;
      this.tail = tail;
    }

    @Override
    public T head() {
      return head;
    }

    @Override
    public MyList<T> tail() {
      return tail;
    }

    @Override
    public boolean isEmpty() {
      return false;
    }

    @Override
    public MyList<T> filter(Predicate<T> p) {
      return isEmpty() ? this : p.test(head()) ? new MyLinkedList<>(head(), tail().filter(p)) : tail().filter(p);
    }

  }

  static class Empty<T> implements MyList<T> {

    @Override
    public T head() {
      throw new UnsupportedOperationException();
    }

    @Override
    public MyList<T> tail() {
      throw new UnsupportedOperationException();
    }

    @Override
    public MyList<T> filter(Predicate<T> p) {
      return this;
    }

  }

  static class LazyList<T> implements MyList<T> {

    final T head;
    final Supplier<MyList<T>> tail;

    public LazyList(T head, Supplier<MyList<T>> tail) {
      this.head = head;
      this.tail = tail;
    }

    @Override
    public T head() {
      return head;
    }

    @Override
    public MyList<T> tail() {
      return tail.get();
    }

    @Override
    public boolean isEmpty() {
      return false;
    }

    @Override
    public MyList<T> filter(Predicate<T> p) {
      return isEmpty() ? this : p.test(head()) ? new LazyList<>(head(), () -> tail().filter(p)) : tail().filter(p);
    }

  }

  public static LazyList<Integer> from(int n) {
    return new LazyList<Integer>(n, () -> from(n + 1));
  }

  public static MyList<Integer> primes(MyList<Integer> numbers) {
    return new LazyList<>(numbers.head(), () -> primes(numbers.tail().filter(n -> n % numbers.head() != 0)));
  }

  static <T> void printAll(MyList<T> numbers) {
    if (numbers.isEmpty()) {
      return;
    }
    System.out.println(numbers.head());
    printAll(numbers.tail());
  }

}

import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class MyMathUtils {

  public static void main(String[] args) {
    System.out.println(primes(25).map(String::valueOf).collect(Collectors.joining(", ")));
  }

  public static Stream<Integer> primes(int n) {
    return Stream.iterate(2, i -> i + 1)
        .filter(MyMathUtils::isPrime)
        .limit(n);
  }

  public static boolean isPrime(int candidate) {
    int candidateRoot = (int) Math.sqrt(candidate);
    return IntStream.rangeClosed(2, candidateRoot)
        .noneMatch(i -> candidate % i == 0);
  }

}


--------------------------------------------------------------------------------------------------------
  public static void main(String[] args) {
    System.out.println(repeat(3, (Integer x) -> 2 * x).apply(10));
  }

  static <A, B, C> Function<A, C> compose(Function<B, C> g, Function<A, B> f) {
    return x -> g.apply(f.apply(x));
  }

  static <A> Function<A, A> repeat(int n, Function<A, A> f) {
    return n == 0 ? x -> x : compose(f, repeat(n - 1, f));
  }

--------------------------------------------------------------------------------------------------------

public class PatternMatching {

  public static void main(String[] args) {
    simplify();

    Expr e = new BinOp("+", new Number(5), new BinOp("*", new Number(3), new Number(4)));
    Integer result = evaluate(e);
    System.out.println(e + " = " + result);
  }

  private static void simplify() {
    TriFunction<String, Expr, Expr, Expr> binopcase = (opname, left, right) -> {
      if ("+".equals(opname)) {
        if (left instanceof Number && ((Number) left).val == 0) {
          return right;
        }
        if (right instanceof Number && ((Number) right).val == 0) {
          return left;
        }
      }
      if ("*".equals(opname)) {
        if (left instanceof Number && ((Number) left).val == 1) {
          return right;
        }
        if (right instanceof Number && ((Number) right).val == 1) {
          return left;
        }
      }
      return new BinOp(opname, left, right);
    };
    Function<Integer, Expr> numcase = val -> new Number(val);
    Supplier<Expr> defaultcase = () -> new Number(0);

    Expr e = new BinOp("+", new Number(5), new Number(0));
    Expr match = patternMatchExpr(e, binopcase, numcase, defaultcase);
    if (match instanceof Number) {
      System.out.println("Number: " + match);
    }
    else if (match instanceof BinOp) {
      System.out.println("BinOp: " + match);
    }
  }

  private static Integer evaluate(Expr e) {
    Function<Integer, Integer> numcase = val -> val;
    Supplier<Integer> defaultcase = () -> 0;
    TriFunction<String, Expr, Expr, Integer> binopcase = (opname, left, right) -> {
      if ("+".equals(opname)) {
        if (left instanceof Number && right instanceof Number) {
          return ((Number) left).val + ((Number) right).val;
        }
        if (right instanceof Number && left instanceof BinOp) {
          return ((Number) right).val + evaluate(left);
        }
        if (left instanceof Number && right instanceof BinOp) {
          return ((Number) left).val + evaluate(right);
        }
        if (left instanceof BinOp && right instanceof BinOp) {
          return evaluate(left) + evaluate(right);
        }
      }
      if ("*".equals(opname)) {
        if (left instanceof Number && right instanceof Number) {
          return ((Number) left).val * ((Number) right).val;
        }
        if (right instanceof Number && left instanceof BinOp) {
          return ((Number) right).val * evaluate(left);
        }
        if (left instanceof Number && right instanceof BinOp) {
          return ((Number) left).val * evaluate(right);
        }
        if (left instanceof BinOp && right instanceof BinOp) {
          return evaluate(left) * evaluate(right);
        }
      }
      return defaultcase.get();
    };

    return patternMatchExpr(e, binopcase, numcase, defaultcase);
  }

  static class Expr {}

  static class Number extends Expr {

    int val;

    public Number(int val) {
      this.val = val;
    }

    @Override
    public String toString() {
      return "" + val;
    }

  }

  static class BinOp extends Expr {

    String opname;
    Expr left, right;

    public BinOp(String opname, Expr left, Expr right) {
      this.opname = opname;
      this.left = left;
      this.right = right;
    }

    @Override
    public String toString() {
      return "(" + left + " " + opname + " " + right + ")";
    }

  }

  static <T> T MyIf(boolean b, Supplier<T> truecase, Supplier<T> falsecase) {
    return b ? truecase.get() : falsecase.get();
  }

  static interface TriFunction<S, T, U, R> {
    R apply(S s, T t, U u);
  }

  static <T> T patternMatchExpr(Expr e, TriFunction<String, Expr, Expr, T> binopcase, Function<Integer, T> numcase, Supplier<T> defaultcase) {
    if (e instanceof BinOp) {
      return binopcase.apply(((BinOp) e).opname, ((BinOp) e).left, ((BinOp) e).right);
    }
    else if (e instanceof Number) {
      return numcase.apply(((Number) e).val);
    }
    else {
      return defaultcase.get();
    }
  }

}
--------------------------------------------------------------------------------------------------------
public class PersistentTree {

  public static void main(String[] args) {
    Tree t = new Tree("Mary", 22,
        new Tree("Emily", 20,
            new Tree("Alan", 50, null, null),
            new Tree("Georgie", 23, null, null)
        ),
        new Tree("Tian", 29,
            new Tree("Raoul", 23, null, null),
            null
        )
    );

    // found = 23
    System.out.printf("Raoul: %d%n", lookup("Raoul", -1, t));
    // not found = -1
    System.out.printf("Jeff: %d%n", lookup("Jeff", -1, t));

    Tree f = fupdate("Jeff", 80, t);
    // found = 80
    System.out.printf("Jeff: %d%n", lookup("Jeff", -1, f));

    Tree u = update("Jim", 40, t);
    // t was not altered by fupdate, so Jeff is not found = -1
    System.out.printf("Jeff: %d%n", lookup("Jeff", -1, u));
    // found = 40
    System.out.printf("Jim: %d%n", lookup("Jim", -1, u));

    Tree f2 = fupdate("Jeff", 80, t);
    // found = 80
    System.out.printf("Jeff: %d%n", lookup("Jeff", -1, f2));
    // f2 built from t altered by update() above, so Jim is still present = 40
    System.out.printf("Jim: %d%n", lookup("Jim", -1, f2));
  }

  static class Tree {

    private String key;
    private int val;
    private Tree left, right;

    public Tree(String k, int v, Tree l, Tree r) {
      key = k;
      val = v;
      left = l;
      right = r;
    }

  }

  public static int lookup(String k, int defaultval, Tree t) {
    if (t == null) {
      return defaultval;
    }
    if (k.equals(t.key)) {
      return t.val;
    }
    return lookup(k, defaultval, k.compareTo(t.key) < 0 ? t.left : t.right);
  }

  public static Tree update(String k, int newval, Tree t) {
    if (t == null) {
      t = new Tree(k, newval, null, null);
    }
    else if (k.equals(t.key)) {
      t.val = newval;
    }
    else if (k.compareTo(t.key) < 0) {
      t.left = update(k, newval, t.left);
    }
    else {
      t.right = update(k, newval, t.right);
    }
    return t;
  }

  public static Tree fupdate(String k, int newval, Tree t) {
    return (t == null) ?
        new Tree(k, newval, null, null) :
        k.equals(t.key) ?
            new Tree(k, newval, t.left, t.right) :
            k.compareTo(t.key) < 0 ?
                new Tree(t.key, t.val, fupdate(k,newval, t.left), t.right) :
                new Tree(t.key, t.val, t.left, fupdate(k,newval, t.right));
  }

}
--------------------------------------------------------------------------------------------------------
    DateTimeFormatter complexFormatter = new DateTimeFormatterBuilder()
        .appendText(ChronoField.DAY_OF_MONTH)
        .appendLiteral(". ")
        .appendText(ChronoField.MONTH_OF_YEAR)
        .appendLiteral(" ")
        .appendText(ChronoField.YEAR)
        .parseCaseInsensitive()
        .toFormatter(Locale.ITALIAN);
--------------------------------------------------------------------------------------------------------
import static java.util.stream.Collector.Characteristics.IDENTITY_FINISH;
import static java.util.stream.Collectors.partitioningBy;

import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class PartitionPrimeNumbers {

  public static void main(String ... args) {
    System.out.println("Numbers partitioned in prime and non-prime: " + partitionPrimes(100));
    System.out.println("Numbers partitioned in prime and non-prime: " + partitionPrimesWithCustomCollector(100));
  }

  public static Map<Boolean, List<Integer>> partitionPrimes(int n) {
    return IntStream.rangeClosed(2, n).boxed()
        .collect(partitioningBy(candidate -> isPrime(candidate)));
  }

  public static boolean isPrime(int candidate) {
    return IntStream.rangeClosed(2, candidate-1)
        .limit((long) Math.floor(Math.sqrt(candidate)) - 1)
        .noneMatch(i -> candidate % i == 0);
  }

  public static Map<Boolean, List<Integer>> partitionPrimesWithCustomCollector(int n) {
    return IntStream.rangeClosed(2, n).boxed().collect(new PrimeNumbersCollector());
  }

  public static boolean isPrime(List<Integer> primes, Integer candidate) {
    double candidateRoot = Math.sqrt(candidate);
    //return takeWhile(primes, i -> i <= candidateRoot).stream().noneMatch(i -> candidate % i == 0);
    return primes.stream().takeWhile(i -> i <= candidateRoot).noneMatch(i -> candidate % i == 0);
  }

/*
  public static <A> List<A> takeWhile(List<A> list, Predicate<A> p) {
    int i = 0;
    for (A item : list) {
      if (!p.test(item)) {
        return list.subList(0, i);
      }
      i++;
    }
    return list;
  }
*/

  public static class PrimeNumbersCollector
      implements Collector<Integer, Map<Boolean, List<Integer>>, Map<Boolean, List<Integer>>> {

    @Override
    public Supplier<Map<Boolean, List<Integer>>> supplier() {
      return () -> new HashMap<>() {{
        put(true, new ArrayList<Integer>());
        put(false, new ArrayList<Integer>());
      }};
    }

    @Override
    public BiConsumer<Map<Boolean, List<Integer>>, Integer> accumulator() {
      return (Map<Boolean, List<Integer>> acc, Integer candidate) -> {
        acc.get(isPrime(acc.get(true), candidate))
            .add(candidate);
      };
    }

    @Override
    public BinaryOperator<Map<Boolean, List<Integer>>> combiner() {
      return (Map<Boolean, List<Integer>> map1, Map<Boolean, List<Integer>> map2) -> {
        map1.get(true).addAll(map2.get(true));
        map1.get(false).addAll(map2.get(false));
        return map1;
      };
    }

    @Override
    public Function<Map<Boolean, List<Integer>>, Map<Boolean, List<Integer>>> finisher() {
      return i -> i;
    }

    @Override
    public Set<Characteristics> characteristics() {
      return Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH));
    }

  }

  public Map<Boolean, List<Integer>> partitionPrimesWithInlineCollector(int n) {
    return Stream.iterate(2, i -> i + 1).limit(n)
        .collect(
            () -> new HashMap<Boolean, List<Integer>>() {{
              put(true, new ArrayList<Integer>());
              put(false, new ArrayList<Integer>());
            }},
            (acc, candidate) -> {
              acc.get(isPrime(acc.get(true), candidate))
                  .add(candidate);
            },
            (map1, map2) -> {
              map1.get(true).addAll(map2.get(true));
              map1.get(false).addAll(map2.get(false));
            }
        );
  }
}
--------------------------------------------------------------------------------------------------------
import java.util.List;

import java.util.TimeZone;
import java.util.SimpleTimeZone;

/**
 * Creates a list of TimeZones for use in the UI. The current implementation just creates a
 * {@link SimpleTimeZone} for all 25 hours from -12 UTC to +12 UTC.
 */
public final class TimeZoneFactory {
    public static final List<TimeZone> TIMEZONES;

    static {
        List<TimeZone> temp = new java.util.ArrayList<TimeZone>(25);

        for (int i = -12; i <= 12; i++) {
            String id = "UTC";

            if (i < 0) {
                id += i;
                id += ":00";
            }
            else if (i > 0) {
                id += '+';
                id += i;
                id += ":00";
            }

            temp.add(new SimpleTimeZone(i * 3600000, id));
        }

        TIMEZONES = java.util.Collections.unmodifiableList(temp);
    }

    private TimeZoneFactory() {}
}
--------------------------------------------------------------------------------------------------------
import java.nio.charset.Charset;
import java.util.concurrent.ThreadLocalRandom;

/**
 * Miscellaneous useful functions for dealing with low level bits and bytes.
 */
public class BitUtil
{
    /**
     * Size of a byte in bytes
     */
    public static final int SIZE_OF_BYTE = 1;

    /**
     * Size of a boolean in bytes
     */
    public static final int SIZE_OF_BOOLEAN = 1;

    /**
     * Size of a char in bytes
     */
    public static final int SIZE_OF_CHAR = 2;

    /**
     * Size of a short in bytes
     */
    public static final int SIZE_OF_SHORT = 2;

    /**
     * Size of an int in bytes
     */
    public static final int SIZE_OF_INT = 4;

    /**
     * Size of a a float in bytes
     */
    public static final int SIZE_OF_FLOAT = 4;

    /**
     * Size of a long in bytes
     */
    public static final int SIZE_OF_LONG = 8;

    /**
     * Size of a double in bytes
     */
    public static final int SIZE_OF_DOUBLE = 8;

    /**
     * Length of the data blocks used by the CPU cache sub-system in bytes.
     */
    public static final int CACHE_LINE_LENGTH = 64;

    private static final byte[] HEX_DIGIT_TABLE =
    {
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
    };

    private static final byte[] FROM_HEX_DIGIT_TABLE;

    static
    {
        FROM_HEX_DIGIT_TABLE = new byte[128];

        FROM_HEX_DIGIT_TABLE['0'] = 0x00;
        FROM_HEX_DIGIT_TABLE['1'] = 0x01;
        FROM_HEX_DIGIT_TABLE['2'] = 0x02;
        FROM_HEX_DIGIT_TABLE['3'] = 0x03;
        FROM_HEX_DIGIT_TABLE['4'] = 0x04;
        FROM_HEX_DIGIT_TABLE['5'] = 0x05;
        FROM_HEX_DIGIT_TABLE['6'] = 0x06;
        FROM_HEX_DIGIT_TABLE['7'] = 0x07;
        FROM_HEX_DIGIT_TABLE['8'] = 0x08;
        FROM_HEX_DIGIT_TABLE['9'] = 0x09;
        FROM_HEX_DIGIT_TABLE['a'] = 0x0a;
        FROM_HEX_DIGIT_TABLE['A'] = 0x0a;
        FROM_HEX_DIGIT_TABLE['b'] = 0x0b;
        FROM_HEX_DIGIT_TABLE['B'] = 0x0b;
        FROM_HEX_DIGIT_TABLE['c'] = 0x0c;
        FROM_HEX_DIGIT_TABLE['C'] = 0x0c;
        FROM_HEX_DIGIT_TABLE['d'] = 0x0d;
        FROM_HEX_DIGIT_TABLE['D'] = 0x0d;
        FROM_HEX_DIGIT_TABLE['e'] = 0x0e;
        FROM_HEX_DIGIT_TABLE['E'] = 0x0e;
        FROM_HEX_DIGIT_TABLE['f'] = 0x0f;
        FROM_HEX_DIGIT_TABLE['F'] = 0x0f;
    }

    private static final int LAST_DIGIT_MASK = 0b1;

    private static final Charset UTF8_CHARSET = Charset.forName("UTF-8");

    /**
     * Fast method of finding the next power of 2 greater than or equal to the supplied value.
     * <p>
     * If the value is &lt;= 0 then 1 will be returned.
     * <p>
     * This method is not suitable for {@link Integer#MIN_VALUE} or numbers greater than 2^30.
     *
     * @param value from which to search for next power of 2
     * @return The next power of 2 or the value itself if it is a power of 2
     */
    public static int findNextPositivePowerOfTwo(final int value)
    {
        return 1 << (32 - Integer.numberOfLeadingZeros(value - 1));
    }

    /**
     * Align a value to the next multiple up of alignment.
     * If the value equals an alignment multiple then it is returned unchanged.
     * <p>
     * This method executes without branching. This code is designed to be use in the fast path and should not
     * be used with negative numbers. Negative numbers will result in undefined behaviour.
     *
     * @param value     to be aligned up.
     * @param alignment to be used.
     * @return the value aligned to the next boundary.
     */
    public static int align(final int value, final int alignment)
    {
        return (value + (alignment - 1)) & ~(alignment - 1);
    }

    /**
     * Generate a byte array from the hex representation of the given byte array.
     *
     * @param buffer to convert from a hex representation (in Big Endian)
     * @return new byte array that is decimal representation of the passed array
     */
    public static byte[] fromHexByteArray(final byte[] buffer)
    {
        final byte[] outputBuffer = new byte[buffer.length >> 1];

        for (int i = 0; i < buffer.length; i += 2)
        {
            outputBuffer[i >> 1] =
                (byte)((FROM_HEX_DIGIT_TABLE[buffer[i]] << 4) | FROM_HEX_DIGIT_TABLE[buffer[i + 1]]);
        }

        return outputBuffer;
    }

    /**
     * Generate a byte array that is a hex representation of a given byte array.
     *
     * @param buffer to convert to a hex representation
     * @return new byte array that is hex representation (in Big Endian) of the passed array
     */
    public static byte[] toHexByteArray(final byte[] buffer)
    {
        return toHexByteArray(buffer, 0, buffer.length);
    }

    /**
     * Generate a byte array that is a hex representation of a given byte array.
     *
     * @param buffer to convert to a hex representation
     * @param offset the offset into the buffer
     * @param length the number of bytes to convert
     * @return new byte array that is hex representation (in Big Endian) of the passed array
     */
    public static byte[] toHexByteArray(final byte[] buffer, final int offset, final int length)
    {
        final byte[] outputBuffer = new byte[length << 1];

        for (int i = 0; i < (length << 1); i += 2)
        {
            final byte b = buffer[offset + (i >> 1)];

            outputBuffer[i] = HEX_DIGIT_TABLE[(b >> 4) & 0x0F];
            outputBuffer[i + 1] = HEX_DIGIT_TABLE[b & 0x0F];
        }

        return outputBuffer;
    }

    /**
     * Generate a byte array from a string that is the hex representation of the given byte array.
     *
     * @param string to convert from a hex representation (in Big Endian)
     * @return new byte array holding the decimal representation of the passed array
     */
    public static byte[] fromHex(final String string)
    {
        return fromHexByteArray(string.getBytes(UTF8_CHARSET));
    }

    /**
     * Generate a string that is the hex representation of a given byte array.
     *
     * @param buffer to convert to a hex representation
     * @param offset the offset into the buffer
     * @param length the number of bytes to convert
     * @return new String holding the hex representation (in Big Endian) of the passed array
     */
    public static String toHex(final byte[] buffer, final int offset, final int length)
    {
        return new String(toHexByteArray(buffer, offset, length), UTF8_CHARSET);
    }

    /**
     * Generate a string that is the hex representation of a given byte array.
     *
     * @param buffer to convert to a hex representation
     * @return new String holding the hex representation (in Big Endian) of the passed array
     */
    public static String toHex(final byte[] buffer)
    {
        return new String(toHexByteArray(buffer), UTF8_CHARSET);
    }

    /**
     * Is a number even.
     *
     * @param value to check.
     * @return true if the number is even otherwise false.
     */
    public static boolean isEven(final int value)
    {
        return (value & LAST_DIGIT_MASK) == 0;
    }

    /**
     * Is a value a positive power of two.
     *
     * @param value to be checked.
     * @return true if the number is a positive power of two otherwise false.
     */
    public static boolean isPowerOfTwo(final int value)
    {
        return value > 0 && ((value & (~value + 1)) == value);
    }

    /**
     * Cycles indices of an array one at a time in a forward fashion
     *
     * @param current value to be incremented.
     * @param max     value for the cycle.
     * @return the next value, or zero if max is reached.
     */
    public static int next(final int current, final int max)
    {
        int next = current + 1;
        if (next == max)
        {
            next = 0;
        }

        return next;
    }

    /**
     * Cycles indices of an array one at a time in a backwards fashion
     *
     * @param current value to be decremented.
     * @param max     value of the cycle.
     * @return the next value, or max - 1 if current is zero
     */
    public static int previous(final int current, final int max)
    {
        if (0 == current)
        {
            return max - 1;
        }

        return current - 1;
    }

    /**
     * Calculate the shift value to scale a number based on how refs are compressed or not.
     *
     * @param scale of the number reported by Unsafe.
     * @return how many times the number needs to be shifted to the left.
     */
    public static int calculateShiftForScale(final int scale)
    {
        if (4 == scale)
        {
            return 2;
        }
        else if (8 == scale)
        {
            return 3;
        }
        else
        {
            throw new IllegalArgumentException("Unknown pointer size");
        }
    }

    /**
     * Generate a randomized integer over [{@link Integer#MIN_VALUE}, {@link Integer#MAX_VALUE}] suitable for
     * use as an Aeron Id.
     *
     * @return randomized integer suitable as an Id.
     */
    public static int generateRandomisedId()
    {
        return ThreadLocalRandom.current().nextInt();
    }

    /**
     * Is an address aligned on a boundary.
     *
     * @param address   to be tested.
     * @param alignment boundary the address is tested against.
     * @return true if the address is on the aligned boundary otherwise false.
     * @throws IllegalArgumentException if the alignment is not a power of 2`
     */
    public static boolean isAligned(final long address, final int alignment)
    {
        if (!BitUtil.isPowerOfTwo(alignment))
        {
            throw new IllegalArgumentException("Alignment must be a power of 2: alignment=" + alignment);
        }

        return (address & (alignment - 1)) == 0;
    }
}
--------------------------------------------------------------------------------------------------------
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;

import static java.lang.invoke.MethodType.methodType;

/**
 * This class captures possible hints that may be used by some
 * runtimes to improve code performance. It is intended to capture hinting
 * behaviours that are implemented in or anticipated to be spec'ed under the
 * {@link java.lang.Thread} class in some Java SE versions, but missing in prior
 * versions.
 */
public final class ThreadHints
{
    private static final MethodHandle ON_SPIN_WAIT_METHOD_HANDLE;

    static
    {
        final MethodHandles.Lookup lookup = MethodHandles.lookup();

        MethodHandle methodHandle = null;
        try
        {
            methodHandle = lookup.findStatic(Thread.class, "onSpinWait", methodType(void.class));
        }
        catch (final Exception ignore)
        {
        }

        ON_SPIN_WAIT_METHOD_HANDLE = methodHandle;
    }

    private ThreadHints()
    {
    }

    /**
     * Indicates that the caller is momentarily unable to progress, until the
     * occurrence of one or more actions on the part of other activities.  By
     * invoking this method within each iteration of a spin-wait loop construct,
     * the calling thread indicates to the runtime that it is busy-waiting. The runtime
     * may take action to improve the performance of invoking spin-wait loop constructions.
     */
    public static void onSpinWait()
    {
        // Call java.lang.Thread.onSpinWait() on Java SE versions that support it. Do nothing otherwise.
        // This should optimize away to either nothing or to an inlining of java.lang.Thread.onSpinWait()
        if (null != ON_SPIN_WAIT_METHOD_HANDLE)
        {
            try
            {
                ON_SPIN_WAIT_METHOD_HANDLE.invokeExact();
            }
            catch (final Throwable ignore)
            {
            }
        }
    }
}
--------------------------------------------------------------------------------------------------------
jlink --module-path $JAVA_HOME/jmods:mods --add-modules org.firstModule --output
firstmoduleapp
javac -d mods --module-source-path src $(find src -name "*.java")
jrunscript –l js myTest.js

jjs /src/org/java9recipes/chapter18/js/helloNashorn.js

--------------------------------------------------------------------------------------------------------
@Component
public class NewUserValidator implements Validator {
 @Autowired
 private UserRepository userRepository;
 @Override
 public boolean supports(Class<?> clazz) {
 return User.class.isAssignableFrom(clazz);
 }
 @Override
 public void validate(Object target, Errors errors) {
 User newUser = (User) target;
 if (userRepository.exists(newUser.getUsername())) {
 errors.rejectValue("username", "new.account.username.already.
exists");
 }
 }
--------------------------------------------------------------------------------------------------------

/**
 * Do-while, break, and continue.
 */
public class Validate {

    public static double scanDouble() {
        Scanner in = new Scanner(System.in);
        boolean okay;
        do {
            System.out.print("Enter a number: ");
            if (in.hasNextDouble()) {
                okay = true;
            } else {
                okay = false;
                String word = in.next();
                System.err.println(word + " is not a number");
            }
        } while (!okay);
        double x = in.nextDouble();
        return x;
    }

    public static double scanDouble2() {
        Scanner in = new Scanner(System.in);
        while (true) {
            System.out.print("Enter a number: ");
            if (in.hasNextDouble()) {
                break;
            }
            String word = in.next();
            System.err.println(word + " is not a number");
        }
        double x = in.nextDouble();
        return x;
    }

    public static double addNumbers() {
        Scanner in = new Scanner(System.in);
        int x = -1;
        int sum = 0;
        while (x != 0) {
            x = in.nextInt();
            if (x <= 0) {
                continue;
            }
            System.out.println("Adding " + x);
            sum += x;
        }
        return sum;
    }

}
--------------------------------------------------------------------------------------------------------
C:\Some Directory>set path=C:\Program Files\Java\jdk1.8.0_25\bin;%path%
C:\Some Directory>keytool -genkey -alias mykeystore -keystore
keystore.jks
keytool -list -v -keystore keystore.jks -alias mykeystore

keytool -genkeypair -alias mykeystore -keystore keystore.jks -keypass
password -storepass password -dname "cn=some name, ou=development,
o=mycom.com, l=some city, st=some state c=jv


This command will create the serverkeystore.jck keystore file using the RSA algorithm
with a key size of 1,024 bits and an expiration date of 365 days:
keytool -genkeypair -alias server -keyalg RSA -keysize 1024 -storetype
jceks -validity 365 -keypass password -keystore serverkeystore.jck -
storepass password -dname "cn=localhost, ou=Department, o=MyComp Inc,
l=Some City, st=JV c=US


This command generates a clientkeystore.jck keystore to be used by the client
application:
keytool -genkeypair -alias client -keyalg RSA -keysize 1024 -storetype
jceks -validity 365 -keypass password -keystore clientkeystore.jck -
storepass password -dname "cn=localhost, ou=Department, o=MyComp Inc,
l=Some City, st=JV c=US
A certificate file for the client is created next and is placed in the client.crt file:
keytool -export -alias client -storetype jceks -keystore clientkeystore.jck
-storepass password -file client.crt
The server’s certificate is exported here:
keytool -export -alias server -storetype jceks -keystore serverkeystore.jck
-storepass password -file server.crt

The following command creates the clienttruststore.jck file, which is the trust store
for the client:
keytool -importcert -alias server -file server.crt -keystore
clienttruststore.jck -keypass password -storepass storepassword

ByteBuffer buffer = ByteBuffer.allocate(4096);
System.out.println(buffer.order());
buffer.order(ByteOrder.LITTLE_ENDIAN);
System.out.println(buffer.order());
--------------------------------------------------------------------------------------------------------
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.UndeclaredThrowableException;
import java.sql.SQLException;
import java.sql.Wrapper;
import java.util.*;

/**
 * Implements an {@link java.lang.reflect.InvocationHandler} that handles {@link java.sql.Wrapper} method invocations.
 */
public class WrapperInvocationHandler<T> implements InvocationHandler {

  private final T wrapped;
  private final boolean wrappedIsWrapper;

  public WrapperInvocationHandler(final T wrapped) {
    Objects.requireNonNull(wrapped, "object to be wrapped");
    this.wrapped = wrapped;
    this.wrappedIsWrapper = this.wrapped instanceof Wrapper;
  }

  @Override
  public Object invoke(final Object proxy, final Method method, Object[] args) throws Throwable {
    if (args == null) args = new Object[0];
    if (args.length == 1 && Class.class.isAssignableFrom(args[0].getClass())) {
      Class<?> clazz = Class.class.cast(args[0]);
      String methodName = method.getName();
      switch (methodName) {
        case "unwrap":
          return unwrapTo(clazz);
        case "isWrapperFor":
          return isWrapped(clazz);
        default: // Fall through
      }
    }
    return method.invoke(wrapped, args);
  }

  private <A> A unwrapTo(Class<A> clazz) throws SQLException {
    Objects.requireNonNull(clazz, "class to unwrap to");
    if (wrappedIsWrapper) {
      Wrapper w = ((Wrapper) wrapped);
      try {
        if (w.isWrapperFor(clazz)) return w.unwrap(clazz);
      } catch(SQLException | UndeclaredThrowableException e) {
        // Driver doesn't implement the wrapper functionality
      }
    }
    if (clazz.isAssignableFrom(wrapped.getClass())) return clazz.cast(wrapped);
    throw new SQLException("Could not unwrap " + wrapped + " to " + clazz);
  }

  private boolean isWrapped(Class<?> clazz) throws SQLException {
    Objects.requireNonNull(clazz, "class to check for wrapping");
    if (clazz.isAssignableFrom(wrapped.getClass())) return true;
    if (wrappedIsWrapper) return ((Wrapper) wrapped).isWrapperFor(clazz);
    return false;
  }
}
--------------------------------------------------------------------------------------------------------
%javac -Xlint:unchecked DeceptiveLibrary.java
% javac -classpath s g/Client.java
% java -ea -classpath l g/Client

--------------------------------------------------------------------------------------------------------
@ExcludeDefaultInterceptors
@ExcludeClassInterceptors
--------------------------------------------------------------------------------------------------------
import java.io.*;
 import java.util.*;
 public class WordFrequency {
 final static int MaxWords = 50;
 public static void main(String[] args) throws IOException {
 String[] wordList = new String[MaxWords];
 int[] frequency = new int[MaxWords];
 FileReader in = new FileReader("passage.txt");
 PrintWriter out = new PrintWriter(new FileWriter("output.txt"));

 for (int h = 0; h < MaxWords; h++) {
 frequency[h] = 0;
 wordList[h] = "";
 }
 int numWords = 0;
 String word = getWord(in).toLowerCase();
 while (!word.equals("")) {
 int loc = binarySearch(word, wordList, 0, numWords-1);
 if (word.compareTo(wordList[loc]) == 0) ++frequency[loc]; //word found
 else //this is a new word
 if (numWords < MaxWords) { //if table is not full
 addToList(word, wordList, frequency, loc, numWords-1);
 ++numWords;
 }
 else out.printf("'%s' not added to table\n", word);
 word = getWord(in).toLowerCase();
 }
 printResults(out, wordList, frequency, numWords);
 in.close();
 out.close();
 } // end main
 public static int binarySearch(String key, String[] list, int lo, int hi){
 //search for key from list[lo] to list[hi]
 //if found, return its location;
 //if not found, return the location in which it should be inserted
 //the calling program will check the location to determine if found
 while (lo <= hi) {
 int mid = (lo + hi) / 2;
 int cmp = key.compareTo(list[mid]);
 if (cmp == 0) return mid; // search succeeds
 if (cmp < 0) hi = mid -1; // key is 'less than' list[mid]
 else lo = mid + 1; // key is 'greater than' list[mid]
 }
 return lo; //key must be inserted in location lo
 } //end binarySearch
 public static void addToList(String item, String[] list, int[] freq, int p, int n) {
 //adds item in position list[p]; sets freq[p] to 1
 //shifts list[n] down to list[p] to the right
 for (int h = n; h >= p; h--) {
 list[h + 1] = list[h];
 freq[h + 1] = freq[h];
 }
 list[p] = item;
 freq[p] = 1;
 } //end addToList
 public static void printResults(PrintWriter out, String[] list, int freq[], int n) {
 out.printf("\nWords Frequency\n\n");
 for (int h = 0; h < n; h++)
 out.printf("%-20s %2d\n", list[h], freq[h]);
 } //end printResults
 public static String getWord(FileReader in) throws IOException {
 //returns the next word found
 final int MaxLen = 255;
 int c, n = 0;
 char[] word = new char[MaxLen];
 // read over non-letters
 while (!Character.isLetter((char) (c = in.read())) && (c != -1)) ;
 //empty while body
 if (c == -1) return ""; //no letter found
 word[n++] = (char) c;
 while (Character.isLetter(c = in.read()))
 if (n < MaxLen) word[n++] = (char) c;
 return new String(word, 0, n);
 } // end getWord
 } //end class WordFrequency
--------------------------------------------------------------------------------------------------------
public static int kthSmall(int[] A, int k, int lo, int hi) {
 //returns the kth smallest from A[lo] to A[hi]
 int kShift = lo + k - 1; //shift k to the given portion, A[lo..hi]
 if (kShift < lo || kShift > hi) return -9999;
 int dp = partition1(A, lo, hi);
 while (dp != kShift) {
 if (kShift < dp) hi = dp - 1; //kth smallest is in the left part
 else lo = dp + 1; //kth smallest is in the right part
 dp = partition1(A, lo, hi);
 }
 return A[dp];
 }
--------------------------------------------------------------------------------------------------------
import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
 import javax.inject.Qualifier;
 @Qualifier
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.FIELD,ElementType.PARAMETER,ElementType.TYPE})
 public @interface MessageEvent {
 Type value();
 enum Type{ SERVICE, PARAMETER }
}
--------------------------------------------------------------------------------------------------------
 package com.devchronicles.singleton;
 public class MySingleton {
 private volatile MySingleton instance;
 private MySingleton() {}
 public MySingleton getInstance() {
 if (instance == null) { // 1
synchronized (MySingleton.class) {
if (instance == null) { // 2
instance = new MySingleton();
}
}
}
return instance;
 }
}
--------------------------------------------------------------------------------------------------------
// enum Season { WINTER, SPRING, SUMMER, FALL }
final class Season extends Enum<Season> {
 private Season(String name, int ordinal) { super(name,ordinal); }
 public static final Season WINTER = new Season("WINTER",0);
 public static final Season SPRING = new Season("SPRING",1);
 public static final Season SUMMER = new Season("SUMMER",2);
 public static final Season FALL = new Season("FALL",3);
 private static final Season[] VALUES = { WINTER, SPRING, SUMMER, FALL };
 public static Season[] values() { return VALUES.clone(); }
 public static Season valueOf(String name) {
 for (Season e : VALUES) if (e.name().equals(name)) return e;
 throw new IllegalArgumentException();
 }
}
--------------------------------------------------------------------------------------------------------
/**
 * If this file is a plain file, provides the lines of the file (read as
 * UTF-8) without the line-termination characters as a stream.
 * Otherwise, returns a single {@link Result} instance with an
 * {@link IOException}.
 *
 * @return The lines of the file; never {@code null}
 */
public Stream<Result<String>> getLines() {
 if (!isFile()) {
 return Stream.of(new Result<>(new IOException(
 "File is not a plain file: " + toString()
 )));
 }
 try {
 return Files.lines(toPath()).map(Result::new);
 } catch (IOException ioe) {
 return Stream.of(new Result<>(ioe));
 }
}
--------------------------------------------------------------------------------------------------------
Function<Path, Stream<String>> readLines = path -> {
 try {
 return Files.lines(path);
 } catch (IOException ioe) {
 throw new RuntimeException("Error reading " + path, ioe);
 }
};
Stream<String> lines = Stream.of("foo.txt", "bar.txt", "baz.txt")
 .map(Paths::get)
 .filter(Files::exists)
 .flatMap(readLines);
 
 Map<Book.Genre, List<Book>> booksByGenre =
 library.getBooks().parallelStream()
 .collect(Collectors.groupingByConcurrent(Book::getGenre));
--------------------------------------------------------------------------------------------------------
<RETURN_T> Result<RETURN_T> withTempFile(Function<File, RETURN_T> function) {
 Objects.requireNonNull(function, "function to apply to temp file");
 Optional<File> file = Optional.empty();
 try {
 file = Optional.of(File.createTempFile("funfile", "tmp"));
 return new Result<>(file.map(function).get());
 } catch (IOException e) {
 return new Result<>(e);
 } finally {
 file.ifPresent(File::delete);
 }
} // This code would work, but could do with improvement: read on!

--------------------------------------------------------------------------------------------------------
  Collection<Character> unique = new ArrayList<Character>();
    
  for (int i = 0; i < s.length(); i++) {
    char c = Character.toLowerCase(s.charAt(i));
    if (Character.isWhitespace(c)) { continue; }
      
    if (!unique.contains(c)) {
      unique.add(c);
    }
  }
--------------------------------------------------------------------------------------------------------
Comparator<File> fileComparator =
 Comparator.nullsLast(
 Comparator.comparing(File::getName)
 );
--------------------------------------------------------------------------------------------------------
mvn install:install-file -Dfile=opencvjar -runtime-natives-linux-x86.
jar -DgroupId=opencvjar -DartifactId=opencvjar-runtime -Dversion=3.0.0
-Dpackaging=jar -Dclassifier=natives-linux-x86

 <plugins>
 <plugin>
 <artifactId>maven-jar-plugin</artifactId>
 <version>2.4</version>
 <configuration>
 <archive>
 <manifest>
 <addClasspath>true</addClasspath>
 <classpathPrefix>lib/</classpathPrefix>
 <mainClass>com.mycompany.app.App</mainClass>
 </manifest>
 </archive>
 </configuration>
 </plugin>
 <plugin>
 <groupId>org.apache.maven.plugins</groupId>
 <artifactId>maven-dependency-plugin</artifactId>
 <version>2.1</version>
 <executions>
 <execution>
 <id>copy-dependencies</id>

 <goals>
 <goal>copy-dependencies</goal>
 </goals>
 <configuration>
 <outputDirectory>${project.build.directory}/lib</
outputDirectory>
 <overWriteReleases>false</overWriteReleases>
 <overWriteSnapshots>false</overWriteSnapshots>
 <overWriteIfNewer>true</overWriteIfNewer>
 </configuration>
 </execution>
 </executions>
 </plugin>
 <plugin>
 <groupId>com.googlecode.mavennatives</groupId>
 <artifactId>maven-nativedependencies-plugin</artifactId>
 <version>0.0.7</version>
 <executions>
 <execution>
 <id>unpacknatives</id>
 <phase>generate-resources</phase>
 <goals>
 <goal>copy</goal>
 </goals>
 </execution>
 </executions>
 </plugin>
 </plugin
--------------------------------------------------------------------------------------------------------
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class AuthFilter implements Filter {
    private static Logger log = LoggerFactory.getLogger(AuthFilter.class);
    public static final int NOT_AUTHORIZED = 401;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        final String secret = httpRequest.getHeader("X-PartnerSecret");
        log.info("Partner secret is {}", secret);
        if (true || "packt".equals(secret) ) {
            chain.doFilter(request, response);
        } else {
            HttpServletResponse httpResponse = (HttpServletResponse) response;
            httpResponse.sendError(NOT_AUTHORIZED);
        }
    }

    @Override
    public void destroy() {

    }
}


java -Xmx1g -cp lingpipe-cookbook.1.0.jar:lib/lingpipe4.1.0.jar:lib/opencsv-2.4.jar com.lingpipe.cookbook.chapter6.
SpellCheck 


<dependency>
 <groupId>org.nd4j</groupId>
 <artifactId>nd4j-x86</artifactId>
 <version>${nd4j.version}</version>
</dependency>

<dependency>
 <artifactId>canova-nd4j-image</artifactId>
 <groupId>org.nd4j</groupId>
 <version>${canova.version}</version>
</dependency>
<dependency>
 <artifactId>canova-nd4j-codec</artifactId>
 <groupId>org.nd4j</groupId>
 <version>${canova.version}</version>
</dependency>


<dependency>
 <groupId>org.nd4j</groupId>
 <artifactId>nd4j-jcublas-XXX</artifactId>
 <version>${nd4j.version}</version>
</dependency>

<dependency>
 <groupId>org.deeplearning4j</groupId>
 <artifactId>deeplearning4j-nlp</artifactId>
 <version>${dl4j.version}</version>
</dependency>
<dependency>
 <groupId>org.deeplearning4j</groupId>
 <artifactId>deeplearning4j-core</artifactId>
 <version>${dl4j.version}</version>
</dependency>
--------------------------------------------------------------------------------------------------------
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.ReadOnlyBufferException;

public enum ByteBufferUtils {
  ;

  public static void checkRange(ByteBuffer buf, int off, int len) {
    SafeUtils.checkLength(len);
    if (len > 0) {
      checkRange(buf, off);
      checkRange(buf, off + len - 1);
    }
  }

  public static void checkRange(ByteBuffer buf, int off) {
    if (off < 0 || off >= buf.capacity()) {
      throw new ArrayIndexOutOfBoundsException(off);
    }
  }

  public static ByteBuffer inLittleEndianOrder(ByteBuffer buf) {
    if (buf.order().equals(ByteOrder.LITTLE_ENDIAN)) {
      return buf;
    } else {
      return buf.duplicate().order(ByteOrder.LITTLE_ENDIAN);
    }
  }

  public static ByteBuffer inNativeByteOrder(ByteBuffer buf) {
    if (buf.order().equals(Utils.NATIVE_BYTE_ORDER)) {
      return buf;
    } else {
      return buf.duplicate().order(Utils.NATIVE_BYTE_ORDER);
    }
  }

  public static byte readByte(ByteBuffer buf, int i) {
    return buf.get(i);
  }

  public static void writeInt(ByteBuffer buf, int i, int v) {
    assert buf.order() == Utils.NATIVE_BYTE_ORDER;
    buf.putInt(i, v);
  }

  public static int readInt(ByteBuffer buf, int i) {
    assert buf.order() == Utils.NATIVE_BYTE_ORDER;
    return buf.getInt(i);
  }

  public static int readIntLE(ByteBuffer buf, int i) {
    assert buf.order() == ByteOrder.LITTLE_ENDIAN;
    return buf.getInt(i);
  }

  public static void writeLong(ByteBuffer buf, int i, long v) {
    assert buf.order() == Utils.NATIVE_BYTE_ORDER;
    buf.putLong(i, v);
  }

  public static long readLong(ByteBuffer buf, int i) {
    assert buf.order() == Utils.NATIVE_BYTE_ORDER;
    return buf.getLong(i);
  }

  public static long readLongLE(ByteBuffer buf, int i) {
    assert buf.order() == ByteOrder.LITTLE_ENDIAN;
    return buf.getLong(i);
  }

  public static void writeByte(ByteBuffer dest, int off, int i) {
    dest.put(off, (byte) i);
  }

  public static void writeShortLE(ByteBuffer dest, int off, int i) {
    dest.put(off, (byte) i);
    dest.put(off + 1, (byte) (i >>> 8));
  }

  public static void checkNotReadOnly(ByteBuffer buffer) {
    if (buffer.isReadOnly()) {
      throw new ReadOnlyBufferException();
    }
  }

  public static int readShortLE(ByteBuffer buf, int i) {
    return (buf.get(i) & 0xFF) | ((buf.get(i+1) & 0xFF) << 8);
  }
}
--------------------------------------------------------------------------------------------------------
import java.io.File;
import java.io.FileFilter;

import java.util.List;

/**
 * Utility methods for recursive directory searches.
 */
public final class FileHelper {
    public static void recurseDirectories(File[] files, FileFilter filter, List<String> filenames) {
        for (int i = 0; i < files.length; i++) {
            if (files[i].isDirectory()) {
                recurseDirectories(files[i].listFiles(), filter, filenames);
            }
            else {
                if (filter.accept(files[i])) {
                    filenames.add(files[i].getAbsolutePath());
                }
            }
        }
    }

    public static void recurseDirectories(List<File> files, FileFilter filter, List<String> filenames) {
        for (File file : files) {
            if (file.isDirectory()) {
                recurseDirectories(file.listFiles(), filter, filenames);
            }
            else {
                if (filter.accept(file)) {
                    filenames.add(file.getAbsolutePath());
                }
            }
        }
    }

    private FileHelper() {}
}
--------------------------------------------------------------------------------------------------------

    private static final class LRUMap<K, V> extends LinkedHashMap<K, V> {
        private static final long serialVersionUID = -1440114072711805032L;

        private final int maxSize;

        LRUMap(int maxSize) {
            this.maxSize = maxSize;
        }

        public V put(K key, V value) {
            V v = super.put(key, value);

            if (v == null) {
                TimeFormatCache.LOGGER.trace("cached {}={}", key, value);
            }

            return v;
        };

        protected boolean removeEldestEntry(java.util.Map.Entry<K, V> eldest) {
            boolean oversized = size() > maxSize;

            if (oversized) {
                TimeFormatCache.LOGGER.trace("evicted {}={}", eldest.getKey(), eldest.getValue());
            }

            return oversized;
        };
    }
--------------------------------------------------------------------------------------------------------
jcmd <myJavaPid> GC.heap_dump /path/to/myDump8.dat
jmap -histo 29620
-Xmx1g -XX:NewSize=512m -XX:MaxNewSize=512m -XX:+UseConcMarkSweepGC -XX:ConcGCThreads=4
jstat -gc <myPid> 1s

tcpdump -X -i any -s 0 "port 8675 and greater 100"

jstack 15893 > myThreadDump.txt

--------------------------------------------------------------------------------------------------------
import java.util.List;
import java.util.stream.Collectors;

public class StackWalkerDemo {
    public static void main(String[] args) {
        List<StackWalker.StackFrame> frames = StackWalker.getInstance()
                                                       .walk(s -> s.limit(10)
                                                                   .collect(Collectors.toList()));
        frames.forEach(System.out::println);
    }
}
--------------------------------------------------------------------------------------------------------
-d docs
-html5
-author
-version
--module-source-path docsrc
--module jdojo.utility,jdojo.jshell
-overview docsrc\overview.html
--------------------------------------------------------------------------------------------------------
  private static class WordCounterSpliterator implements Spliterator<Character> {

    private final String string;
    private int currentChar = 0;

    private WordCounterSpliterator(String string) {
      this.string = string;
    }

    @Override
    public boolean tryAdvance(Consumer<? super Character> action) {
      action.accept(string.charAt(currentChar++));
      return currentChar < string.length();
    }

    @Override
    public Spliterator<Character> trySplit() {
      int currentSize = string.length() - currentChar;
      if (currentSize < 10) {
        return null;
      }
      for (int splitPos = currentSize / 2 + currentChar; splitPos < string.length(); splitPos++) {
        if (Character.isWhitespace(string.charAt(splitPos))) {
          Spliterator<Character> spliterator = new WordCounterSpliterator(string.substring(currentChar, splitPos));
          currentChar = splitPos;
          return spliterator;
        }
      }
      return null;
    }

    @Override
    public long estimateSize() {
      return string.length() - currentChar;
    }

    @Override
    public int characteristics() {
      return ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;
    }

  }
--------------------------------------------------------------------------------------------------------
import java.util.stream.LongStream;

public class Recursion {

  public static void main(String[] args) {
    System.out.println(factorialIterative(5));
    System.out.println(factorialRecursive(5));
    System.out.println(factorialStreams(5));
    System.out.println(factorialTailRecursive(5));
  }

  public static int factorialIterative(int n) {
    int r = 1;
    for (int i = 1; i <= n; i++) {
      r *= i;
    }
    return r;
  }

  public static long factorialRecursive(long n) {
    return n == 1 ? 1 : n * factorialRecursive(n - 1);
  }

  public static long factorialStreams(long n) {
    return LongStream.rangeClosed(1, n).reduce(1, (long a, long b) -> a * b);
  }

  public static long factorialTailRecursive(long n) {
    return factorialHelper(1, n);
  }

  public static long factorialHelper(long acc, long n) {
    return n == 1 ? acc : factorialHelper(acc * n, n - 1);
  }

}

--------------------------------------------------------------------------------------------------------
@Author(name = "Raoul")
@Author(name = "Mario")
@Author(name = "Alan")
public class Book {

    public static void main(String[] args) {
        Author[] authors = Book.class.getAnnotationsByType(Author.class);
        Arrays.asList(authors).stream().forEach(a -> {
            System.out.println(a.name());
        });
    }

--------------------------------------------------------------------------------------------------------
package ai.grakn.engine;

/**
 * <p>
 *     Describes the six possible states a task can be in.
 *     Each state represents a different point in the process of execution.
 * </p>
 *
 * @author alexandraorth, Denis Lobanov
 */
public enum TaskStatus {
    /**
     * Save task in the graph, but not plans to run it yet - initial state.
     */
    CREATED,
    /**
     * Scheduled for execution. For example, if one instance of the Engine server schedules it,
     * other instances won't.
     */
    SCHEDULED,
    /**
     * Currently executing task.
     */
    RUNNING,
    /**
     * The task has successfully completed execution.
     */
    COMPLETED,
    /**
     * The task has been stopped on request.
     */
    STOPPED,
    /**
     * The task has failed to execute.
     */
    FAILED;
}
--------------------------------------------------------------------------------------------------------
Comparator<Student> byNameConsonants
 = Comparator.comparing( x -> x.name,
 (x,y) ->
 removeVowels(x).compareTo(removeVowels(y)));
Comparator<Integer> byDifference = (x,y) -> x - y;
Comparator<Double> byCeil =
 (x,y) -> (int)(Math.ceil(x) - Math.ceil(y));


Arrays.parallelPrefix(arr, op);

--------------------------------------------------------------------------------------------------------
BiConsumer<StringBuilder,String> accs = (x,y) ->
 x.append(y.replaceAll("[aeiou]",""));
String s = Stream.of("Joe","Kalpana","Christopher")
 .collect(Collector.of(
 StringBuilder::new,
Appendix Method References
402
 accs,
StringBuilder::append,
StringBuilder::toString));
 System.out.println(s);

--------------------------------------------------------------------------------------------------------
import com.basaki.example.postgres.jsonb.util.UuidBeanFactory;
import java.util.UUID;
import org.dozer.DozerBeanMapper;
import org.dozer.Mapper;
import org.dozer.loader.api.BeanMappingBuilder;
import org.dozer.loader.api.TypeMappingOptions;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Created by indra.basak on 3/8/17.
 */
@Configuration
public class SpringConfiguration {

    @Bean
    public static Mapper getMapper() {
        BeanMappingBuilder builder = new BeanMappingBuilder() {
            protected void configure() {
                mapping(UUID.class, UUID.class, TypeMappingOptions.oneWay(),
                        TypeMappingOptions.beanFactory(
                                UuidBeanFactory.class.getName()));
            }
        };

        DozerBeanMapper mapper = new DozerBeanMapper();
        mapper.addMapping(builder);

        return mapper;
    }
}
--------------------------------------------------------------------------------------------------------
import com.basaki.example.postgres.jsonb.data.entity.BookEntity;
import java.util.List;
import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

/**
 * {@code BookRepository} exposes all CRUD operations on a data of type
 * {@code Book}.
 * <p/>
 *
 * @author Indra Basak
 * @since 3/8/17
 */
public interface BookRepository extends JpaRepository<BookEntity, UUID> {

    @Query("SELECT DISTINCT b.publisher FROM BookEntity b WHERE UPPER(b.publisher) LIKE UPPER(CONCAT('%', ?1, '%'))")
    List<String> findDistinctPublisher(String publisher);

    @Query(value = "SELECT * FROM example_jsonb.books b WHERE b.author->>'firstName' ILIKE CONCAT('%', ?1, '%')", nativeQuery = true)
    List<BookEntity> findByAuthorFirstName(String firstName);

    @Query(value = "SELECT * FROM example_jsonb.books b WHERE b.author->>'lastName' ILIKE CONCAT('%', ?1, '%')", nativeQuery = true)
    List<BookEntity> findByAuthorLastName(String lastName);

    @Query(value = "SELECT * FROM example_jsonb.books b WHERE b.author->>'firstName' ILIKE CONCAT('%', ?1, '%') AND  b.author->>'lastName' ILIKE CONCAT('%', ?2, '%')", nativeQuery = true)
    List<BookEntity> findByAuthorFirstNameAndLastName(String firstName,
            String lastName);
}
--------------------------------------------------------------------------------------------------------

import java.util.LinkedHashMap;
import java.util.Map;
import org.springframework.boot.actuate.endpoint.annotation.Endpoint;
import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;

/**
 * {@code MyHealthEndpoint} to expose to my health endpoint.
 * <p/>
 *
 * @author Indra Basak
 * @since 10/17/17
 */
@Endpoint(id = "myhealth")
public class MyHealthEndpoint {

    @ReadOperation
    public MyHealth health() {
        Map<String, Object> details = new LinkedHashMap<>();
        details.put("MyStatus", "is happy");
        MyHealth health = new MyHealth();
        health.setDetails(details);

        return health;
    }
}
--------------------------------------------------------------------------------------------------------
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Transactional;

/**
 * {@code FilterCallerAnnotationAspect} intercepts {@code
 * com.basaki.service.UselessService.sayHello} a
 * method if the calling method is marked with annotaion
 * {@code org.springframework.transaction.annotation.Transactional}.
 * <p>
 *
 * @author Indra Basak
 * @since 02/10/18
 */
@Aspect
public class FilterCallerAnnotationAspect {

    private static final Logger
            log = LoggerFactory.getLogger(FilterCallerAnnotationAspect.class);

    @Before("call(* com.basaki.service.UselessService.sayHello(..))" +
            "  && cflow(@annotation(trx))")
    public void inspectMethod(JoinPoint jp,
            JoinPoint.EnclosingStaticPart esjp, Transactional trx) {
        log.info(
                "Entering FilterCallerAnnotationAspect.inspectMethod() in class "
                        + jp.getSignature().getDeclaringTypeName()
                        + " - method: " + jp.getSignature().getName());
    }
}
--------------------------------------------------------------------------------------------------------
HandlerInterceptorAdapter 

@Bean
public HandlerInterceptor performanceInterceptor() {
 PerformanceInterceptor interceptor;
 interceptor = new PerformanceInterceptor();
 return interceptor;
}
@Override
public void addInterceptors(InterceptorRegistry registry) {
 registry.addInterceptor(performanceInterceptor());
}
--------------------------------------------------------------------------------------------------------
version: 0.2
            
phases:
  install:
    runtime-versions:
      java: openjdk8
    commands:
      - echo install
  pre_build:
    commands:
      - echo pre_build
  build:
    commands:
      - mvn package
      - echo build
  post_build:
    commands:
      - echo post_build

artifacts:
  files:
    - target/spring-boot-todo-rest-api-h2-aws-codepipeline-0.0.1-SNAPSHOT.jar
--------------------------------------------------------------------------------------------------------
public class StringHelper {

	// ABCD,BCD
	public String truncateAInFirst2Positions(String input) {
		if (input.length() < 2)
			return input.replace("A", "");
		String first2Chars = input.substring(0, 2);
		String restOfTheString = input.substring(2);
		return first2Chars.replaceAll("A", "").concat(restOfTheString);
	}

	public boolean areFirstAndLastTwoCharsTheSame(String input) {
		
		if (input.length() < 2)
			return false;

		String first2Chars = input.substring(0,2);
		String last2Chars = input.substring(input.length()-2);
		
		return first2Chars.equals(last2Chars);
	}
}
--------------------------------------------------------------------------------------------------------
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;
import org.springframework.stereotype.Component;

@Component
@Scope(value=ConfigurableBeanFactory.SCOPE_PROTOTYPE, 
		proxyMode = ScopedProxyMode.TARGET_CLASS)
public class JdbcConnection {
	public JdbcConnection() {
		System.out.println("JDBC Connection");
	}
}
--------------------------------------------------------------------------------------------------------
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;

import com.in28minutes.springmvc.web.util.SessionData;

public class SessionCheckInterceptor extends HandlerInterceptorAdapter {

	@Autowired
	private SessionData sessionData;

	@Override
	public boolean preHandle(final HttpServletRequest request,
			final HttpServletResponse response, final Object handler)
			throws Exception {
		if (sessionData.getUser() == null) {
			response.sendRedirect("/login");
			return false;
		} else {
			return true;
		}
	}
}
--------------------------------------------------------------------------------------------------------
    /**
     * ECDSA algorithm is not supported by out-of-the-box JCA implementation.
     *
     * @return
     */
    public KeyPair generateKeyPair() {
        try {
            SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
            ECGenParameterSpec ecSpec = new ECGenParameterSpec("prime192v1");

            KeyPairGenerator keyGen =
                    KeyPairGenerator.getInstance(ALGO_ECDSA, "BC");
            keyGen.initialize(ecSpec, random);
            return keyGen.generateKeyPair();
        } catch (Exception e) {
            String msg =
                    "Failed to create a key pair for algortithm " + ALGO_ECDSA;
            log.error(msg, e);
            throw new InvalidCryptoException(msg, e);
        }
    }
--------------------------------------------------------------------------------------------------------
import lombok.extern.slf4j.Slf4j;

/**
 * Created by indra.basak on 3/21/17.
 */
@Slf4j
public enum AlgorithmType {

    HS256, HS384, HS512, RS256, RS384, RS512;
}
--------------------------------------------------------------------------------------------------------
import org.basaki.example.book.data.entity.BookEntity;
import java.util.List;
import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

/**
 * {@code BookRepository} exposes all CRUD operations on a data of type
 * {@code Book}.
 * <p/>
 *
 * @author Indra Basak
 * @since 4/16/17
 */
@Repository
public interface BookRepository extends JpaRepository<BookEntity, UUID> {

    @Query("SELECT DISTINCT b.publisher FROM BookEntity b WHERE " +
            "UPPER(b.publisher) LIKE UPPER(CONCAT('%', ?1, '%'))")
    List<String> findDistinctPublisher(String publisher);
}
--------------------------------------------------------------------------------------------------------
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Properties;
import org.springframework.beans.factory.config.YamlPropertiesFactoryBean;
import org.springframework.core.env.PropertiesPropertySource;
import org.springframework.core.env.PropertySource;
import org.springframework.core.io.support.EncodedResource;
import org.springframework.core.io.support.PropertySourceFactory;

/**
 * {@code YamlSourceFactory} is a used reading properties from a YAML file.
 * metrics.
 * <p>
 *
 * @author Indra Basak
 * @since 06/05/19
 */
public class YamlSourceFactory implements PropertySourceFactory {

    @Override
    public PropertySource<?> createPropertySource(String source,
            EncodedResource resource) throws IOException {
        Properties props = readYaml(resource);
        String name =
                source != null ? source : resource.getResource().getFilename();

        return new PropertiesPropertySource(name, props);
    }

    private Properties readYaml(EncodedResource resource)
            throws FileNotFoundException {
        try {
            YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();
            factory.setResources(resource.getResource());
            factory.afterPropertiesSet();

            return factory.getObject();
        } catch (IllegalStateException e) {
            if (e.getCause() instanceof FileNotFoundException) {
                throw ((FileNotFoundException) e.getCause());
            }

            throw e;
        }
    }
}
--------------------------------------------------------------------------------------------------------
@Schedules(value = {
 @Scheduled(fixedDelay = 3000),
 @Scheduled(cron="0 00 01 * * *")
})
--------------------------------------------------------------------------------------------------------
<plugins>
 <plugin>
 <groupId>org.eclipse.jetty</groupId>
 <artifactId>jetty-maven-plugin</artifactId>
 <version>9.2.1.v20140609</version>
 <configuration>
 <scanIntervalSeconds>2</scanIntervalSeconds>
 <webApp>
 <contextPath>/</contextPath>
 </webApp>
 </configuration>
 </plugin>
</plugins>
--------------------------------------------------------------------------------------------------------
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
@Slf4j
@SuppressWarnings({"squid:S2094"})
public class AddRequestTimeHeaderPreFilter extends AbstractGatewayFilterFactory<AddRequestTimeHeaderPreFilter.Config> {

    public static final String HEADER_TXN_DATE = "X-TXN-DATE";

    public AddRequestTimeHeaderPreFilter() {
        super(AddRequestTimeHeaderPreFilter.Config.class);
    }

    @Override
    public GatewayFilter apply(AddRequestTimeHeaderPreFilter.Config config) {
        return (exchange, chain) -> {
            String timestamp = LocalDateTime.now().toString();

            log.debug("Adding txn date header {}", timestamp);
            ServerHttpRequest request = exchange.getRequest()
                    .mutate()
                    .headers(httpHeaders -> httpHeaders.set(HEADER_TXN_DATE, timestamp))
                    .build();

            return chain.filter(exchange.mutate().request(request).build());
        };
    }

    public static class Config {

    }
}
--------------------------------------------------------------------------------------------------------
    @Bean
    public CommonsRequestLoggingFilter logFilter() {
        CommonsRequestLoggingFilter filter
                = new CommonsRequestLoggingFilter();
        filter.setIncludeQueryString(true);
        filter.setIncludePayload(true);
        filter.setMaxPayloadLength(10000);
        filter.setIncludeHeaders(true);
        filter.setAfterMessagePrefix("REQUEST DATA : ");
        return filter;
    }
--------------------------------------------------------------------------------------------------------
import javax.sql.DataSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;
import org.springframework.transaction.annotation.EnableTransactionManagement;

/**
 * {@code DataConfiguration} configures an embedded database.
 * <p/>
 *
 * @author Indra Basak
 * @since 10/20/18
 */
@Configuration
@EnableJpaRepositories(basePackages = {"com.basaki.k8s.data.repository"})
@EnableTransactionManagement
public class DataConfiguration {

    @Bean
    public DataSource dataSource() {
        EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();
        return builder
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("db/create-db.sql")
                .build();
    }
}
--------------------------------------------------------------------------------------------------------
import org.hibernate.Criteria;
import org.hibernate.criterion.Projections;
import org.springframework.stereotype.Repository;

import com.bytestree.model.Employee;

@Repository
public class EmployeeDaoImpl extends AbstractGenericDao<Employee> implements EmployeeDao {

	@Override
	public Integer getMaxSalary() {
		Criteria criteria = getSession().createCriteria(Employee.class).setProjection(Projections.max("salary"));
		Integer maxSalary = (Integer) criteria.uniqueResult();
		return maxSalary;
	}

}
--------------------------------------------------------------------------------------------------------
	@Bean
	public BasicAuthenticationEntryPoint getBasicAuthEntryPoint(){
		BasicAuthenticationEntryPoint basicAuthEntryPoint = new BasicAuthenticationEntryPoint();
		basicAuthEntryPoint.setRealmName(REALM_NAME);
		return basicAuthEntryPoint;
	}
--------------------------------------------------------------------------------------------------------
import org.h2.server.web.WebServlet;
import org.springframework.boot.context.embedded.ServletRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
@Configuration
public class WebConfiguration {
    @Bean
    ServletRegistrationBean h2servletRegistration(){
        ServletRegistrationBean registrationBean = new ServletRegistrationBean( new WebServlet());
        registrationBean.addUrlMappings("/console/*");
        return registrationBean;
    }

<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
</dependency>
--------------------------------------------------------------------------------------------------------
		<!-- Spring Security -->
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-web</artifactId>
			<version>${spring.security.version}</version>
		</dependency>

		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-config</artifactId>
			<version>${spring.security.version}</version>
		</dependency>
--------------------------------------------------------------------------------------------------------
mvn clean javadoc:jar source:jar package gpg:sign repository:bundle-create deploy
--------------------------------------------------------------------------------------------------------
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.thymeleaf.spring3.SpringTemplateEngine;
import org.thymeleaf.spring3.view.ThymeleafViewResolver;
import org.thymeleaf.templateresolver.ServletContextTemplateResolver;

@Configuration 
public class ThymeleafConfig {

	@Bean 
	public ServletContextTemplateResolver templateResolver() {
		ServletContextTemplateResolver resolver = new ServletContextTemplateResolver();
		resolver.setPrefix("/WEB-INF/templates/");
		resolver.setSuffix(".html");
		resolver.setTemplateMode("HTML5");
		resolver.setOrder(1);
		return resolver;
	}
	
	@Bean 
	public SpringTemplateEngine templateEngine() {
		SpringTemplateEngine engine = new SpringTemplateEngine();
		engine.setTemplateResolver(templateResolver());
		return engine;
	}
	
	@Bean 
	public ThymeleafViewResolver thymeleafViewResolver() {
		ThymeleafViewResolver resolver = new ThymeleafViewResolver();
		resolver.setTemplateEngine(templateEngine());
		return resolver;
	}
	
}
--------------------------------------------------------------------------------------------------------
import java.io.IOException;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.web.filter.OncePerRequestFilter;
 
 
public class CorsFilter extends OncePerRequestFilter {
 
 @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        if (request.getHeader("Access-Control-Request-Method") != null && "OPTIONS".equals(request.getMethod())) {
            // CORS "pre-flight" request
            response.addHeader("Access-Control-Allow-Origin", "*");
            response.addHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
            response.addHeader("Access-Control-Allow-Headers", "origin, content-type, accept, x-requested-with, sid, mycustom, smuser");
            response.addHeader("Access-Control-Max-Age", "1800");//30 min
        }
        filterChain.doFilter(request, response);
    }
}
--------------------------------------------------------------------------------------------------------
import com.querydsl.core.types.dsl.BooleanExpression;
import com.querydsl.core.types.dsl.Expressions;
import org.springframework.util.CollectionUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class SearchPredicatesBuilder<T> {
    private final List<SearchCriteria<T>> params;

    public SearchPredicatesBuilder() {
        this.params = new ArrayList<>();
    }

    public SearchPredicatesBuilder with(final String key, final SearchOperation operation, final T value) {
        this.params.add(SearchCriteria.of(key, operation, value));
        return this;
    }

    public BooleanExpression build(final Class<? extends T> typeClass) {
        if (CollectionUtils.isEmpty(this.params)) {
            return null;
        }

        final List<BooleanExpression> predicates = this.params.stream()
                .map(param -> {
                    final SearchPredicate predicate = new SearchPredicate(param, typeClass);
                    return predicate.getPredicate();
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

        BooleanExpression result = Expressions.asBoolean(true).isTrue();
        for (final BooleanExpression predicate : predicates) {
            result = result.and(predicate);
        }
        return result;
    }
}
--------------------------------------------------------------------------------------------------------
import javax.enterprise.event.Event;
import javax.inject.Inject;

/**
 * @author Antonio Goncalves
 *         http://www.antoniogoncalves.org
 *         --
 */
// tag::adocsnippet[]
public class BookService {

  @Inject
  private NumberGenerator numberGenerator;

  @Inject
  private Event<Book> bookAddedEvent;

  public Book createBook(String title, Float price, String description) {
    Book book = new Book(title, price, description);
    book.setIsbn(numberGenerator.generateNumber());
    bookAddedEvent.fire(book);
    return book;
  }
}
// end::adocsnippet[]
--------------------------------------------------------------------------------------------------------
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.io.Writer;
import java.util.Scanner;

public class IOUtils {

    private IOUtils() {
        super();
    }

    public static String readFull(InputStream inputStream) {
        return new Scanner(inputStream).useDelimiter("\\A").next();
    }

    public static String readFull(Reader reader) {
        return new Scanner(reader).useDelimiter("\\A").next();
    }

    public static void writeFull(Writer writer, String content) throws IOException {
        writer.append(content);
        writer.flush();
    }

}
--------------------------------------------------------------------------------------------------------
\os: linux
dist: trusty
language: java
matrix:
  include:
    - jdk: oraclejdk8
    - jdk: oraclejdk7
      dist: precise
    - jdk: openjdk7
      dist: precise
    - os: osx

addons:
  hosts:
    - asciidoctorj-builder
  hostname: asciidoctorj-builder
  apt:
    packages:
      - graphviz

before_install:
  - if [[ "$TRAVIS_OS_NAME" == "osx" ]]; then brew update          ; fi
  - if [[ "$TRAVIS_OS_NAME" == "osx" ]]; then brew install graphviz; fi

install: ./gradlew -S -Pskip.signing assemble

before_script: unset GEM_PATH GEM_HOME JRUBY_OPTS

script: ./gradlew -S -Pskip.signing check && bash test-asciidoctor-upstream.sh
--------------------------------------------------------------------------------------------------------
input {
  gelf {

  }
}

filter {
  multiline {
    pattern => '^\s'
    what => 'previous'
    stream_identity => "%{host}.%{container_id}"
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
  }
  stdout {
  }
}
--------------------------------------------------------------------------------------------------------
#!/bin/sh

echo "The application will start in ${JHIPSTER_SLEEP}s..." && sleep ${JHIPSTER_SLEEP}
exec java ${JAVA_OPTS} -Djava.security.egd=file:/dev/./urandom -jar "${HOME}/app.war" "$@"

version: '2'
services:
    autocompletedto-app:
        image: autocompletedto
        environment:
            - _JAVA_OPTIONS=-Xmx512m -Xms256m
            - SPRING_PROFILES_ACTIVE=prod,swagger
            - SPRING_DATASOURCE_URL=jdbc:postgresql://autocompletedto-postgresql:5432/autocompletedto
            - JHIPSTER_SLEEP=10 # gives time for the database to boot before the application
        ports:
            - 8080:8080
    autocompletedto-postgresql:
        extends:
            file: postgresql.yml
            service: autocompletedto-postgresql
			
			  
FROM openjdk:8-jre-alpine

ENV SPRING_OUTPUT_ANSI_ENABLED=ALWAYS \
    JHIPSTER_SLEEP=0 \
    JAVA_OPTS=""

# Add a jhipster user to run our application so that it doesn't need to run as root
RUN adduser -D -s /bin/sh jhipster
WORKDIR /home/jhipster

ADD entrypoint.sh entrypoint.sh
RUN chmod 755 entrypoint.sh && chown jhipster:jhipster entrypoint.sh
USER jhipster

ENTRYPOINT ["./entrypoint.sh"]

EXPOSE 8080

ADD *.war app.war

--------------------------------------------------------------------------------------------------------
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
 com.moelholm.prometheus.PrometheusAutoConfiguration
--------------------------------------------------------------------------------------------------------
import io.prometheus.client.spring.boot.SpringBootMetricsCollector;
import java.util.Collection;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.actuate.endpoint.PublicMetrics;
import org.springframework.boot.actuate.endpoint.mvc.AbstractMvcEndpoint;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConditionalOnWebApplication
public class PrometheusAutoConfiguration {

  @Bean
  @ConditionalOnMissingBean(name = "prometheusActuatorEndpoint")
  AbstractMvcEndpoint prometheusActuatorEndpoint(
      @Value("${endpoints.prometheus.path:/prometheus}") String path,
      @Value("${endpoints.prometheus.sensitive:false}") boolean sensitive) {
    return new PrometheusActuatorEndpoint(path, sensitive);
  }

  @Bean
  @ConditionalOnMissingBean(SpringBootMetricsCollector.class)
  SpringBootMetricsCollector springBootMetricsCollector(Collection<PublicMetrics> publicMetrics) {
    SpringBootMetricsCollector collector = new SpringBootMetricsCollector(publicMetrics);
    collector.register();
    return collector;
  }
}

https://github.com/moelholm/prometheus-spring-boot-starter/blob/master/src/main/java/com/moelholm/prometheus/PrometheusActuatorEndpoint.java
--------------------------------------------------------------------------------------------------------
    @RequestMapping("${actuator-ui.dump-ui.path:dump-ui}")
    public void dumpAsHtml(HttpServletRequest request, HttpServletResponse response) {
        response.setContentType("text/html");
        try (PrintWriter writer = response.getWriter()) {
            writer.println(getHtml(request));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
--------------------------------------------------------------------------------------------------------
- mvn install -DskipTests=true -Dmaven.javadoc.skip=true -B -V


os:
  - linux
services:
  - docker
language: java
jdk:
  - oraclejdk8
sudo: false
cache:
  directories:
    - $HOME/.m2
before_install:
  - mvn install -DskipTests=true -Dmaven.javadoc.skip=true -B -V
  - java -version
script:
  - mvn clean test
notifications:
  webhooks:
    on_success: change  # options: [always|never|change] default: always
    on_failure: always  # options: [always|never|change] default: always
    on_start: false     # default: false
--------------------------------------------------------------------------------------------------------
import org.slf4j.MDC;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.GenericFilterBean;

import javax.servlet.*;
import java.io.IOException;

@Component
public class MdcFilter extends GenericFilterBean {

  @Override
  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
      throws IOException, ServletException {
    try {
      MDC.put("mdcData", "[userId:Duke]");
      chain.doFilter(request, response);
    } finally {
      MDC.clear();
    }
  }
}
--------------------------------------------------------------------------------------------------------
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.AsyncResult;
import org.springframework.stereotype.Repository;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Future;

@Repository
class MessageRepository {

  private final Logger logger = LoggerFactory.getLogger(getClass());

  @Async
  Future<List<String>> findAll() {
    logger.info("Repository in action");
    return new AsyncResult<>(Arrays.asList("Hello World", "Spring Boot is awesome"));
  }
}
--------------------------------------------------------------------------------------------------------
   @Component
    @RestControllerEndpoint(id = "remote")
    public class CustomActuator {
        @RequestMapping(value = {"/{actuatorInput}"}, produces = MediaType.APPLICATION_JSON_VALUE, method = RequestMethod.GET)
        @ResponseBody
        public Map<String, Object> feature(@PathVariable("actuatorInput") String actuatorInput) {
            System.out.println("actuatorInput : " + actuatorInput);
            Map<String, Object> details = new HashMap<>();
            details.put("input", actuatorInput);
            return details;
        }
    }
	
	@Component
@Endpoint(id = "custom-health")
public class CustomHealthEndpoint {

    @ReadOperation
    public String customEndPointByName(@Selector String name) {
        return "custom-end-point : " + name;
    }
    @WriteOperation
    public void writeOperation(@Selector String name) {
        System.out.println("Write Operation! :: " + name);
    }
    @DeleteOperation
    public void deleteOperation(@Selector String name){
        System.out.println("Delete Operation! :: " + name);
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.stereotype.Service;

import javax.servlet.http.HttpSession;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentSkipListMap;

@Service
public class SessionRegistry {

    private final Map<String, HttpSession> httpSessionMap = new ConcurrentSkipListMap<>();

    public void addSession(HttpSession httpSession) {
        this.httpSessionMap.put(httpSession.getId(), httpSession);
    }

    public void removeSession(HttpSession httpSession) {
        this.httpSessionMap.remove(httpSession.getId());
    }

    public List<HttpSession> getSessions() {
        return new ArrayList<>(httpSessionMap.values());
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpSession;
import java.util.Optional;

@RestController
public class GreetingController {

    @RequestMapping(value = "/greetings/{caller}", produces = MediaType.TEXT_HTML_VALUE)
    public String getGreeting(@PathVariable("caller") String caller, HttpSession httpSession) {

        httpSession.setAttribute("invocationCount", 1 + Optional.ofNullable((Integer) httpSession.getAttribute("invocationCount")).orElse(0));
        httpSession.setAttribute("latestGreetingArgument", caller);

        return new StringBuilder()
                .append("<html><body>")
                .append("Your session id is: [").append(httpSession.getId()).append("]")
                .append("<br> ( Invocation count is : [").append(httpSession.getAttribute("invocationCount")).append("] )")
                .append("</body></html>")
                .toString();
    }

}
--------------------------------------------------------------------------------------------------------
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.util.DateUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.Date;

public class ExpirationJwtClaimsSetVerifier implements JwtClaimsSetVerifier {
    private final Log logger = LogFactory.getLog(this.getClass());

    private int maxClockSkewSeconds = 60;

    @Override
    public boolean verify(JWTClaimsSet claimsSet) {
        Date now = Date.from(ZonedDateTime.now(ZoneOffset.UTC).toInstant());
        Date expirationTime = claimsSet.getExpirationTime();
        if (expirationTime == null) {
            logger.warn("Missing expiration date in JWT claims set");
            return false;
        }
        return DateUtils.isAfter(expirationTime, now, maxClockSkewSeconds);
    }

    public void setMaxClockSkewSeconds(int maxClockSkewSeconds) {
        this.maxClockSkewSeconds = maxClockSkewSeconds;
    }
}
--------------------------------------------------------------------------------------------------------
openssl rand 32 | base64

machine:
  java:
    version: oraclejdk8
  post:
    # Install Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files for build
    - rm -f jce_policy-8.zip
    - "curl -o jce_policy-8.zip -v -j -k -L -H 'Cookie: oraclelicense=accept-securebackup-cookie' http://download.oracle.com/otn-pub/java/jce/8/jce_policy-8.zip"
    - sudo unzip -j -o -d $JAVA_HOME/jre/lib/security jce_policy-8.zip
test:
  override:
    - ./gradlew clean build
  post:
    - mkdir -p $CIRCLE_TEST_REPORTS/junit/
    - find . -type f -regex ".*/build/test-results/.*xml" -exec cp {} $CIRCLE_TEST_REPORTS/junit/ \;
deployment:
  gh-release:
    tag: /^v\d+\.\d+\.\d+$/
    owner: AusDTO
    commands:
      - gradle assemble
      - mkdir -p release
      - cp build/libs/* release/
      - curl -kjLo ghr.zip https://github.com/tcnksm/ghr/releases/download/v0.4.0/ghr_v0.4.0_linux_amd64.zip
      - unzip ghr.zip
      - ./ghr -t $GITHUB_ACCESS_TOKEN -u $CIRCLE_PROJECT_USERNAME -r $CIRCLE_PROJECT_REPONAME $CIRCLE_TAG release/
      - "curl -skL -o /dev/null -c jitpack_cookie.txt https://jitpack.io"
      - "curl -skiL -H 'Referer: https://jitpack.io/' -b jitpack_cookie.txt https://jitpack.io/api/builds/com.github.AusDTO/spring-security-stateless/${CIRCLE_TAG}"

--------------------------------------------------------------------------------------------------------
@Configuration
public class Config {
    @Bean
    public CsrfTokenInterceptor csrfTokenInterceptor() {
        return new CsrfTokenInterceptor();
    }
}
--------------------------------------------------------------------------------------------------------
import java.util.List;

import com.mifmif.networking.mspider.database.dao.api.WebsiteDao;
import com.mifmif.networking.mspider.model.Website;

/**
 * @author y.mifrah
 * 
 */
public class JpaWebsiteDao extends JpaDao<Long, Website> implements WebsiteDao {

	@Override
	public Website finbByHost(String host) {
		List<Website> found = entityManager.createNamedQuery("Website.findByHost", Website.class).setParameter("host", host).getResultList();
		return found.isEmpty() ? null : found.get(0);
	}

}
--------------------------------------------------------------------------------------------------------
app.menus:
  - title: Home
    name: Home
    path: /
  - title: Login
    name: Login
    path: /login
spring:
  mustache:
    expose-request-attributes: true
logging:
  level:
    org.springframework.security: DEBUG
--------------------------------------------------------------------------------------------------------
import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;

import java.io.IOException;

public final class ResponseUtil {
    private ResponseUtil() {
    }

    public static void closeResponse(CloseableHttpResponse response) throws IOException {
        if (response == null) {
            return;
        }

        try {
            final HttpEntity entity = response.getEntity();
            if (entity != null) {
                entity.getContent().close();
            }
        } finally {
            response.close();
        }
    }
}
--------------------------------------------------------------------------------------------------------
yarn global add bower• yarn global add gulp-cli
jhipster entity Post --table-name post


@OneToMany(mappedBy = "post")@JsonIgnore@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)private Set<Comment> comments = new HashSet<>();

heroku logs --tail --app <application_name>
--------------------------------------------------------------------------------------------------------
import java.util.Date;import org.springframework.boot.actuate.health.Health;import org.springframework.boot.actuate.health.HealthIndicator;import org.springframework.stereotype.Component;import org.springframework.web.client.RestClientException;import org.springframework.web.client.RestTemplate;@Componentpublic class FeedServerHealthIndicator implements HealthIndicator{    @Override    public Health health() {RestTemplate restTemplate = new RestTemplate();String url = "http://feedserver.com/ping";try {String resp = restTemplate.getForObject(url, String.class);if("OK".equalsIgnoreCase(resp)){return Health.up().build();} else {return Health.down().withDetail("ping_url", url).withDetail("ping_time", new Date()).build();}} catch (RestClientException e) {return Health.down(e).withDetail("ping_url", url).withDetail("ping_time", new Date()).build();}    }}


import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.actuate.metrics.CounterService;import org.springframework.stereotype.Service;@Servicepublic class LoginService{@Autowiredprivate CounterService counterService;public boolean login(String email, String password){if("admin@gmail.com".equalsIgnoreCase(email) && "admin".equals(password)){counterService.increment("counter.login.success");return true;} else {counterService.increment("counter.login.failure");return false;}}}
--------------------------------------------------------------------------------------------------------
@BeforeEach
void init(@Mock SettingRepository settingRepository) {
    userService = new DefaultUserService(userRepository, settingRepository, mailClient);
       
    Mockito.lenient().when(settingRepository.getUserMinAge()).thenReturn(10);
         
    when(settingRepository.getUserNameMinLength()).thenReturn(4);
         
    Mockito.lenient().when(userRepository.isUsernameAlreadyExists(any(String.class))).thenReturn(false);
}
--------------------------------------------------------------------------------------------------------
        <dependency>
            <groupId>org.powermock</groupId>
            <artifactId>powermock-module-junit4-rule</artifactId>
            <version>2.0.2</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.powermock</groupId>
            <artifactId>powermock-classloading-objenesis</artifactId>
            <version>2.0.2</version>
            <scope>test</scope>
        </dependency>
--------------------------------------------------------------------------------------------------------
class BlankStringsArgumentsProvider implements ArgumentsProvider {
 
    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
        return Stream.of(
          Arguments.of((String) null), 
          Arguments.of(""), 
          Arguments.of("   ") 
        );
    }
}

@ParameterizedTest
@ArgumentsSource(BlankStringsArgumentsProvider.class)
void isBlank_ShouldReturnTrueForNullOrBlankStringsArgProvider(String input) {
    assertTrue(Strings.isBlank(input));
}
--------------------------------------------------------------------------------------------------------
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.RepetitionInfo;
import org.junit.jupiter.api.TestInfo;

public class RepeatedTestAnnotationUnitTest {

    @BeforeEach
    void beforeEachTest() {
        System.out.println("Before Each Test");
    }

    @AfterEach
    void afterEachTest() {
        System.out.println("After Each Test");
        System.out.println("=====================");
    }

    @RepeatedTest(3)
    void repeatedTest(TestInfo testInfo) {
        System.out.println("Executing repeated test");
        assertEquals(2, Math.addExact(1, 1), "1 + 1 should equal 2");
    }

    @RepeatedTest(value = 3, name = RepeatedTest.LONG_DISPLAY_NAME)
    void repeatedTestWithLongName() {
        System.out.println("Executing repeated test with long name");
        assertEquals(2, Math.addExact(1, 1), "1 + 1 should equal 2");
    }

    @RepeatedTest(value = 3, name = RepeatedTest.SHORT_DISPLAY_NAME)
    void repeatedTestWithShortName() {
        System.out.println("Executing repeated test with long name");
        assertEquals(2, Math.addExact(1, 1), "1 + 1 should equal 2");
    }

    @RepeatedTest(value = 3, name = "Custom name {currentRepetition}/{totalRepetitions}")
    void repeatedTestWithCustomDisplayName() {
        assertEquals(2, Math.addExact(1, 1), "1 + 1 should equal 2");
    }

    @RepeatedTest(3)
    void repeatedTestWithRepetitionInfo(RepetitionInfo repetitionInfo) {
        System.out.println("Repetition #" + repetitionInfo.getCurrentRepetition());
        assertEquals(3, repetitionInfo.getTotalRepetitions());
    }
}
--------------------------------------------------------------------------------------------------------
TransactionSupportAsyncJobServiceTest
--------------------------------------------------------------------------------------------------------
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.EnumSource;

import java.time.Month;
import java.util.EnumSet;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

class EnumsUnitTest {

    @ParameterizedTest
    @EnumSource(Month.class)
    void getValueForAMonth_IsAlwaysBetweenOneAndTwelve(Month month) {
        int monthNumber = month.getValue();
        assertTrue(monthNumber >= 1 && monthNumber <= 12);
    }

    @ParameterizedTest(name = "{index} {0} is 30 days long")
    @EnumSource(value = Month.class, names = {"APRIL", "JUNE", "SEPTEMBER", "NOVEMBER"})
    void someMonths_Are30DaysLong(Month month) {
        final boolean isALeapYear = false;
        assertEquals(30, month.length(isALeapYear));
    }

    @ParameterizedTest
    @EnumSource(value = Month.class, names = {"APRIL", "JUNE", "SEPTEMBER", "NOVEMBER", "FEBRUARY"}, mode = EnumSource.Mode.EXCLUDE)
    void exceptFourMonths_OthersAre31DaysLong(Month month) {
        final boolean isALeapYear = false;
        assertEquals(31, month.length(isALeapYear));
    }

    @ParameterizedTest
    @EnumSource(value = Month.class, names = ".+BER", mode = EnumSource.Mode.MATCH_ANY)
    void fourMonths_AreEndingWithBer(Month month) {
        EnumSet<Month> months = EnumSet.of(Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER);
        assertTrue(months.contains(month));
    }

    @ParameterizedTest
    @CsvSource({"APRIL", "JUNE", "SEPTEMBER", "NOVEMBER"})
    void someMonths_Are30DaysLongCsv(Month month) {
        final boolean isALeapYear = false;
        assertEquals(30, month.length(isALeapYear));
    }
    
}
--------------------------------------------------------------------------------------------------------
static Stream<Arguments> arguments = Stream.of(
  Arguments.of(null, true), // null strings should be considered blank
  Arguments.of("", true),
  Arguments.of("  ", true),
  Arguments.of("not blank", false)
);
 
@ParameterizedTest
@VariableSource("arguments")
void isBlank_ShouldReturnTrueForNullOrBlankStringsVariableSource(String input, boolean expected) {
    assertEquals(expected, Strings.isBlank(input));
}
--------------------------------------------------------------------------------------------------------
@RunWith(PowerMockRunner.class)
@PowerMockRunnerDelegate(Parameterized.class)
@PrepareForTest({FinalDemo.class, PrivateFinal.class})
public class FinalDemoTest {

    @Parameterized.Parameter(0)
    public String expected;

    @Parameterized.Parameters(name = "expected={0}")
    public static Collection<?> expections() {
        return java.util.Arrays.asList(new Object[][]{
            {"Hello altered World"}, {"something"}, {"test"}
        });
    }

    @Test
    public void assertMockFinalWithExpectationsWorks() throws Exception {
        final String argument = "hello";

        FinalDemo tested = mock(FinalDemo.class);

        when(tested.say(argument)).thenReturn(expected);

        final String actual = "" + tested.say(argument);

        verify(tested).say(argument);

        assertEquals("Expected and actual did not match", expected, actual);
    }
}
--------------------------------------------------------------------------------------------------------
import org.junit.jupiter.api.extension.ParameterContext;
import org.junit.jupiter.params.converter.ArgumentConversionException;
import org.junit.jupiter.params.converter.ArgumentConverter;

import java.time.LocalDate;

class SlashyDateConverter implements ArgumentConverter {

    @Override
    public Object convert(Object source, ParameterContext context) throws ArgumentConversionException {
        if (!(source instanceof String))
            throw new IllegalArgumentException("The argument should be a string: " + source);

        try {
            String[] parts = ((String) source).split("/");
            int year = Integer.parseInt(parts[0]);
            int month = Integer.parseInt(parts[1]);
            int day = Integer.parseInt(parts[2]);

            return LocalDate.of(year, month, day);
        } catch (Exception e) {
            throw new IllegalArgumentException("Failed to convert", e);
        }
    }
}

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.aggregator.AggregateWith;
import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
import org.junit.jupiter.params.provider.CsvSource;

import static org.junit.jupiter.api.Assertions.assertEquals;

class PersonUnitTest {

    @ParameterizedTest
    @CsvSource({"Isaac,,Newton, Isaac Newton", "Charles,Robert,Darwin,Charles Robert Darwin"})
    void fullName_ShouldGenerateTheExpectedFullName(ArgumentsAccessor argumentsAccessor) {
        String firstName = argumentsAccessor.getString(0);
        String middleName = (String) argumentsAccessor.get(1);
        String lastName = argumentsAccessor.get(2, String.class);
        String expectedFullName = argumentsAccessor.getString(3);

        Person person = new Person(firstName, middleName, lastName);
        assertEquals(expectedFullName, person.fullName());
    }

    @ParameterizedTest
    @CsvSource({"Isaac Newton,Isaac,,Newton", "Charles Robert Darwin,Charles,Robert,Darwin"})
    void fullName_ShouldGenerateTheExpectedFullName(String expectedFullName,
                                                    @AggregateWith(PersonAggregator.class) Person person) {

        assertEquals(expectedFullName, person.fullName());
    }
}

import org.junit.jupiter.api.extension.ParameterContext;
import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
import org.junit.jupiter.params.aggregator.ArgumentsAggregationException;
import org.junit.jupiter.params.aggregator.ArgumentsAggregator;

class PersonAggregator implements ArgumentsAggregator {

    @Override
    public Object aggregateArguments(ArgumentsAccessor accessor, ParameterContext context)
            throws ArgumentsAggregationException {
        return new Person(accessor.getString(1), accessor.getString(2), accessor.getString(3));
    }
}

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;

import javax.sql.DataSource;

@Configuration
@ComponentScan("com.baeldung.junit.tags.example")
public class SpringJdbcConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2).addScript("classpath:jdbc/schema.sql").addScript("classpath:jdbc/test-data.sql").build();
    }
}

import org.junit.platform.runner.JUnitPlatform;
import org.junit.platform.suite.api.IncludeTags;
import org.junit.platform.suite.api.SelectPackages;
import org.junit.runner.RunWith;

@RunWith(JUnitPlatform.class)
@SelectPackages("com.baeldung.tags")
@IncludeTags("UnitTest")
public class EmployeeDAOTestSuite {
}


import static org.junit.Assert.assertTrue;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertLinesMatch;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;

import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.io.TempDir;

import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;

@TestMethodOrder(OrderAnnotation.class)
class SharedTemporaryDirectoryUnitTest {

    @TempDir
    static Path sharedTempDir;
    
    @Test
    @Order(1)
    void givenFieldWithSharedTempDirectoryPath_whenWriteToFile_thenContentIsCorrect() throws IOException {
        Path numbers = sharedTempDir.resolve("numbers.txt");

        List<String> lines = Arrays.asList("1", "2", "3");
        Files.write(numbers, lines);

        assertAll(
            () -> assertTrue("File should exist", Files.exists(numbers)),
            () -> assertLinesMatch(lines, Files.readAllLines(numbers)));
        
        Files.createTempDirectory("bpb");
    }

    @Test
    @Order(2)
    void givenAlreadyWrittenToSharedFile_whenCheckContents_thenContentIsCorrect() throws IOException {
        Path numbers = sharedTempDir.resolve("numbers.txt");

        assertLinesMatch(Arrays.asList("1", "2", "3"), Files.readAllLines(numbers));
    }

}import org.junit.Rule;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.migrationsupport.rules.EnableRuleMigrationSupport;
import org.junit.rules.ExpectedException;

@EnableRuleMigrationSupport
public class RuleMigrationSupportUnitTest {

    @Rule
    public ExpectedException exceptionRule = ExpectedException.none();

    @Test
    public void whenExceptionThrown_thenExpectationSatisfied() {
        exceptionRule.expect(NullPointerException.class);
        String test = null;
        test.length();
    }

    @Test
    public void whenExceptionThrown_thenRuleIsApplied() {
        exceptionRule.expect(NumberFormatException.class);
        exceptionRule.expectMessage("For input string");
        Integer.parseInt("1a");
    }
}

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.platform.runner.JUnitPlatform;
import org.junit.runner.RunWith;

@RunWith(JUnitPlatform.class)
@ExtendWith(TraceUnitExtension.class)
public class RuleExampleUnitTest {

    @Test
    public void whenTracingTests() {
        System.out.println("This is my test");
        /*...*/
    }
}
--------------------------------------------------------------------------------------------------------
sudo add-apt-repository -y ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installersudo apt-get install oracle-java8-set-defaul

sudo add-apt-repository -y ppa:natecarlson/maven3sudo apt-get updatesudo apt-get --assume-yes install maven3sudo ln -sf /usr/bin/mvn3 /usr/bin/mvn

SELECT *
FROM tablename
WHERE 
columnname REGEXP '^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$'
--------------------------------------------------------------------------------------------------------
language: javajdk:- openjdk8script: mvn clean install -Ptestcache:directories:- $HOME/.m2/deploy:provider: herokuapp: HEROKU-APP-NAMEapi_key:secure: YOUR-API-KEYrun: "DATABASE_URL_JDBC=$DB_PROD mvn liquibase:update -pl liquibase -Pheroku"on: master

./travis-encrypt.sh -r user/repo -e 258cfb90-XXXX-4720-XXX-9bfba5332254

heroku auth:token

heroku addons:create heroku-postgresql:hobby-dev

--------------------------------------------------------------------------------------------------------
/**
 * Interface to build objects in a
 * fluent fashion.
 *
 * @param <T> The type of object being built.
 * @author Rui Vilao (rui.vilao@ed-era.com)
 */
public interface FluentBuilder<T> {
    /**
     * Builds the object.
     *
     * @return The object.
     */
    T build();
}
--------------------------------------------------------------------------------------------------------
import com.github.tomakehurst.wiremock.junit.WireMockRule;
import io.restassured.builder.RequestSpecBuilder;
import io.restassured.specification.RequestSpecification;
import org.junit.*;

import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.options;
import static io.restassured.RestAssured.given;
import static org.hamcrest.Matchers.*;

public class RestAssuredExercises4Test {

	private static RequestSpecification requestSpec;

	@Rule
	public WireMockRule wireMockRule = new WireMockRule(options().port(9876));

	@BeforeClass
	public static void createRequestSpecification() {

		requestSpec = new RequestSpecBuilder().
			setBaseUri("http://localhost").
			setPort(9876).
			build();
	}

	/*******************************************************
	 * Perform a GET request to /xml/de/24848 to get the
	 * list of places associated with German zip code 24848
	 * in XML format. Assert that the third place in the list
	 * is Kropp
	 ******************************************************/

	@Test
	public void getDeZipCode24848_checkThirdPlaceInList_expectKropp() {

		given().
			spec(requestSpec).
		when().
		then();
	}

	/*******************************************************
	 * Perform a GET request to /xml/de/24848 to get the
	 * list of places associated with German zip code 24848
	 * in XML format. Assert that the latitude for the third
	 * place in the list equal to 54.45
	 ******************************************************/

	@Test
	public void getDeZipCode24848_checkLatitudeForSecondPlaceInList_expect5445() {

		given().
			spec(requestSpec).
		when().
		then();
	}

	/*******************************************************
	 * Perform a GET request to /xml/de/24848 to get the
	 * list of places associated with German zip code 24848
	 * in XML format. Assert that there are 4 places that
	 * have a stateAbbreviation that equals 'SH'
	 ******************************************************/

	@Test
	public void getDeZipCode24848_checkNumberOfPlacesInSH_expect4() {

		given().
			spec(requestSpec).
		when().
		then();
	}


	/*******************************************************
	 * Perform a GET request to /xml/de/24848 to get the
	 * list of places associated with German zip code 24848
	 * in XML format. Assert that there are 3 places that
	 * have a name that starts with 'Klein'
	 ******************************************************/

	@Test
	public void getDeZipCode24848_checkNumberOfPlacesStartingWithKlein_expect3() {

		given().
			spec(requestSpec).
		when().
		then();
	}
}

jumia
finastra
--------------------------------------------------------------------------------------------------------
http://localhost:8080/posts?sort=createdOn,desc
--------------------------------------------------------------------------------------------------------
cp .xinitrc /home/YOUR_USERNAME/.xinitrc 
--------------------------------------------------------------------------------------------------------
@FunctionalInterfacepublic interface HandlerFunction<T extends ServerResponse>{    Mono<T> handle(ServerRequest request);}

@FunctionalInterfacepublic interface HandlerFilterFunction<T extends ServerResponse, R extends ServerResponse>{    Mono<R> filter(ServerRequest request, HandlerFunction<T> next);    //other methods}
--------------------------------------------------------------------------------------------------------
@Controllerpublic class RegistrationController{    @Autowired    private UserValidator userValidator;    @PostMapping("/registration")    public String handleRegistration(@Valid User user, BindingResult result) {userValidator.validate(user, result);if(result.hasErrors()){return "registration";}return "redirect:/registrationsuccess";    }}

spring.servlet.multipart.enabled=truespring.servlet.multipart.max-file-size=2MBspring.servlet.multipart.max-request-size=20MBspring.servlet.multipart.file-size-threshold=5MB
--------------------------------------------------------------------------------------------------------
    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnBean(TogglzProperties.class)
    @ConditionalOnClass({EnableWebSecurity.class, AuthenticationEntryPoint.class, SpringSecurityUserProvider.class})
    @Description("Spring security user provider")
    public UserProvider userProvider(final TogglzProperties properties) {
        return new SpringSecurityUserProvider(properties.getConsole().getFeatureAdminAuthority());
    }
--------------------------------------------------------------------------------------------------------
@Test
public void givenFeaturePropertyTrue_whenIncreaseSalary_thenIncrease() 
  throws Exception {
    Employee emp = new Employee(1, 2000);
    employeeRepository.save(emp);
    System.setProperty("employee.feature", "true");
 
    mockMvc.perform(post("/increaseSalary")
      .param("id", emp.getId() + ""))
      .andExpect(status().is(200));
 
    emp = employeeRepository.findById(1L).orElse(null);
    assertEquals("salary incorrect", 2200, emp.getSalary(), 0.5);
}
--------------------------------------------------------------------------------------------------------
public enum MyFeatures implements Feature {
 
    @Label("Employee Management Feature")
    EMPLOYEE_MANAGEMENT_FEATURE;
 
    public boolean isActive() {
        return FeatureContext.getFeatureManager().isActive(this);
    }
}
@Configuration
public class ToggleConfiguration {
 
    @Bean
    public FeatureProvider featureProvider() {
        return new EnumBasedFeatureProvider(MyFeatures.class);
    }
}

public enum MyFeatures implements Feature {
 
    @Label("Employee Management Feature") 
    @EnabledByDefault
    @DefaultActivationStrategy(id = SystemPropertyActivationStrategy.ID, 
      parameters = { 
      @ActivationParameter(
        name = SystemPropertyActivationStrategy.PARAM_PROPERTY_NAME,
        value = "employee.feature"),
      @ActivationParameter(
        name = SystemPropertyActivationStrategy.PARAM_PROPERTY_VALUE,
        value = "true") }) 
    EMPLOYEE_MANAGEMENT_FEATURE;
    //...
}
--------------------------------------------------------------------------------------------------------
@Configuration@EnableWebMvcpublic class WebMvcConfig implements WebMvcConfigurer{@Bean(name="simpleMappingExceptionResolver")public SimpleMappingExceptionResolver simpleMappingExceptionResolver(){SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingException Resolver();Properties mappings = new Properties();mappings.setProperty("DataAccessException", "dbError");mappings.setProperty("RuntimeException", "error");exceptionResolver.setExceptionMappings(mappings);exceptionResolver.setDefaultErrorView("error");return exceptionResolver;}}

@Controllerpublic class CustomerController{@GetMapping("/customers/{id}")public String findCustomer(@PathVariable Long id, Model model){Customer c = customerRepository.findById(id);if(c == null) throw new CustomerNotFoundException();model.add("customer", c);return "view_customer";}@ExceptionHandler(CustomerNotFoundException.class)public ModelAndView handleCustomerNotFoundException(CustomerNotFoundException ex){ModelAndView model = new ModelAndView("error/404");model.addObject("exception", ex);return model;}}

@Controllerpublic class GenericErrorController implements ErrorController{private static final String ERROR_PATH = "/error";@RequestMapping(ERROR_PATH)public String error(){return "errorPage.html";}@Overridepublic String getErrorPath() {return ERROR_PATH;}}

@Configurationpublic class WebConfig implements WebMvcConfigurer{@Overridepublic void addCorsMappings(CorsRegistry registry) {registry.addMapping("/api/**").allowedOrigins("http://localhost:3000").allowedMethods("*").allowedHeaders("*").allowCredentials(false).maxAge(3600);}}
--------------------------------------------------------------------------------------------------------
vue init vuetifyjs/nuxt frontend

spring.devtools.restart.exclude=assets/**,resources/**

spring.devtools.restart.additional-exclude=assets/**,setup-instructions/**spring.devtools.restart.additional-paths=D:/global-overrides/

spring.devtools.restart.trigger-file=restart.txt
java -jar -Dspring.devtools.restart.enabled=false app.jar

spring.datasource.hikari.allow-pool-suspension=truespring.datasource.hikari.connection-test-query=SELECT 1spring.datasource.hikari.transaction-isolation=TRANSACTION_READ_COMMITTEDspring.datasource.hikari.connection-timeout=45000

java -classpath jooq-3.9.3.jar;jooq-meta-3.9.3.jar;jooq-codegen-3.9.3.jar;mysql-connector-java-5.1.18-bin.jar;. org.jooq.util.GenerationTool jooq-config.xml

spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=adminspring.jooq.sql-dialect=MYSQ

@Query("{ 'name' : ?0 }")User findByUserName(String name);

keytool -genkey -alias mydomain -keyalg RSA -keysize 2048 -keystore KeyStore.jks -validity 3650
server.port=8443server.ssl.key-store=classpath:KeyStore.jksserver.ssl.key-store-password=mysecretserver.ssl.keyStoreType=JKSserver.ssl.keyAlias=mydomain
--------------------------------------------------------------------------------------------------------
icacls "D:\test" /grant John:(OI)(CI)F /T
According do MS documentation:

F = Full Control
CI = Container Inherit - This flag indicates that subordinate containers will inherit this ACE.
OI = Object Inherit - This flag indicates that subordinate files will inherit the ACE.
/T = Apply recursively to existing files and sub-folders. (OI and CI only apply to new files and sub-folders). Credit: comment by @AlexSpence.
--------------------------------------------------------------------------------------------------------
@Bean    public LocalContainerEntityManagerFactoryBean entityManagerFactory()    {LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();vendorAdapter.setShowSql(Boolean.TRUE);factory.setDataSource(dataSource());factory.setJpaVendorAdapter(vendorAdapter);factory.setPackagesToScan(env.getProperty("packages-to-scan"));Properties jpaProperties = new Properties();jpaProperties.put("hibernate.hbm2ddl.auto", env.getProperty ("hibernate.hbm2ddl.auto"));factory.setJpaProperties(jpaProperties);factory.afterPropertiesSet();factory.setLoadTimeWeaver(new InstrumentationLoadTimeWeaver());return factory;    }
--------------------------------------------------------------------------------------------------------
@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = {@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication {    ....    ....}
--------------------------------------------------------------------------------------------------------
@RequestMapping(value = "/{roomId}", method = RequestMethod.GET,   consumes = "application/json;version=2")public RoomDTOv2 getRoomV2(@PathVariable("roomId") long id) {  Room room = inventoryService.getRoom(id);  return new RoomDTOv2(room);}

@RequestMapping(value = "/{roomId}", method = RequestMethod.GET, headers = {"X-API-Version=3"})public RoomDTOv3 getRoomV3(@PathVariable("roomId") long id) {  Room room = inventoryService.getRoom(id);  return new RoomDTOv3(room);}

@RequestMapping(value = "/{roomId}", method = RequestMethod.POST, headers = {"X-HTTP-Method-Override=PUT"})public ApiResponse updateRoomAsPost(@PathVariable("roomId") long   id, @RequestBody RoomDTO updatedRoom) {  return updateRoom(id, updatedRoom);}
--------------------------------------------------------------------------------------------------------
@Configuration@EnableWebMvc@ComponentScanpublic class WebApplicationConfiguration extends WebMvcAutoConfiguration {  @Bean  public Filter etagFilter() {    return new ShallowEtagHeaderFilter();  }}

@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(classes = WebApplication.class)@WebAppConfiguration@IntegrationTest("integration_server:9000")public class BookingsResourceIntegrationTest {  @Test  public void runTests() {    // ...  }}
--------------------------------------------------------------------------------------------------------
<build>        <plugins>            <plugin>                <artifactId>maven-war-plugin</artifactId>                <version>2.6</version>                <configuration><attachClasses>true</attachClasses>                </configuration>            </plugin>        </plugins>    </build>

<plugin>      <groupId>org.mortbay.jetty</groupId>      <artifactId>jetty-maven-plugin</artifactId>      <configuration>        <useTestScope>true</useTestScope>        <stopPort>8005</stopPort>        <stopKey>DIE!</stopKey>        <systemProperties>          <systemProperty>            <name>jetty.port</name>            <value>8080</value>          </systemProperty>        </systemProperties>      </configuration>    </plugin>
--------------------------------------------------------------------------------------------------------

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Configuration
@ComponentScan
@EnableAutoConfiguration
@EnableResourceServer
@RestController
public class Application {
	
	@Bean
	public JwtTokenStore tokenStore() throws Exception {
		JwtAccessTokenConverter enhancer = new JwtAccessTokenConverter();
		// N.B. in a real system you would have to configure the verifierKey (or use JdbcTokenStore)
		enhancer.afterPropertiesSet();
		return new JwtTokenStore(enhancer);
	}

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

	@RequestMapping("/")
	public String home() {
		return "Hello World";
	}

}
--------------------------------------------------------------------------------------------------------
Usage

    Download script travis-encrypt.sh
    Make it executable chmod +x travis-encrypt.sh
    Run the script with ./travis-encrypt.sh -r username/repositoryname -e example
        It will return something like O+woVD9K+PeFrcyu5GCjKSFvfcSPwDW0kyDYEQnNbwt/iSkqjpl2OPA9W//KEKEB9UUSZD+XmQ3Ij0gnvJnOowcWY5sSeJlVEVTrSer0kW6uWpa/uWzDHCBz2YhBnI6u9SfYfMkhDl22pcaCEwaUkmK2gjcVo+v0bS8vAQFz0Na5/WiKj0GkSX50iIGgfaXheuC8KgIC25T0h+czpap7vb13OlblMnClfyTH9+TmAwTlcV7ljXpv1QY+K72L8jK1/CQVZ8quBYrBwwxO2V6cpXRMMCIw4m4lqxUyN4FBGnq7cJ7BWLzeqSMpFBoP+ZxAqS5yem8KLh1VkEo7PVjCkZE6M+2meFf2VJEVUs/KJY9xnH3eDzipWkwXon2qVpCkT7FDEzGFs/DapYsSo7eCO6pUYYhcpaYpWeYV9DSSV0QcrOeZp664iJMHWPSmrs/lESbbHpKWsM/AFVB9X75q/OB+QU0tQxpReZmKw3ZHbDVMlmlwhP8VSiQ05LV2W6gYzADGiUiL6n1X8teeHEVDSZnD7nrxMD/FchnWI5La3tZeFovRMf6hH3NItW+QZaGaGNftJrP488J/F2hCycPJk3+YrxbBCGHE2X379QbkMz3S0B5UiAcJKmwuTstF6X3CCurZVYIkUGGXhnmalPtVpEqxeTiLw5RU6C9z2qSwhhw=
    Use the encrypted secret in your .travis.yml according to https://docs.travis-ci.com/user/encryption-keys/#Usage


#!/bin/bash

usage() { echo -e "Travis Encrypt Script\nUsage:\t$0 \n -r\t<username/repository> \n -e\t<string which should be encrypted>" 1>&2; exit 1; }

while getopts ":r:e:" param; do
  case "${param}" in
    r)
      r=${OPTARG}
      ;;
    e)
      e=${OPTARG}
      ;;
    *)
      usage
      ;;
  esac
done
shift $((OPTIND -1))

if [ -z "${r}" ] || [[ !(${r} =~ [[:alnum:]]/[[:alnum:]]) ]] || [ -z "${e}" ]; then
  usage
fi

key_match="\"key\":\"([^\"]+)\""
key_url="https://api.travis-ci.org/repos/${r}/key"
request_result=$(curl --silent $key_url)

if [[ !($request_result =~ $key_match) ]]; then
  echo "Couldn't retrieve key from ${key_url}. "
  usage
fi

echo -n "${e}" | openssl rsautl -encrypt -pubin -inkey <(echo -e "${BASH_REMATCH[1]}") | openssl base64 -A
echo
--------------------------------------------------------------------------------------------------------
import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;@SpringBootApplicationpublic class CalculatorApplication {public static void main(String[] args) {SpringApplication.run(CalculatorApplication.class, args);  }  @Beanpublic ApplicationRunner calculationRunner(Calculator calculator) {return args -> {calculator.calculate(137, 21, '+');calculator.calculate(137, 21, '*');calculator.calculate(137, 21, '-');};  }}
--------------------------------------------------------------------------------------------------------
@RunWith(SpringRunner.class)@SpringBootTest(classes = CalculatorApplication.class)public class CalculatorApplicationTests {  @Rulepublic OutputCapture capture = new OutputCapture();  @Autowiredprivate Calculator calculator;  @Testpublic void doingMultiplicationShouldSucceed() {    calculator.calculate(12,13, '*');    capture.expect(Matchers.containsString("12 * 13 = 156"));  }  @Test(expected = IllegalArgumentException.class)public void doingDivisionShouldFail() {    calculator.calculate(12,13, '/');  }}
--------------------------------------------------------------------------------------------------------
spring.http.encoding.charset
spring.mvc.formcontent.filter.enabled
spring.mvc.hiddenmethod.filter.enabled

--------------------------------------------------------------------------------------------------------
import java.net.URL;
import java.net.HttpURLConnection;
import java.io.InputStream;
import java.io.IOException;

/**
 * A sample web-client class that opens an HTTP connection to a web-server and reads the response from it.
 * 
 * @version $Id$
 */
public class WebClient
{
    public String getContent( URL url )
    {
        StringBuffer content = new StringBuffer();
        try
        {
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setDoInput( true );
            InputStream is = connection.getInputStream();
            byte[] buffer = new byte[2048];
            int count;
            while ( -1 != ( count = is.read( buffer ) ) )
            {
                content.append( new String( buffer, 0, count ) );
            }
        }
        catch ( IOException e )
        {
            return null;
        }
        return content.toString();
    }
}

--------------------------------------------------------------------------------------------------------
import java.util.Arrays;
import java.util.Collection;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;

/**
 * A sample test-case that demonstrates the parameterized feature of JUnit.
 * 
 * @version $Id$
 */
@RunWith( value = Parameterized.class )
public class TestCalculator
{

    private int expected;

    private int actual;

    @Parameters
    public static Collection<Integer[]> data()
    {
        return Arrays.asList( new Integer[][] { { 1, 1 }, { 2, 4 }, { 3, 9 }, { 4, 16 }, { 5, 25 }, } );
    }

    public TestCalculator( int expected, int actual )
    {
        this.expected = expected;
        this.actual = actual;
    }

    @Test
    public void squareRoot()
    {
        Calculator calculator = new Calculator();
        assertEquals( expected, calculator.squareRoot( actual ) );
    }
}
--------------------------------------------------------------------------------------------------------

import java.util.HashMap;
import java.util.Map;

/**
 * Default implementation of the controller.
 * 
 * @version $Id: DefaultController.java 553 2010-03-06 12:29:58Z paranoid12 $
 */
public class DefaultController implements Controller {
	private Map<String, RequestHandler> requestHandlers = new HashMap<String, RequestHandler>();

	protected RequestHandler getHandler(Request request) {
		if (!this.requestHandlers.containsKey(request.getName())) {
			String message = "Cannot find handler for request name " + "["
					+ request.getName() + "]";
			throw new RuntimeException(message);
		}
		return this.requestHandlers.get(request.getName());
	}

	public Response processRequest(Request request) {
		Response response;
		try {
			response = getHandler(request).process(request);
		} catch (Exception exception) {
			response = new ErrorResponse(request, exception);
		}
		return response;
	}

	public void addHandler(Request request, RequestHandler requestHandler) {
		if (this.requestHandlers.containsKey(request.getName())) {
			throw new RuntimeException("A request handler has "
					+ "already been registered for request name " + "["
					+ request.getName() + "]");
		} else {
			this.requestHandlers.put(request.getName(), requestHandler);
		}
	}
}

--------------------------------------------------------------------------------------------------------
import java.util.Arrays;
import java.util.Collection;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;

/**
 * A sample parameterized test-case.
 * 
 * @version $Id: ParameterizedTest.java 551 2010-03-06 11:37:34Z paranoid12 $
 */
@RunWith(value=Parameterized.class)
public class ParameterizedTest {

    private double expected; 
    private double valueOne; 
    private double valueTwo; 

    @Parameters 
    public static Collection<Integer[]> getTestParameters() {
       return Arrays.asList(new Integer[][] {
          {2, 1, 1},  //expected, valueOne, valueTwo   
          {3, 2, 1},  //expected, valueOne, valueTwo   
          {4, 3, 1},  //expected, valueOne, valueTwo   
       });
    }

    public ParameterizedTest(double expected, 
       double valueOne, double valueTwo) {
       this.expected = expected;
       this.valueOne = valueOne;
       this.valueTwo = valueTwo;
    }

    @Test
    public void sum() {
       Calculator calc = new Calculator();
       assertEquals(expected, calc.add(valueOne, valueTwo), 0);
    } 
}
--------------------------------------------------------------------------------------------------------
  @RunWith(DataProviderRunner.class)
  public class MathUtilsTest {

    private MathUtils mathUtils;

    @Before
    public void setup(){
        mathUtils = new MathUtils();
    }

    @Test
    @UseDataProvider(value = "testAddData", location = MathUtilsDataProviders.class)
    public void add(int inputData[], int expectedOutput) throws Exception {
        assertTrue(mathUtils.add(inputData[0], inputData[1]) == expectedOutput);
    }

    @Test
    @UseDataProvider(value = "testSubtractData", location = MathUtilsDataProviders.class)
    public void subtract(int inputData[], int expectedOutput) throws Exception {
        assertTrue(mathUtils.subtract(inputData[0], inputData[1]) == expectedOutput);
    }

    @Test
    @UseDataProvider(value = "testMultiplyData", location = MathUtilsDataProviders.class)
    public void multiply(int inputData[], int expectedOutput) throws Exception {
        assertTrue(mathUtils.multiply(inputData[0], inputData[1]) == expectedOutput);
    }

    @Test
    @UseDataProvider(value = "testDivideData", location = MathUtilsDataProviders.class)
    public void divide(int inputData[], int expectedOutput) throws Exception {
        assertTrue(mathUtils.divide(inputData[0], inputData[1]) == expectedOutput);
    }

  }
--------------------------------------------------------------------------------------------------------
import static book.twju.timeline.util.Assertion.checkArgument;
import book.twju.timeline.model.Item;
import book.twju.timeline.model.Timeline;

public enum FetchOperation {
  
  NEW {
    @Override
    public <T extends Item> void fetch( Timeline<T> timeline ) {
      checkArgument( timeline != null, TIMELINE_MUST_NOT_BE_NULL );
      
      timeline.fetchNew();
    }
  },
  
  MORE {
    @Override
    public <T extends Item> void fetch( Timeline<T> timeline ) {
      checkArgument( timeline != null, TIMELINE_MUST_NOT_BE_NULL );

      timeline.fetchItems();
    }
  };
  
  static final String TIMELINE_MUST_NOT_BE_NULL = "Argument 'timeline' must not be null.";

  public abstract <T extends Item> void fetch( Timeline<T> timeline );
}
--------------------------------------------------------------------------------------------------------

	public static class OddFilter<T> implements Transformer<T, T> {

		@Override
		public Observable<T> call(Observable<T> observable) {
			return observable
					.lift(new Indexed<T>(1L))
					.filter(pair -> pair.getLeft() % 2 == 1)
					.map(pair -> pair.getRight());
		}
		
	}
--------------------------------------------------------------------------------------------------------
ArgumentCaptor<Memento> captor = forClass( Memento.class );verify( sessionStorage ).store( captor.capture() );assertTrue( !captor.getValue().getItems().isEmpty() 
--------------------------------------------------------------------------------------------------------
public class Indexed<T> implements Operator<Pair<Long, T>, T> {  private final long initialIndex;  public Indexed() {    this(0L);  }  public Indexed(long initial) {    this. initialIndex = initial;  }  @Overridepublic Subscriber<? super T> call(Subscriber<? super Pair<Long, T>>   s) {    return new Subscriber<T>(s) {      private long index = initialIndex;      @Override      public void onCompleted() {        s.onCompleted();      }      @Override      public void onError(Throwable e) {        s.onError(e);      }      @Override      public void onNext(T t) {        s.onNext(new Pair<Long, T>(index++, t));      }    };  }}
--------------------------------------------------------------------------------------------------------
public class ConditionalIgnoreTest {  @Rule  public ConditionalIgnoreRule rule = new ConditionalIgnoreRule();  @Test  @ConditionalIgnore( condition = NotRunningOnWindows.class )  public void focus() {    // ...  }}class NotRunningOnWindows implements IgnoreCondition {  public boolean isSatisfied() {    return      !System.getProperty( "os.name" ).startsWith( "Windows" );  }}

public class ProvideSystemInputExample {  private static final String INPUT = "input";  @Rule  public final TextFromStandardInputStream systemInRule    = TextFromStandardInputStream.emptyStandardInputStream();  @Test  public void stubInput() {    systemInRule.provideLines( INPUT );    assertEquals( INPUT, readLine( System.in ) );  }  private String readLine( InputStream inputstream ) {    return new Scanner( inputstream ).nextLine();  }}

public class CaptureSystemOutputExample {  private static final String OUTPUT = "output";  @Rule  public final SystemOutRule systemOutRule    = new SystemOutRule().enableLog().muteForSuccessfulTests();  @Test  public void captureSystemOutput() {    System.out.print( OUTPUT );    assertEquals( OUTPUT, systemOutRule.getLog() );  }}

public class ProvideSystemPropertyExample {
private static final String JAVA_IO_TMPDIR = "java.io.tmpdir";  private static final String MY_TMPDIR = "/path/to/my/tmpdir";  @Rule  public final ProvideSystemProperty provideCustomTempDirRule    = new ProvideSystemProperty( JAVA_IO_TMPDIR, MY_TMPDIR );  @Test  public void checkTempDir() {    assertEquals( MY_TMPDIR,                  System.getProperty( JAVA_IO_TMPDIR ) );  }}

public class ClearPropertiesExample {  private static final String JAVA_IO_TMPDIR = "java.io.tmpdir";  @Rule  public final ClearSystemProperties clearTempDirRule    = new ClearSystemProperties( JAVA_IO_TMPDIR );  @Test  public void checkTempDir() {    assertNull( System.getProperty( JAVA_IO_TMPDIR ) );  }}

@RunWith( ClasspathSuite.class )@ClassnameFilters( { ".*ServerTest" } )public class ServerIntegrationTestSuite {  @ClassRule  public static TestRule chain = RuleChain    .outerRule( new ServerRule( 4711 ) )    .around( new MyRule() );}

public class ServerRule extends ExternalResource {  private final int port;  public ServerRule( int port ) {    this.port = port;  }  @Override  protected void before() throws Throwable {    System.out.println( "start server on port: " + port );  }  @Override  protected void after() {    System.out.println( "stop server on port: " + port );  }}
--------------------------------------------------------------------------------------------------------
public class MementoAssert  extends AbstractAssert<MementoAssert, Memento>{  private static final String ITEM_PATTERN    = "\nExpected items to be\n  <%s>,\nbut were\n  <%s>.";  private static final String TOP_ITEM_PATTERN    = "\nExpected top item to be\n  <%s>,\nbut was\n  <%s>.";  public static MementoAssert assertThat( Memento actual ) {    return new MementoAssert( actual );  }  public MementoAssert( Memento actual ) {    super( actual, MementoAssert.class );  }  @Override  public MementoAssert isEqualTo( Object expected ) {    hasEqualItems( ( Memento )expected );    hasEqualTopItem( ( Memento )expected );    return this;  }  public MementoAssert hasEqualItems( Memento expected ) {    isNotNull();    if( !actual.getItems().equals( expected.getItems() ) ) {      failWithMessage( ITEM_PATTERN,                       expected.getItems(),                       actual.getItems() );

}    return this;  }  public MementoAssert hasEqualTopItem( Memento expected ) {    isNotNull();    if( !actual.getTopItem().equals( expected.getTopItem() ) ) {      failWithMessage( TOP_ITEM_PATTERN,                       expected.getTopItem(),                       actual.getTopItem() );    }    return this;  }}

assertThat( actual )  .describedAs( description )  .hasMessage( EXPECTED_ERROR_MESSAGE )  .isInstanceOf( NullPointerException.class );
--------------------------------------------------------------------------------------------------------
yum install jenkins
sudo service jenkins start/stop/restart

wget -q -O - http://pkg.jenkins-ci.org/debian/jenkins-ci.org.key | sudo apt-key add -

svnserve -dsvn mkdir svn://localhost/$PATH_REPO/packt-app --username svnpackt

mvn archetype:generate \  -DarchetypeGroupId=org.apache.maven.archetypes \  -DgroupId=com.packt.app \  -DartifactId=packt-app

svnadmin create $PATH_REPO
sudo apt-get install doxygen
--------------------------------------------------------------------------------------------------------

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.springframework.boot.actuate.endpoint.AbstractEndpoint;
import org.springframework.boot.actuate.endpoint.Endpoint;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.util.Assert;
import org.togglz.core.Feature;
import org.togglz.core.manager.FeatureManager;
import org.togglz.core.repository.FeatureState;
import org.togglz.spring.boot.autoconfigure.TogglzFeature;

/**
 * {@link Endpoint} to expose Togglz info.
 *
 * @author Marcel Overdijk
 */
@ConfigurationProperties(prefix = "togglz.endpoint", ignoreUnknownFields = true)
public class TogglzEndpoint extends AbstractEndpoint<List<TogglzFeature>> {

    private final FeatureManager featureManager;

    public TogglzEndpoint(FeatureManager featureManager) {
        super("togglz");
        Assert.notNull(featureManager, "FeatureManager must not be null");
        this.featureManager = featureManager;
    }

    @Override
    public List<TogglzFeature> invoke() {
        List<TogglzFeature> features = new ArrayList<>();
        for (Feature feature : this.featureManager.getFeatures()) {
            FeatureState featureState = this.featureManager.getFeatureState(feature);
            features.add(new TogglzFeature(feature, featureState));
        }
        Collections.sort(features);
        return features;
    }
}
--------------------------------------------------------------------------------------------------------
public enum MyFeatures implements Feature {

    @EnabledByDefault
    @Label("First Feature")
    FEATURE_ONE,

    @Label("Second Feature")
    FEATURE_TWO;
}

@Bean
public FeatureProvider featureProvider() {
    return new EnumBasedFeatureProvider(MyFeatures.class);
}

@Controller
public class MyClass {
  private FeatureManager manager;

  public MyClass(FeatureManager manager) {
      this.manager = manager;
  }

  @RequestMapping("/")
  public ResponseEntity<?> index() {
      if (manager.isActive(HELLO_WORLD)) {
           ...
      }
  }
}
--------------------------------------------------------------------------------------------------------
/**
	 * The configured features in a format that can be consumed by a
	 * PropertyFeatureProvider.
	 *
	 * @return features in the right format.
	 */
	public Properties getFeatureProperties() {
		Properties properties = new Properties();
		for (String name : features.keySet()) {
			properties.setProperty(name, features.get(name).spec());
		}
		return properties;
	}
--------------------------------------------------------------------------------------------------------
public class TicTacToeSpec {    @Rule    public ExpectedException exception =      ExpectedException.none();    private TicTacToe ticTacToe;    @Before    public final void before() {        ticTacToe = new TicTacToe();    }    @Test    public void whenXOutsideBoardThenRuntimeException()    {        exception.expect(RuntimeException.class);        ticTacToe.validatePosition(5, 2);    }    @Test    public void whenYOutsideBoardThenRuntimeException()    {        exception.expect(RuntimeException.class);        ticTacToe.validatePosition(2, 5);    }}
--------------------------------------------------------------------------------------------------------
@Service("fibonacci")public class FibonacciService {    public static final int LIMIT = 30;    public int getNthNumber(int n) {        if (isOutOfLimits(n) {        throw new IllegalArgumentException(        "Requested number must be a positive " +           number no bigger than " + LIMIT);        if (n == 0) return 0;        if (n == 1 || n == 2) return 1;        int first, second = 1, result = 1;        do {            first = second;            second = result;            result = first + second;            --n;        } while (n > 2);        return result;    }    private boolean isOutOfLimits(int number) {        return number > LIMIT || number < 0;    }}
--------------------------------------------------------------------------------------------------------
apply plugin: 'java'apply plugin: 'application'sourceCompatibility = 1.8version = '1.0'mainClassName = "com.packtpublishing.tddjava.ch09.Application"repositories {    mavenLocal()    mavenCentral()}dependencies {    compile group: 'org.springframework.boot',            name: 'spring-boot-starter-thymeleaf',            version: '1.2.4.RELEASE'    testCompile group: 'junit',    name: 'junit',    version: '4.12'}
--------------------------------------------------------------------------------------------------------
mvn clean jetty:run
--------------------------------------------------------------------------------------------------------
import java.util.ArrayList;
import java.util.List;

public class Location {

    private static final int FORWARD = 1;
    private static final int BACKWARD = -1;

    public int getX() {
        return point.getX();
    }

    public int getY() {
        return point.getY();
    }

    private Point point;
    public Point getPoint() {
        return point;
    }

    private Direction direction;
    public Direction getDirection() {
        return this.direction;
    }
    public void setDirection(Direction direction) {
        this.direction = direction;
    }

    public Location(Point point, Direction direction) {
        this.point = point;
        this.direction = direction;
    }

    public boolean forward() {
        return move(FORWARD, new Point(100, 100), new ArrayList<>());
    }
    public boolean forward(Point max) {
        return move(FORWARD, max, new ArrayList<>());
    }
    public boolean forward(Point max, List<Point> obstacles) {
        return move(FORWARD, max, obstacles);
    }

    public boolean backward() {
        return move(BACKWARD, new Point(100, 100), new ArrayList<>());
    }
    public boolean backward(Point max) {
        return move(BACKWARD, max, new ArrayList<>());
    }
    public boolean backward(Point max, List<Point> obstacles) {
        return move(BACKWARD, max, obstacles);
    }

    private boolean move(int fw, Point max, List<Point> obstacles) {
        int x = point.getX();
        int y = point.getY();
        switch(getDirection()) {
            case NORTH:
                y = wrap(getY() - fw, max.getY());
                break;
            case SOUTH:
                y = wrap(getY() + fw, max.getY());
                break;
            case EAST:
                x = wrap(getX() + fw, max.getX());
                break;
            case WEST:
                x = wrap(getX() - fw, max.getX());
                break;
        }
        if (isObstacle(new Point(x, y), obstacles)) {
            return false;
        } else {
            point = new Point(x, y);
            return true;
        }
    }

    private boolean isObstacle(Point point, List<Point> obstacles) {
        for (Point obstacle : obstacles) {
            if (obstacle.getX() == point.getX() && obstacle.getY() == point.getY()) {
                return true;
            }
        }
        return false;
    }

    private int wrap(int point, int maxPoint) {
        if (maxPoint > 0) {
            if (point > maxPoint) {
                return 1;
            } else if (point == 0) {
                return maxPoint;
            }
        }
        return point;
    }

    public void turnLeft() {
        this.direction = direction.turnLeft();
    }

    public void turnRight() {
        this.direction = direction.turnRight();
    }

    public Location copy() {
        return new Location(new Point(point.getX(), point.getY()), direction);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Location location = (Location) o;
        if (getX() != location.getX()) return false;
        if (getY() != location.getY()) return false;
        if (direction != location.direction) return false;
        return true;
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.stereotype.Component;

import javax.ws.rs.core.Response;
import javax.ws.rs.ext.ExceptionMapper;
import javax.ws.rs.ext.Provider;

@Provider
public class CustomExceptionMapper implements ExceptionMapper<IllegalArgumentException> {

    @Override
    public Response toResponse(IllegalArgumentException exception) {
        return Response.ok("Illegal Argument Exception Caught").build();
    }
}

--------------------------------------------------------------------------------------------------------
import java.lang.reflect.Method;

import org.apache.log4j.Logger;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.BeanPostProcessor;

import com.google.common.eventbus.EventBus;
import com.google.common.eventbus.Subscribe;

public class FindEventBusSubscribers implements BeanPostProcessor {

	@Autowired
	private EventBus eventBus;
	private static final Logger LOG = Logger.getLogger(FindEventBusSubscribers.class);

	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		Method[] beanMethods = bean.getClass().getMethods();
		for (Method beanMethod : beanMethods) {
			if (beanMethod.isAnnotationPresent(Subscribe.class)) {
				eventBus.register(bean);
				LOG.info(String.format("Found event bus subscriber class %s. Subscriber method name=%s", bean
						.getClass().getSimpleName(), beanMethod.getName()));
				break;
			}
		}
		return bean;
	}

}
--------------------------------------------------------------------------------------------------------
<Connector port="8080" protocol="HTTP/1.1"               connectionTimeout="20000"               redirectPort="8443" />

<role rolename="manager-gui"/>  <user username="admin" password="admin" roles="manager-gui"/>

insert into user (host, user, password, select_priv, insert_priv, update_priv)           values ('%', 'user1', password('usper1_pass'),'Y','Y','Y');

<%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%>

wsimport -keep -p packt.jee.eclipse.ws.soap.client http://localhost:8080/CourseMgmtWSProject/courseService?wsdl


-- MySQL Script generated by MySQL Workbench-- Sun Mar  8 18:17:07 2015-- Model: New Model    Version: 1.0-- MySQL Workbench Forward EngineeringSET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='TRADITIONAL,ALLOW_INVALID_DATES';-- ------------------------------------------------------- Schema course_management-- -----------------------------------------------------DROP SCHEMA IF EXISTS `course_management` ;-- ------------------------------------------------------- Schema course_management-- -----------------------------------------------------CREATE SCHEMA IF NOT EXISTS `course_management` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci ;USE `course_management` ;-- ------------------------------------------------------- Table `course_management`.`Teacher`-- -----------------------------------------------------DROP TABLE IF EXISTS `course_management`.`Teacher` ;CREATE TABLE IF NOT EXISTS `course_management`.`Teacher` (  `id` INT NOT NULL AUTO_INCREMENT,  `first_name` VARCHAR(45) NOT NULL,  `last_name` VARCHAR(45) NULL,  `designation` VARCHAR(45) NOT NULL,  PRIMARY KEY (`id`))ENGINE = InnoDB;-- ------------------------------------------------------- Table `course_management`.`Course`

SET SQL_MODE=@OLD_SQL_MODE;SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;


--------------------------------------------------------------------------------------------------------
LocalDate.of(2017, 1, 31)                         .datesUntil(LocalDate.of(2018, 1, 1), Period.ofMonths(1))         .map(ld -> ld.format(DateTimeFormatter.ofPattern("EEE MMM dd, yyyy")))         .forEach(System.out::println)
long sundaysIn2017 = LocalDate.of(2017, 1, 1)                              .datesUntil(LocalDate.of(2018, 1, 1))                              .filter(ld -> ld.getDayOfWeek() == DayOfWeek.SUNDAY)                              .count(); 

Date dt = new Date();LocalDate ld= dt.toInstant()                 .atZone(ZoneId.systemDefault())                 .toLocalDate();System.out.println("Current Local Date: " + ld);

package com.jdojo.misc;public class SpinWaitTest implements Runnable {    private volatile boolean dataReady = false;    @Override    public void run() {        // Wait while data is ready        while (!dataReady) {            // Hint a spin-wait            Thread.onSpinWait();        }        processData();    }    private void processData() {        // Data processing logic goes here    }    public void setDataReady(boolean dataReady) {        this.dataReady = dataReady;    }}
--------------------------------------------------------------------------------------------------------
javadoc -html5 <other-options>
M/dd/yyyy HH:mm zzzz
M/dd/yyyy HH:mm vvvv
--------------------------------------------------------------------------------------------------------
java -Djdk.serialFilter=maxarray=100;maxdepth=3;com.jdojo.** --module-path com.jdojo.misc\build\classes --module com.jdojo.misc/com.jdojo.misc.ObjectFilterTest

Chapter 20 ■ Other Changes in JDK 9509public class Item implements Serializable {    private int id;        private String name;    private int[] points;    public Item(int id, String name, int[] points) {        this.id = id;        this.name = name;        this.points = points;    }    /* Add getters and setters here */    @Override    public String toString() {        return "[id=" + id + ", name=" + name + ", points=" + Arrays.toString(points) + "]";    }}

import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputFilter;import java.io.ObjectInputFilter.Config;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class ObjectFilterTest {    public static void main(String[] args)  {                 // Relative path of the output/input file        File file = new File("serialized", "item.ser");        // Make sure directories exist        ensureParentDirExists(file);        // Create an Item used in serialization and deserialization        Item item = new Item(100, "Pen", new int[]{1,2,3,4});        // Serialize the item        serialize(file, item);
        // Print the global filter        ObjectInputFilter globalFilter = Config.getSerialFilter();        System.out.println("Global filter: " + globalFilter);        // Deserialize the item        Item item2 = deserialize(file);        System.out.println("Deserialized using global filter: " + item2);        // Use a filter to reject array size > 2        String maxArrayFilterPattern = "maxarray=2";        ObjectInputFilter maxArrayFilter = Config.createFilter(maxArrayFilterPattern);                 Item item3 = deserialize(file, maxArrayFilter);        System.out.println("Deserialized with a maxarray=2 filter: " + item3);        // Create a custom filterArrayLengthObjectFilter customFilter = new ArrayLengthObjectFilter(5);                        Item item4 = deserialize(file, customFilter);        System.out.println("Deserialized with a custom filter (maxarray=5): " + item4);    }    private static void serialize(File file, Item item) {                try (ObjectOutputStream out =  new ObjectOutputStream(new FileOutputStream(file))) {                        out.writeObject(item);            System.out.println("Serialized Item: " + item);        } catch (Exception e) {            e.printStackTrace();        }    }    private static Item deserialize(File file) {try  (ObjectInputStream  in  =   new  ObjectInputStream(new  FileInputStream(file)))  {                                    Item item = (Item)in.readObject();            return item;        } catch (Exception e) {            System.out.println("Could not deserialize item. Error: " + e.getMessage());        }        return null;    }    private static Item deserialize(File file, ObjectInputFilter filter) {        try (ObjectInputStream in =  new ObjectInputStream(new FileInputStream(file))) {                        // Set the object input filter passed in            in.setObjectInputFilter(filter);            Item item = (Item)in.readObject();            return item;        } catch (Exception e) {            System.out.println("Could not deserialize item. Error: " + e.getMessage());                    }        return null;    }
    private static void ensureParentDirExists(File file) {        File parent = file.getParentFile();        if(!parent.exists()) {            parent.mkdirs();        }        System.out.println("Input/output file is " + file.getAbsolutePath());    }}
--------------------------------------------------------------------------------------------------------
ObjectInputFilter.Config class:// Create a filterString pattern = "maxarray=100;maxdepth=3;com.jdojo.**";ObjectInputFilter globalFilter = ObjectInputFilter.Config.createFilter(pattern);// Set a global filterObjectInputFilter.Config.setSerialFilter(lobalFilter);

import java.io.ObjectInputFilter;public class ArrayLengthObjectFilter implements ObjectInputFilter {    private long maxLenth = -1;    public ArrayLengthObjectFilter(int maxLength) {        this.maxLenth = maxLength;    }    @Override    public Status checkInput(FilterInfo info) {        long arrayLength = info.arrayLength();        if (arrayLength >= 0 && arrayLength > this.maxLenth) {            return Status.REJECTED;        }        return Status.ALLOWED;    }}

import java.io.ObjectInputFilter;public class ArrayLengthObjectFilter implements ObjectInputFilter {    private long maxLenth = -1;    public ArrayLengthObjectFilter(int maxLength) {        this.maxLenth = maxLength;    }    @Override    public Status checkInput(FilterInfo info) {        long arrayLength = info.arrayLength();        if (arrayLength >= 0 && arrayLength > this.maxLenth) {            return Status.REJECTED;        }        return Status.ALLOWED;    }}
--------------------------------------------------------------------------------------------------------
java -p lib -m claim/pkg3.Main
ava -Xdiag:resolver -p lib -m claim/pkg3.Main
java --module-path C:\applib;C:\lib other-args-go-here
java -p C:\applib;C:\extlib other-args-go-here
java --module-path=C:\applib;C:\lib other-args-go-here
java --list-modules
java --module-path lib --list-modules
java --list-modules java.sql
javac -d mods --module-source-path src $(find src -name "*.java"
avac -d mods\com.jdojo.intro  --module-version 1.0  src\com.jdojo.intro\module-info.java      src\com.jdojo.intro\com\jdojo\intro\Welcome.java
FOR /F "tokens=1 delims=" %A in ('dir src\*.java /S /B') do javac -d mods --module-source-path src %A
javac -d mods --module-source-path src $(find src -name "*.java")
ar --create --file lib/com.jdojo.intro-1.0.jar --main-class com.jdojo.intro.Welcome --module-version 1.0 -C mods/com.jdojo.intro .
java --module-path <module-path> --module <module>/<main-class>
jar --describe-module --file lib\cglib-2.2.2.jar-plugin













javap -verbose jar:file:lib/com.jdojo.intro-1.0.jar!/module-info.class
javap --module-path lib --module com.jdojo.intro com.jdojo.intro.Welcome
javap jrt:/java.sql/module-info.class
--------------------------------------------------------------------------------------------------------
/env -class-path C:\Java9Revealed\com.jdojo.jshell\build\classes
import java.io.*
import java.math.*
import java.net.*
import java.nio.file.*
import java.util.*
import java.util.concurrent.*
import java.util.function.*
import java.util.prefs.*
import java.util.regex.*
import java.util.stream.*
import java.time.*;
import com.jdojo.jshell.*;
void printf(String format, Object... args) { System.out.printf(format, args); }
--------------------------------------------------------------------------------------------------------
Map<String, Integer> mapNameAge = people.stream()
      .collect(Collectors.toMap(
          Person::getName,
          Person::getAge,
          (u,v) -> { throw new IllegalStateException(String.format("Duplicate key %s", u)); },
          LinkedHashMap::new
          ));
--------------------------------------------------------------------------------------------------------
# itertools.permutations() generates permutations 
# for an iterable. Time to brute-force those passwords ;-)

>>> import itertools
>>> for p in itertools.permutations('ABCD'):
...     print(p)
--------------------------------------------------------------------------------------------------------
BufferedImageimg=null;try{img=ImageIO.read(newFile("Image.png"));intheight=img.getHeight();intwidth=img.getWidth();int[][]data=newint[height][width];for(inti=0;i<height;i++){for(intj=0;j<width;j++){intrgb=img.getRGB(i,j);// negative integersdata[i][j]=rgb;}}}catch(IOExceptione){// handle exception}

intblue=0x0000ff&rgb;intgreen=0x0000ff&(rgb>>8);intred=0x0000ff&(rgb>>16);intalpha=0x0000ff&(rgb>>24);

byte[]pixels=((DataBufferByte)img.getRaster().getDataBuffer()).getData();for(inti=0;i<pixels.length/3;i++){intblue=Byte.toUnsignedInt(pixels[3*i]);intgreen=Byte.toUnsignedInt(pixels[3*i+1]);intred=Byte.toUnsignedInt(pixels[3*i+2]);}

//convert rgb to grayscale (0 to 1) where colors are on a scale of 0 to 255doublegray=(0.2126*red+0.7152*green+0.0722*blue)/255.0
--------------------------------------------------------------------------------------------------------
source <filename>
order by rand() limit 1000
DROPTABLEIFEXISTSdata;CREATETABLEIFNOTEXISTSdata(idINTEGERPRIMARYKEY,yrINTEGER,cityVARCHAR(80));INSERTINTOdata(id,yr,city)VALUES(1,2015,"San Francisco"),(2,2014,"New York"),(3,2012,"Los Angeles")
--------------------------------------------------------------------------------------------------------
intsize=3;RealVectorvector=newArrayRealVector(size);

introwDimension=10;intcolDimension=20;RealMatrixmatrix=newArray2DRowRealMatrix(rowDimension,colDimension);

double[][]data=;RealMatrixblockMatrix=newBlockRealMatrix(data);
intdim=10000;RealVectorsparseVector=newOpenMapRealVector(dim);
--------------------------------------------------------------------------------------------------------
publicclassBasicScatterChartextendsApplication{publicstaticvoidmain(String[]args){launch(args);}@Overridepublicvoidstart(Stagestage)throwsException{int[]xData={1,2,3,4,5};double[]yData={1.3,2.1,3.3,4.0,4.8};/* add Data to a Series */Seriesseries=newSeries();for(inti=0;i<xData.length;i++){series.getData().add(newData(xData[i],yData[i]));}/* define the axes */NumberAxisxAxis=newNumberAxis();xAxis.setLabel("x");NumberAxisyAxis=newNumberAxis();yAxis.setLabel("y");/* create the scatter chart */ScatterChart<Number,Number>scatterChart=newScatterChart<>(xAxis,yAxis);scatterChart.getData().add(series);/* create a scene using the chart */Scenescene=newScene(scatterChart,800,600);/* tell the stage what scene to use and render it! */stage.setScene(scene);stage.show();}}
--------------------------------------------------------------------------------------------------------
scatterChart.setAnimated(false);.../* render the image */stage.show();.../* save the chart to a file AFTER the stage is rendered */WritableImageimage=scatterChart.snapshot(newSnapshotParameters(),null);Filefile=newFile("chart.png");ImageIO.write(SwingFXUtils.fromFXImage(image,null),"png",file);

--------------------------------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>org.demo</groupId>
	<artifactId>demo</artifactId>
	<version>0.0.1-SNAPSHOT</version>

    <packaging>war</packaging>
	<description>Demo project</description>

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>1.0.0.BUILD-SNAPSHOT</version>
	</parent>

	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-tomcat</artifactId>
                </exclusion>
            </exclusions>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
		</dependency>
	</dependencies>

	<properties>
        <start-class>demo.Application</start-class>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.7</java.version>
	</properties>
	<repositories>
		<repository>
			<id>spring-snapshots</id>
			<name>Spring Snapshots</name>
			<url>http://repo.spring.io/snapshot</url>
			<snapshots>
				<enabled>true</enabled>
			</snapshots>
		</repository>
		<repository>
			<id>spring-milestones</id>
			<name>Spring Milestones</name>
			<url>http://repo.spring.io/milestone</url>
			<snapshots>
				<enabled>false</enabled>
			</snapshots>
		</repository>
	</repositories>
	<pluginRepositories>
		<pluginRepository>
			<id>spring-snapshots</id>
			<name>Spring Snapshots</name>
			<url>http://repo.spring.io/snapshot</url>
			<snapshots>
				<enabled>true</enabled>
			</snapshots>
		</pluginRepository>
		<pluginRepository>
			<id>spring-milestones</id>
			<name>Spring Milestones</name>
			<url>http://repo.spring.io/milestone</url>
			<snapshots>
				<enabled>false</enabled>
			</snapshots>
		</pluginRepository>
	</pluginRepositories>
</project>
--------------------------------------------------------------------------------------------------------
List<Class<?>> getAllClassesInPackageContaining(Class<?> clazz) 
    throws IOException 
{
    String clazzPackageName = clazz
            .getPackage()
            .getName();

    String clazzPath = clazz
            .getResource(".")
            .getPath();

    Path packagePath = Paths.get(clazzPath)
            .getParent();

    final List<Class<?>> packageClasses = new ArrayList<>();

    Files.walkFileTree(packagePath, new SimpleFileVisitor<Path>() {
        @Override
        public FileVisitResult visitFile(
                Path file, BasicFileAttributes attrs) 
                throws IOException 
        {
            String filename = 
                file.getName(file.getNameCount()-1).toString();

            if (filename.endsWith(".class")) {
                String className = filename.replace(".class", "");

                try {
                    Class<?> loadedClazz = Class.forName(
                        clazzPackageName + "." + className);
                        
                    packageClasses.add(loadedClazz);
                }
                catch(ClassNotFoundException e) {
                    System.err.println(
                        "class not found: " + e.getMessage());
                }
            }

            return super.visitFile(file, attrs);
        }
    });

    return packageClasses;
}
--------------------------------------------------------------------------------------------------------
language: java

matrix:
  include:
    - jdk: openjdk8
    - jdk: openjdk10
    - jdk: openjdk11
    - jdk: openjdk-ea
  allow_failures:
    # ErrorProne/javac is not yet working on JDK 11 nor 12 (current -ea)
    - jdk: openjdk11
    - jdk: openjdk-ea

before_install:
  - unset _JAVA_OPTIONS

after_success:
  - .buildscript/deploy_snapshot.sh

env:
  global:
    - secure: "nkVNCk8H2orIZOmow0t+Qub1lFQCYpJgNZf17zYI5x0JVqQNCqkcTYYDHqzwkvkmixXFCrfYZQuXy7x2qg9zjCX+vmhlmiMWwe8dNa34OLTseuuR2irS0C8nRGRYxKM7EGenRZSqbFVUksKRm2iWnHKxtmCzeDaS7MoMit2wdUo="
    - secure: "j8+hPaZnyM+UlOBYOEA96fPbVWbN6bMQ28SGQnFMwxo2axHi9ww9Au1N7002HzHnxX8iyesdWFBigArnEL8zKEoXH9Bmur0sn3Ys4bu72C3ozscP4cjXfYSHj8aVLp1EIMdQPDF7MkCccx9l7ONdsW0ltmdiVUtDxzqkH+63WLU="

branches:
  except:
    - gh-pages

notifications:
  email: false

cache:
  directories:
    - $HOME/.m2
--------------------------------------------------------------------------------------------------------
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.RouterFunctions;
import org.springframework.web.reactive.function.server.ServerResponse;

import static org.springframework.web.reactive.function.server.RequestPredicates.GET;

@Configuration
public class PlayerRouter {

    @Bean
    public RouterFunction<ServerResponse> route(PlayerHandler playerHandler) {
        return RouterFunctions
                .route(GET("/players/{name}"), playerHandler::getName)
                .filter(new ExampleHandlerFilterFunction());
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.web.reactive.function.server.HandlerFilterFunction;
import org.springframework.web.reactive.function.server.HandlerFunction;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Mono;

import static org.springframework.http.HttpStatus.FORBIDDEN;

public class ExampleHandlerFilterFunction implements HandlerFilterFunction<ServerResponse, ServerResponse> {

    @Override
    public Mono<ServerResponse> filter(ServerRequest serverRequest, HandlerFunction<ServerResponse> handlerFunction) {
        if (serverRequest.pathVariable("name").equalsIgnoreCase("test")) {
            return ServerResponse.status(FORBIDDEN).build();
        }
        return handlerFunction.handle(serverRequest);
    }
}
--------------------------------------------------------------------------------------------------------
@Testpublic void fetchItemWithExceptionOnStoreTop()  throws IOException{  IOException cause = new IOException();  doThrow( cause ).when( storage ).storeTop( any( Item.class ) );  Throwable actual = thrownBy( () -> timeline.fetchItems() );  assertNotNull( actual );  assertTrue( actual instanceof IllegalStateException );  assertSame( cause, actual.getCause() );  assertEquals( Timeline.ERROR_STORE_TOP, actual.getMessage() );}
--------------------------------------------------------------------------------------------------------
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;

public class AdminInterceptor extends HandlerInterceptorAdapter {

   @Override
   public void postHandle(HttpServletRequest req, HttpServletResponse res,
         Object handler, ModelAndView model)  throws Exception {

      System.out.println("Called after handler method request completion,"
            + " before rendering the view");

      LocalTime time = LocalTime.now();
      int hrs = time.getHour();
      if (hrs >= 0 && hrs <= 12) {
         model.addObject("greeting", "Good morning!");
      } else if (hrs > 12 && hrs <= 17) {
         model.addObject("greeting", "Good afternoon!");
      } else {
         model.addObject("greeting", "Good evening!");
      }
   }
}
--------------------------------------------------------------------------------------------------------
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

public class GuestInterceptor implements HandlerInterceptor {

   // Called before handler method invocation
   @Override
   public boolean preHandle(HttpServletRequest req, HttpServletResponse res,
         Object handler) throws Exception {
      System.out.println("Called before handler method");
      req.setAttribute("fname", "Elizabeth");
      return true;
   }

   // Called after handler method request completion, before rendering the view
   @Override
   public void postHandle(HttpServletRequest req, HttpServletResponse res, 
         Object handler, ModelAndView model)  throws Exception {
      System.out.println("Called after handler method request completion,"
            + " before rendering the view");

      model.addObject("lname", "Brown");
   }

   // Called after rendering the view
   @Override
   public void afterCompletion(HttpServletRequest req, HttpServletResponse res,
         Object handler, Exception ex)  throws Exception {
      System.out.println("Called after rendering the view");
   }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

@Component
public class MyWebSocketHandler extends TextWebSocketHandler {

    @Override
    protected void handleTextMessage(final WebSocketSession session, final TextMessage message) throws Exception {

        String clientMessage = message.getPayload();

        if (clientMessage.startsWith("Hello") || clientMessage.startsWith("Hi")) {
            session.sendMessage(new TextMessage("Hello! What can i do for you?"));
        } else {
            session.sendMessage(
                new TextMessage("This is a simple hello world example of using Spring WebSocket."));
        }
    }
}
--------------------------------------------------------------------------------------------------------
@Qualifier@Retention(RUNTIME)@Target({ TYPE, METHOD, FIELD, PARAMETER })@Documentedpublic @interface SomeQualifierOne {    public static final class Literalextends AnnotationLiteral<SomeQualifierOne>implements SomeQualifierOne {Chapter 3  IdentIfyIng Beans
71private static final long serialVersionUID = 1L;public static final Literal INSTANCE = new Literal();   }}

@Qualifier@Retention(RUNTIME)@Target({ TYPE, METHOD, FIELD, PARAMETER })@Documentedpublic @interface SomeQualifierOne {    TimeUnit value() default DAYS;    public static final class Literalextends AnnotationLiteral<SomeQualifierOne>implements SomeQualifierOne {private static final long serialVersionUID = 1L;public static final Literal INSTANCE = of(DAYS);private final TimeUnit value;public static Literal of(TimeUnit value) {return new Literal(value);}private Literal(TimeUnit value) {this.value = value;}public TimeUnit value() {return value;}    }}
--------------------------------------------------------------------------------------------------------

import org.apache.commons.lang3.StringUtils;
import org.springframework.boot.context.properties.ConfigurationPropertiesBinding;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.convert.converter.Converter;

import java.util.Objects;

/**
 * Redis data converter implementation
 */
@Configuration
public class RedisDataConverter {

    @Bean
    @ConfigurationPropertiesBinding
    public Str2Host strToHost() {
        return new Str2Host();
    }

    @Bean
    @ConfigurationPropertiesBinding
    public Int2Port intToPort() {
        return new Int2Port();
    }

    /**
     * Custom string to host redis converter {@link Converter}
     */
    public class Str2Host implements Converter<String, RedisData.RedisHost> {
        @Override
        public RedisData.RedisHost convert(final String source) {
            if (StringUtils.isNotBlank(source)) {
                return RedisData.RedisHost.of(source);
            }
            return null;
        }
    }

    /**
     * Custom integer to port redis converter {@link Converter}
     */
    public class Int2Port implements Converter<Integer, RedisData.RedisPort> {
        @Override
        public RedisData.RedisPort convert(final Integer source) {
            if (Objects.nonNull(source)) {
                return RedisData.RedisPort.of(source);
            }
            return null;
        }
    }
}
--------------------------------------------------------------------------------------------------------
@Aspect
@Component
public class FeaturesAspect {

    private static final Logger LOG = LogManager.getLogger(FeaturesAspect.class);

    @Around(value = "@within(featureAssociation) || @annotation(featureAssociation)")
    public Object checkAspect(ProceedingJoinPoint joinPoint, FeatureAssociation featureAssociation) throws Throwable {
        if (featureAssociation.value().isActive()) {
            return joinPoint.proceed();
        } else {
            LOG.info("Feature " + featureAssociation.value().name() + " is not enabled!");
            return null;
        }
    }

}

import java.lang.annotation.*;

/**
 * Api ignore constraint
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE, ElementType.PARAMETER})
public @interface ApiIgnore {

    /**
     * A brief description of why this parameter/operation is ignored
     *
     * @return the description of why it is ignored
     */
    String message() default "{ApiIgnore.message}";
}
--------------------------------------------------------------------------------------------------------
import com.sensiblemetrics.api.sqoola.common.exception.InvalidTokenFormatException;
import org.apache.commons.lang3.StringUtils;

public class KeycloakTokenValidator {
    private static final String BEARER_PREFIX = "Bearer ";

    public static void validate(final String keycloakToken) throws InvalidTokenFormatException {
        if (!isValid(keycloakToken)) {
            throw new InvalidTokenFormatException("Keycloak token must have 'Bearer ' prefix");
        }
    }

    private static boolean isValid(final String keycloakToken) {
        return (StringUtils.isNotBlank(keycloakToken) && keycloakToken.startsWith(BEARER_PREFIX));
    }
}
--------------------------------------------------------------------------------------------------------
import org.apache.commons.lang3.StringUtils;
import org.springframework.web.client.RestTemplate;

import java.util.Collections;

public class KeycloakRestTemplate extends RestTemplate {

    public KeycloakRestTemplate(final String keycloakToken) {
        if (StringUtils.isNotBlank(keycloakToken)) {
            this.setInterceptors(Collections.singletonList(new KeycloakInterceptor(keycloakToken)));
        }
    }
}

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpRequest;
import org.springframework.http.client.ClientHttpRequestExecution;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.ClientHttpResponse;

import java.io.IOException;

public class KeycloakInterceptor implements ClientHttpRequestInterceptor {
    private static final Logger LOG = LoggerFactory.getLogger(KeycloakInterceptor.class);

    private static final String AUTHORIZATION_HEADER = "Authorization";
    private static final String REQUEST_ID_HEADER = "X-Request-Id";
    private static final String REQUEST_ID_MDC_KEY = "req_id";
    private static final String BEARER_PREFIX = "Bearer ";
    private String keycloakToken;

    public KeycloakInterceptor(String keycloakToken) {
        this.keycloakToken = keycloakToken.startsWith(BEARER_PREFIX) ? keycloakToken : BEARER_PREFIX + keycloakToken;
    }

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution)
        throws IOException {
        HttpHeaders headers = request.getHeaders();
        headers.add(AUTHORIZATION_HEADER, keycloakToken);
        headers.add(REQUEST_ID_HEADER, getRequestId());
        return execution.execute(request, body);
    }

    private String getRequestId() {
        String requestId = MDC.get(REQUEST_ID_MDC_KEY);
        LOG.debug("'X-Request-Id' sent {}", requestId);
        return requestId;
    }
}
--------------------------------------------------------------------------------------------------------
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Slf4j
@Aspect
@Component(SubscriptionOperationServiceAspect.COMPONENT_ID)
public class SubscriptionOperationServiceAspect {

    /**
     * Default component ID
     */
    public static final String COMPONENT_ID = "subscriptionOperationServiceAspect";

    @Before(value = "execution(* com.sensiblemetrics.api.sqoola.common.service.dao.impl.subscription.period.SubscriptionOperationPeriodServiceImpl.*(..))")
    public void subscriptionOperationPeriodBeforeAdvice(final JoinPoint joinPoint) {
        log.info(String.format("SubscriptionOperationServiceAspect: processing model={%s} by method={%s} with args={%s}", joinPoint.getTarget(), joinPoint.getSignature(), joinPoint.getArgs()));
    }

    @After(value = "execution(* com.sensiblemetrics.api.sqoola.common.service.dao.impl.subscription.period.SubscriptionOperationPeriodServiceImpl.*(..))")
    public void subscriptionOperationPeriodAfterAdvice(final JoinPoint joinPoint) {
        log.info(String.format("SubscriptionOperationServiceAspect: model={%s} has been processed", joinPoint.getTarget()));
    }

    @Before(value = "execution(* com.sensiblemetrics.api.sqoola.common.service.dao.impl.subscription.SubscriptionOperationServiceImpl.*(..))")
    public void subscriptionOperationBeforeAdvice(final JoinPoint joinPoint) {
        log.info(String.format("SubscriptionOperationServiceAspect: processing model={%s} by method={%s} with args={%s}", joinPoint.getTarget(), joinPoint.getSignature(), joinPoint.getArgs()));
    }

    @After(value = "execution(* com.sensiblemetrics.api.sqoola.common.service.dao.impl.subscription.SubscriptionOperationServiceImpl.*(..))")
    public void subscriptionOperationAfterAdvice(final JoinPoint joinPoint) {
        log.info(String.format("SubscriptionOperationServiceAspect: model={%s} has been processed", joinPoint.getTarget()));
    }
}
--------------------------------------------------------------------------------------------------------
import com.sensiblemetrics.api.sqoola.common.model.dao.listeners.event.LoadEventListenerImp;
import com.sensiblemetrics.api.sqoola.common.model.dao.listeners.event.RefreshEventListenerImp;
import com.sensiblemetrics.api.sqoola.common.model.dao.listeners.event.SaveUpdateEventListenerImp;
import org.hibernate.boot.Metadata;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.hibernate.event.service.spi.EventListenerRegistry;
import org.hibernate.event.spi.EventType;
import org.hibernate.integrator.spi.Integrator;
import org.hibernate.service.spi.SessionFactoryServiceRegistry;

public class EventListenerIntegrator implements Integrator {

    @Override
    public void integrate(Metadata metadata, SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {

        final EventListenerRegistry eventListenerRegistry = serviceRegistry.getService(EventListenerRegistry.class);
        eventListenerRegistry.getEventListenerGroup(EventType.SAVE).appendListener(new SaveUpdateEventListenerImp());
        eventListenerRegistry.getEventListenerGroup(EventType.LOAD).appendListener(new LoadEventListenerImp());
        eventListenerRegistry.getEventListenerGroup(EventType.REFRESH).appendListener(new RefreshEventListenerImp());
    }

    @Override
    public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.amqp.core.AcknowledgeMode;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.listener.MessageListenerContainer;
import org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class MessageListenerContainerFactory {

    @Autowired
    private ConnectionFactory connectionFactory;

    public MessageListenerContainer createMessageListenerContainer(final String queueName) {
        final SimpleMessageListenerContainer mlc = new SimpleMessageListenerContainer(this.connectionFactory);
        mlc.addQueueNames(queueName);
        mlc.setAcknowledgeMode(AcknowledgeMode.AUTO);
        return mlc;
    }
}
 @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME, pattern = DEFAULT_DATE_FORMAT_PATTERN_EXT)
--------------------------------------------------------------------------------------------------------
    @Bean
    public MultipartResolver multipartResolver() {
        final CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver();
        multipartResolver.setMaxUploadSize(env.getRequiredProperty("sqoola.config.maxUploadSize", Integer.class));
        multipartResolver.setMaxUploadSizePerFile(env.getRequiredProperty("sqoola.config.maxUploadSizePerFile", Integer.class));
        multipartResolver.setResolveLazily(true);
        multipartResolver.setPreserveFilename(false);
        multipartResolver.setDefaultEncoding(StandardCharsets.UTF_8.name());
        return multipartResolver;
    }
--------------------------------------------------------------------------------------------------------
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        final ThemeChangeInterceptor themeChangeInterceptor = new ThemeChangeInterceptor();
        themeChangeInterceptor.setParamName("theme");
        registry.addInterceptor(themeChangeInterceptor);

        final LocaleChangeInterceptor localeChangeInterceptor = new LocaleChangeInterceptor();
        localeChangeInterceptor.setParamName("lang");
        registry.addInterceptor(localeChangeInterceptor);

        // Register guest interceptor with single path pattern
        registry.addInterceptor(new GuestInterceptor()).addPathPatterns("/guest");

        // Register admin interceptor with multiple path patterns
        registry.addInterceptor(new AdminInterceptor()).addPathPatterns(new String[]{"/admin", "/admin/*"});
    }
--------------------------------------------------------------------------------------------------------

@ConfigurationProperties(prefix = "myapp.mail")
@Validated
//@EnableConfigurationProperties(MailProperties.class)
public class MailConfigProperties {

    @Email
    private String to;
    @NotBlank
    private String host;
    private int port;
    private String[] cc;
    private List<String> bcc;

    @Valid
    private Credential credential = new Credential();

    //Setter and Getter methods

    public class Credential {
        @NotBlank
        private String userName;
        @Size(max = 15, min = 6)
        private String password;

        //Setter and Getter methods

    }
}
//myapp:
//    mail:
//    to: sunil@example.com
//    host: mail.example.com
//        port: 250
//        cc:
//        - mike@example.com
//      - david@example.com
//    bcc:
//        - sumit@example.com
//      - admin@example.com
//    credential:
//        user-name: sunil1234
//        password: xyz@1234
--------------------------------------------------------------------------------------------------------

import lombok.experimental.UtilityClass;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.dialect.*;
import org.javers.common.exception.JaversException;
import org.javers.common.exception.JaversExceptionCode;
import org.javers.repository.sql.DialectName;

/**
 * Dialect utilities implementation
 */
@Slf4j
@UtilityClass
public class DialectMapper {

    public DialectName map(final Dialect hibernateDialect) {

        if (hibernateDialect instanceof SQLServerDialect) {
            return DialectName.MSSQL;
        }
        if (hibernateDialect instanceof H2Dialect) {
            return DialectName.H2;
        }
        if (hibernateDialect instanceof Oracle8iDialect) {
            return DialectName.ORACLE;
        }
        if (hibernateDialect instanceof PostgreSQL81Dialect) {
            return DialectName.POSTGRES;
        }
        if (hibernateDialect instanceof MySQLDialect) {
            return DialectName.MYSQL;
        }
        throw new JaversException(JaversExceptionCode.UNSUPPORTED_SQL_DIALECT, hibernateDialect.getClass().getSimpleName());
    }
}
--------------------------------------------------------------------------------------------------------
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

/**
 * @author Josh Cummings
 */
@EnableWebSecurity
public class OAuth2ResourceServerSecurityConfiguration extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		// @formatter:off
		http
			.authorizeRequests()
				.antMatchers("/message/**").hasAuthority("SCOPE_message:read")
				.anyRequest().authenticated()
				.and()
			.oauth2ResourceServer()
				.jwt();
		// @formatter:on
	}
}
--------------------------------------------------------------------------------------------------------
/**
	 * Reads text from a file
	 * @param file the file to read from
	 * @return the text within the {@link File}
	 */
	static String readTextFrom(File file) {
		assertValidFile(file);
		try {
			return new String(Files.readAllBytes(file.toPath()));
		} catch (IOException e) {
			throw new IllegalArgumentException("Could not read " + file, e);
		}
	}

	/**
	 * Writes text to a file overriding any existing text
	 * @param text the text to write to the {@link File}
	 * @param file the {@link File} to write to
	 */
	static void writeTextTo(String text, File file) {
		if (text == null) {
			throw new IllegalArgumentException("text cannot be null");
		}
		assertValidFile(file);
		try (Writer writer = new OutputStreamWriter(new FileOutputStream(file))) {
			writer.write(text);
		} catch (IOException e) {
			throw new IllegalArgumentException("Could not write to " + file, e);
		}
	}

	private static void assertValidFile(File file) {
		if (file == null) {
			throw new IllegalArgumentException("file cannot be null");
		}
	}
--------------------------------------------------------------------------------------------------------
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: ${mockwebserver.url}/.well-known/jwks.json
--------------------------------------------------------------------------------------------------------

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationContext;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@SpringBootTest
class AsgardBpmClientApplicationIT {

    @Autowired
    ApplicationContext ctx;

    @Test
    public void testRun() {
        CommandLineRunner runner = ctx.getBean(CommandLineRunner.class);
        runner.run ( "-k", "arg1", "-i", "arg2");
    }

}
--------------------------------------------------------------------------------------------------------

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

import com.sample.myApp.model.MyBean;

@SpringBootApplication
public class Application {

 public static void main(String args[]) {

  ConfigurableApplicationContext configurableApplicationContext = SpringApplication.run(Application.class, args);

  MyBean myBean = configurableApplicationContext.getBean(MyBean.class);
  
  configurableApplicationContext.close();
 }
}
--------------------------------------------------------------------------------------------------------
java -jar swagger-codegen-cli-2.2.1.jar generate -i spec.yaml -l python
--------------------------------------------------------------------------------------------------------
<plugin>
    <groupId>io.swagger</groupId>
    <artifactId>swagger-codegen-maven-plugin</artifactId>
    <version>${swagger-codegen-maven-plugin-version}</version>
    <executions>
        <execution>
            <goals>
                <goal>generate</goal>
            </goals>
            <configuration>
                <inputSpec>${project.basedir}/src/main/resources/yaml/yamlfilename.yaml</inputSpec>
                <!-- language file, like e.g. JavaJaxRSCodegen shipped with swagger -->
                <language>com.my.package.for.GeneratorLanguage</language>
                <templateDirectory>myTemplateDir</templateDirectory>

                <output>${project.build.directory}/generated-sources</output>
                <apiPackage>${default.package}.handler</apiPackage>
                <modelPackage>${default.package}.model</modelPackage>
                <invokerPackage>${default.package}.handler</invokerPackage>
            </configuration>
        </execution>
    </executions>

    <dependencies>
        <dependency>
            <groupId>com.my.generator</groupId>
            <artifactId>customgenerator</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
    </dependencies>
</plugin>
--------------------------------------------------------------------------------------------------------
2019-10-17T15:34:31.038324Z
2019-10-21T05:07:41.644+03:00
--------------------------------------------------------------------------------------------------------
curl -X POST -H "content-type:application/json" \
-d '{"swaggerUrl":"http://petstore.swagger.io/v2/swagger.json"}' \
http://generator.swagger.io/api/gen/clients/java
--------------------------------------------------------------------------------------------------------
import java.util.concurrent.atomic.*;

/**
 * Created by shiqifeng on 2017/5/5.
 * Mail byhieg@gmail.com
 */
public class AtomFactory {

    private static final AtomFactory atomFactory = new AtomFactory();

    private AtomFactory(){

    }

    public static AtomFactory getInstance(){
        return atomFactory;
    }

    public AtomicInteger createAtomInt(int a){
        return new AtomicInteger(a);
    }

    public AtomicIntegerArray createAtomArray(int[] a) {
        return new AtomicIntegerArray(a);
    }

    public AtomicReference<MyObject> createAtomReference(MyObject object){
        return new AtomicReference<>();
    }

    public AtomicIntegerFieldUpdater<MyObject> createAtomIntegerUpdate(String fieldName) {
        return  AtomicIntegerFieldUpdater.newUpdater(MyObject.class, fieldName);
    }
}
--------------------------------------------------------------------------------------------------------
import java.util.concurrent.BlockingQueue;

/**
 * Created by byhieg on 17/5/3.
 * Mail to byhieg@gmail.com
 */
public class Producer extends Thread {

    private BlockingQueue<String> blockingQueue;
    @Override
    public void run() {
        super.run();
        for (int i = 0 ; i < 5;i++) {
            try {
                blockingQueue.put(i + "");
                System.out.println(getName() + " 生产数据");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public Producer(ArrayBlock arrayBlock){
        this.setName("Producer");
        blockingQueue = arrayBlock.getBlockingQueue();
    }
}
import java.util.concurrent.BlockingQueue;

/**
 * Created by byhieg on 17/5/3.
 * Mail to byhieg@gmail.com
 */
public class Costumer extends Thread{

    private BlockingQueue<String> blockingQueue;

    public Costumer(ArrayBlock arrayBlock) {
        blockingQueue = arrayBlock.getBlockingQueue();
        this.setName("Costumer");
    }

    @Override
    public void run() {
        super.run();
        while (true) {
            try {
                Thread.sleep(5000);
                String str = blockingQueue.take();
                System.out.println(getName() + " 取出数据 " + str);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
--------------------------------------------------------------------------------------------------------
/**
 * Current version of the project. Generated from a template at build time.
 * @author Georgy Vlasov (wlasowegor@gmail.com)
 * @version $Id$
 * @since 0.23
 */
public enum Version {
    /**
     * Current version.
     */
    CURRENT("${project.version}", "${buildNumber}");

    /**
     * Project version.
     */
    private final String version;

    /**
     * Build number.
     */
    private final String build;

    /**
     * Public ctor.
     * @param ver Maven's project.version property
     * @param buildnum Maven's buildNumber property created with
     *  buildnumber-maven-plugin
     */
    Version(final String ver, final String buildnum) {
        this.version = ver;
        this.build = buildnum;
    }

    /**
     * Returns project version number.
     * @return Project version number
     */
    public String projectVersion() {
        return this.version;
    }

    /**
     * Returns project build number.
     * @return Build number
     */
    public String buildNumber() {
        return this.build;
    }
}s
--------------------------------------------------------------------------------------------------------
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri("http://localhost")
    .setPort(8080)
    .setAccept(ContentType.JSON)
    .setContentType(ContentType.ANY)
...
    .log(LogDetail.ALL)
    .build();

// можно задать одну спецификацию для всех запросов:
RestAssured.requestSpecification = requestSpec;

// или для отдельного:
given().spec(requestSpec)...when().get(someEndpoint);

ResponseSpecification responseSpec = new ResponseSpecBuilder()
    .expectStatusCode(200)
    .expectBody(containsString("success"))
    .build();

// можно задать одну спецификацию для всех ответов:
RestAssured.responseSpecification = responseSpec;

// или для отдельного:
given()...when().get(someEndpoint).then().spec(responseSpec)...;

// то же самое работает и в обратную сторону:
SomePojo pojo = given().
    .when().get(EndPoints.get)
    .then().extract().body().as(SomePojo.class);
--------------------------------------------------------------------------------------------------------
-Xjsr305={strict|warn|ignore}
--------------------------------------------------------------------------------------------------------
@TestExecutionListeners(MockitoTestExecutionListener.class)
private Duration loginTimeout = Duration.ofSeconds(3);

assertThat(json.write(message))
    .extractingJsonPathNumberValue("@.test.numberValue")
    .satisfies((number) -> assertThat(number.floatValue()).isCloseTo(0.15f, within(0.01f)));
--------------------------------------------------------------------------------------------------------
@ExtendWith(OutputCaptureExtension.class)
class OutputCaptureTests {

    @Test
    void testName(CapturedOutput output) {
        System.out.println("Hello World!");
        assertThat(output).contains("World");
    }

}


spring.webservices.wsdl-locations=classpath:/wsdl



@Bean
public WebServiceTemplate webServiceTemplate(WebServiceTemplateBuilder builder) {
    return builder.messageSenders(new HttpWebServiceMessageSenderBuilder()
            .setConnectTimeout(5000).setReadTimeout(2000).build()).build();
}
--------------------------------------------------------------------------------------------------------
@Configuration(proxyBeanMethods = false)
@EnableKafkaStreams
public static class KafkaStreamsExampleConfiguration {

    @Bean
    public KStream<Integer, String> kStream(StreamsBuilder streamsBuilder) {
        KStream<Integer, String> stream = streamsBuilder.stream("ks1In");
        stream.map((k, v) -> new KeyValue<>(k, v.toUpperCase())).to("ks1Out",
                Produced.with(Serdes.Integer(), new JsonSerde<>()));
        return stream;
    }

}


spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.value.default.type=com.example.Invoice
spring.kafka.consumer.properties.spring.json.trusted.packages=com.example,org.acme




spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.producer.properties.spring.json.add.type.headers=false

spring.jta.log-dir
spring.jta.atomikos.properties


spring.session.jdbc.table-name=SESSIONS




<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.junit.vintage</groupId>
            <artifactId>junit-vintage-engine</artifactId>
        </exclusion>
    </exclusions>
</dependency>


--------------------------------------------------------------------------------------------------------
@Test
public void whenMeasureResponseTime_thenOK() {
    Response response = RestAssured.get("/users/eugenp");
    long timeInMS = response.time();
    long timeInS = response.timeIn(TimeUnit.SECONDS);
     
    assertEquals(timeInS, timeInMS/1000);
}
@Test
public void whenLogResponseIfErrorOccurred_thenSuccess() {
  
    when().get("/users/eugenp")
      .then().log().ifError();
    when().get("/users/eugenp")
      .then().log().ifStatusCodeIsEqualTo(500);
    when().get("/users/eugenp")
      .then().log().ifStatusCodeMatches(greaterThan(200));
}
--------------------------------------------------------------------------------------------------------
@Test
public void whenLogResponseIfErrorOccurred_thenSuccess() {
  
    when().get("/users/eugenp")
      .then().log().ifError();
    when().get("/users/eugenp")
      .then().log().ifStatusCodeIsEqualTo(500);
    when().get("/users/eugenp")
      .then().log().ifStatusCodeMatches(greaterThan(200));
}
--------------------------------------------------------------------------------------------------------

// методы find, findAll применяются к коллекции для поиска первого и всех вхождений, метод collect для  создания новой коллекции из найденных результатов. 

// переменная it создается неявно и указывает на текущий элемент коллекции
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.find { it.title =~ 'anythingRegExp'}");

// можете явно задать название переменной, указывающей на текущий элемент
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.findAll { element -> element.title.length() > 4 }");

// вы можете использовать методы sum, max, min для суммирования всех значений коллекции, а также поиска максимального и минимально значения

String expensiveCar = get(EndPoints.cars).path("cars.find { it.title == 'Toyota Motor Corporation'}.models.max { it.averagePrice }.title");

--------------------------------------------------------------------------------------------------------
language: java
sudo: false
cache:
  directories:
    - $HOME/.m2
script:
  - set -e
  - mvn clean install -Pqulice --errors --batch-mode
  - mvn clean
  - pdd --source=$(pwd) --file=/dev/null
  - est --dir=est --file=/dev/null
before_install:
  - rvm install 2.6.0
  - rvm use 2.6.0
install:
  - gem install pdd -v 0.20.5
  - gem install est -v 0.3.4
env:
  global:
    - MAVEN_OPTS="-Xmx256m"
    - JAVA_OPTS="-Xmx256m"
jdk:
  - oraclejdk8
  - openjdk7
--------------------------------------------------------------------------------------------------------
    public String getRightestOne(int n){
        int res = n & (~n + 1);
        return Integer.toBinaryString(res);
    }
--------------------------------------------------------------------------------------------------------
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;

/**
 * Created by shiqifeng on 2017/2/23.
 * Mail byhieg@gmail.com
 */
public class BufferedReaderExample {

    public void readFromFile() throws Exception{
        try(BufferedReader reader = new BufferedReader(new FileReader("D:" + File.separator + "read_file.txt"))){
            String str;
            while ((str = reader.readLine()) != null) {
                System.out.println(str);
            }
        }
    }
}
--------------------------------------------------------------------------------------------------------
<plugin>
    <groupId>io.swagger</groupId>
    <artifactId>swagger-codegen-maven-plugin</artifactId>
    <version>2.3.1</version>
    <executions>
        <execution>
            <id>contract-service</id>
            <goals>
                <goal>generate</goal>
            </goals>
            <configuration>
                <inputSpec>${basedir}/src/main/resources/swagger/rest-data-exchange-format.yaml</inputSpec>
                <artifactId>contract-service</artifactId>
                <output>${basedir}/target/generated-sources</output>
                <language>spring</language>
                <modelPackage>ru.payhub.rest.v1.model</modelPackage>
                <apiPackage>ru.payhub.rest.v1.api</apiPackage>
                <!-- <invokerPackage>ru.payhub.rest.v1.handler</invokerPackage> -->
                <generateSupportingFiles>false</generateSupportingFiles>
                <configOptions>
                    <sourceFolder>src/main/java</sourceFolder>
                    <interfaceOnly>true</interfaceOnly>
                    <library>spring-boot</library>
                    <dateLibrary>${generator.datelibrary}</dateLibrary>
                    <configPackage>ru.payhub.config</configPackage>
                    <singleContentTypes>true</singleContentTypes>
                </configOptions>
            </configuration>
        </execution>
    </executions>
</plugin>
--------------------------------------------------------------------------------------------------------
del /f /q /a "C:\git-project\paragon.microservices.distributor\.build\bin"
--------------------------------------------------------------------------------------------------------
List<Enum> enumValues = Arrays.asList(Enum.values());
or

List<Enum> enumValues = new ArrayList<Enum>(EnumSet.allOf(Enum.class));
Using Java 8 features, you can map each constant to its name:

List<String> enumNames = Stream.of(Enum.values())
                               .map(Enum::name)
                               .collect(Collectors.toList());
--------------------------------------------------------------------------------------------------------
enum Primitive<X> {
    INT<Integer>(Integer.class, 0) {
        int mod(int x, int y) { return x % y; }
        int add(int x, int y) { return x + y; }
    },
    FLOAT<Float>(Float.class, 0f)  {
        long add(long x, long y) { return x + y; }
    }, ... ;

    final Class<X> boxClass;
    final X defaultValue;

    Primitive(Class<X> boxClass, X defaultValue) {
        this.boxClass = boxClass;
        this.defaultValue = defaultValue;
    }
}

// class name is awful for this example, but it will make more sense if you
//  read further
public interface MetaDataKey<T extends Serializable> extends Serializable
{
    T getValue();
}

public final class TypeSafeKeys
{
    static enum StringKeys implements MetaDataKey<String>
    {
        A1("key1");

        private final String value;

        StringKeys(String value) { this.value = value; }

        @Override
        public String getValue() { return value; }
    }

    static enum IntegerKeys implements MetaDataKey<Integer>
    {
        A2(0);

        private final Integer value;

        IntegerKeys (Integer value) { this.value = value; }

        @Override
        public Integer getValue() { return value; }
    }

    public static final MetaDataKey<String> A1 = StringKeys.A1;
    public static final MetaDataKey<Integer> A2 = IntegerKeys.A2;
}
--------------------------------------------------------------------------------------------------------
private static WireMockServer wireMockServer
  = new WireMockServer();
 
@BeforeClass
public static void setUp() throws Exception {
    wireMockServer.start();
    configureFor("localhost", 8080);
    stubFor(
      get(urlEqualTo("/user/get"))
        .willReturn(aResponse()
          .withStatus(200)
          .withHeader("Content-Type", "application/json")
          .withBody("{ \"id\": \"1234\", name: \"John Smith\" }")));
 
    stubFor(
      post(urlEqualTo("/user/create"))
        .withHeader("content-type", equalTo("application/json"))
        .withRequestBody(containing("id"))
        .willReturn(aResponse()
          .withStatus(200)
          .withHeader("Content-Type", "application/json")
          .withBody("{ \"id\": \"1234\", name: \"John Smith\" }")));
 
}
 
@AfterClass
public static void tearDown() throws Exception {
    wireMockServer.stop();
}
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------